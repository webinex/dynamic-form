var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-BAyBVE51.js"(exports, module) {
    function _mergeNamespaces(n2, m2) {
      for (var i2 = 0; i2 < m2.length; i2++) {
        const e2 = m2[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (const k2 in e2) {
            if (k2 !== "default" && !(k2 in n2)) {
              const d2 = Object.getOwnPropertyDescriptor(e2, k2);
              if (d2) {
                Object.defineProperty(n2, k2, d2.get ? d2 : {
                  enumerable: true,
                  get: () => e2[k2]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
    }
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node2 of mutation.addedNodes) {
            if (node2.tagName === "LINK" && node2.rel === "modulepreload")
              processPreload(node2);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity) fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    function getAugmentedNamespace(n2) {
      if (n2.__esModule) return n2;
      var f2 = n2.default;
      if (typeof f2 == "function") {
        var a = function a2() {
          if (this instanceof a2) {
            return Reflect.construct(f2, arguments, this.constructor);
          }
          return f2.apply(this, arguments);
        };
        a.prototype = f2.prototype;
      } else a = {};
      Object.defineProperty(a, "__esModule", { value: true });
      Object.keys(n2).forEach(function(k2) {
        var d2 = Object.getOwnPropertyDescriptor(n2, k2);
        Object.defineProperty(a, k2, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return n2[k2];
          }
        });
      });
      return a;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production = {};
    /**
     * @license React
     * react-jsx-runtime.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var REACT_ELEMENT_TYPE$3 = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE$3 = Symbol.for("react.fragment");
    function jsxProd(type2, config, maybeKey) {
      var key = null;
      void 0 !== maybeKey && (key = "" + maybeKey);
      void 0 !== config.key && (key = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      config = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE$3,
        type: type2,
        key,
        ref: void 0 !== config ? config : null,
        props: maybeKey
      };
    }
    reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE$3;
    reactJsxRuntime_production.jsx = jsxProd;
    reactJsxRuntime_production.jsxs = jsxProd;
    {
      jsxRuntime.exports = reactJsxRuntime_production;
    }
    var jsxRuntimeExports = jsxRuntime.exports;
    var react = { exports: {} };
    var react_production = {};
    /**
     * @license React
     * react.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var REACT_ELEMENT_TYPE$2 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE$2 = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE$2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE$1 = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE$1 = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE$1 = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE$1 = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE$1 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE$1 = Symbol.for("react.suspense"), REACT_MEMO_TYPE$1 = Symbol.for("react.memo"), REACT_LAZY_TYPE$1 = Symbol.for("react.lazy"), MAYBE_ITERATOR_SYMBOL$1 = Symbol.iterator;
    function getIteratorFn$1(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL$1 && maybeIterable[MAYBE_ITERATOR_SYMBOL$1] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    }, assign$1 = Object.assign, emptyObject = {};
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign$1(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl$1 = Array.isArray, ReactSharedInternals$2 = { H: null, A: null, T: null, S: null }, hasOwnProperty$c = Object.prototype.hasOwnProperty;
    function ReactElement(type2, key, self2, source, owner, props) {
      self2 = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE$2,
        type: type2,
        key,
        ref: void 0 !== self2 ? self2 : null,
        props
      };
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(
        oldElement.type,
        newKey,
        void 0,
        void 0,
        void 0,
        oldElement.props
      );
    }
    function isValidElement(object2) {
      return "object" === typeof object2 && null !== object2 && object2.$$typeof === REACT_ELEMENT_TYPE$2;
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match2) {
        return escaperLookup[match2];
      });
    }
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index2) {
      return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index2.toString(36);
    }
    function noop$1$2() {
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop$1$2, noop$1$2) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
      var type2 = typeof children;
      if ("undefined" === type2 || "boolean" === type2) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type2) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE$2:
              case REACT_PORTAL_TYPE$2:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE$1:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array2,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl$1(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array2, escapedPrefix, "", function(c2) {
          return c2;
        })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array2.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl$1(children))
        for (var i2 = 0; i2 < children.length; i2++)
          nameSoFar = children[i2], type2 = nextNamePrefix + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(
            nameSoFar,
            array2,
            escapedPrefix,
            type2,
            callback
          );
      else if (i2 = getIteratorFn$1(children), "function" === typeof i2)
        for (children = i2.call(children), i2 = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type2 = nextNamePrefix + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(
            nameSoFar,
            array2,
            escapedPrefix,
            type2,
            callback
          );
      else if ("object" === type2) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array2,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array2 = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array2 ? "object with keys {" + Object.keys(children).join(", ") + "}" : array2) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    var reportGlobalError$1 = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    function noop$6() {
    }
    react_production.Children = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function(children) {
        var n2 = 0;
        mapChildren(children, function() {
          n2++;
        });
        return n2;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    react_production.Component = Component;
    react_production.Fragment = REACT_FRAGMENT_TYPE$2;
    react_production.Profiler = REACT_PROFILER_TYPE$1;
    react_production.PureComponent = PureComponent;
    react_production.StrictMode = REACT_STRICT_MODE_TYPE$1;
    react_production.Suspense = REACT_SUSPENSE_TYPE$1;
    react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals$2;
    react_production.act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    react_production.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    react_production.cloneElement = function(element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign$1({}, element.props), key = element.key, owner = void 0;
      if (null != config)
        for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config)
          !hasOwnProperty$c.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i2 = 0; i2 < propName; i2++)
          childArray[i2] = arguments[i2 + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key, void 0, void 0, owner, props);
    };
    react_production.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE$1,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE$1,
        _context: defaultValue
      };
      return defaultValue;
    };
    react_production.createElement = function(type2, config, children) {
      var propName, props = {}, key = null;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          hasOwnProperty$c.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i2 = 0; i2 < childrenLength; i2++)
          childArray[i2] = arguments[i2 + 2];
        props.children = childArray;
      }
      if (type2 && type2.defaultProps)
        for (propName in childrenLength = type2.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement(type2, key, void 0, void 0, null, props);
    };
    react_production.createRef = function() {
      return { current: null };
    };
    react_production.forwardRef = function(render2) {
      return { $$typeof: REACT_FORWARD_REF_TYPE$1, render: render2 };
    };
    react_production.isValidElement = isValidElement;
    react_production.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE$1,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    react_production.memo = function(type2, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE$1,
        type: type2,
        compare: void 0 === compare ? null : compare
      };
    };
    react_production.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals$2.T, currentTransition = {};
      ReactSharedInternals$2.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals$2.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop$6, reportGlobalError$1);
      } catch (error) {
        reportGlobalError$1(error);
      } finally {
        ReactSharedInternals$2.T = prevTransition;
      }
    };
    react_production.unstable_useCacheRefresh = function() {
      return ReactSharedInternals$2.H.useCacheRefresh();
    };
    react_production.use = function(usable) {
      return ReactSharedInternals$2.H.use(usable);
    };
    react_production.useActionState = function(action, initialState2, permalink) {
      return ReactSharedInternals$2.H.useActionState(action, initialState2, permalink);
    };
    react_production.useCallback = function(callback, deps) {
      return ReactSharedInternals$2.H.useCallback(callback, deps);
    };
    react_production.useContext = function(Context2) {
      return ReactSharedInternals$2.H.useContext(Context2);
    };
    react_production.useDebugValue = function() {
    };
    react_production.useDeferredValue = function(value, initialValue2) {
      return ReactSharedInternals$2.H.useDeferredValue(value, initialValue2);
    };
    react_production.useEffect = function(create2, deps) {
      return ReactSharedInternals$2.H.useEffect(create2, deps);
    };
    react_production.useId = function() {
      return ReactSharedInternals$2.H.useId();
    };
    react_production.useImperativeHandle = function(ref, create2, deps) {
      return ReactSharedInternals$2.H.useImperativeHandle(ref, create2, deps);
    };
    react_production.useInsertionEffect = function(create2, deps) {
      return ReactSharedInternals$2.H.useInsertionEffect(create2, deps);
    };
    react_production.useLayoutEffect = function(create2, deps) {
      return ReactSharedInternals$2.H.useLayoutEffect(create2, deps);
    };
    react_production.useMemo = function(create2, deps) {
      return ReactSharedInternals$2.H.useMemo(create2, deps);
    };
    react_production.useOptimistic = function(passthrough, reducer) {
      return ReactSharedInternals$2.H.useOptimistic(passthrough, reducer);
    };
    react_production.useReducer = function(reducer, initialArg, init) {
      return ReactSharedInternals$2.H.useReducer(reducer, initialArg, init);
    };
    react_production.useRef = function(initialValue2) {
      return ReactSharedInternals$2.H.useRef(initialValue2);
    };
    react_production.useState = function(initialState2) {
      return ReactSharedInternals$2.H.useState(initialState2);
    };
    react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals$2.H.useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    react_production.useTransition = function() {
      return ReactSharedInternals$2.H.useTransition();
    };
    react_production.version = "19.0.0";
    {
      react.exports = react_production;
    }
    var reactExports = react.exports;
    const i = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    const React$5 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: i
    }, [reactExports]);
    var client = { exports: {} };
    var reactDomClient_production = {};
    var scheduler = { exports: {} };
    var scheduler_production = {};
    /**
     * @license React
     * scheduler.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      function push2(heap, node2) {
        var index2 = heap.length;
        heap.push(node2);
        a: for (; 0 < index2; ) {
          var parentIndex = index2 - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node2))
            heap[parentIndex] = node2, heap[index2] = parent, index2 = parentIndex;
          else break a;
        }
      }
      function peek2(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop2(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (var index2 = 0, length2 = heap.length, halfLength = length2 >>> 1; index2 < halfLength; ) {
            var leftIndex = 2 * (index2 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length2 && 0 > compare(right, left) ? (heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex) : (heap[index2] = left, heap[leftIndex] = last, index2 = leftIndex);
            else if (rightIndex < length2 && 0 > compare(right, last))
              heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare(a, b2) {
        var diff = a.sortIndex - b2.sortIndex;
        return 0 !== diff ? diff : a.id - b2.id;
      }
      exports2.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports2.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports2.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var taskQueue2 = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer = peek2(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop2(timerQueue);
          else if (timer.startTime <= currentTime)
            pop2(timerQueue), timer.sortIndex = timer.expirationTime, push2(taskQueue2, timer);
          else break;
          timer = peek2(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek2(taskQueue2))
            isHostCallbackScheduled = true, requestHostCallback();
          else {
            var firstTimer = peek2(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
      function shouldYieldToHost() {
        return exports2.unstable_now() - startTime < frameInterval ? false : true;
      }
      function performWorkUntilDeadline() {
        if (isMessageLoopRunning) {
          var currentTime = exports2.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek2(taskQueue2); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports2.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek2(taskQueue2) && pop2(taskQueue2);
                      advanceTimers(currentTime);
                    } else pop2(taskQueue2);
                    currentTask = peek2(taskQueue2);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek2(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ("function" === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      function requestHostCallback() {
        isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
      }
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports2.unstable_now());
        }, ms);
      }
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback());
      };
      exports2.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return peek2(taskQueue2);
      };
      exports2.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = function() {
      };
      exports2.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports2.unstable_scheduleCallback = function(priorityLevel, callback, options2) {
        var currentTime = exports2.unstable_now();
        "object" === typeof options2 && null !== options2 ? (options2 = options2.delay, options2 = "number" === typeof options2 && 0 < options2 ? currentTime + options2 : currentTime) : options2 = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options2 + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options2,
          expirationTime: timeout,
          sortIndex: -1
        };
        options2 > currentTime ? (priorityLevel.sortIndex = options2, push2(timerQueue, priorityLevel), null === peek2(taskQueue2) && priorityLevel === peek2(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options2 - currentTime))) : (priorityLevel.sortIndex = timeout, push2(taskQueue2, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback()));
        return priorityLevel;
      };
      exports2.unstable_shouldYield = shouldYieldToHost;
      exports2.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
    })(scheduler_production);
    {
      scheduler.exports = scheduler_production;
    }
    var schedulerExports = scheduler.exports;
    var reactDom = { exports: {} };
    var reactDom_production = {};
    /**
     * @license React
     * react-dom.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var React$4 = reactExports;
    function formatProdErrorMessage$1(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i2 = 2; i2 < arguments.length; i2++)
          url += "&args[]=" + encodeURIComponent(arguments[i2]);
      }
      return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function noop$5() {
    }
    var Internals = {
      d: {
        f: noop$5,
        r: function() {
          throw Error(formatProdErrorMessage$1(522));
        },
        D: noop$5,
        C: noop$5,
        L: noop$5,
        m: noop$5,
        X: noop$5,
        S: noop$5,
        M: noop$5
      },
      p: 0,
      findDOMNode: null
    }, REACT_PORTAL_TYPE$1 = Symbol.for("react.portal");
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return {
        $$typeof: REACT_PORTAL_TYPE$1,
        key: null == key ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    var ReactSharedInternals$1 = React$4.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    reactDom_production.createPortal = function(children, container) {
      var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
        throw Error(formatProdErrorMessage$1(299));
      return createPortal$1(children, container, null, key);
    };
    reactDom_production.flushSync = function(fn) {
      var previousTransition = ReactSharedInternals$1.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals$1.T = null, Internals.p = 2, fn) return fn();
      } finally {
        ReactSharedInternals$1.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
      }
    };
    reactDom_production.preconnect = function(href, options2) {
      "string" === typeof href && (options2 ? (options2 = options2.crossOrigin, options2 = "string" === typeof options2 ? "use-credentials" === options2 ? options2 : "" : void 0) : options2 = null, Internals.d.C(href, options2));
    };
    reactDom_production.prefetchDNS = function(href) {
      "string" === typeof href && Internals.d.D(href);
    };
    reactDom_production.preinit = function(href, options2) {
      if ("string" === typeof href && options2 && "string" === typeof options2.as) {
        var as = options2.as, crossOrigin = getCrossOriginStringAs(as, options2.crossOrigin), integrity = "string" === typeof options2.integrity ? options2.integrity : void 0, fetchPriority = "string" === typeof options2.fetchPriority ? options2.fetchPriority : void 0;
        "style" === as ? Internals.d.S(
          href,
          "string" === typeof options2.precedence ? options2.precedence : void 0,
          {
            crossOrigin,
            integrity,
            fetchPriority
          }
        ) : "script" === as && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: "string" === typeof options2.nonce ? options2.nonce : void 0
        });
      }
    };
    reactDom_production.preinitModule = function(href, options2) {
      if ("string" === typeof href)
        if ("object" === typeof options2 && null !== options2) {
          if (null == options2.as || "script" === options2.as) {
            var crossOrigin = getCrossOriginStringAs(
              options2.as,
              options2.crossOrigin
            );
            Internals.d.M(href, {
              crossOrigin,
              integrity: "string" === typeof options2.integrity ? options2.integrity : void 0,
              nonce: "string" === typeof options2.nonce ? options2.nonce : void 0
            });
          }
        } else null == options2 && Internals.d.M(href);
    };
    reactDom_production.preload = function(href, options2) {
      if ("string" === typeof href && "object" === typeof options2 && null !== options2 && "string" === typeof options2.as) {
        var as = options2.as, crossOrigin = getCrossOriginStringAs(as, options2.crossOrigin);
        Internals.d.L(href, as, {
          crossOrigin,
          integrity: "string" === typeof options2.integrity ? options2.integrity : void 0,
          nonce: "string" === typeof options2.nonce ? options2.nonce : void 0,
          type: "string" === typeof options2.type ? options2.type : void 0,
          fetchPriority: "string" === typeof options2.fetchPriority ? options2.fetchPriority : void 0,
          referrerPolicy: "string" === typeof options2.referrerPolicy ? options2.referrerPolicy : void 0,
          imageSrcSet: "string" === typeof options2.imageSrcSet ? options2.imageSrcSet : void 0,
          imageSizes: "string" === typeof options2.imageSizes ? options2.imageSizes : void 0,
          media: "string" === typeof options2.media ? options2.media : void 0
        });
      }
    };
    reactDom_production.preloadModule = function(href, options2) {
      if ("string" === typeof href)
        if (options2) {
          var crossOrigin = getCrossOriginStringAs(options2.as, options2.crossOrigin);
          Internals.d.m(href, {
            as: "string" === typeof options2.as && "script" !== options2.as ? options2.as : void 0,
            crossOrigin,
            integrity: "string" === typeof options2.integrity ? options2.integrity : void 0
          });
        } else Internals.d.m(href);
    };
    reactDom_production.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    reactDom_production.unstable_batchedUpdates = function(fn, a) {
      return fn(a);
    };
    reactDom_production.useFormState = function(action, initialState2, permalink) {
      return ReactSharedInternals$1.H.useFormState(action, initialState2, permalink);
    };
    reactDom_production.useFormStatus = function() {
      return ReactSharedInternals$1.H.useHostTransitionStatus();
    };
    reactDom_production.version = "19.0.0";
    function checkDCE$1() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE$1);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE$1();
      reactDom.exports = reactDom_production;
    }
    var reactDomExports = reactDom.exports;
    const ReactDOM$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
    const ReactDOM$2 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: ReactDOM$1
    }, [reactDomExports]);
    /**
     * @license React
     * react-dom-client.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var Scheduler = schedulerExports, React$3 = reactExports, ReactDOM = reactDomExports;
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i2 = 2; i2 < arguments.length; i2++)
          url += "&args[]=" + encodeURIComponent(arguments[i2]);
      }
      return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function isValidContainer(node2) {
      return !(!node2 || 1 !== node2.nodeType && 9 !== node2.nodeType && 11 !== node2.nodeType);
    }
    var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE$1 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE$1 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function getComponentNameFromType(type2) {
      if (null == type2) return null;
      if ("function" === typeof type2)
        return type2.$$typeof === REACT_CLIENT_REFERENCE ? null : type2.displayName || type2.name || null;
      if ("string" === typeof type2) return type2;
      switch (type2) {
        case REACT_FRAGMENT_TYPE$1:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
      }
      if ("object" === typeof type2)
        switch (type2.$$typeof) {
          case REACT_CONTEXT_TYPE:
            return (type2.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type2._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type2.render;
            type2 = type2.displayName;
            type2 || (type2 = innerType.displayName || innerType.name || "", type2 = "" !== type2 ? "ForwardRef(" + type2 + ")" : "ForwardRef");
            return type2;
          case REACT_MEMO_TYPE:
            return innerType = type2.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type2.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type2._payload;
            type2 = type2._init;
            try {
              return getComponentNameFromType(type2(innerType));
            } catch (x2) {
            }
        }
      return null;
    }
    var ReactSharedInternals = React$3.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, assign = Object.assign, prefix, suffix;
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x2) {
          var match2 = x2.stack.trim().match(/\n( *(at )?)/);
          prefix = match2 && match2[1] || "";
          suffix = -1 < x2.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return "\n" + prefix + name + suffix;
    }
    var reentry = false;
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x2) {
                    var control = x2;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$12) {
                  control = x$12;
                }
                (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                });
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
          for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
            RunInRootFrame++;
          for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
            "DetermineComponentFrameRoot"
          ); )
            namePropDescriptor++;
          if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
            for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
              namePropDescriptor--;
          for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
            if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
              if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                do
                  if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                    var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                    fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                    return frame;
                  }
                while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
              }
              break;
            }
        }
      } finally {
        reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
      }
      return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
    }
    function describeFiber(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return fiber = describeNativeComponentFrame(fiber.type, false), fiber;
        case 11:
          return fiber = describeNativeComponentFrame(fiber.type.render, false), fiber;
        case 1:
          return fiber = describeNativeComponentFrame(fiber.type, true), fiber;
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress2) {
      try {
        var info = "";
        do
          info += describeFiber(workInProgress2), workInProgress2 = workInProgress2.return;
        while (workInProgress2);
        return info;
      } catch (x2) {
        return "\nError generating stack: " + x2.message + "\n" + x2.stack;
      }
    }
    function getNearestMountedFiber(fiber) {
      var node2 = fiber, nearestMounted = fiber;
      if (fiber.alternate) for (; node2.return; ) node2 = node2.return;
      else {
        fiber = node2;
        do
          node2 = fiber, 0 !== (node2.flags & 4098) && (nearestMounted = node2.return), fiber = node2.return;
        while (fiber);
      }
      return 3 === node2.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error(formatProdErrorMessage(188));
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate) throw Error(formatProdErrorMessage(188));
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b2 = alternate; ; ) {
        var parentA = a.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b2 = parentA.return;
          if (null !== b2) {
            a = b2;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB; ) {
            if (parentB === a) return assertIsMounted(parentA), fiber;
            if (parentB === b2) return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error(formatProdErrorMessage(188));
        }
        if (a.return !== b2.return) a = parentA, b2 = parentB;
        else {
          for (var didFindChild = false, child$2 = parentA.child; child$2; ) {
            if (child$2 === a) {
              didFindChild = true;
              a = parentA;
              b2 = parentB;
              break;
            }
            if (child$2 === b2) {
              didFindChild = true;
              b2 = parentA;
              a = parentB;
              break;
            }
            child$2 = child$2.sibling;
          }
          if (!didFindChild) {
            for (child$2 = parentB.child; child$2; ) {
              if (child$2 === a) {
                didFindChild = true;
                a = parentB;
                b2 = parentA;
                break;
              }
              if (child$2 === b2) {
                didFindChild = true;
                b2 = parentB;
                a = parentA;
                break;
              }
              child$2 = child$2.sibling;
            }
            if (!didFindChild) throw Error(formatProdErrorMessage(189));
          }
        }
        if (a.alternate !== b2) throw Error(formatProdErrorMessage(190));
      }
      if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node2) {
      var tag = node2.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node2;
      for (node2 = node2.child; null !== node2; ) {
        tag = findCurrentHostFiberImpl(node2);
        if (null !== tag) return tag;
        node2 = node2.sibling;
      }
      return null;
    }
    var isArrayImpl = Array.isArray, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
      pending: false,
      data: null,
      method: null,
      action: null
    }, valueStack = [], index$1 = -1;
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor) {
      0 > index$1 || (cursor.current = valueStack[index$1], valueStack[index$1] = null, index$1--);
    }
    function push(cursor, value) {
      index$1++;
      valueStack[index$1] = cursor.current;
      cursor.current = value;
    }
    var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance);
      push(contextFiberStackCursor, fiber);
      push(contextStackCursor, null);
      fiber = nextRootInstance.nodeType;
      switch (fiber) {
        case 9:
        case 11:
          nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : 0 : 0;
          break;
        default:
          if (fiber = 8 === fiber ? nextRootInstance.parentNode : nextRootInstance, nextRootInstance = fiber.tagName, fiber = fiber.namespaceURI)
            fiber = getOwnHostContext(fiber), nextRootInstance = getChildHostContextProd(fiber, nextRootInstance);
          else
            switch (nextRootInstance) {
              case "svg":
                nextRootInstance = 1;
                break;
              case "math":
                nextRootInstance = 2;
                break;
              default:
                nextRootInstance = 0;
            }
      }
      pop(contextStackCursor);
      push(contextStackCursor, nextRootInstance);
    }
    function popHostContainer() {
      pop(contextStackCursor);
      pop(contextFiberStackCursor);
      pop(rootInstanceStackCursor);
    }
    function pushHostContext(fiber) {
      null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
      var context = contextStackCursor.current;
      var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
      context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
    }
    var hasOwnProperty$b = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
    function onCommitRoot(root2) {
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
        try {
          injectedHook.onCommitFiberRoot(
            rendererID,
            root2,
            void 0,
            128 === (root2.current.flags & 128)
          );
        } catch (err) {
        }
    }
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
        }
    }
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
    function clz32Fallback(x2) {
      x2 >>>= 0;
      return 0 === x2 ? 32 : 31 - (log(x2) / LN2 | 0) | 0;
    }
    var nextTransitionLane = 128, nextRetryLane = 4194304;
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 4194176;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return lanes;
      }
    }
    function getNextLanes(root2, wipLanes) {
      var pendingLanes = root2.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, warmLanes = root2.warmLanes;
      root2 = 0 !== root2.finishedLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root2 || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root2 || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));
      return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;
    }
    function checkIfRootIsPrerendering(root2, renderLanes2) {
      return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
          return currentTime + 250;
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function claimNextTransitionLane() {
      var lane = nextTransitionLane;
      nextTransitionLane <<= 1;
      0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
      return lane;
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i2 = 0; 31 > i2; i2++) laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root2, updateLane) {
      root2.pendingLanes |= updateLane;
      268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
    }
    function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root2.pendingLanes;
      root2.pendingLanes = remainingLanes;
      root2.suspendedLanes = 0;
      root2.pingedLanes = 0;
      root2.warmLanes = 0;
      root2.expiredLanes &= remainingLanes;
      root2.entangledLanes &= remainingLanes;
      root2.errorRecoveryDisabledLanes &= remainingLanes;
      root2.shellSuspendCounter = 0;
      var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
        var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
        entanglements[index$7] = 0;
        expirationTimes[index$7] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index$7];
        if (null !== hiddenUpdatesForLane)
          for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
            var update = hiddenUpdatesForLane[index$7];
            null !== update && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
      0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
      root2.pendingLanes |= spawnedLane;
      root2.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root2.entangledLanes |= spawnedLane;
      root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;
    }
    function markRootEntangled(root2, entangledLanes) {
      var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
      for (root2 = root2.entanglements; rootEntangledLanes; ) {
        var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
        lane & entangledLanes | root2[index$8] & entangledLanes && (root2[index$8] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return ReactDOMSharedInternals.p = priority, fn();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
    function detachDeletedInstance(node2) {
      delete node2[internalInstanceKey];
      delete node2[internalPropsKey];
      delete node2[internalEventHandlersKey];
      delete node2[internalEventHandlerListenersKey];
      delete node2[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode; ) {
        if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
          parentNode = targetInst.alternate;
          if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
            for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
              if (parentNode = targetNode[internalInstanceKey]) return parentNode;
              targetNode = getParentSuspenseInstance(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node2) {
      if (node2 = node2[internalInstanceKey] || node2[internalContainerInstanceKey]) {
        var tag = node2.tag;
        if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
          return node2;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
      throw Error(formatProdErrorMessage(33));
    }
    function getResourcesFromRoot(root2) {
      var resources = root2[internalRootNodeResourcesKey];
      resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
      return resources;
    }
    function markNodeAsHoistable(node2) {
      node2[internalHoistableMarker] = true;
    }
    var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] = dependencies;
      for (registrationName = 0; registrationName < dependencies.length; registrationName++)
        allNativeEvents.add(dependencies[registrationName]);
    }
    var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), VALID_ATTRIBUTE_NAME_REGEX = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty$b.call(validatedAttributeNameCache, attributeName))
        return true;
      if (hasOwnProperty$b.call(illegalAttributeNameCache, attributeName)) return false;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return validatedAttributeNameCache[attributeName] = true;
      illegalAttributeNameCache[attributeName] = true;
      return false;
    }
    function setValueForAttribute(node2, name, value) {
      if (isAttributeNameSafe(name))
        if (null === value) node2.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              node2.removeAttribute(name);
              return;
            case "boolean":
              var prefix$10 = name.toLowerCase().slice(0, 5);
              if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                node2.removeAttribute(name);
                return;
              }
          }
          node2.setAttribute(name, "" + value);
        }
    }
    function setValueForKnownAttribute(node2, name, value) {
      if (null === value) node2.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node2.removeAttribute(name);
            return;
        }
        node2.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node2, namespace, name, value) {
      if (null === value) node2.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node2.removeAttribute(name);
            return;
        }
        node2.setAttributeNS(namespace, name, "" + value);
      }
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type2 = elem.type;
      return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type2 || "radio" === type2);
    }
    function trackValueOnNode(node2) {
      var valueField = isCheckable(node2) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
        node2.constructor.prototype,
        valueField
      ), currentValue = "" + node2[valueField];
      if (!node2.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
        var get2 = descriptor.get, set2 = descriptor.set;
        Object.defineProperty(node2, valueField, {
          configurable: true,
          get: function() {
            return get2.call(this);
          },
          set: function(value) {
            currentValue = "" + value;
            set2.call(this, value);
          }
        });
        Object.defineProperty(node2, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            currentValue = "" + value;
          },
          stopTracking: function() {
            node2._valueTracker = null;
            delete node2[valueField];
          }
        };
      }
    }
    function track(node2) {
      node2._valueTracker || (node2._valueTracker = trackValueOnNode(node2));
    }
    function updateValueIfChanged(node2) {
      if (!node2) return false;
      var tracker = node2._valueTracker;
      if (!tracker) return true;
      var lastValue = tracker.getValue();
      var value = "";
      node2 && (value = isCheckable(node2) ? node2.checked ? "true" : "false" : node2.value);
      node2 = value;
      return node2 !== lastValue ? (tracker.setValue(node2), true) : false;
    }
    function getActiveElement(doc) {
      doc = doc || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc) return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e2) {
        return doc.body;
      }
    }
    var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(
        escapeSelectorAttributeValueInsideDoubleQuotesRegex,
        function(ch) {
          return "\\" + ch.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type2, name) {
      element.name = "";
      null != type2 && "function" !== typeof type2 && "symbol" !== typeof type2 && "boolean" !== typeof type2 ? element.type = type2 : element.removeAttribute("type");
      if (null != value)
        if ("number" === type2) {
          if (0 === value && "" === element.value || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
      else
        "submit" !== type2 && "reset" !== type2 || element.removeAttribute("value");
      null != value ? setDefaultValue(element, type2, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type2, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
      null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
      null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
    }
    function initInput(element, value, defaultValue, checked, defaultChecked, type2, name, isHydrating2) {
      null != type2 && "function" !== typeof type2 && "symbol" !== typeof type2 && "boolean" !== typeof type2 && (element.type = type2);
      if (null != value || null != defaultValue) {
        if (!("submit" !== type2 && "reset" !== type2 || void 0 !== value && null !== value))
          return;
        defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue;
        isHydrating2 || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
      element.checked = isHydrating2 ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
    }
    function setDefaultValue(node2, type2, value) {
      "number" === type2 && getActiveElement(node2.ownerDocument) === node2 || node2.defaultValue === "" + value || (node2.defaultValue = "" + value);
    }
    function updateOptions(node2, multiple, propValue, setDefaultSelected) {
      node2 = node2.options;
      if (multiple) {
        multiple = {};
        for (var i2 = 0; i2 < propValue.length; i2++)
          multiple["$" + propValue[i2]] = true;
        for (propValue = 0; propValue < node2.length; propValue++)
          i2 = multiple.hasOwnProperty("$" + node2[propValue].value), node2[propValue].selected !== i2 && (node2[propValue].selected = i2), i2 && setDefaultSelected && (node2[propValue].defaultSelected = true);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i2 = 0; i2 < node2.length; i2++) {
          if (node2[i2].value === propValue) {
            node2[i2].selected = true;
            setDefaultSelected && (node2[i2].defaultSelected = true);
            return;
          }
          null !== multiple || node2[i2].disabled || (multiple = node2[i2]);
        }
        null !== multiple && (multiple.selected = true);
      }
    }
    function updateTextarea(element, value, defaultValue) {
      if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue) throw Error(formatProdErrorMessage(92));
          if (isArrayImpl(children)) {
            if (1 < children.length) throw Error(formatProdErrorMessage(93));
            children = children[0];
          }
          defaultValue = children;
        }
        null == defaultValue && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue && "" !== children && null !== children && (element.value = children);
    }
    function setTextContent(node2, text) {
      if (text) {
        var firstChild = node2.firstChild;
        if (firstChild && firstChild === node2.lastChild && 3 === firstChild.nodeType) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node2.textContent = text;
    }
    var unitlessNumbers = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    function setValueForStyle(style2, styleName, value) {
      var isCustomProperty = 0 === styleName.indexOf("--");
      null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
    }
    function setValueForStyles(node2, styles, prevStyles) {
      if (null != styles && "object" !== typeof styles)
        throw Error(formatProdErrorMessage(62));
      node2 = node2.style;
      if (null != prevStyles) {
        for (var styleName in prevStyles)
          !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node2.setProperty(styleName, "") : "float" === styleName ? node2.cssFloat = "" : node2[styleName] = "");
        for (var styleName$16 in styles)
          styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node2, styleName$16, styleName);
      } else
        for (var styleName$17 in styles)
          styles.hasOwnProperty(styleName$17) && setValueForStyle(node2, styleName$17, styles[styleName$17]);
    }
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return false;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var aliases = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    var currentReplayingEvent = null;
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    var restoreTarget = null, restoreQueue = null;
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (target = internalInstance.stateNode, internalInstance.type) {
          case "input":
            updateInput(
              target,
              props.value,
              props.defaultValue,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name
            );
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode; ) props = props.parentNode;
              props = props.querySelectorAll(
                'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                  "" + internalInstance
                ) + '"][type="radio"]'
              );
              for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps) throw Error(formatProdErrorMessage(90));
                  updateInput(
                    otherNode,
                    otherProps.value,
                    otherProps.defaultValue,
                    otherProps.defaultValue,
                    otherProps.checked,
                    otherProps.defaultChecked,
                    otherProps.type,
                    otherProps.name
                  );
                }
              }
              for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
        }
      }
    }
    var isInsideEventHandler = false;
    function batchedUpdates$1(fn, a, b2) {
      if (isInsideEventHandler) return fn(a, b2);
      isInsideEventHandler = true;
      try {
        var JSCompiler_inline_result = fn(a);
        return JSCompiler_inline_result;
      } finally {
        if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
          if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
            for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
        }
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
          inst = !props;
          break a;
        default:
          inst = false;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode)
        throw Error(
          formatProdErrorMessage(231, registrationName, typeof stateNode)
        );
      return stateNode;
    }
    var passiveBrowserEventsSupported = false;
    if (canUseDOM)
      try {
        var options$1 = {};
        Object.defineProperty(options$1, "passive", {
          get: function() {
            passiveBrowserEventsSupported = true;
          }
        });
        window.addEventListener("test", options$1, options$1);
        window.removeEventListener("test", options$1, options$1);
      } catch (e2) {
        passiveBrowserEventsSupported = false;
      }
    var root$1 = null, startText = null, fallbackText = null;
    function getData() {
      if (fallbackText) return fallbackText;
      var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root$1 ? root$1.value : root$1.textContent, endLength = endValue.length;
      for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
      return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return true;
    }
    function functionThatReturnsFalse() {
      return false;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface)
          Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
        this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: function() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;
          event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
        },
        stopPropagation: function() {
          var event = this.nativeEvent;
          event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
        },
        persist: function() {
        },
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    var EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: function(event) {
        return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
      },
      movementX: function(event) {
        if ("movementX" in event) return event.movementX;
        event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
        return lastMovementX;
      },
      movementY: function(event) {
        return "movementY" in event ? event.movementY : lastMovementY;
      }
    }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
      clipboardData: function(event) {
        return "clipboardData" in event ? event.clipboardData : window.clipboardData;
      }
    }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    var KeyboardEventInterface = assign({}, UIEventInterface, {
      key: function(nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if ("Unidentified" !== key) return key;
        }
        return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      charCode: function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : 0;
      },
      keyCode: function(event) {
        return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      },
      which: function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      }
    }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
      deltaX: function(event) {
        return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
      },
      deltaY: function(event) {
        return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
      newState: 0,
      oldState: 0
    }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
    canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return 229 !== nativeEvent.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
    }
    var isComposing = false;
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (32 !== nativeEvent.which) return null;
          hasSpaceKeypress = true;
          return SPACEBAR_CHAR;
        case "textInput":
          return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root$1 = null, isComposing = false, domEventName) : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
        default:
          return null;
      }
    }
    var supportedInputTypes = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    };
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
      restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length && (nativeEvent = new SyntheticEvent(
        "onChange",
        "change",
        null,
        nativeEvent,
        target
      ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    var activeElement$1 = null, activeElementInst$1 = null;
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    var isInputEventSupported = false;
    if (canUseDOM) {
      var JSCompiler_inline_result$jscomp$283;
      if (canUseDOM) {
        var isSupported$jscomp$inline_418 = "oninput" in document;
        if (!isSupported$jscomp$inline_418) {
          var element$jscomp$inline_419 = document.createElement("div");
          element$jscomp$inline_419.setAttribute("oninput", "return;");
          isSupported$jscomp$inline_418 = "function" === typeof element$jscomp$inline_419.oninput;
        }
        JSCompiler_inline_result$jscomp$283 = isSupported$jscomp$inline_418;
      } else JSCompiler_inline_result$jscomp$283 = false;
      isInputEventSupported = JSCompiler_inline_result$jscomp$283 && (!document.documentMode || 9 < document.documentMode);
    }
    function stopWatchingForValueChange() {
      activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
    }
    function handlePropertyChange(nativeEvent) {
      if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(
          dispatchQueue,
          activeElementInst$1,
          nativeEvent,
          getEventTarget(nativeEvent)
        );
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
      "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
        return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName)
        return getInstIfValueChanged(targetInst);
    }
    function is(x2, y2) {
      return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is;
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB)) return true;
      if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
        return false;
      var keysA = Object.keys(objA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return false;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (!hasOwnProperty$b.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
          return false;
      }
      return true;
    }
    function getLeafNode(node2) {
      for (; node2 && node2.firstChild; ) node2 = node2.firstChild;
      return node2;
    }
    function getNodeForCharacterOffset(root2, offset2) {
      var node2 = getLeafNode(root2);
      root2 = 0;
      for (var nodeEnd; node2; ) {
        if (3 === node2.nodeType) {
          nodeEnd = root2 + node2.textContent.length;
          if (root2 <= offset2 && nodeEnd >= offset2)
            return { node: node2, offset: offset2 - root2 };
          root2 = nodeEnd;
        }
        a: {
          for (; node2; ) {
            if (node2.nextSibling) {
              node2 = node2.nextSibling;
              break a;
            }
            node2 = node2.parentNode;
          }
          node2 = void 0;
        }
        node2 = getLeafNode(node2);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
      for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
        try {
          var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
        } catch (err) {
          JSCompiler_inline_result = false;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;
        else break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
    }
    function restoreSelection(priorSelectionInformation, containerInfo) {
      var curFocusedElem = getActiveElementDeep(containerInfo);
      containerInfo = priorSelectionInformation.focusedElem;
      var priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== containerInfo && containerInfo && containerInfo.ownerDocument && containsNode(containerInfo.ownerDocument.documentElement, containerInfo)) {
        if (null !== priorSelectionRange && hasSelectionCapabilities(containerInfo)) {
          if (priorSelectionInformation = priorSelectionRange.start, curFocusedElem = priorSelectionRange.end, void 0 === curFocusedElem && (curFocusedElem = priorSelectionInformation), "selectionStart" in containerInfo)
            containerInfo.selectionStart = priorSelectionInformation, containerInfo.selectionEnd = Math.min(
              curFocusedElem,
              containerInfo.value.length
            );
          else if (curFocusedElem = (priorSelectionInformation = containerInfo.ownerDocument || document) && priorSelectionInformation.defaultView || window, curFocusedElem.getSelection) {
            curFocusedElem = curFocusedElem.getSelection();
            var length2 = containerInfo.textContent.length, start = Math.min(priorSelectionRange.start, length2);
            priorSelectionRange = void 0 === priorSelectionRange.end ? start : Math.min(priorSelectionRange.end, length2);
            !curFocusedElem.extend && start > priorSelectionRange && (length2 = priorSelectionRange, priorSelectionRange = start, start = length2);
            length2 = getNodeForCharacterOffset(containerInfo, start);
            var endMarker = getNodeForCharacterOffset(
              containerInfo,
              priorSelectionRange
            );
            length2 && endMarker && (1 !== curFocusedElem.rangeCount || curFocusedElem.anchorNode !== length2.node || curFocusedElem.anchorOffset !== length2.offset || curFocusedElem.focusNode !== endMarker.node || curFocusedElem.focusOffset !== endMarker.offset) && (priorSelectionInformation = priorSelectionInformation.createRange(), priorSelectionInformation.setStart(length2.node, length2.offset), curFocusedElem.removeAllRanges(), start > priorSelectionRange ? (curFocusedElem.addRange(priorSelectionInformation), curFocusedElem.extend(endMarker.node, endMarker.offset)) : (priorSelectionInformation.setEnd(
              endMarker.node,
              endMarker.offset
            ), curFocusedElem.addRange(priorSelectionInformation)));
          }
        }
        priorSelectionInformation = [];
        for (curFocusedElem = containerInfo; curFocusedElem = curFocusedElem.parentNode; )
          1 === curFocusedElem.nodeType && priorSelectionInformation.push({
            element: curFocusedElem,
            left: curFocusedElem.scrollLeft,
            top: curFocusedElem.scrollTop
          });
        "function" === typeof containerInfo.focus && containerInfo.focus();
        for (containerInfo = 0; containerInfo < priorSelectionInformation.length; containerInfo++)
          curFocusedElem = priorSelectionInformation[containerInfo], curFocusedElem.element.scrollLeft = curFocusedElem.left, curFocusedElem.element.scrollTop = curFocusedElem.top;
      }
    }
    var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
      mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
        anchorNode: doc.anchorNode,
        anchorOffset: doc.anchorOffset,
        focusNode: doc.focusNode,
        focusOffset: doc.focusOffset
      }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
        "onSelect",
        "select",
        null,
        nativeEvent,
        nativeEventTarget
      ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
    }
    function makePrefixMap$1(styleProp, eventName) {
      var prefixes2 = {};
      prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes2["Webkit" + styleProp] = "webkit" + eventName;
      prefixes2["Moz" + styleProp] = "moz" + eventName;
      return prefixes2;
    }
    var vendorPrefixes$1 = {
      animationend: makePrefixMap$1("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap$1("Animation", "AnimationIteration"),
      animationstart: makePrefixMap$1("Animation", "AnimationStart"),
      transitionrun: makePrefixMap$1("Transition", "TransitionRun"),
      transitionstart: makePrefixMap$1("Transition", "TransitionStart"),
      transitioncancel: makePrefixMap$1("Transition", "TransitionCancel"),
      transitionend: makePrefixMap$1("Transition", "TransitionEnd")
    }, prefixedEventNames$1 = {}, style$1 = {};
    canUseDOM && (style$1 = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes$1.animationend.animation, delete vendorPrefixes$1.animationiteration.animation, delete vendorPrefixes$1.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes$1.transitionend.transition);
    function getVendorPrefixedEventName$1(eventName) {
      if (prefixedEventNames$1[eventName]) return prefixedEventNames$1[eventName];
      if (!vendorPrefixes$1[eventName]) return eventName;
      var prefixMap = vendorPrefixes$1[eventName], styleProp;
      for (styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style$1)
          return prefixedEventNames$1[eventName] = prefixMap[styleProp];
      return eventName;
    }
    var ANIMATION_END = getVendorPrefixedEventName$1("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName$1("animationiteration"), ANIMATION_START = getVendorPrefixedEventName$1("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName$1("transitionrun"), TRANSITION_START = getVendorPrefixedEventName$1("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName$1("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName$1("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(
      " "
    );
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    var concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
    function finishQueueingConcurrentUpdates() {
      for (var endIndex = concurrentQueuesIndex, i2 = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i2 < endIndex; ) {
        var fiber = concurrentQueues[i2];
        concurrentQueues[i2++] = null;
        var queue = concurrentQueues[i2];
        concurrentQueues[i2++] = null;
        var update = concurrentQueues[i2];
        concurrentQueues[i2++] = null;
        var lane = concurrentQueues[i2];
        concurrentQueues[i2++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
        parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
      isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [update] : sourceFiber.push(update), update.lane = lane | 536870912);
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (50 < nestedUpdateCount)
        throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
      for (var parent = sourceFiber.return; null !== parent; )
        sourceFiber = parent, parent = sourceFiber.return;
      return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
    }
    var emptyContextObject = {}, CapturedStacks = /* @__PURE__ */ new WeakMap();
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
    function pushTreeFork(workInProgress2, totalChildren) {
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress2;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress2, totalChildren, index2) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress2;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress2 = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index2 += 1;
      var length2 = 32 - clz32(totalChildren) + baseLength;
      if (30 < length2) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length2 = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length2 + workInProgress2;
      } else
        treeContextId = 1 << length2 | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
    }
    function pushMaterializedTreeId(workInProgress2) {
      null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
    }
    function popTreeContext(workInProgress2) {
      for (; workInProgress2 === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (; workInProgress2 === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
    function throwOnHydrationMismatch(fiber) {
      var error = Error(formatProdErrorMessage(418, ""));
      queueHydrationError(createCapturedValueAtFiber(error, fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var instance = fiber.stateNode, type2 = fiber.type, props = fiber.memoizedProps;
      instance[internalInstanceKey] = fiber;
      instance[internalPropsKey] = props;
      switch (type2) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", instance);
          listenToNonDelegatedEvent("close", instance);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", instance);
          break;
        case "video":
        case "audio":
          for (type2 = 0; type2 < mediaEventTypes.length; type2++)
            listenToNonDelegatedEvent(mediaEventTypes[type2], instance);
          break;
        case "source":
          listenToNonDelegatedEvent("error", instance);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", instance);
          listenToNonDelegatedEvent("load", instance);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", instance);
          break;
        case "input":
          listenToNonDelegatedEvent("invalid", instance);
          initInput(
            instance,
            props.value,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name,
            true
          );
          track(instance);
          break;
        case "select":
          listenToNonDelegatedEvent("invalid", instance);
          break;
        case "textarea":
          listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
      }
      type2 = props.children;
      "string" !== typeof type2 && "number" !== typeof type2 && "bigint" !== typeof type2 || instance.textContent === "" + type2 || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type2) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1$1), instance = true) : instance = false;
      instance || throwOnHydrationMismatch(fiber);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 3:
          case 27:
            rootOrSingletonContext = true;
            return;
          case 5:
          case 13:
            rootOrSingletonContext = false;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return false;
      if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
      var shouldClear = false, JSCompiler_temp;
      if (JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag) {
        if (JSCompiler_temp = 5 === fiber.tag)
          JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
        JSCompiler_temp = !JSCompiler_temp;
      }
      JSCompiler_temp && (shouldClear = true);
      shouldClear && nextHydratableInstance && throwOnHydrationMismatch(fiber);
      popToNextHostParent(fiber);
      if (13 === fiber.tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        a: {
          fiber = fiber.nextSibling;
          for (shouldClear = 0; fiber; ) {
            if (8 === fiber.nodeType)
              if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
                if (0 === shouldClear) {
                  nextHydratableInstance = getNextHydratable(fiber.nextSibling);
                  break a;
                }
                shouldClear--;
              } else
                "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || shouldClear++;
            fiber = fiber.nextSibling;
          }
          nextHydratableInstance = null;
        }
      } else
        nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
      return true;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      isHydrating = false;
    }
    function queueHydrationError(error) {
      null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), noopSuspenseyCommitThenable = { then: function() {
    } };
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    function noop$3() {
    }
    function trackUsedThenable(thenableState2, thenable, index2) {
      index2 = thenableState2[index2];
      void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$3, noop$3), thenable = index2);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          thenableState2 = thenable.reason;
          if (thenableState2 === SuspenseException)
            throw Error(formatProdErrorMessage(483));
          throw thenableState2;
        default:
          if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
          else {
            thenableState2 = workInProgressRoot;
            if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
              throw Error(formatProdErrorMessage(482));
            thenableState2 = thenable;
            thenableState2.status = "pending";
            thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            );
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              thenableState2 = thenable.reason;
              if (thenableState2 === SuspenseException)
                throw Error(formatProdErrorMessage(483));
              throw thenableState2;
          }
          suspendedThenable = thenable;
          throw SuspenseException;
      }
    }
    var suspendedThenable = null;
    function getSuspendedThenable() {
      if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
      var thenable = suspendedThenable;
      suspendedThenable = null;
      return thenable;
    }
    var thenableState$1 = null, thenableIndexCounter$1 = 0;
    function unwrapThenable(thenable) {
      var index2 = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = []);
      return trackUsedThenable(thenableState$1, thenable, index2);
    }
    function coerceRef(workInProgress2, element) {
      element = element.props.ref;
      workInProgress2.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(formatProdErrorMessage(525));
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error(
        formatProdErrorMessage(
          31,
          "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
        )
      );
    }
    function resolveLazy(lazyType) {
      var init = lazyType._init;
      return init(lazyType._payload);
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild; )
          deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
          null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return newFiber.flags |= 1048576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (null !== newIndex)
          return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;
        newFiber.flags |= 33554434;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);
        return newFiber;
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag)
          return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, textContent);
        current.return = returnFiber;
        return current;
      }
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE$1)
          return updateFragment(
            returnFiber,
            current,
            element.props.children,
            lanes,
            element.key
          );
        if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
          return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
        current = createFiberFromTypeAndProps(
          element.type,
          element.key,
          element.props,
          null,
          returnFiber.mode,
          lanes
        );
        coerceRef(current, element);
        current.return = returnFiber;
        return current;
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
          return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        return current;
      }
      function updateFragment(returnFiber, current, fragment, lanes, key) {
        if (null === current || 7 !== current.tag)
          return current = createFiberFromFragment(
            fragment,
            returnFiber.mode,
            lanes,
            key
          ), current.return = returnFiber, current;
        current = useFiber(current, fragment);
        current.return = returnFiber;
        return current;
      }
      function createChild(returnFiber, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return newChild = createFiberFromText(
            "" + newChild,
            returnFiber.mode,
            lanes
          ), newChild.return = returnFiber, newChild;
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE$1:
              return lanes = createFiberFromTypeAndProps(
                newChild.type,
                newChild.key,
                newChild.props,
                null,
                returnFiber.mode,
                lanes
              ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(
                newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild;
            case REACT_LAZY_TYPE:
              var init = newChild._init;
              newChild = init(newChild._payload);
              return createChild(returnFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return newChild = createFiberFromFragment(
              newChild,
              returnFiber.mode,
              lanes,
              null
            ), newChild.return = returnFiber, newChild;
          if ("function" === typeof newChild.then)
            return createChild(returnFiber, unwrapThenable(newChild), lanes);
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(
              returnFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = null !== oldFiber ? oldFiber.key : null;
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE$1:
              return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE:
              return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateSlot(
              returnFiber,
              oldFiber,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(
              returnFiber,
              oldFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        return null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE$1:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            case REACT_LAZY_TYPE:
              var init = newChild._init;
              newChild = init(newChild._payload);
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        return null;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(
            returnFiber,
            oldFiber,
            newChildren[newIdx],
            lanes
          );
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++)
            oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
          nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            newChildren[newIdx],
            lanes
          ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
            null === nextOldFiber.key ? newIdx : nextOldFiber.key
          ), currentFirstChild = placeChild(
            nextOldFiber,
            currentFirstChild,
            newIdx
          ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (null == newChildren) throw Error(formatProdErrorMessage(151));
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next())
            step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
          step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE$1 && null === newChild.key && (newChild = newChild.props.children);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE$1:
              a: {
                for (var key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE$1) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          newChild.props.children
                        );
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE$1 ? (lanes = createFiberFromFragment(
                  newChild.props.children,
                  returnFiber.mode,
                  lanes,
                  newChild.key
                ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
              }
              return placeSingleChild(returnFiber);
            case REACT_PORTAL_TYPE:
              a: {
                for (key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key)
                    if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild))
            return reconcileChildrenArray(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          if (getIteratorFn(newChild)) {
            key = getIteratorFn(newChild);
            if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
            newChild = key.call(newChild);
            return reconcileChildrenIterator(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          }
          if ("function" === typeof newChild.then)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function(returnFiber, currentFirstChild, newChild, lanes) {
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x2) {
          if (x2 === SuspenseException) throw x2;
          var fiber = createFiberImplClass(29, x2, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          return fiber;
        } finally {
        }
      };
    }
    var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
    function pushHiddenContext(fiber, context) {
      fiber = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, fiber);
      push(currentTreeHiddenStackCursor, context);
      entangledRenderLanes = fiber | context.baseLanes;
    }
    function reuseHiddenContextOnStack() {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
    }
    function popHiddenContext() {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor);
      pop(prevEntangledRenderLanesCursor);
    }
    var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & 1);
      push(suspenseHandlerStackCursor, handler);
      null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushOffscreenSuspenseHandler(fiber) {
      if (22 === fiber.tag) {
        if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
          var current = fiber.alternate;
          null !== current && null !== current.memoizedState && (shellBoundary = fiber);
        }
      } else reuseSuspenseHandlerOnStack();
    }
    function reuseSuspenseHandlerOnStack() {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor);
    }
    var suspenseStackCursor = createCursor(0);
    function findFirstSuspended(row) {
      for (var node2 = row; null !== node2; ) {
        if (13 === node2.tag) {
          var state = node2.memoizedState;
          if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || "$!" === state.data))
            return node2;
        } else if (19 === node2.tag && void 0 !== node2.memoizedProps.revealOrder) {
          if (0 !== (node2.flags & 128)) return node2;
        } else if (null !== node2.child) {
          node2.child.return = node2;
          node2 = node2.child;
          continue;
        }
        if (node2 === row) break;
        for (; null === node2.sibling; ) {
          if (null === node2.return || node2.return === row) return null;
          node2 = node2.return;
        }
        node2.sibling.return = node2.return;
        node2 = node2.sibling;
      }
      return null;
    }
    var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
      var listeners = [], signal = this.signal = {
        aborted: false,
        addEventListener: function(type2, listener) {
          listeners.push(listener);
        }
      };
      this.abort = function() {
        signal.aborted = true;
        listeners.forEach(function(listener) {
          return listener();
        });
      };
    }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function createCache$1() {
      return {
        controller: new AbortControllerLocal(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
        cache.controller.abort();
      });
    }
    var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: function(resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
        null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i2 = 0; i2 < listeners.length; i2++) (0, listeners[i2])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [], thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: function(resolve) {
          listeners.push(resolve);
        }
      };
      thenable.then(
        function() {
          thenableWithOverride.status = "fulfilled";
          thenableWithOverride.value = result;
          for (var i2 = 0; i2 < listeners.length; i2++) (0, listeners[i2])(result);
        },
        function(error) {
          thenableWithOverride.status = "rejected";
          thenableWithOverride.reason = error;
          for (error = 0; error < listeners.length; error++)
            (0, listeners[error])(void 0);
        }
      );
      return thenableWithOverride;
    }
    var prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function(transition, returnValue) {
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
      null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null);
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    var renderLanes = 0, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0;
    function throwInvalidHookError() {
      throw Error(formatProdErrorMessage(321));
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (null === prevDeps) return false;
      for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++)
        if (!objectIs(nextDeps[i2], prevDeps[i2])) return false;
      return true;
    }
    function renderWithHooks(current, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber$1 = workInProgress2;
      workInProgress2.memoizedState = null;
      workInProgress2.updateQueue = null;
      workInProgress2.lanes = 0;
      ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      nextRenderLanes = Component2(props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
        workInProgress2,
        Component2,
        props,
        secondArg
      ));
      finishRenderingHooks(current);
      return nextRenderLanes;
    }
    function finishRenderingHooks(current) {
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
      didScheduleRenderPhaseUpdate = false;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
      null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
    }
    function renderWithHooksAgain(workInProgress2, Component2, props, secondArg) {
      currentlyRenderingFiber$1 = workInProgress2;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
        numberOfReRenders += 1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress2.updateQueue) {
          var children = workInProgress2.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        ReactSharedInternals.H = HooksDispatcherOnRerender;
        children = Component2(props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
      maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress2, lanes) {
      workInProgress2.updateQueue = current.updateQueue;
      workInProgress2.flags &= -2053;
      current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress2) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
          var queue = workInProgress2.queue;
          null !== queue && (queue.pending = null);
          workInProgress2 = workInProgress2.next;
        }
        didScheduleRenderPhaseUpdate = false;
      }
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber$1.alternate;
        nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;
      if (null !== nextWorkInProgressHook)
        workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
      else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber$1.alternate)
            throw Error(formatProdErrorMessage(467));
          throw Error(formatProdErrorMessage(310));
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      return workInProgressHook;
    }
    var createFunctionComponentUpdateQueue;
    createFunctionComponentUpdateQueue = function() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    };
    function useThenable(thenable) {
      var index2 = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = []);
      thenable = trackUsedThenable(thenableState, thenable, index2);
      index2 = currentlyRenderingFiber$1;
      null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
      return thenable;
    }
    function use(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error(formatProdErrorMessage(438, String(usable)));
    }
    function useMemoCache(size) {
      var memoCache = null, updateQueue = currentlyRenderingFiber$1.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber$1.alternate;
        null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
          data: current.data.map(function(array2) {
            return array2.slice();
          }),
          index: 0
        })));
      }
      null == memoCache && (memoCache = { data: [], index: 0 });
      null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue)
        for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;
      else {
        current = baseQueue.next;
        var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$54 = false;
        do {
          var updateLane = update.lane & -536870913;
          if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (0 === revertLane)
              null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                lane: 0,
                revertLane: 0,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$54 = true);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$54 = true);
              continue;
            } else
              updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
          } else
            revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$54 && (reducer = currentEntangledActionThenable, null !== reducer)))
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(), queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do
          newState = reducer(newState, update.action), update = update.next;
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber$1, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else getServerSnapshot = getSnapshot();
      var snapshotChanged = !objectIs(
        (currentHook || hook).memoizedState,
        getServerSnapshot
      );
      snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
      hook = hook.queue;
      updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
        subscribe
      ]);
      if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
        fiber.flags |= 2048;
        pushEffect(
          9,
          updateStoreInstance.bind(
            null,
            fiber,
            hook,
            getServerSnapshot,
            getSnapshot
          ),
          { destroy: void 0 },
          null
        );
        if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
        isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber$1.updateQueue;
      null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function() {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function forceStoreRerender(fiber) {
      var root2 = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
    }
    function mountStateImpl(initialState2) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState2) {
        var initialStateInitializer = initialState2;
        initialState2 = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState2;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState2
      };
      return hook;
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(
        hook,
        currentHook,
        "function" === typeof reducer ? reducer : basicStateReducer
      );
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload,
          action: fiber,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(listener) {
            actionNode.listeners.push(listener);
          }
        };
        null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    function runActionStateAction(actionQueue, node2) {
      var action = node2.action, payload = node2.payload, prevState = actionQueue.state;
      if (node2.isTransition) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node2, returnValue);
        } catch (error) {
          onActionError(actionQueue, node2, error);
        } finally {
          ReactSharedInternals.T = prevTransition;
        }
      } else
        try {
          prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node2, prevTransition);
        } catch (error$60) {
          onActionError(actionQueue, node2, error$60);
        }
    }
    function handleActionReturnValue(actionQueue, node2, returnValue) {
      null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
        function(nextState) {
          onActionSuccess(actionQueue, node2, nextState);
        },
        function(error) {
          return onActionError(actionQueue, node2, error);
        }
      ) : onActionSuccess(actionQueue, node2, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last) {
        last = last.next;
        do
          actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i2 = 0; i2 < actionNode.length; i2++) (0, actionNode[i2])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var JSCompiler_inline_result = currentlyRenderingFiber$1;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                  for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                    if (!inRootOrSingleton) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                    JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_inline_result$jscomp$0) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                  JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                }
                if (JSCompiler_inline_result$jscomp$0) {
                  nextHydratableInstance = getNextHydratable(
                    JSCompiler_inline_result$jscomp$0.nextSibling
                  );
                  JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                  break a;
                }
              }
              throwOnHydrationMismatch(JSCompiler_inline_result);
            }
            JSCompiler_inline_result = false;
          }
          JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      JSCompiler_inline_result = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = JSCompiler_inline_result;
      ssrFormState = dispatchSetState.bind(
        null,
        currentlyRenderingFiber$1,
        JSCompiler_inline_result
      );
      JSCompiler_inline_result.dispatch = ssrFormState;
      JSCompiler_inline_result = mountStateImpl(false);
      inRootOrSingleton = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber$1,
        false,
        JSCompiler_inline_result.queue
      );
      JSCompiler_inline_result = mountWorkInProgressHook();
      JSCompiler_inline_result$jscomp$0 = {
        state: initialStateProp,
        dispatch: null,
        action,
        pending: null
      };
      JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
      ssrFormState = dispatchActionState.bind(
        null,
        currentlyRenderingFiber$1,
        JSCompiler_inline_result$jscomp$0,
        inRootOrSingleton,
        ssrFormState
      );
      JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
      JSCompiler_inline_result.memoizedState = action;
      return [initialStateProp, ssrFormState, false];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(
        stateHook,
        currentStateHook,
        actionStateReducer
      )[0];
      stateHook = updateReducer(basicStateReducer)[0];
      currentStateHook = "object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;
      var actionQueueHook = updateWorkInProgressHook(), actionQueue = actionQueueHook.queue, dispatch = actionQueue.dispatch;
      action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(
        9,
        actionStateActionEffect.bind(null, actionQueue, action),
        { destroy: void 0 },
        null
      ));
      return [currentStateHook, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
      if (null !== currentStateHook)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, false];
    }
    function pushEffect(tag, create2, inst, deps) {
      tag = { tag, create: create2, inst, deps, next: null };
      create2 = currentlyRenderingFiber$1.updateQueue;
      null === create2 && (create2 = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create2);
      inst = create2.lastEffect;
      null === inst ? create2.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create2.lastEffect = tag);
      return tag;
    }
    function updateRef() {
      return updateWorkInProgressHook().memoizedState;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create2, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber$1.flags |= fiberFlags;
      hook.memoizedState = pushEffect(
        1 | hookFlags,
        create2,
        { destroy: void 0 },
        void 0 === deps ? null : deps
      );
    }
    function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create2, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(1 | hookFlags, create2, inst, deps));
    }
    function mountEffect(create2, deps) {
      mountEffectImpl(8390656, 8, create2, deps);
    }
    function updateEffect(create2, deps) {
      updateEffectImpl(2048, 8, create2, deps);
    }
    function updateInsertionEffect(create2, deps) {
      return updateEffectImpl(4, 2, create2, deps);
    }
    function updateLayoutEffect(create2, deps) {
      return updateEffectImpl(4, 4, create2, deps);
    }
    function imperativeHandleEffect(create2, ref) {
      if ("function" === typeof ref) {
        create2 = create2();
        var refCleanup = ref(create2);
        return function() {
          "function" === typeof refCleanup ? refCleanup() : ref(null);
        };
      }
      if (null !== ref && void 0 !== ref)
        return create2 = create2(), ref.current = create2, function() {
          ref.current = null;
        };
    }
    function updateImperativeHandle(ref, create2, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create2, ref), deps);
    }
    function mountDebugValue() {
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValueImpl(hook, value, initialValue2) {
      if (void 0 === initialValue2 || 0 !== (renderLanes & 1073741824))
        return hook.memoizedState = value;
      hook.memoizedState = initialValue2;
      hook = requestDeferredLane();
      currentlyRenderingFiber$1.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue2;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue2) {
      if (objectIs(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current)
        return hook = mountDeferredValueImpl(hook, value, initialValue2), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
      if (0 === (renderLanes & 42))
        return didReceiveUpdate = true, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber$1.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, false, queue, pendingState);
      try {
        var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
          var thenableForFinishedState = chainThenableValue(
            returnValue,
            finishedState
          );
          dispatchSetStateInternal(
            fiber,
            queue,
            thenableForFinishedState,
            requestUpdateLane(fiber)
          );
        } else
          dispatchSetStateInternal(
            fiber,
            queue,
            finishedState,
            requestUpdateLane(fiber)
          );
      } catch (error) {
        dispatchSetStateInternal(
          fiber,
          queue,
          { then: function() {
          }, status: "rejected", reason: error },
          requestUpdateLane()
        );
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function noop$2$1() {
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(
        formFiber,
        queue,
        pendingState,
        sharedNotPendingObject,
        null === action ? noop$2$1 : function() {
          requestFormReset$1(formFiber);
          return action(formData);
        }
      );
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: sharedNotPendingObject,
        baseState: sharedNotPendingObject,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: sharedNotPendingObject
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
      dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function updateId() {
      return updateWorkInProgressHook().memoizedState;
    }
    function updateRefresh() {
      return updateWorkInProgressHook().memoizedState;
    }
    function refreshCache(fiber) {
      for (var provider = fiber.return; null !== provider; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane();
            fiber = createUpdate(lane);
            var root$63 = enqueueUpdate(provider, fiber, lane);
            null !== root$63 && (scheduleUpdateOnFiber(root$63, provider, lane), entangleTransitions(root$63, provider, lane));
            provider = { cache: createCache$1() };
            fiber.payload = provider;
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var lane = requestUpdateLane();
      action = {
        lane,
        revertLane: 0,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
    }
    function dispatchSetState(fiber, queue, action) {
      var lane = requestUpdateLane();
      dispatchSetStateInternal(fiber, queue, action, lane);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane,
        revertLane: 0,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
          try {
            var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
            update.hasEagerState = true;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
          } catch (error) {
          } finally {
          }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action)
          return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
      }
      return false;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
      } else
        throwIfDuringRender = enqueueConcurrentHookUpdate(
          fiber,
          queue,
          action,
          2
        ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
      var pending = queue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    function entangleTransitionUpdate(root2, queue, lane) {
      if (0 !== (lane & 4194176)) {
        var queueLanes = queue.lanes;
        queueLanes &= root2.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root2, lane);
      }
    }
    var ContextOnlyDispatcher = {
      readContext,
      use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError
    };
    ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
    ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;
    ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
    ContextOnlyDispatcher.useFormState = throwInvalidHookError;
    ContextOnlyDispatcher.useActionState = throwInvalidHookError;
    ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
    var HooksDispatcherOnMount = {
      readContext,
      use,
      useCallback: function(callback, deps) {
        mountWorkInProgressHook().memoizedState = [
          callback,
          void 0 === deps ? null : deps
        ];
        return callback;
      },
      useContext: readContext,
      useEffect: mountEffect,
      useImperativeHandle: function(ref, create2, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        mountEffectImpl(
          4194308,
          4,
          imperativeHandleEffect.bind(null, create2, ref),
          deps
        );
      },
      useLayoutEffect: function(create2, deps) {
        return mountEffectImpl(4194308, 4, create2, deps);
      },
      useInsertionEffect: function(create2, deps) {
        mountEffectImpl(4, 2, create2, deps);
      },
      useMemo: function(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var nextValue = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [nextValue, deps];
        return nextValue;
      },
      useReducer: function(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        if (void 0 !== init) {
          var initialState2 = init(initialArg);
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              init(initialArg);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        } else initialState2 = initialArg;
        hook.memoizedState = hook.baseState = initialState2;
        reducer = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState2
        };
        hook.queue = reducer;
        reducer = reducer.dispatch = dispatchReducerAction.bind(
          null,
          currentlyRenderingFiber$1,
          reducer
        );
        return [hook.memoizedState, reducer];
      },
      useRef: function(initialValue2) {
        var hook = mountWorkInProgressHook();
        initialValue2 = { current: initialValue2 };
        return hook.memoizedState = initialValue2;
      },
      useState: function(initialState2) {
        initialState2 = mountStateImpl(initialState2);
        var queue = initialState2.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
        queue.dispatch = dispatch;
        return [initialState2.memoizedState, dispatch];
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue2) {
        var hook = mountWorkInProgressHook();
        return mountDeferredValueImpl(hook, value, initialValue2);
      },
      useTransition: function() {
        var stateHook = mountStateImpl(false);
        stateHook = startTransition.bind(
          null,
          currentlyRenderingFiber$1,
          stateHook.queue,
          true,
          false
        );
        mountWorkInProgressHook().memoizedState = stateHook;
        return [false, stateHook];
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1, hook = mountWorkInProgressHook();
        if (isHydrating) {
          if (void 0 === getServerSnapshot)
            throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else {
          getServerSnapshot = getSnapshot();
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        hook.memoizedState = getServerSnapshot;
        var inst = { value: getServerSnapshot, getSnapshot };
        hook.queue = inst;
        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
          subscribe
        ]);
        fiber.flags |= 2048;
        pushEffect(
          9,
          updateStoreInstance.bind(
            null,
            fiber,
            inst,
            getServerSnapshot,
            getSnapshot
          ),
          { destroy: void 0 },
          null
        );
        return getServerSnapshot;
      },
      useId: function() {
        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
        if (isHydrating) {
          var JSCompiler_inline_result = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
          identifierPrefix = ":" + identifierPrefix + "R" + JSCompiler_inline_result;
          JSCompiler_inline_result = localIdCounter++;
          0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
          identifierPrefix += ":";
        } else
          JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = ":" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + ":";
        return hook.memoizedState = identifierPrefix;
      },
      useCacheRefresh: function() {
        return mountWorkInProgressHook().memoizedState = refreshCache.bind(
          null,
          currentlyRenderingFiber$1
        );
      }
    };
    HooksDispatcherOnMount.useMemoCache = useMemoCache;
    HooksDispatcherOnMount.useHostTransitionStatus = useHostTransitionStatus;
    HooksDispatcherOnMount.useFormState = mountActionState;
    HooksDispatcherOnMount.useActionState = mountActionState;
    HooksDispatcherOnMount.useOptimistic = function(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber$1,
        true,
        queue
      );
      queue.dispatch = hook;
      return [passthrough, hook];
    };
    var HooksDispatcherOnUpdate = {
      readContext,
      use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: updateReducer,
      useRef: updateRef,
      useState: function() {
        return updateReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue2) {
        var hook = updateWorkInProgressHook();
        return updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue2
        );
      },
      useTransition: function() {
        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId
    };
    HooksDispatcherOnUpdate.useCacheRefresh = updateRefresh;
    HooksDispatcherOnUpdate.useMemoCache = useMemoCache;
    HooksDispatcherOnUpdate.useHostTransitionStatus = useHostTransitionStatus;
    HooksDispatcherOnUpdate.useFormState = updateActionState;
    HooksDispatcherOnUpdate.useActionState = updateActionState;
    HooksDispatcherOnUpdate.useOptimistic = function(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    };
    var HooksDispatcherOnRerender = {
      readContext,
      use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: rerenderReducer,
      useRef: updateRef,
      useState: function() {
        return rerenderReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue2) {
        var hook = updateWorkInProgressHook();
        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue2) : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue2
        );
      },
      useTransition: function() {
        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId
    };
    HooksDispatcherOnRerender.useCacheRefresh = updateRefresh;
    HooksDispatcherOnRerender.useMemoCache = useMemoCache;
    HooksDispatcherOnRerender.useHostTransitionStatus = useHostTransitionStatus;
    HooksDispatcherOnRerender.useFormState = rerenderActionState;
    HooksDispatcherOnRerender.useActionState = rerenderActionState;
    HooksDispatcherOnRerender.useOptimistic = function(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (null !== currentHook)
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    };
    function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
      ctor = workInProgress2.memoizedState;
      getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
      getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
      workInProgress2.memoizedState = getDerivedStateFromProps;
      0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
    }
    var classComponentUpdater = {
      isMounted: function(component) {
        return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : false;
      },
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 1;
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 2;
        void 0 !== callback && null !== callback && (update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
      }
    };
    function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
      workInProgress2 = workInProgress2.stateNode;
      return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
    }
    function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
      workInProgress2 = instance.state;
      "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
    }
    function resolveClassComponentProps(Component2, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if (Component2 = Component2.defaultProps) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var propName$67 in Component2)
          void 0 === newProps[propName$67] && (newProps[propName$67] = Component2[propName$67]);
      }
      return newProps;
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
    }
    function defaultOnCaughtError(error) {
      console.error(error);
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root2, errorInfo) {
      try {
        var onUncaughtError = root2.onUncaughtError;
        onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
      } catch (e$68) {
        setTimeout(function() {
          throw e$68;
        });
      }
    }
    function logCaughtError(root2, boundary, errorInfo) {
      try {
        var onCaughtError = root2.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
        });
      } catch (e$69) {
        setTimeout(function() {
          throw e$69;
        });
      }
    }
    function createRootErrorUpdate(root2, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      lane.payload = { element: null };
      lane.callback = function() {
        logUncaughtError(root2, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      return lane;
    }
    function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function() {
          return getDerivedStateFromError(error);
        };
        update.callback = function() {
          logCaughtError(root2, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
        logCaughtError(root2, fiber, errorInfo);
        "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        var stack = errorInfo.stack;
        this.componentDidCatch(errorInfo.value, {
          componentStack: null !== stack ? stack : ""
        });
      });
    }
    function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32768;
      if (null !== value && "object" === typeof value && "function" === typeof value.then) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber && propagateParentContextChanges(
          returnFiber,
          sourceFiber,
          rootRenderLanes,
          true
        );
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 13:
              return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
            case 22:
              return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
          }
          throw Error(formatProdErrorMessage(435, sourceFiber.tag));
        }
        attachPingListener(root2, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return false;
      }
      if (isHydrating)
        return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
          cause: value
        }), queueHydrationError(
          createCapturedValueAtFiber(returnFiber, sourceFiber)
        )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
          root2.stateNode,
          value,
          rootRenderLanes
        ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
      var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
      wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
      null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
      4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
      if (null === returnFiber) return true;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
          case 1:
            if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
              return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                rootRenderLanes,
                root2,
                sourceFiber,
                value
              ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return false;
    }
    var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
    function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
      workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
        workInProgress2,
        current.child,
        nextChildren,
        renderLanes2
      );
    }
    function updateForwardRef(current, workInProgress2, Component2, nextProps, renderLanes2) {
      Component2 = Component2.render;
      var ref = workInProgress2.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress2);
      nextProps = renderWithHooks(
        current,
        workInProgress2,
        Component2,
        propsWithoutRef,
        ref,
        renderLanes2
      );
      key = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && key && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateMemoComponent(current, workInProgress2, Component2, nextProps, renderLanes2) {
      if (null === current) {
        var type2 = Component2.type;
        if ("function" === typeof type2 && !shouldConstruct(type2) && void 0 === type2.defaultProps && null === Component2.compare)
          return workInProgress2.tag = 15, workInProgress2.type = type2, updateSimpleMemoComponent(
            current,
            workInProgress2,
            type2,
            nextProps,
            renderLanes2
          );
        current = createFiberFromTypeAndProps(
          Component2.type,
          null,
          nextProps,
          workInProgress2,
          workInProgress2.mode,
          renderLanes2
        );
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      type2 = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
        var prevProps = type2.memoizedProps;
        Component2 = Component2.compare;
        Component2 = null !== Component2 ? Component2 : shallowEqual;
        if (Component2(prevProps, nextProps) && current.ref === workInProgress2.ref)
          return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      workInProgress2.flags |= 1;
      current = createWorkInProgress(type2, nextProps);
      current.ref = workInProgress2.ref;
      current.return = workInProgress2;
      return workInProgress2.child = current;
    }
    function updateSimpleMemoComponent(current, workInProgress2, Component2, nextProps, renderLanes2) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
          if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
            0 !== (current.flags & 131072) && (didReceiveUpdate = true);
          else
            return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      return updateFunctionComponent(
        current,
        workInProgress2,
        Component2,
        nextProps,
        renderLanes2
      );
    }
    function updateOffscreenComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, nextIsDetached = 0 !== (workInProgress2.stateNode._pendingVisibility & 2), prevState = null !== current ? current.memoizedState : null;
      markRef(current, workInProgress2);
      if ("hidden" === nextProps.mode || nextIsDetached) {
        if (0 !== (workInProgress2.flags & 128)) {
          nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
          if (null !== current) {
            nextChildren = workInProgress2.child = current.child;
            for (nextIsDetached = 0; null !== nextChildren; )
              nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
            workInProgress2.childLanes = nextIsDetached & ~nextProps;
          } else workInProgress2.childLanes = 0, workInProgress2.child = null;
          return deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            nextProps,
            renderLanes2
          );
        }
        if (0 !== (renderLanes2 & 536870912))
          workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
            workInProgress2,
            null !== prevState ? prevState.cachePool : null
          ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
        else
          return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
            renderLanes2
          );
      } else
        null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
      workInProgress2.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      null !== current && pushTransition(workInProgress2, null);
      reuseHiddenContextOnStack();
      pushOffscreenSuspenseHandler(workInProgress2);
      null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
      return null;
    }
    function markRef(current, workInProgress2) {
      var ref = workInProgress2.ref;
      if (null === ref)
        null !== current && null !== current.ref && (workInProgress2.flags |= 2097664);
      else {
        if ("function" !== typeof ref && "object" !== typeof ref)
          throw Error(formatProdErrorMessage(284));
        if (null === current || current.ref !== ref)
          workInProgress2.flags |= 2097664;
      }
    }
    function updateFunctionComponent(current, workInProgress2, Component2, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      Component2 = renderWithHooks(
        current,
        workInProgress2,
        Component2,
        nextProps,
        void 0,
        renderLanes2
      );
      nextProps = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, Component2, renderLanes2);
      return workInProgress2.child;
    }
    function replayFunctionComponent(current, workInProgress2, nextProps, Component2, secondArg, renderLanes2) {
      prepareToReadContext(workInProgress2);
      workInProgress2.updateQueue = null;
      nextProps = renderWithHooksAgain(
        workInProgress2,
        Component2,
        nextProps,
        secondArg
      );
      finishRenderingHooks(current);
      Component2 = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && Component2 && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateClassComponent(current, workInProgress2, Component2, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      if (null === workInProgress2.stateNode) {
        var context = emptyContextObject, contextType = Component2.contextType;
        "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
        context = new Component2(nextProps, context);
        workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
        context.updater = classComponentUpdater;
        workInProgress2.stateNode = context;
        context._reactInternals = workInProgress2;
        context = workInProgress2.stateNode;
        context.props = nextProps;
        context.state = workInProgress2.memoizedState;
        context.refs = {};
        initializeUpdateQueue(workInProgress2);
        contextType = Component2.contextType;
        context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
        context.state = workInProgress2.memoizedState;
        contextType = Component2.getDerivedStateFromProps;
        "function" === typeof contextType && (applyDerivedStateFromProps(
          workInProgress2,
          Component2,
          contextType,
          nextProps
        ), context.state = workInProgress2.memoizedState);
        "function" === typeof Component2.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
        "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
        nextProps = true;
      } else if (null === current) {
        context = workInProgress2.stateNode;
        var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component2, unresolvedOldProps);
        context.props = oldProps;
        var oldContext = context.context, contextType$jscomp$0 = Component2.contextType;
        contextType = emptyContextObject;
        "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
        var getDerivedStateFromProps = Component2.getDerivedStateFromProps;
        contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
        contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          contextType
        );
        hasForceUpdate = false;
        var oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress2.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component2,
          getDerivedStateFromProps,
          nextProps
        ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component2,
          oldProps,
          nextProps,
          oldState,
          oldContext,
          contextType
        )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
      } else {
        context = workInProgress2.stateNode;
        cloneUpdateQueue(current, workInProgress2);
        contextType = workInProgress2.memoizedProps;
        contextType$jscomp$0 = resolveClassComponentProps(Component2, contextType);
        context.props = contextType$jscomp$0;
        getDerivedStateFromProps = workInProgress2.pendingProps;
        oldState = context.context;
        oldContext = Component2.contextType;
        oldProps = emptyContextObject;
        "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
        unresolvedOldProps = Component2.getDerivedStateFromProps;
        (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          oldProps
        );
        hasForceUpdate = false;
        oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress2.memoizedState;
        contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component2,
          unresolvedOldProps,
          nextProps
        ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component2,
          contextType$jscomp$0,
          nextProps,
          oldState,
          newState,
          oldProps
        ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
          nextProps,
          newState,
          oldProps
        )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
      }
      context = nextProps;
      markRef(current, workInProgress2);
      nextProps = 0 !== (workInProgress2.flags & 128);
      context || nextProps ? (context = workInProgress2.stateNode, Component2 = nextProps && "function" !== typeof Component2.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        current.child,
        null,
        renderLanes2
      ), workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        null,
        Component2,
        renderLanes2
      )) : reconcileChildren(current, workInProgress2, Component2, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
        current,
        workInProgress2,
        renderLanes2
      );
      return current;
    }
    function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
      resetHydrationState();
      workInProgress2.flags |= 256;
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    var SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0 };
    function mountSuspenseOffscreenState(renderLanes2) {
      return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
      current = null !== current ? current.childLanes & ~renderLanes2 : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
      (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
      JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
      JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
      workInProgress2.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
          if (isHydrating) {
            var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
            if (JSCompiler_temp$jscomp$0 = nextInstance) {
              c: {
                JSCompiler_temp$jscomp$0 = nextInstance;
                for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType; ) {
                  if (!nextInstance) {
                    nextInstance = null;
                    break c;
                  }
                  JSCompiler_temp$jscomp$0 = getNextHydratable(
                    JSCompiler_temp$jscomp$0.nextSibling
                  );
                  if (null === JSCompiler_temp$jscomp$0) {
                    nextInstance = null;
                    break c;
                  }
                }
                nextInstance = JSCompiler_temp$jscomp$0;
              }
              null !== nextInstance ? (workInProgress2.memoizedState = {
                dehydrated: nextInstance,
                treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                retryLane: 536870912
              }, JSCompiler_temp$jscomp$0 = createFiberImplClass(
                18,
                null,
                null,
                0
              ), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress2, workInProgress2.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
            }
            JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress2);
          }
          nextInstance = workInProgress2.memoizedState;
          if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
            return "$!" === nextInstance.data ? workInProgress2.lanes = 16 : workInProgress2.lanes = 536870912, null;
          popSuspenseHandler(workInProgress2);
        }
        nextInstance = nextProps.children;
        nextProps = nextProps.fallback;
        if (showFallback)
          return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
            { mode: "hidden", children: nextInstance },
            showFallback
          ), nextProps = createFiberFromFragment(
            nextProps,
            showFallback,
            renderLanes2,
            null
          ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
      }
      JSCompiler_temp$jscomp$0 = current.memoizedState;
      if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
        if (didSuspend)
          workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: nextProps.children },
            nextInstance
          ), showFallback = createFiberFromFragment(
            showFallback,
            nextInstance,
            renderLanes2,
            null
          ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
            workInProgress2,
            current.child,
            null,
            renderLanes2
          ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
        else if (pushPrimaryTreeSuspenseHandler(workInProgress2), "$!" === nextInstance.data) {
          JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
          if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
          JSCompiler_temp = digest;
          nextProps = Error(formatProdErrorMessage(419));
          nextProps.stack = "";
          nextProps.digest = JSCompiler_temp;
          queueHydrationError({ value: nextProps, source: null, stack: null });
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
          JSCompiler_temp = workInProgressRoot;
          if (null !== JSCompiler_temp) {
            nextProps = renderLanes2 & -renderLanes2;
            if (0 !== (nextProps & 42)) nextProps = 1;
            else
              switch (nextProps) {
                case 2:
                  nextProps = 1;
                  break;
                case 8:
                  nextProps = 4;
                  break;
                case 32:
                  nextProps = 16;
                  break;
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                  nextProps = 64;
                  break;
                case 268435456:
                  nextProps = 134217728;
                  break;
                default:
                  nextProps = 0;
              }
            nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps;
            if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)
              throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
          }
          "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else
          "$?" === nextInstance.data ? (workInProgress2.flags |= 128, workInProgress2.child = current.child, workInProgress2 = retryDehydratedSuspenseBoundary.bind(
            null,
            current
          ), nextInstance._reactRetry = workInProgress2, workInProgress2 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(
            nextInstance.nextSibling
          ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
            workInProgress2,
            nextProps.children
          ), workInProgress2.flags |= 4096);
        return workInProgress2;
      }
      if (showFallback)
        return reuseSuspenseHandlerOnStack(), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
          mode: "hidden",
          children: nextProps.children
        }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 31457280, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(
          showFallback,
          nextInstance,
          renderLanes2,
          null
        ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? { parent: digest, pool: digest } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
          baseLanes: nextInstance.baseLanes | renderLanes2,
          cachePool: JSCompiler_temp$jscomp$0
        }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      renderLanes2 = current.child;
      current = renderLanes2.sibling;
      renderLanes2 = createWorkInProgress(renderLanes2, {
        mode: "visible",
        children: nextProps.children
      });
      renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
      null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
      workInProgress2.child = renderLanes2;
      workInProgress2.memoizedState = null;
      return renderLanes2;
    }
    function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber(
        { mode: "visible", children: primaryChildren },
        workInProgress2.mode
      );
      primaryChildren.return = workInProgress2;
      return workInProgress2.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      return createFiberFromOffscreen(offscreenProps, mode, 0, null);
    }
    function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
      current = mountSuspensePrimaryChildren(
        workInProgress2,
        workInProgress2.pendingProps.children
      );
      current.flags |= 2;
      workInProgress2.memoizedState = null;
      return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
      fiber.lanes |= renderLanes2;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes2);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
    }
    function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
      var renderState = workInProgress2.memoizedState;
      null === renderState ? workInProgress2.memoizedState = {
        isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail,
        tailMode
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
    }
    function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
      reconcileChildren(current, workInProgress2, nextProps.children, renderLanes2);
      nextProps = suspenseStackCursor.current;
      if (0 !== (nextProps & 2))
        nextProps = nextProps & 1 | 2, workInProgress2.flags |= 128;
      else {
        if (null !== current && 0 !== (current.flags & 128))
          a: for (current = workInProgress2.child; null !== current; ) {
            if (13 === current.tag)
              null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
            else if (19 === current.tag)
              scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
            else if (null !== current.child) {
              current.child.return = current;
              current = current.child;
              continue;
            }
            if (current === workInProgress2) break a;
            for (; null === current.sibling; ) {
              if (null === current.return || current.return === workInProgress2)
                break a;
              current = current.return;
            }
            current.sibling.return = current.return;
            current = current.sibling;
          }
        nextProps &= 1;
      }
      push(suspenseStackCursor, nextProps);
      switch (revealOrder) {
        case "forwards":
          renderLanes2 = workInProgress2.child;
          for (revealOrder = null; null !== renderLanes2; )
            current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
          renderLanes2 = revealOrder;
          null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
          initSuspenseListRenderState(
            workInProgress2,
            false,
            revealOrder,
            renderLanes2,
            tailMode
          );
          break;
        case "backwards":
          renderLanes2 = null;
          revealOrder = workInProgress2.child;
          for (workInProgress2.child = null; null !== revealOrder; ) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress2.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes2;
            renderLanes2 = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(
            workInProgress2,
            true,
            renderLanes2,
            null,
            tailMode
          );
          break;
        case "together":
          initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
          break;
        default:
          workInProgress2.memoizedState = null;
      }
      return workInProgress2.child;
    }
    function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
      null !== current && (workInProgress2.dependencies = current.dependencies);
      workInProgressRootSkippedLanes |= workInProgress2.lanes;
      if (0 === (renderLanes2 & workInProgress2.childLanes))
        if (null !== current) {
          if (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), 0 === (renderLanes2 & workInProgress2.childLanes))
            return null;
        } else return null;
      if (null !== current && workInProgress2.child !== current.child)
        throw Error(formatProdErrorMessage(153));
      if (null !== workInProgress2.child) {
        current = workInProgress2.child;
        renderLanes2 = createWorkInProgress(current, current.pendingProps);
        workInProgress2.child = renderLanes2;
        for (renderLanes2.return = workInProgress2; null !== current.sibling; )
          current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
      }
      return workInProgress2.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes2) {
      if (0 !== (current.lanes & renderLanes2)) return true;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? true : false;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
      switch (workInProgress2.tag) {
        case 3:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress2);
          break;
        case 4:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          break;
        case 10:
          pushProvider(
            workInProgress2,
            workInProgress2.type,
            workInProgress2.memoizedProps.value
          );
          break;
        case 13:
          var state = workInProgress2.memoizedState;
          if (null !== state) {
            if (null !== state.dehydrated)
              return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
            if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
              return updateSuspenseComponent(current, workInProgress2, renderLanes2);
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            current = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress2,
              renderLanes2
            );
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          state = 0 !== (renderLanes2 & workInProgress2.childLanes);
          state || (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), state = 0 !== (renderLanes2 & workInProgress2.childLanes));
          if (didSuspendBefore) {
            if (state)
              return updateSuspenseListComponent(
                current,
                workInProgress2,
                renderLanes2
              );
            workInProgress2.flags |= 128;
          }
          didSuspendBefore = workInProgress2.memoizedState;
          null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current);
          if (state) break;
          else return null;
        case 22:
        case 23:
          return workInProgress2.lanes = 0, updateOffscreenComponent(current, workInProgress2, renderLanes2);
        case 24:
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    function beginWork(current, workInProgress2, renderLanes2) {
      if (null !== current)
        if (current.memoizedProps !== workInProgress2.pendingProps)
          didReceiveUpdate = true;
        else {
          if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
            return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
              current,
              workInProgress2,
              renderLanes2
            );
          didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
        }
      else
        didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
      workInProgress2.lanes = 0;
      switch (workInProgress2.tag) {
        case 16:
          a: {
            current = workInProgress2.pendingProps;
            var lazyComponent = workInProgress2.elementType, init = lazyComponent._init;
            lazyComponent = init(lazyComponent._payload);
            workInProgress2.type = lazyComponent;
            if ("function" === typeof lazyComponent)
              shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                null,
                workInProgress2,
                lazyComponent,
                current,
                renderLanes2
              )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                null,
                workInProgress2,
                lazyComponent,
                current,
                renderLanes2
              ));
            else {
              if (void 0 !== lazyComponent && null !== lazyComponent) {
                if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2 = updateForwardRef(
                    null,
                    workInProgress2,
                    lazyComponent,
                    current,
                    renderLanes2
                  );
                  break a;
                } else if (init === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(
                    null,
                    workInProgress2,
                    lazyComponent,
                    current,
                    renderLanes2
                  );
                  break a;
                }
              }
              workInProgress2 = getComponentNameFromType(lazyComponent) || lazyComponent;
              throw Error(formatProdErrorMessage(306, workInProgress2, ""));
            }
          }
          return workInProgress2;
        case 0:
          return updateFunctionComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 1:
          return lazyComponent = workInProgress2.type, init = resolveClassComponentProps(
            lazyComponent,
            workInProgress2.pendingProps
          ), updateClassComponent(
            current,
            workInProgress2,
            lazyComponent,
            init,
            renderLanes2
          );
        case 3:
          a: {
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            if (null === current) throw Error(formatProdErrorMessage(387));
            var nextProps = workInProgress2.pendingProps;
            init = workInProgress2.memoizedState;
            lazyComponent = init.element;
            cloneUpdateQueue(current, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            nextProps = nextState.cache;
            pushProvider(workInProgress2, CacheContext, nextProps);
            nextProps !== init.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            );
            suspendIfUpdateReadFromEntangledAsyncAction();
            nextProps = nextState.element;
            if (init.isDehydrated)
              if (init = {
                element: nextProps,
                isDehydrated: false,
                cache: nextState.cache
              }, workInProgress2.updateQueue.baseState = init, workInProgress2.memoizedState = init, workInProgress2.flags & 256) {
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  nextProps,
                  renderLanes2
                );
                break a;
              } else if (nextProps !== lazyComponent) {
                lazyComponent = createCapturedValueAtFiber(
                  Error(formatProdErrorMessage(424)),
                  workInProgress2
                );
                queueHydrationError(lazyComponent);
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  nextProps,
                  renderLanes2
                );
                break a;
              } else
                for (nextHydratableInstance = getNextHydratable(
                  workInProgress2.stateNode.containerInfo.firstChild
                ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = true, renderLanes2 = mountChildFibers(
                  workInProgress2,
                  null,
                  nextProps,
                  renderLanes2
                ), workInProgress2.child = renderLanes2; renderLanes2; )
                  renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
            else {
              resetHydrationState();
              if (nextProps === lazyComponent) {
                workInProgress2 = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress2,
                  renderLanes2
                );
                break a;
              }
              reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
            }
            workInProgress2 = workInProgress2.child;
          }
          return workInProgress2;
        case 26:
          return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
            workInProgress2.type,
            null,
            workInProgress2.pendingProps,
            null
          )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          ).createElement(renderLanes2), lazyComponent[internalInstanceKey] = workInProgress2, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes2, current), markNodeAsHoistable(lazyComponent), workInProgress2.stateNode = lazyComponent) : workInProgress2.memoizedState = getResource(
            workInProgress2.type,
            current.memoizedProps,
            workInProgress2.pendingProps,
            current.memoizedState
          ), null;
        case 27:
          return pushHostContext(workInProgress2), null === current && isHydrating && (lazyComponent = workInProgress2.stateNode = resolveSingletonInstance(
            workInProgress2.type,
            workInProgress2.pendingProps,
            rootInstanceStackCursor.current
          ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, nextHydratableInstance = getNextHydratable(
            lazyComponent.firstChild
          )), lazyComponent = workInProgress2.pendingProps.children, null !== current || isHydrating ? reconcileChildren(
            current,
            workInProgress2,
            lazyComponent,
            renderLanes2
          ) : workInProgress2.child = reconcileChildFibers(
            workInProgress2,
            null,
            lazyComponent,
            renderLanes2
          ), markRef(current, workInProgress2), workInProgress2.child;
        case 5:
          if (null === current && isHydrating) {
            if (init = lazyComponent = nextHydratableInstance)
              lazyComponent = canHydrateInstance(
                lazyComponent,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== lazyComponent ? (workInProgress2.stateNode = lazyComponent, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                lazyComponent.firstChild
              ), rootOrSingletonContext = false, init = true) : init = false;
            init || throwOnHydrationMismatch(workInProgress2);
          }
          pushHostContext(workInProgress2);
          init = workInProgress2.type;
          nextProps = workInProgress2.pendingProps;
          nextState = null !== current ? current.memoizedProps : null;
          lazyComponent = nextProps.children;
          shouldSetTextContent(init, nextProps) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress2.flags |= 32);
          null !== workInProgress2.memoizedState && (init = renderWithHooks(
            current,
            workInProgress2,
            TransitionAwareHostComponent,
            null,
            null,
            renderLanes2
          ), HostTransitionContext._currentValue = init);
          markRef(current, workInProgress2);
          reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2);
          return workInProgress2.child;
        case 6:
          if (null === current && isHydrating) {
            if (current = renderLanes2 = nextHydratableInstance)
              renderLanes2 = canHydrateTextInstance(
                renderLanes2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
            current || throwOnHydrationMismatch(workInProgress2);
          }
          return null;
        case 13:
          return updateSuspenseComponent(current, workInProgress2, renderLanes2);
        case 4:
          return pushHostContainer(
            workInProgress2,
            workInProgress2.stateNode.containerInfo
          ), lazyComponent = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
            workInProgress2,
            null,
            lazyComponent,
            renderLanes2
          ) : reconcileChildren(
            current,
            workInProgress2,
            lazyComponent,
            renderLanes2
          ), workInProgress2.child;
        case 11:
          return updateForwardRef(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 7:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps,
            renderLanes2
          ), workInProgress2.child;
        case 8:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 12:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 10:
          return lazyComponent = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, lazyComponent.value), reconcileChildren(
            current,
            workInProgress2,
            lazyComponent.children,
            renderLanes2
          ), workInProgress2.child;
        case 9:
          return init = workInProgress2.type._context, lazyComponent = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2), workInProgress2.child;
        case 14:
          return updateMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 15:
          return updateSimpleMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 19:
          return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
        case 22:
          return updateOffscreenComponent(current, workInProgress2, renderLanes2);
        case 24:
          return prepareToReadContext(workInProgress2), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, nextProps = createCache$1(), init.pooledCache = nextProps, nextProps.refCount++, null !== nextProps && (init.pooledCacheLanes |= renderLanes2), init = nextProps), workInProgress2.memoizedState = {
            parent: lazyComponent,
            cache: init
          }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, init)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, nextProps = workInProgress2.memoizedState, init.parent !== lazyComponent ? (init = { parent: lazyComponent, cache: lazyComponent }, workInProgress2.memoizedState = init, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = init), pushProvider(workInProgress2, CacheContext, lazyComponent)) : (lazyComponent = nextProps.cache, pushProvider(workInProgress2, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(
            workInProgress2,
            [CacheContext],
            renderLanes2,
            true
          ))), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 29:
          throw workInProgress2.pendingProps;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    var valueCursor = createCursor(null), currentlyRenderingFiber = null, lastContextDependency = null;
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue);
      context._currentValue = nextValue;
    }
    function popProvider(context) {
      context._currentValue = valueCursor.current;
      pop(valueCursor);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
      for (; null !== parent; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
    }
    function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
      var fiber = workInProgress2.child;
      null !== fiber && (fiber.return = workInProgress2);
      for (; null !== fiber; ) {
        var list = fiber.dependencies;
        if (null !== list) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a: for (; null !== list; ) {
            var dependency = list;
            list = fiber;
            for (var i2 = 0; i2 < contexts.length; i2++)
              if (dependency.context === contexts[i2]) {
                list.lanes |= renderLanes2;
                dependency = list.alternate;
                null !== dependency && (dependency.lanes |= renderLanes2);
                scheduleContextWorkOnParentPath(
                  list.return,
                  renderLanes2,
                  workInProgress2
                );
                forcePropagateEntireTree || (nextFiber = null);
                break a;
              }
            list = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber) throw Error(formatProdErrorMessage(341));
          nextFiber.lanes |= renderLanes2;
          list = nextFiber.alternate;
          null !== list && (list.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;
        else
          for (nextFiber = fiber; null !== nextFiber; ) {
            if (nextFiber === workInProgress2) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (null !== fiber) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
      current = null;
      for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
        if (!isInsidePropagationBailout) {
          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
          else if (0 !== (parent.flags & 262144)) break;
        }
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
        }
        parent = parent.return;
      }
      null !== current && propagateContextChanges(
        workInProgress2,
        current,
        renderLanes2,
        forcePropagateEntireTree
      );
      workInProgress2.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
        if (!objectIs(
          currentDependencies.context._currentValue,
          currentDependencies.memoizedValue
        ))
          return true;
        currentDependencies = currentDependencies.next;
      }
      return false;
    }
    function prepareToReadContext(workInProgress2) {
      currentlyRenderingFiber = workInProgress2;
      lastContextDependency = null;
      workInProgress2 = workInProgress2.dependencies;
      null !== workInProgress2 && (workInProgress2.firstContext = null);
    }
    function readContext(context) {
      return readContextForConsumer(currentlyRenderingFiber, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = { context, memoizedValue: value, next: null };
      if (null === lastContextDependency) {
        if (null === consumer) throw Error(formatProdErrorMessage(308));
        lastContextDependency = context;
        consumer.dependencies = { lanes: 0, firstContext: context };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    var hasForceUpdate = false;
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current, workInProgress2) {
      current = current.updateQueue;
      workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
        baseState: current.baseState,
        firstBaseUpdate: current.firstBaseUpdate,
        lastBaseUpdate: current.lastBaseUpdate,
        shared: current.shared,
        callbacks: null
      });
    }
    function createUpdate(lane) {
      return { lane, tag: 0, payload: null, callback: null, next: null };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (0 !== (executionContext & 2)) {
        var pending = updateQueue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        updateQueue.pending = update;
        update = getRootForUpdatedFiber(fiber);
        markUpdateLaneFromFiberToRoot(fiber, null, lane);
        return update;
      }
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root2, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root2.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root2, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
      var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
      if (null !== current && (current = current.updateQueue, queue === current)) {
        var newFirst = null, newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone2 = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            null === newLast ? newFirst = newLast = clone2 : newLast = newLast.next = clone2;
            queue = queue.next;
          } while (null !== queue);
          null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks
        };
        workInProgress2.updateQueue = queue;
        return;
      }
      workInProgress2 = queue.lastBaseUpdate;
      null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    var didReadFromEntangledAsyncAction = false;
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
      didReadFromEntangledAsyncAction = false;
      var queue = workInProgress$jscomp$0.updateQueue;
      hasForceUpdate = false;
      var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress$jscomp$0.alternate;
        null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
            0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
            null !== current && (current = current.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
              updateLane = props;
              var instance = instance$jscomp$0;
              switch (update.tag) {
                case 1:
                  workInProgress2 = update.payload;
                  if ("function" === typeof workInProgress2) {
                    newState = workInProgress2.call(instance, newState, updateLane);
                    break a;
                  }
                  newState = workInProgress2;
                  break a;
                case 3:
                  workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                case 0:
                  workInProgress2 = update.payload;
                  updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                  if (null === updateLane || void 0 === updateLane) break a;
                  newState = assign({}, newState, updateLane);
                  break a;
                case 2:
                  hasForceUpdate = true;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else
            isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue)
            if (pendingQueue = queue.shared.pending, null === pendingQueue)
              break;
            else
              isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress$jscomp$0.lanes = lastBaseUpdate;
        workInProgress$jscomp$0.memoizedState = newState;
      }
    }
    function callCallback(callback, context) {
      if ("function" !== typeof callback)
        throw Error(formatProdErrorMessage(191, callback));
      callback.call(context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks)
        for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
          callCallback(callbacks[updateQueue], context);
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              lastEffect = void 0;
              var create2 = updateQueue.create, inst = updateQueue.inst;
              lastEffect = create2();
              inst.destroy = lastEffect;
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst, destroy2 = inst.destroy;
              if (void 0 !== destroy2) {
                inst.destroy = void 0;
                lastEffect = finishedWork;
                var nearestMountedAncestor = nearestMountedAncestor$jscomp$0;
                try {
                  destroy2();
                } catch (error) {
                  captureCommitPhaseError(
                    lastEffect,
                    nearestMountedAncestor,
                    error
                  );
                }
              }
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        try {
          commitCallbacks(updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(
        current.type,
        current.memoizedProps
      );
      instance.state = current.memoizedState;
      try {
        instance.componentWillUnmount();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        var ref = current.ref;
        if (null !== ref) {
          var instance = current.stateNode;
          switch (current.tag) {
            case 26:
            case 27:
            case 5:
              var instanceToUse = instance;
              break;
            default:
              instanceToUse = instance;
          }
          "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
        }
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref, refCleanup = current.refCleanup;
      if (null !== ref)
        if ("function" === typeof refCleanup)
          try {
            refCleanup();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          } finally {
            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
          }
        else if ("function" === typeof ref)
          try {
            ref(null);
          } catch (error$112) {
            captureCommitPhaseError(current, nearestMountedAncestor, error$112);
          }
        else ref.current = null;
    }
    function commitHostMount(finishedWork) {
      var type2 = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
      try {
        a: switch (type2) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            props.autoFocus && instance.focus();
            break a;
          case "img":
            props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        var domElement = finishedWork.stateNode;
        updateProperties(domElement, finishedWork.type, oldProps, newProps);
        domElement[internalPropsKey] = newProps;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag || 4 === fiber.tag;
    }
    function getHostSibling(fiber) {
      a: for (; ; ) {
        for (; null === fiber.sibling; ) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 27 !== fiber.tag && 18 !== fiber.tag; ) {
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;
          else fiber.child.return = fiber, fiber = fiber.child;
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node2, before, parent) {
      var tag = node2.tag;
      if (5 === tag || 6 === tag)
        node2 = node2.stateNode, before ? 8 === parent.nodeType ? parent.parentNode.insertBefore(node2, before) : parent.insertBefore(node2, before) : (8 === parent.nodeType ? (before = parent.parentNode, before.insertBefore(node2, parent)) : (before = parent, before.appendChild(node2)), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1$1));
      else if (4 !== tag && 27 !== tag && (node2 = node2.child, null !== node2))
        for (insertOrAppendPlacementNodeIntoContainer(node2, before, parent), node2 = node2.sibling; null !== node2; )
          insertOrAppendPlacementNodeIntoContainer(node2, before, parent), node2 = node2.sibling;
    }
    function insertOrAppendPlacementNode(node2, before, parent) {
      var tag = node2.tag;
      if (5 === tag || 6 === tag)
        node2 = node2.stateNode, before ? parent.insertBefore(node2, before) : parent.appendChild(node2);
      else if (4 !== tag && 27 !== tag && (node2 = node2.child, null !== node2))
        for (insertOrAppendPlacementNode(node2, before, parent), node2 = node2.sibling; null !== node2; )
          insertOrAppendPlacementNode(node2, before, parent), node2 = node2.sibling;
    }
    var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, shouldFireAfterActiveInstanceBlur = false;
    function commitBeforeMutationEffects(root2, firstChild) {
      root2 = root2.containerInfo;
      eventsEnabled = _enabled;
      root2 = getActiveElementDeep(root2);
      if (hasSelectionCapabilities(root2)) {
        if ("selectionStart" in root2)
          var JSCompiler_temp = {
            start: root2.selectionStart,
            end: root2.selectionEnd
          };
        else
          a: {
            JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
            var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && 0 !== selection.rangeCount) {
              JSCompiler_temp = selection.anchorNode;
              var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
              selection = selection.focusOffset;
              try {
                JSCompiler_temp.nodeType, focusNode.nodeType;
              } catch (e$20) {
                JSCompiler_temp = null;
                break a;
              }
              var length2 = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node2 = root2, parentNode = null;
              b: for (; ; ) {
                for (var next2; ; ) {
                  node2 !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node2.nodeType || (start = length2 + anchorOffset);
                  node2 !== focusNode || 0 !== selection && 3 !== node2.nodeType || (end = length2 + selection);
                  3 === node2.nodeType && (length2 += node2.nodeValue.length);
                  if (null === (next2 = node2.firstChild)) break;
                  parentNode = node2;
                  node2 = next2;
                }
                for (; ; ) {
                  if (node2 === root2) break b;
                  parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length2);
                  parentNode === focusNode && ++indexWithinFocus === selection && (end = length2);
                  if (null !== (next2 = node2.nextSibling)) break;
                  node2 = parentNode;
                  parentNode = node2.parentNode;
                }
                node2 = next2;
              }
              JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
            } else JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else JSCompiler_temp = null;
      selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
      _enabled = false;
      for (nextEffect = firstChild; null !== nextEffect; )
        if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
          root2.return = firstChild, nextEffect = root2;
        else
          for (; null !== nextEffect; ) {
            firstChild = nextEffect;
            focusNode = firstChild.alternate;
            root2 = firstChild.flags;
            switch (firstChild.tag) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                if (0 !== (root2 & 1024) && null !== focusNode) {
                  root2 = void 0;
                  JSCompiler_temp = firstChild;
                  anchorOffset = focusNode.memoizedProps;
                  focusNode = focusNode.memoizedState;
                  selection = JSCompiler_temp.stateNode;
                  try {
                    var resolvedPrevProps = resolveClassComponentProps(
                      JSCompiler_temp.type,
                      anchorOffset,
                      JSCompiler_temp.elementType === JSCompiler_temp.type
                    );
                    root2 = selection.getSnapshotBeforeUpdate(
                      resolvedPrevProps,
                      focusNode
                    );
                    selection.__reactInternalSnapshotBeforeUpdate = root2;
                  } catch (error) {
                    captureCommitPhaseError(
                      JSCompiler_temp,
                      JSCompiler_temp.return,
                      error
                    );
                  }
                }
                break;
              case 3:
                if (0 !== (root2 & 1024)) {
                  if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                    clearContainerSparingly(root2);
                  else if (1 === JSCompiler_temp)
                    switch (root2.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        clearContainerSparingly(root2);
                        break;
                      default:
                        root2.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
            }
            root2 = firstChild.sibling;
            if (null !== root2) {
              root2.return = firstChild.return;
              nextEffect = root2;
              break;
            }
            nextEffect = firstChild.return;
          }
      resolvedPrevProps = shouldFireAfterActiveInstanceBlur;
      shouldFireAfterActiveInstanceBlur = false;
      return resolvedPrevProps;
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookEffectListMount(5, finishedWork);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (finishedRoot = finishedWork.stateNode, null === current)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            else {
              var prevProps = resolveClassComponentProps(
                finishedWork.type,
                current.memoizedProps
              );
              current = current.memoizedState;
              try {
                finishedRoot.componentDidUpdate(
                  prevProps,
                  current,
                  finishedRoot.__reactInternalSnapshotBeforeUpdate
                );
              } catch (error$111) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error$111
                );
              }
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
            finishedRoot = null;
            if (null !== finishedWork.child)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  finishedRoot = finishedWork.child.stateNode;
                  break;
                case 1:
                  finishedRoot = finishedWork.child.stateNode;
              }
            try {
              commitCallbacks(flags, finishedRoot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 26:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          null === current && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!prevProps) {
            current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
            var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevProps;
            (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              0 !== (finishedWork.subtreeFlags & 8772)
            ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          flags & 512 && ("manual" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    var hostParent = null, hostParentIsContainer = false;
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child; null !== parent; )
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
        }
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        case 27:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          deletedFiber = deletedFiber.stateNode;
          for (nearestMountedAncestor = deletedFiber.attributes; nearestMountedAncestor.length; )
            deletedFiber.removeAttributeNode(nearestMountedAncestor[0]);
          detachDeletedInstance(deletedFiber);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParentIsContainer = hostParent;
          var prevHostParentIsContainer$119 = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParentIsContainer;
          hostParentIsContainer = prevHostParentIsContainer$119;
          if (null !== hostParent)
            if (hostParentIsContainer)
              try {
                finishedRoot = hostParent, prevHostParent = deletedFiber.stateNode, 8 === finishedRoot.nodeType ? finishedRoot.parentNode.removeChild(prevHostParent) : finishedRoot.removeChild(prevHostParent);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
            else
              try {
                hostParent.removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
          break;
        case 18:
          null !== hostParent && (hostParentIsContainer ? (nearestMountedAncestor = hostParent, deletedFiber = deletedFiber.stateNode, 8 === nearestMountedAncestor.nodeType ? clearSuspenseBoundary(
            nearestMountedAncestor.parentNode,
            deletedFiber
          ) : 1 === nearestMountedAncestor.nodeType && clearSuspenseBoundary(nearestMountedAncestor, deletedFiber), retryIfBlockedOn(nearestMountedAncestor)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = true;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 1:
          offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            prevHostParent
          ));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 21:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 22:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
        default:
          throw Error(formatProdErrorMessage(435, finishedWork.tag));
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function(wakeable) {
        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
        retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions)
        for (var i2 = 0; i2 < deletions.length; i2++) {
          var childToDelete = deletions[i2], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
          a: for (; null !== parent; ) {
            switch (parent.tag) {
              case 27:
              case 5:
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break a;
              case 3:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break a;
              case 4:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break a;
            }
            parent = parent.return;
          }
          if (null === hostParent) throw Error(formatProdErrorMessage(160));
          commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
          hostParent = null;
          hostParentIsContainer = false;
          root2 = childToDelete.alternate;
          null !== root2 && (root2.return = null);
          childToDelete.return = null;
        }
      if (parentFiber.subtreeFlags & 13878)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    var currentHoistableRoot = null;
    function commitMutationEffectsOnFiber(finishedWork, root2) {
      var current = finishedWork.alternate, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
          break;
        case 26:
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (flags & 4) {
            var currentResource = null !== current ? current.memoizedState : null;
            flags = finishedWork.memoizedState;
            if (null === current)
              if (null === flags)
                if (null === finishedWork.stateNode) {
                  a: {
                    flags = finishedWork.type;
                    current = finishedWork.memoizedProps;
                    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                    b: switch (flags) {
                      case "title":
                        currentResource = hoistableRoot.getElementsByTagName("title")[0];
                        if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                          currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                            currentResource,
                            hoistableRoot.querySelector("head > title")
                          );
                        setInitialProperties(currentResource, flags, current);
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                        break a;
                      case "link":
                        var maybeNodes = getHydratableHoistableCache(
                          "link",
                          "href",
                          hoistableRoot
                        ).get(flags + (current.href || ""));
                        if (maybeNodes) {
                          for (var i2 = 0; i2 < maybeNodes.length; i2++)
                            if (currentResource = maybeNodes[i2], currentResource.getAttribute("href") === (null == current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                              maybeNodes.splice(i2, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      case "meta":
                        if (maybeNodes = getHydratableHoistableCache(
                          "meta",
                          "content",
                          hoistableRoot
                        ).get(flags + (current.content || ""))) {
                          for (i2 = 0; i2 < maybeNodes.length; i2++)
                            if (currentResource = maybeNodes[i2], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                              maybeNodes.splice(i2, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      default:
                        throw Error(formatProdErrorMessage(468, flags));
                    }
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  );
              else
                finishedWork.stateNode = acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                );
            else
              currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              ) : acquireResource(
                hoistableRoot,
                flags,
                finishedWork.memoizedProps
              )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
          }
          break;
        case 27:
          if (flags & 4 && null === finishedWork.alternate) {
            hoistableRoot = finishedWork.stateNode;
            currentResource = finishedWork.memoizedProps;
            try {
              for (var node2 = hoistableRoot.firstChild; node2; ) {
                var nextNode = node2.nextSibling, nodeName = node2.nodeName;
                node2[internalHoistableMarker] || "HEAD" === nodeName || "BODY" === nodeName || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node2.rel.toLowerCase() || hoistableRoot.removeChild(node2);
                node2 = nextNode;
              }
              for (var type2 = finishedWork.type, attributes2 = hoistableRoot.attributes; attributes2.length; )
                hoistableRoot.removeAttributeNode(attributes2[0]);
              setInitialProperties(hoistableRoot, type2, currentResource);
              hoistableRoot[internalInstanceKey] = finishedWork;
              hoistableRoot[internalPropsKey] = currentResource;
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        case 5:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            hoistableRoot = finishedWork.stateNode;
            try {
              setTextContent(hoistableRoot, "");
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
            finishedWork,
            hoistableRoot,
            null !== current ? current.memoizedProps : hoistableRoot
          ));
          flags & 1024 && (needsFormReset = true);
          break;
        case 6:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode)
              throw Error(formatProdErrorMessage(162));
            flags = finishedWork.memoizedProps;
            current = finishedWork.stateNode;
            try {
              current.nodeValue = flags;
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          tagCaches = null;
          hoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root2.containerInfo);
          recursivelyTraverseMutationEffects(root2, finishedWork);
          currentHoistableRoot = hoistableRoot;
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
            try {
              retryIfBlockedOn(root2.containerInfo);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            finishedWork.stateNode.containerInfo
          );
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          break;
        case 13:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          node2 = null !== finishedWork.memoizedState;
          nextNode = null !== current && null !== current.memoizedState;
          nodeName = offscreenSubtreeIsHidden;
          type2 = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = nodeName || node2;
          offscreenSubtreeWasHidden = type2 || nextNode;
          recursivelyTraverseMutationEffects(root2, finishedWork);
          offscreenSubtreeWasHidden = type2;
          offscreenSubtreeIsHidden = nodeName;
          commitReconciliationEffects(finishedWork);
          root2 = finishedWork.stateNode;
          root2._current = finishedWork;
          root2._visibility &= -3;
          root2._visibility |= root2._pendingVisibility & 2;
          if (flags & 8192 && (root2._visibility = node2 ? root2._visibility & -2 : root2._visibility | 1, node2 && (root2 = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current || nextNode || root2 || recursivelyTraverseDisappearLayoutEffects(finishedWork)), null === finishedWork.memoizedProps || "manual" !== finishedWork.memoizedProps.mode))
            a: for (current = null, root2 = finishedWork; ; ) {
              if (5 === root2.tag || 26 === root2.tag || 27 === root2.tag) {
                if (null === current) {
                  nextNode = current = root2;
                  try {
                    if (hoistableRoot = nextNode.stateNode, node2)
                      currentResource = hoistableRoot.style, "function" === typeof currentResource.setProperty ? currentResource.setProperty(
                        "display",
                        "none",
                        "important"
                      ) : currentResource.display = "none";
                    else {
                      maybeNodes = nextNode.stateNode;
                      i2 = nextNode.memoizedProps.style;
                      var display = void 0 !== i2 && null !== i2 && i2.hasOwnProperty("display") ? i2.display : null;
                      maybeNodes.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                    }
                  } catch (error) {
                    captureCommitPhaseError(nextNode, nextNode.return, error);
                  }
                }
              } else if (6 === root2.tag) {
                if (null === current) {
                  nextNode = root2;
                  try {
                    nextNode.stateNode.nodeValue = node2 ? "" : nextNode.memoizedProps;
                  } catch (error) {
                    captureCommitPhaseError(nextNode, nextNode.return, error);
                  }
                }
              } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                root2.child.return = root2;
                root2 = root2.child;
                continue;
              }
              if (root2 === finishedWork) break a;
              for (; null === root2.sibling; ) {
                if (null === root2.return || root2.return === finishedWork) break a;
                current === root2 && (current = null);
                root2 = root2.return;
              }
              current === root2 && (current = null);
              root2.sibling.return = root2.return;
              root2 = root2.sibling;
            }
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          if (27 !== finishedWork.tag) {
            a: {
              for (var parent = finishedWork.return; null !== parent; ) {
                if (isHostParent(parent)) {
                  var JSCompiler_inline_result = parent;
                  break a;
                }
                parent = parent.return;
              }
              throw Error(formatProdErrorMessage(160));
            }
            switch (JSCompiler_inline_result.tag) {
              case 27:
                var parent$jscomp$0 = JSCompiler_inline_result.stateNode, before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
                break;
              case 5:
                var parent$113 = JSCompiler_inline_result.stateNode;
                JSCompiler_inline_result.flags & 32 && (setTextContent(parent$113, ""), JSCompiler_inline_result.flags &= -33);
                var before$114 = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before$114, parent$113);
                break;
              case 3:
              case 4:
                var parent$115 = JSCompiler_inline_result.stateNode.containerInfo, before$116 = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  before$116,
                  parent$115
                );
                break;
              default:
                throw Error(formatProdErrorMessage(161));
            }
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root2, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedWork = parentFiber;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 1:
            safelyDetachRef(finishedWork, finishedWork.return);
            var instance = finishedWork.stateNode;
            "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
              finishedWork,
              finishedWork.return,
              instance
            );
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 26:
          case 27:
          case 5:
            safelyDetachRef(finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 22:
            safelyDetachRef(finishedWork, finishedWork.return);
            null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          default:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(4, finishedWork);
            break;
          case 1:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            current = finishedWork;
            finishedRoot = current.stateNode;
            if ("function" === typeof finishedRoot.componentDidMount)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            current = finishedWork;
            finishedRoot = current.updateQueue;
            if (null !== finishedRoot) {
              var instance = current.stateNode;
              try {
                var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                if (null !== hiddenCallbacks)
                  for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                    callCallback(hiddenCallbacks[finishedRoot], instance);
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            }
            includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 26:
          case 27:
          case 5:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            break;
          case 13:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          default:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveMountOnFiber(
            root2,
            parentFiber,
            committedLanes,
            committedTransitions
          ), parentFiber = parentFiber.sibling;
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitHookEffectListMount(9, finishedWork);
          break;
        case 3:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
          break;
        case 12:
          if (flags & 2048) {
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            finishedRoot = finishedWork.stateNode;
            try {
              var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
              "function" === typeof onPostCommit && onPostCommit(
                id,
                null === finishedWork.alternate ? "mount" : "update",
                finishedRoot.passiveEffectDuration,
                -0
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
          break;
        case 23:
          break;
        case 22:
          _finishedWork$memoize2 = finishedWork.stateNode;
          null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 4 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 4 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : (_finishedWork$memoize2._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            0 !== (finishedWork.subtreeFlags & 10256)
          ));
          flags & 2048 && commitOffscreenPassiveMountEffects(
            finishedWork.alternate,
            finishedWork
          );
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(8, finishedWork);
            break;
          case 23:
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState ? instance._visibility & 4 ? recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ) : recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork
            ) : (instance._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
            includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
    }
    var suspenseyCommitFlag = 8192;
    function recursivelyAccumulateSuspenseyCommit(parentFiber) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(fiber);
          fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
            currentHoistableRoot,
            fiber.memoizedState,
            fiber.memoizedProps
          );
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(fiber);
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
          recursivelyAccumulateSuspenseyCommit(fiber);
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(fiber);
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
        previousFiber.child = null;
        do
          previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
        while (null !== parentFiber);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i2 = 0; i2 < deletions.length; i2++) {
            var childToDelete = deletions[i2];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 12:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          null !== finishedWork.memoizedState && instance._visibility & 4 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i2 = 0; i2 < deletions.length; i2++) {
            var childToDelete = deletions[i2];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        deletions = parentFiber;
        switch (deletions.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, deletions, deletions.return);
            recursivelyTraverseDisconnectPassiveEffects(deletions);
            break;
          case 22:
            i2 = deletions.stateNode;
            i2._visibility & 4 && (i2._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(deletions));
            break;
          default:
            recursivelyTraverseDisconnectPassiveEffects(deletions);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
      for (; null !== nextEffect; ) {
        var fiber = nextEffect;
        switch (fiber.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
            break;
          case 23:
          case 22:
            if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
              var cache = fiber.memoizedState.cachePool.pool;
              null != cache && cache.refCount++;
            }
            break;
          case 24:
            releaseCache(fiber.memoizedState.cache);
        }
        cache = fiber.child;
        if (null !== cache) cache.return = fiber, nextEffect = cache;
        else
          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
            cache = nextEffect;
            var sibling = cache.sibling, returnFiber = cache.return;
            detachFiberAfterEffects(cache);
            if (cache === fiber) {
              nextEffect = null;
              break a;
            }
            if (null !== sibling) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              break a;
            }
            nextEffect = returnFiber;
          }
      }
    }
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function createFiberImplClass(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function shouldConstruct(Component2) {
      Component2 = Component2.prototype;
      return !(!Component2 || !Component2.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress2 = current.alternate;
      null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
        current.tag,
        pendingProps,
        current.key,
        current.mode
      ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
      workInProgress2.flags = current.flags & 31457280;
      workInProgress2.childLanes = current.childLanes;
      workInProgress2.lanes = current.lanes;
      workInProgress2.child = current.child;
      workInProgress2.memoizedProps = current.memoizedProps;
      workInProgress2.memoizedState = current.memoizedState;
      workInProgress2.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
      workInProgress2.sibling = current.sibling;
      workInProgress2.index = current.index;
      workInProgress2.ref = current.ref;
      workInProgress2.refCleanup = current.refCleanup;
      return workInProgress2;
    }
    function resetWorkInProgress(workInProgress2, renderLanes2) {
      workInProgress2.flags &= 31457282;
      var current = workInProgress2.alternate;
      null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
        lanes: renderLanes2.lanes,
        firstContext: renderLanes2.firstContext
      });
      return workInProgress2;
    }
    function createFiberFromTypeAndProps(type2, key, pendingProps, owner, mode, lanes) {
      var fiberTag = 0;
      owner = type2;
      if ("function" === typeof type2) shouldConstruct(type2) && (fiberTag = 1);
      else if ("string" === typeof type2)
        fiberTag = isHostHoistableType(
          type2,
          pendingProps,
          contextStackCursor.current
        ) ? 26 : "html" === type2 || "head" === type2 || "body" === type2 ? 27 : 5;
      else
        a: switch (type2) {
          case REACT_FRAGMENT_TYPE$1:
            return createFiberFromFragment(pendingProps.children, mode, lanes, key);
          case REACT_STRICT_MODE_TYPE:
            fiberTag = 8;
            mode |= 24;
            break;
          case REACT_PROFILER_TYPE:
            return type2 = createFiberImplClass(12, pendingProps, key, mode | 2), type2.elementType = REACT_PROFILER_TYPE, type2.lanes = lanes, type2;
          case REACT_SUSPENSE_TYPE:
            return type2 = createFiberImplClass(13, pendingProps, key, mode), type2.elementType = REACT_SUSPENSE_TYPE, type2.lanes = lanes, type2;
          case REACT_SUSPENSE_LIST_TYPE:
            return type2 = createFiberImplClass(19, pendingProps, key, mode), type2.elementType = REACT_SUSPENSE_LIST_TYPE, type2.lanes = lanes, type2;
          case REACT_OFFSCREEN_TYPE:
            return createFiberFromOffscreen(pendingProps, mode, lanes, key);
          default:
            if ("object" === typeof type2 && null !== type2)
              switch (type2.$$typeof) {
                case REACT_PROVIDER_TYPE:
                case REACT_CONTEXT_TYPE:
                  fiberTag = 10;
                  break a;
                case REACT_CONSUMER_TYPE:
                  fiberTag = 9;
                  break a;
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = 11;
                  break a;
                case REACT_MEMO_TYPE:
                  fiberTag = 14;
                  break a;
                case REACT_LAZY_TYPE:
                  fiberTag = 16;
                  owner = null;
                  break a;
              }
            fiberTag = 29;
            pendingProps = Error(
              formatProdErrorMessage(130, null === type2 ? "null" : typeof type2, "")
            );
            owner = null;
        }
      key = createFiberImplClass(fiberTag, pendingProps, key, mode);
      key.elementType = type2;
      key.type = owner;
      key.lanes = lanes;
      return key;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiberImplClass(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
      pendingProps = createFiberImplClass(22, pendingProps, key, mode);
      pendingProps.elementType = REACT_OFFSCREEN_TYPE;
      pendingProps.lanes = lanes;
      var primaryChildInstance = {
        _visibility: 1,
        _pendingVisibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null,
        _current: null,
        detach: function() {
          var fiber = primaryChildInstance._current;
          if (null === fiber) throw Error(formatProdErrorMessage(456));
          if (0 === (primaryChildInstance._pendingVisibility & 2)) {
            var root2 = enqueueConcurrentRenderForLane(fiber, 2);
            null !== root2 && (primaryChildInstance._pendingVisibility |= 2, scheduleUpdateOnFiber(root2, fiber, 2));
          }
        },
        attach: function() {
          var fiber = primaryChildInstance._current;
          if (null === fiber) throw Error(formatProdErrorMessage(456));
          if (0 !== (primaryChildInstance._pendingVisibility & 2)) {
            var root2 = enqueueConcurrentRenderForLane(fiber, 2);
            null !== root2 && (primaryChildInstance._pendingVisibility &= -3, scheduleUpdateOnFiber(root2, fiber, 2));
          }
        }
      };
      pendingProps.stateNode = primaryChildInstance;
      return pendingProps;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiberImplClass(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiberImplClass(
        4,
        null !== portal.children ? portal.children : [],
        portal.key,
        mode
      );
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    function markUpdate(workInProgress2) {
      workInProgress2.flags |= 4;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
      if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
        workInProgress2.flags &= -16777217;
      else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
        resource = suspenseHandlerStackCursor.current;
        if (null !== resource && ((workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
          throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        workInProgress2.flags |= 8192;
      }
    }
    function scheduleRetryEffect(workInProgress2, retryQueue) {
      null !== retryQueue && (workInProgress2.flags |= 4);
      workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
              null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
            null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var lastTailNode$131 = null; null !== lastTailNode; )
              null !== lastTailNode.alternate && (lastTailNode$131 = lastTailNode), lastTailNode = lastTailNode.sibling;
            null === lastTailNode$131 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$131.sibling = null;
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
      if (didBailout)
        for (var child$132 = completedWork.child; null !== child$132; )
          newChildLanes |= child$132.lanes | child$132.childLanes, subtreeFlags |= child$132.subtreeFlags & 31457280, subtreeFlags |= child$132.flags & 31457280, child$132.return = completedWork, child$132 = child$132.sibling;
      else
        for (child$132 = completedWork.child; null !== child$132; )
          newChildLanes |= child$132.lanes | child$132.childLanes, subtreeFlags |= child$132.subtreeFlags, subtreeFlags |= child$132.flags, child$132.return = completedWork, child$132 = child$132.sibling;
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current, workInProgress2, renderLanes2) {
      var newProps = workInProgress2.pendingProps;
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress2), null;
        case 1:
          return bubbleProperties(workInProgress2), null;
        case 3:
          renderLanes2 = workInProgress2.stateNode;
          newProps = null;
          null !== current && (newProps = current.memoizedState.cache);
          workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
          popProvider(CacheContext);
          popHostContainer();
          renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
          if (null === current || null === current.child)
            popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));
          bubbleProperties(workInProgress2);
          return null;
        case 26:
          return renderLanes2 = workInProgress2.memoizedState, null === current ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
        case 27:
          popHostContext(workInProgress2);
          renderLanes2 = rootInstanceStackCursor.current;
          var type2 = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            current = contextStackCursor.current;
            popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type2, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 5:
          popHostContext(workInProgress2);
          renderLanes2 = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            current = contextStackCursor.current;
            if (popHydrationState(workInProgress2))
              prepareToHydrateHostInstance(workInProgress2);
            else {
              type2 = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current
              );
              switch (current) {
                case 1:
                  current = type2.createElementNS(
                    "http://www.w3.org/2000/svg",
                    renderLanes2
                  );
                  break;
                case 2:
                  current = type2.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    renderLanes2
                  );
                  break;
                default:
                  switch (renderLanes2) {
                    case "svg":
                      current = type2.createElementNS(
                        "http://www.w3.org/2000/svg",
                        renderLanes2
                      );
                      break;
                    case "math":
                      current = type2.createElementNS(
                        "http://www.w3.org/1998/Math/MathML",
                        renderLanes2
                      );
                      break;
                    case "script":
                      current = type2.createElement("div");
                      current.innerHTML = "<script><\/script>";
                      current = current.removeChild(current.firstChild);
                      break;
                    case "select":
                      current = "string" === typeof newProps.is ? type2.createElement("select", { is: newProps.is }) : type2.createElement("select");
                      newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
                      break;
                    default:
                      current = "string" === typeof newProps.is ? type2.createElement(renderLanes2, { is: newProps.is }) : type2.createElement(renderLanes2);
                  }
              }
              current[internalInstanceKey] = workInProgress2;
              current[internalPropsKey] = newProps;
              a: for (type2 = workInProgress2.child; null !== type2; ) {
                if (5 === type2.tag || 6 === type2.tag)
                  current.appendChild(type2.stateNode);
                else if (4 !== type2.tag && 27 !== type2.tag && null !== type2.child) {
                  type2.child.return = type2;
                  type2 = type2.child;
                  continue;
                }
                if (type2 === workInProgress2) break a;
                for (; null === type2.sibling; ) {
                  if (null === type2.return || type2.return === workInProgress2)
                    break a;
                  type2 = type2.return;
                }
                type2.sibling.return = type2.return;
                type2 = type2.sibling;
              }
              workInProgress2.stateNode = current;
              a: switch (setInitialProperties(current, renderLanes2, newProps), renderLanes2) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  current = !!newProps.autoFocus;
                  break a;
                case "img":
                  current = true;
                  break a;
                default:
                  current = false;
              }
              current && markUpdate(workInProgress2);
            }
          }
          bubbleProperties(workInProgress2);
          workInProgress2.flags &= -16777217;
          return null;
        case 6:
          if (current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if ("string" !== typeof newProps && null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            current = rootInstanceStackCursor.current;
            if (popHydrationState(workInProgress2)) {
              current = workInProgress2.stateNode;
              renderLanes2 = workInProgress2.memoizedProps;
              newProps = null;
              type2 = hydrationParentFiber;
              if (null !== type2)
                switch (type2.tag) {
                  case 27:
                  case 5:
                    newProps = type2.memoizedProps;
                }
              current[internalInstanceKey] = workInProgress2;
              current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
              current || throwOnHydrationMismatch(workInProgress2);
            } else
              current = getOwnerDocumentFromRootContainer(current).createTextNode(
                newProps
              ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
          }
          bubbleProperties(workInProgress2);
          return null;
        case 13:
          newProps = workInProgress2.memoizedState;
          if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
            type2 = popHydrationState(workInProgress2);
            if (null !== newProps && null !== newProps.dehydrated) {
              if (null === current) {
                if (!type2) throw Error(formatProdErrorMessage(318));
                type2 = workInProgress2.memoizedState;
                type2 = null !== type2 ? type2.dehydrated : null;
                if (!type2) throw Error(formatProdErrorMessage(317));
                type2[internalInstanceKey] = workInProgress2;
              } else
                resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
              bubbleProperties(workInProgress2);
              type2 = false;
            } else
              null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), type2 = true;
            if (!type2) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
          }
          popSuspenseHandler(workInProgress2);
          if (0 !== (workInProgress2.flags & 128))
            return workInProgress2.lanes = renderLanes2, workInProgress2;
          renderLanes2 = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          if (renderLanes2) {
            newProps = workInProgress2.child;
            type2 = null;
            null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type2 = newProps.alternate.memoizedState.cachePool.pool);
            var cache$144 = null;
            null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$144 = newProps.memoizedState.cachePool.pool);
            cache$144 !== type2 && (newProps.flags |= 2048);
          }
          renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
          scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
          bubbleProperties(workInProgress2);
          return null;
        case 4:
          return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
        case 19:
          pop(suspenseStackCursor);
          type2 = workInProgress2.memoizedState;
          if (null === type2) return bubbleProperties(workInProgress2), null;
          newProps = 0 !== (workInProgress2.flags & 128);
          cache$144 = type2.rendering;
          if (null === cache$144)
            if (newProps) cutOffTailIfNeeded(type2, false);
            else {
              if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                for (current = workInProgress2.child; null !== current; ) {
                  cache$144 = findFirstSuspended(current);
                  if (null !== cache$144) {
                    workInProgress2.flags |= 128;
                    cutOffTailIfNeeded(type2, false);
                    current = cache$144.updateQueue;
                    workInProgress2.updateQueue = current;
                    scheduleRetryEffect(workInProgress2, current);
                    workInProgress2.subtreeFlags = 0;
                    current = renderLanes2;
                    for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                      resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                    push(
                      suspenseStackCursor,
                      suspenseStackCursor.current & 1 | 2
                    );
                    return workInProgress2.child;
                  }
                  current = current.sibling;
                }
              null !== type2.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type2, false), workInProgress2.lanes = 4194304);
            }
          else {
            if (!newProps)
              if (current = findFirstSuspended(cache$144), null !== current) {
                if (workInProgress2.flags |= 128, newProps = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(type2, true), null === type2.tail && "hidden" === type2.tailMode && !cache$144.alternate && !isHydrating)
                  return bubbleProperties(workInProgress2), null;
              } else
                2 * now() - type2.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type2, false), workInProgress2.lanes = 4194304);
            type2.isBackwards ? (cache$144.sibling = workInProgress2.child, workInProgress2.child = cache$144) : (current = type2.last, null !== current ? current.sibling = cache$144 : workInProgress2.child = cache$144, type2.last = cache$144);
          }
          if (null !== type2.tail)
            return workInProgress2 = type2.tail, type2.rendering = workInProgress2, type2.tail = workInProgress2.sibling, type2.renderingStartTime = now(), workInProgress2.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress2;
          bubbleProperties(workInProgress2);
          return null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
        case 24:
          return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
        case 25:
          return null;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    function unwindWork(current, workInProgress2) {
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 1:
          return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 3:
          return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress2), null;
        case 13:
          popSuspenseHandler(workInProgress2);
          current = workInProgress2.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress2.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress2.flags;
          return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 19:
          return pop(suspenseStackCursor), null;
        case 4:
          return popHostContainer(), null;
        case 10:
          return popProvider(workInProgress2.type), null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 24:
          return popProvider(CacheContext), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext);
          popHostContainer();
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer();
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor);
          break;
        case 10:
          popProvider(interruptedWork.type);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext();
          null !== current && pop(resumedCache);
          break;
        case 24:
          popProvider(CacheContext);
      }
    }
    var DefaultAsyncDispatcher = {
      getCacheForType: function(resourceType) {
        var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
        void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
        return cacheForType;
      }
    }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = false, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = 0, pendingPassiveEffectsRemainingLanes = 0, pendingPassiveTransitions = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
    function requestUpdateLane() {
      if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
      if (null !== ReactSharedInternals.T) {
        var actionScopeLane = currentEntangledLane;
        return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
      }
      return resolveUpdatePriority();
    }
    function requestDeferredLane() {
      0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
      var suspenseHandler = suspenseHandlerStackCursor.current;
      null !== suspenseHandler && (suspenseHandler.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root2, fiber, lane) {
      if (root2 === workInProgressRoot && 2 === workInProgressSuspendedReason || null !== root2.cancelPendingCommit)
        prepareFreshStack(root2, 0), markRootSuspended(
          root2,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      markRootUpdated$1(root2, lane);
      if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
        root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
          root2,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        )), ensureRootIsScheduled(root2);
    }
    function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
      do {
        if (0 === exitStatus) {
          workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
          break;
        } else if (6 === exitStatus)
          markRootSuspended(
            root$jscomp$0,
            lanes,
            0,
            !workInProgressRootDidSkipSuspendedSiblings
          );
        else {
          forceSync = root$jscomp$0.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
            exitStatus = renderRootSync(root$jscomp$0, lanes, false);
            renderWasConcurrent = false;
            continue;
          }
          if (2 === exitStatus) {
            renderWasConcurrent = lanes;
            if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
              var JSCompiler_inline_result = 0;
            else
              JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
            if (0 !== JSCompiler_inline_result) {
              lanes = JSCompiler_inline_result;
              a: {
                var root2 = root$jscomp$0;
                exitStatus = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
                JSCompiler_inline_result = renderRootSync(
                  root2,
                  JSCompiler_inline_result,
                  false
                );
                if (2 !== JSCompiler_inline_result) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                    exitStatus = 4;
                    break a;
                  }
                  renderWasConcurrent = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = exitStatus;
                  null !== renderWasConcurrent && queueRecoverableErrors(renderWasConcurrent);
                }
                exitStatus = JSCompiler_inline_result;
              }
              renderWasConcurrent = false;
              if (2 !== exitStatus) continue;
            }
          }
          if (1 === exitStatus) {
            prepareFreshStack(root$jscomp$0, 0);
            markRootSuspended(root$jscomp$0, lanes, 0, true);
            break;
          }
          a: {
            shouldTimeSlice = root$jscomp$0;
            switch (exitStatus) {
              case 0:
              case 1:
                throw Error(formatProdErrorMessage(345));
              case 4:
                if ((lanes & 4194176) === lanes) {
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                }
                break;
              case 2:
                workInProgressRootRecoverableErrors = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(formatProdErrorMessage(329));
            }
            shouldTimeSlice.finishedWork = forceSync;
            shouldTimeSlice.finishedLanes = lanes;
            if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + 300 - now(), 10 < renderWasConcurrent)) {
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings
              );
              if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;
              shouldTimeSlice.timeoutHandle = scheduleTimeout(
                commitRootWhenReady.bind(
                  null,
                  shouldTimeSlice,
                  forceSync,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  lanes,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  workInProgressRootDidSkipSuspendedSiblings,
                  2,
                  -0,
                  0
                ),
                renderWasConcurrent
              );
              break a;
            }
            commitRootWhenReady(
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              0,
              -0,
              0
            );
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root$jscomp$0);
    }
    function queueRecoverableErrors(errors) {
      null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(
        workInProgressRootRecoverableErrors,
        errors
      );
    }
    function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      var subtreeFlags = finishedWork.subtreeFlags;
      if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {
        if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop$4 }, accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {
          root2.cancelPendingCommit = finishedWork(
            commitRoot.bind(
              null,
              root2,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
              1,
              completedRenderStartTime,
              completedRenderEndTime
            )
          );
          markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
          return;
        }
      }
      commitRoot(
        root2,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes,
        suspendedCommitReason,
        completedRenderStartTime,
        completedRenderEndTime
      );
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node2 = finishedWork; ; ) {
        var tag = node2.tag;
        if ((0 === tag || 11 === tag || 15 === tag) && node2.flags & 16384 && (tag = node2.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
          for (var i2 = 0; i2 < tag.length; i2++) {
            var check = tag[i2], getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check)) return false;
            } catch (error) {
              return false;
            }
          }
        tag = node2.child;
        if (node2.subtreeFlags & 16384 && null !== tag)
          tag.return = node2, node2 = tag;
        else {
          if (node2 === finishedWork) break;
          for (; null === node2.sibling; ) {
            if (null === node2.return || node2.return === finishedWork) return true;
            node2 = node2.return;
          }
          node2.sibling.return = node2.return;
          node2 = node2.sibling;
        }
      }
      return true;
    }
    function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root2.suspendedLanes |= suspendedLanes;
      root2.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root2.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes; ) {
        var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
        didAttemptEntireTree[index$6] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
    }
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (0 === workInProgressSuspendedReason)
          var interruptedWork = workInProgress.return;
        else
          interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
        for (; null !== interruptedWork; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    function prepareFreshStack(root2, lanes) {
      root2.finishedWork = null;
      root2.finishedLanes = 0;
      var timeoutHandle = root2.timeoutHandle;
      -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
      timeoutHandle = root2.cancelPendingCommit;
      null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
      resetWorkInProgressStack();
      workInProgressRoot = root2;
      workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = 0;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = false;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
      workInProgressRootDidAttachPingListener = false;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      var allEntangledLanes = root2.entangledLanes;
      if (0 !== allEntangledLanes)
        for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
          var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
          lanes |= root2[index$4];
          allEntangledLanes &= ~lane;
        }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      return timeoutHandle;
    }
    function handleThrow(root2, thrownValue) {
      currentlyRenderingFiber$1 = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
      workInProgressThrownValue = thrownValue;
      null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
        root2,
        createCapturedValueAtFiber(thrownValue, root2.current)
      ));
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = 4;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
      0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
        workInProgressRoot,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      );
    }
    function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
        workInProgressTransitions = null, prepareFreshStack(root2, lanes);
      lanes = false;
      var exitStatus = workInProgressRootExitStatus;
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
            switch (workInProgressSuspendedReason) {
              case 8:
                resetWorkInProgressStack();
                exitStatus = 6;
                break a;
              case 3:
              case 2:
              case 6:
                null === suspenseHandlerStackCursor.current && (lanes = true);
                var reason = workInProgressSuspendedReason;
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                  exitStatus = 0;
                  break a;
                }
                break;
              default:
                reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
            }
          }
          workLoopSync();
          exitStatus = workInProgressRootExitStatus;
          break;
        } catch (thrownValue$164) {
          handleThrow(root2, thrownValue$164);
        }
      while (1);
      lanes && root2.shellSuspendCounter++;
      lastContextDependency = currentlyRenderingFiber = null;
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return exitStatus;
    }
    function workLoopSync() {
      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root2, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
        root2,
        lanes
      );
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            lanes = workInProgress;
            var thrownValue = workInProgressThrownValue;
            b: switch (workInProgressSuspendedReason) {
              case 1:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
                break;
              case 2:
                if (isThenableResolved(thrownValue)) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  replaySuspendedUnitOfWork(lanes);
                  break;
                }
                lanes = function() {
                  2 === workInProgressSuspendedReason && workInProgressRoot === root2 && (workInProgressSuspendedReason = 7);
                  ensureRootIsScheduled(root2);
                };
                thrownValue.then(lanes, lanes);
                break a;
              case 3:
                workInProgressSuspendedReason = 7;
                break a;
              case 4:
                workInProgressSuspendedReason = 5;
                break a;
              case 7:
                isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
                break;
              case 5:
                var resource = null;
                switch (workInProgress.tag) {
                  case 26:
                    resource = workInProgress.memoizedState;
                  case 5:
                  case 27:
                    var hostFiber = workInProgress;
                    if (resource ? preloadResource(resource) : 1) {
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      var sibling = hostFiber.sibling;
                      if (null !== sibling) workInProgress = sibling;
                      else {
                        var returnFiber = hostFiber.return;
                        null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                      }
                      break b;
                    }
                }
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
                break;
              case 6:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
                break;
              case 8:
                resetWorkInProgressStack();
                workInProgressRootExitStatus = 6;
                break a;
              default:
                throw Error(formatProdErrorMessage(462));
            }
          }
          workLoopConcurrent();
          break;
        } catch (thrownValue$166) {
          handleThrow(root2, thrownValue$166);
        }
      while (1);
      lastContextDependency = currentlyRenderingFiber = null;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress) return 0;
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrent() {
      for (; null !== workInProgress && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var next2 = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next2 ? completeUnitOfWork(unitOfWork) : workInProgress = next2;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next2 = unitOfWork;
      var current = next2.alternate;
      switch (next2.tag) {
        case 15:
        case 0:
          next2 = replayFunctionComponent(
            current,
            next2,
            next2.pendingProps,
            next2.type,
            void 0,
            workInProgressRootRenderLanes
          );
          break;
        case 11:
          next2 = replayFunctionComponent(
            current,
            next2,
            next2.pendingProps,
            next2.type.render,
            next2.ref,
            workInProgressRootRenderLanes
          );
          break;
        case 5:
          resetHooksOnUnwind(next2);
        default:
          unwindInterruptedWork(current, next2), next2 = workInProgress = resetWorkInProgress(next2, entangledRenderLanes), next2 = beginWork(current, next2, entangledRenderLanes);
      }
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next2 ? completeUnitOfWork(unitOfWork) : workInProgress = next2;
    }
    function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
      lastContextDependency = currentlyRenderingFiber = null;
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (throwException(
          root2,
          returnFiber,
          unitOfWork,
          thrownValue,
          workInProgressRootRenderLanes
        )) {
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          );
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = 1;
        logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        );
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || 1 === suspendedReason) root2 = true;
        else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
          root2 = false;
        else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
          suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root2);
      } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(
            completedWork,
            workInProgressRootDidSkipSuspendedSiblings
          );
          return;
        }
        unitOfWork = completedWork.return;
        var next2 = completeWork(
          completedWork.alternate,
          completedWork,
          entangledRenderLanes
        );
        if (null !== next2) {
          workInProgress = next2;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next2 = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next2) {
          next2.flags &= 32767;
          workInProgress = next2;
          return;
        }
        next2 = unitOfWork.return;
        null !== next2 && (next2.flags |= 32768, next2.subtreeFlags = 0, next2.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next2;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = 6;
      workInProgress = null;
    }
    function commitRoot(root2, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      var prevTransition = ReactSharedInternals.T, previousUpdateLanePriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 2, ReactSharedInternals.T = null, commitRootImpl(
          root2,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          previousUpdateLanePriority,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
          suspendedCommitReason,
          completedRenderStartTime,
          completedRenderEndTime
        );
      } finally {
        ReactSharedInternals.T = prevTransition, ReactDOMSharedInternals.p = previousUpdateLanePriority;
      }
    }
    function commitRootImpl(root2, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {
      do
        flushPassiveEffects();
      while (null !== rootWithPendingPassiveEffects);
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      var finishedWork = root2.finishedWork;
      didIncludeRenderPhaseUpdate = root2.finishedLanes;
      if (null === finishedWork) return null;
      root2.finishedWork = null;
      root2.finishedLanes = 0;
      if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
      root2.callbackNode = null;
      root2.callbackPriority = 0;
      root2.cancelPendingCommit = null;
      var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
      remainingLanes |= concurrentlyUpdatedLanes;
      markRootFinished(
        root2,
        didIncludeRenderPhaseUpdate,
        remainingLanes,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      );
      root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
      0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = true, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback$1(NormalPriority$1, function() {
        flushPassiveEffects();
        return null;
      }));
      transitions = 0 !== (finishedWork.flags & 15990);
      0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = ReactDOMSharedInternals.p, ReactDOMSharedInternals.p = 2, updatedLanes = executionContext, executionContext |= 4, commitBeforeMutationEffects(root2, finishedWork), commitMutationEffectsOnFiber(finishedWork, root2), restoreSelection(selectionInformation, root2.containerInfo), _enabled = !!eventsEnabled, selectionInformation = eventsEnabled = null, root2.current = finishedWork, commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork), requestPaint(), executionContext = updatedLanes, ReactDOMSharedInternals.p = spawnedLane, ReactSharedInternals.T = transitions) : root2.current = finishedWork;
      rootDoesHavePassiveEffects ? (rootDoesHavePassiveEffects = false, rootWithPendingPassiveEffects = root2, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : releaseRootPooledCache(root2, remainingLanes);
      remainingLanes = root2.pendingLanes;
      0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
      onCommitRoot(finishedWork.stateNode);
      ensureRootIsScheduled(root2);
      if (null !== recoverableErrors)
        for (renderPriorityLevel = root2.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++)
          remainingLanes = recoverableErrors[finishedWork], renderPriorityLevel(remainingLanes.value, {
            componentStack: remainingLanes.stack
          });
      0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();
      remainingLanes = root2.pendingLanes;
      0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
      flushSyncWorkAcrossRoots_impl(0);
      return null;
    }
    function releaseRootPooledCache(root2, remainingLanes) {
      0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPassiveEffects() {
      if (null !== rootWithPendingPassiveEffects) {
        var root$170 = rootWithPendingPassiveEffects, remainingLanes = pendingPassiveEffectsRemainingLanes;
        pendingPassiveEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
          ReactSharedInternals.T = null;
          if (null === rootWithPendingPassiveEffects)
            var JSCompiler_inline_result = false;
          else {
            renderPriority = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root2 = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = 0;
            if (0 !== (executionContext & 6))
              throw Error(formatProdErrorMessage(331));
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            commitPassiveUnmountOnFiber(root2.current);
            commitPassiveMountOnFiber(root2, root2.current, lanes, renderPriority);
            executionContext = prevExecutionContext;
            flushSyncWorkAcrossRoots_impl(0, false);
            if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root2);
              } catch (err) {
              }
            JSCompiler_inline_result = true;
          }
          return JSCompiler_inline_result;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root$170, remainingLanes);
        }
      }
      return false;
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      if (3 === sourceFiber.tag)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else
        for (; null !== nearestMountedAncestor; ) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(
              nearestMountedAncestor,
              sourceFiber,
              error
            );
            break;
          } else if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance && (initializeClassErrorUpdate(
                error,
                instance,
                nearestMountedAncestor,
                sourceFiber
              ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              break;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
    }
    function attachPingListener(root2, wakeable, lanes) {
      var pingCache = root2.pingCache;
      if (null === pingCache) {
        pingCache = root2.pingCache = new PossiblyWeakMap();
        var threadIDs = /* @__PURE__ */ new Set();
        pingCache.set(wakeable, threadIDs);
      } else
        threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
    }
    function pingSuspendedRoot(root2, wakeable, pingedLanes) {
      var pingCache = root2.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
      root2.warmLanes &= ~pingedLanes;
      workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root2);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error(formatProdErrorMessage(314));
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function scheduleCallback$1(priorityLevel, callback) {
      return scheduleCallback$3(priorityLevel, callback);
    }
    var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
    function ensureRootIsScheduled(root2) {
      root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
      mightHavePendingSyncWork = true;
      didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateTask(processRootScheduleInMicrotask));
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = true;
        do {
          var didPerformSomeWork = false;
          for (var root$172 = firstScheduledRoot; null !== root$172; ) {
            if (0 !== syncTransitionLanes) {
              var pendingLanes = root$172.pendingLanes;
              if (0 === pendingLanes) var JSCompiler_inline_result = 0;
              else {
                var suspendedLanes = root$172.suspendedLanes, pingedLanes = root$172.pingedLanes;
                JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                JSCompiler_inline_result = JSCompiler_inline_result & 201326677 ? JSCompiler_inline_result & 201326677 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
              }
              0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$172, JSCompiler_inline_result));
            } else
              JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                root$172,
                root$172 === workInProgressRoot ? JSCompiler_inline_result : 0
              ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$172, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$172, JSCompiler_inline_result));
            root$172 = root$172.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = false;
      }
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask = false;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
      for (var currentTime = now(), prev2 = null, root2 = firstScheduledRoot; null !== root2; ) {
        var next2 = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
        if (0 === nextLanes)
          root2.next = null, null === prev2 ? firstScheduledRoot = next2 : prev2.next = next2, null === next2 && (lastScheduledRoot = prev2);
        else if (prev2 = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
          mightHavePendingSyncWork = true;
        root2 = next2;
      }
      flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
    }
    function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
      for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
        var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
            expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(
        root2,
        root2 === currentTime ? suspendedLanes : 0
      );
      pingedLanes = root2.callbackNode;
      if (0 === suspendedLanes || root2 === currentTime && 2 === workInProgressSuspendedReason || null !== root2.cancelPendingCommit)
        return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
      if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime === root2.callbackPriority) return currentTime;
        null !== pingedLanes && cancelCallback$1(pingedLanes);
        switch (lanesToEventPriority(suspendedLanes)) {
          case 2:
          case 8:
            suspendedLanes = UserBlockingPriority;
            break;
          case 32:
            suspendedLanes = NormalPriority$1;
            break;
          case 268435456:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
        suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root2.callbackPriority = currentTime;
        root2.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
      root2.callbackPriority = 2;
      root2.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
      var originalCallbackNode = root2.callbackNode;
      if (flushPassiveEffects() && root2.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
        root2,
        root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0
      );
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root2, now());
      return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
    }
    function performSyncWorkOnRoot(root2, lanes) {
      if (flushPassiveEffects()) return null;
      performWorkOnRoot(root2, lanes, true);
    }
    function scheduleImmediateTask(cb) {
      scheduleMicrotask(function() {
        0 !== (executionContext & 6) ? scheduleCallback$3(ImmediatePriority, cb) : cb();
      });
    }
    function requestTransitionLane() {
      0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
      if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
        var action = coerceFormActionProp(
          (nativeEventTarget[internalPropsKey] || null).action
        ), submitter = nativeEvent.submitter;
        submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
        var event = new SyntheticEvent(
          "action",
          "action",
          null,
          nativeEvent,
          nativeEventTarget
        );
        dispatchQueue.push({
          event,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (nativeEvent.defaultPrevented) {
                  if (0 !== currentEventTransitionLane) {
                    var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                    startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      null,
                      formData
                    );
                  }
                } else
                  "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                    maybeTargetInst,
                    {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action
                    },
                    action,
                    formData
                  ));
              },
              currentTarget: nativeEventTarget
            }
          ]
        });
      }
    }
    for (var i$jscomp$inline_1439 = 0; i$jscomp$inline_1439 < simpleEventPluginEvents.length; i$jscomp$inline_1439++) {
      var eventName$jscomp$inline_1440 = simpleEventPluginEvents[i$jscomp$inline_1439], domEventName$jscomp$inline_1441 = eventName$jscomp$inline_1440.toLowerCase(), capitalizedEvent$jscomp$inline_1442 = eventName$jscomp$inline_1440[0].toUpperCase() + eventName$jscomp$inline_1440.slice(1);
      registerSimpleEvent(
        domEventName$jscomp$inline_1441,
        "on" + capitalizedEvent$jscomp$inline_1442
      );
    }
    registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
    registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
    registerSimpleEvent(ANIMATION_START, "onAnimationStart");
    registerSimpleEvent("dblclick", "onDoubleClick");
    registerSimpleEvent("focusin", "onFocus");
    registerSimpleEvent("focusout", "onBlur");
    registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
    registerSimpleEvent(TRANSITION_START, "onTransitionStart");
    registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
    registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(" ")
    );
    registerTwoPhaseEvent(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]);
    registerTwoPhaseEvent(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), nonDelegatedEvents = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
    );
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i2 = 0; i2 < dispatchQueue.length; i2++) {
        var _dispatchQueue$i = dispatchQueue[i2], event = _dispatchQueue$i.event;
        _dispatchQueue$i = _dispatchQueue$i.listeners;
        a: {
          var previousInstance = void 0;
          if (eventSystemFlags)
            for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
          else
            for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
      void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
      var listenerSetKey = domEventName + "__bubble";
      JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(
        target,
        domEventName,
        eventSystemFlags,
        isCapturePhaseListener
      );
    }
    var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = true;
        allNativeEvents.forEach(function(domEventName) {
          "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
        });
        var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
      }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
      switch (getEventPriority(domEventName)) {
        case 2:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case 8:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(
        null,
        domEventName,
        eventSystemFlags,
        targetContainer
      );
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
      isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        capture: true,
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
      var ancestorInst = targetInst$jscomp$0;
      if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
        a: for (; ; ) {
          if (null === targetInst$jscomp$0) return;
          var nodeTag = targetInst$jscomp$0.tag;
          if (3 === nodeTag || 4 === nodeTag) {
            var container = targetInst$jscomp$0.stateNode.containerInfo;
            if (container === targetContainer || 8 === container.nodeType && container.parentNode === targetContainer)
              break;
            if (4 === nodeTag)
              for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                var grandTag = nodeTag.tag;
                if (3 === grandTag || 4 === grandTag) {
                  if (grandTag = nodeTag.stateNode.containerInfo, grandTag === targetContainer || 8 === grandTag.nodeType && grandTag.parentNode === targetContainer)
                    return;
                }
                nodeTag = nodeTag.return;
              }
            for (; null !== container; ) {
              nodeTag = getClosestInstanceFromNode(container);
              if (null === nodeTag) return;
              grandTag = nodeTag.tag;
              if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                targetInst$jscomp$0 = ancestorInst = nodeTag;
                continue a;
              }
              container = container.parentNode;
            }
          }
          targetInst$jscomp$0 = targetInst$jscomp$0.return;
        }
      batchedUpdates$1(function() {
        var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
            inCapturePhase = [];
            for (var instance = targetInst, lastHostComponent; null !== instance; ) {
              var _instance = instance;
              lastHostComponent = _instance.stateNode;
              _instance = _instance.tag;
              5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                createDispatchListener(instance, _instance, lastHostComponent)
              ));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
              reactName,
              reactEventType,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName = "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
            if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
              if (SyntheticEventCtor) {
                if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                  reactEventType = null;
              } else SyntheticEventCtor = null, reactEventType = targetInst;
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if ("pointerout" === domEventName || "pointerover" === domEventName)
                  inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(
                  _instance,
                  instance + "leave",
                  SyntheticEventCtor,
                  nativeEvent,
                  nativeEventTarget
                );
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                  reactEventName,
                  instance + "enter",
                  reactEventType,
                  nativeEvent,
                  nativeEventTarget
                ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                accumulateTargetOnly = _instance;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = SyntheticEventCtor;
                    reactEventName = reactEventType;
                    instance = 0;
                    for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                      instance++;
                    lastHostComponent = 0;
                    for (_instance = reactEventName; _instance; _instance = getParent(_instance))
                      lastHostComponent++;
                    for (; 0 < instance - lastHostComponent; )
                      inCapturePhase = getParent(inCapturePhase), instance--;
                    for (; 0 < lastHostComponent - instance; )
                      reactEventName = getParent(reactEventName), lastHostComponent--;
                    for (; instance--; ) {
                      if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                        break b;
                      inCapturePhase = getParent(inCapturePhase);
                      reactEventName = getParent(reactEventName);
                    }
                    inCapturePhase = null;
                  }
                else inCapturePhase = null;
                null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  reactName,
                  SyntheticEventCtor,
                  inCapturePhase,
                  false
                );
                null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  accumulateTargetOnly,
                  reactEventType,
                  inCapturePhase,
                  true
                );
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
            if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
              var getTargetInstFunc = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
            if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
              createAndAccumulateChangeEvent(
                dispatchQueue,
                getTargetInstFunc,
                nativeEvent,
                nativeEventTarget
              );
              break a;
            }
            handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
          var fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart":
                  var eventType = "onCompositionStart";
                  break b;
                case "compositionend":
                  eventType = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  eventType = "onCompositionUpdate";
                  break b;
              }
              eventType = void 0;
            }
          else
            isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
          eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root$1 = nativeEventTarget, startText = "value" in root$1 ? root$1.value : root$1.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
            eventType,
            domEventName,
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
          if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
            eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
              "onBeforeInput",
              "beforeinput",
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }), handleEventFunc.data = fallbackData);
          extractEvents$1(
            dispatchQueue,
            domEventName,
            targetInst,
            nativeEvent,
            nativeEventTarget
          );
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance,
        listener,
        currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
        var _instance2 = targetFiber, stateNode = _instance2.stateNode;
        _instance2 = _instance2.tag;
        5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ));
        targetFiber = targetFiber.return;
      }
      return listeners;
    }
    function getParent(inst) {
      if (null === inst) return null;
      do
        inst = inst.return;
      while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
      for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
        var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        if (null !== alternate && alternate === common) break;
        5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
          createDispatchListener(target, stateNode, alternate)
        )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
          createDispatchListener(target, stateNode, alternate)
        )));
        target = target.return;
      }
      0 !== listeners.length && dispatchQueue.push({ event, listeners });
    }
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
    function normalizeMarkupForTextOrAttribute(markup) {
      return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
    }
    function noop$1$1() {
    }
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key)) {
            domElement.removeAttribute(key);
            break;
          }
          if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          if ("function" === typeof value) {
            domElement.setAttribute(
              key,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
              domElement,
              tag,
              "formEncType",
              props.formEncType,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formMethod",
              props.formMethod,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formTarget",
              props.formTarget,
              props,
              null
            )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
          if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$1$1);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            key
          );
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:actuate",
            value
          );
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:arcrole",
            value
          );
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:role",
            value
          );
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:show",
            value
          );
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:title",
            value
          );
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:type",
            value
          );
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:base",
            value
          );
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:lang",
            value
          );
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:space",
            value
          );
          break;
        case "is":
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
            key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
      }
    }
    function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$1$1);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!registrationNameDependencies.hasOwnProperty(key))
            a: {
              if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
            }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = false, hasSrcSet = false, propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "src":
                    hasSrc = true;
                    break;
                  case "srcSet":
                    hasSrcSet = true;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, propKey, propValue, props, null);
                }
            }
          hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var propValue$186 = props[hasSrc];
              if (null != propValue$186)
                switch (hasSrc) {
                  case "name":
                    hasSrcSet = propValue$186;
                    break;
                  case "type":
                    propValue = propValue$186;
                    break;
                  case "checked":
                    checked = propValue$186;
                    break;
                  case "defaultChecked":
                    defaultChecked = propValue$186;
                    break;
                  case "value":
                    propKey = propValue$186;
                    break;
                  case "defaultValue":
                    defaultValue = propValue$186;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propValue$186)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(domElement, tag, hasSrc, propValue$186, props, null);
                }
            }
          initInput(
            domElement,
            propKey,
            defaultValue,
            checked,
            defaultChecked,
            propValue,
            hasSrcSet,
            false
          );
          track(domElement);
          return;
        case "select":
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
              switch (hasSrcSet) {
                case "value":
                  propKey = defaultValue;
                  break;
                case "defaultValue":
                  propValue = defaultValue;
                  break;
                case "multiple":
                  hasSrc = defaultValue;
                default:
                  setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
              }
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
          return;
        case "textarea":
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
              switch (propValue) {
                case "value":
                  hasSrc = defaultValue;
                  break;
                case "defaultValue":
                  hasSrcSet = defaultValue;
                  break;
                case "children":
                  propKey = defaultValue;
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  setProp(domElement, tag, propValue, defaultValue, props, null);
              }
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          track(domElement);
          return;
        case "option":
          for (checked in props)
            if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
              switch (checked) {
                case "selected":
                  domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                  break;
                default:
                  setProp(domElement, tag, checked, hasSrc, props, null);
              }
          return;
        case "dialog":
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props)
            if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(137, tag));
                default:
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (propValue$186 in props)
              props.hasOwnProperty(propValue$186) && (hasSrc = props[propValue$186], void 0 !== hasSrc && setPropOnCustomElement(
                domElement,
                tag,
                propValue$186,
                hasSrc,
                props,
                void 0
              ));
            return;
          }
      }
      for (defaultValue in props)
        props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null, type2 = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp)
              switch (propKey) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  lastDefaultValue = lastProp;
                default:
                  nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
              }
          }
          for (var propKey$203 in nextProps) {
            var propKey = nextProps[propKey$203];
            lastProp = lastProps[propKey$203];
            if (nextProps.hasOwnProperty(propKey$203) && (null != propKey || null != lastProp))
              switch (propKey$203) {
                case "type":
                  type2 = propKey;
                  break;
                case "name":
                  name = propKey;
                  break;
                case "checked":
                  checked = propKey;
                  break;
                case "defaultChecked":
                  defaultChecked = propKey;
                  break;
                case "value":
                  value = propKey;
                  break;
                case "defaultValue":
                  defaultValue = propKey;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  propKey !== lastProp && setProp(
                    domElement,
                    tag,
                    propKey$203,
                    propKey,
                    nextProps,
                    lastProp
                  );
              }
          }
          updateInput(
            domElement,
            value,
            defaultValue,
            lastDefaultValue,
            checked,
            defaultChecked,
            type2,
            name
          );
          return;
        case "select":
          propKey = value = defaultValue = propKey$203 = null;
          for (type2 in lastProps)
            if (lastDefaultValue = lastProps[type2], lastProps.hasOwnProperty(type2) && null != lastDefaultValue)
              switch (type2) {
                case "value":
                  break;
                case "multiple":
                  propKey = lastDefaultValue;
                default:
                  nextProps.hasOwnProperty(type2) || setProp(
                    domElement,
                    tag,
                    type2,
                    null,
                    nextProps,
                    lastDefaultValue
                  );
              }
          for (name in nextProps)
            if (type2 = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type2 || null != lastDefaultValue))
              switch (name) {
                case "value":
                  propKey$203 = type2;
                  break;
                case "defaultValue":
                  defaultValue = type2;
                  break;
                case "multiple":
                  value = type2;
                default:
                  type2 !== lastDefaultValue && setProp(
                    domElement,
                    tag,
                    name,
                    type2,
                    nextProps,
                    lastDefaultValue
                  );
              }
          tag = defaultValue;
          lastProps = value;
          nextProps = propKey;
          null != propKey$203 ? updateOptions(domElement, !!lastProps, propKey$203, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
          return;
        case "textarea":
          propKey = propKey$203 = null;
          for (defaultValue in lastProps)
            if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
              switch (defaultValue) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  setProp(domElement, tag, defaultValue, null, nextProps, name);
              }
          for (value in nextProps)
            if (name = nextProps[value], type2 = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type2))
              switch (value) {
                case "value":
                  propKey$203 = name;
                  break;
                case "defaultValue":
                  propKey = name;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != name) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  name !== type2 && setProp(domElement, tag, value, name, nextProps, type2);
              }
          updateTextarea(domElement, propKey$203, propKey);
          return;
        case "option":
          for (var propKey$219 in lastProps)
            if (propKey$203 = lastProps[propKey$219], lastProps.hasOwnProperty(propKey$219) && null != propKey$203 && !nextProps.hasOwnProperty(propKey$219))
              switch (propKey$219) {
                case "selected":
                  domElement.selected = false;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    propKey$219,
                    null,
                    nextProps,
                    propKey$203
                  );
              }
          for (lastDefaultValue in nextProps)
            if (propKey$203 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$203 !== propKey && (null != propKey$203 || null != propKey))
              switch (lastDefaultValue) {
                case "selected":
                  domElement.selected = propKey$203 && "function" !== typeof propKey$203 && "symbol" !== typeof propKey$203;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    lastDefaultValue,
                    propKey$203,
                    nextProps,
                    propKey
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var propKey$224 in lastProps)
            propKey$203 = lastProps[propKey$224], lastProps.hasOwnProperty(propKey$224) && null != propKey$203 && !nextProps.hasOwnProperty(propKey$224) && setProp(domElement, tag, propKey$224, null, nextProps, propKey$203);
          for (checked in nextProps)
            if (propKey$203 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$203 !== propKey && (null != propKey$203 || null != propKey))
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey$203)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    checked,
                    propKey$203,
                    nextProps,
                    propKey
                  );
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var propKey$229 in lastProps)
              propKey$203 = lastProps[propKey$229], lastProps.hasOwnProperty(propKey$229) && void 0 !== propKey$203 && !nextProps.hasOwnProperty(propKey$229) && setPropOnCustomElement(
                domElement,
                tag,
                propKey$229,
                void 0,
                nextProps,
                propKey$203
              );
            for (defaultChecked in nextProps)
              propKey$203 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$203 === propKey || void 0 === propKey$203 && void 0 === propKey || setPropOnCustomElement(
                domElement,
                tag,
                defaultChecked,
                propKey$203,
                nextProps,
                propKey
              );
            return;
          }
      }
      for (var propKey$234 in lastProps)
        propKey$203 = lastProps[propKey$234], lastProps.hasOwnProperty(propKey$234) && null != propKey$203 && !nextProps.hasOwnProperty(propKey$234) && setProp(domElement, tag, propKey$234, null, nextProps, propKey$203);
      for (lastProp in nextProps)
        propKey$203 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$203 === propKey || null == propKey$203 && null == propKey || setProp(domElement, tag, lastProp, propKey$203, nextProps, propKey);
    }
    var eventsEnabled = null, selectionInformation = null;
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function getChildHostContextProd(parentNamespace, type2) {
      if (0 === parentNamespace)
        switch (type2) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
      return 1 === parentNamespace && "foreignObject" === type2 ? 0 : parentNamespace;
    }
    function shouldSetTextContent(type2, props) {
      return "textarea" === type2 || "noscript" === type2 || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
    }
    var currentPopstateTransitionEvent = null;
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return false;
        currentPopstateTransitionEvent = event;
        return true;
      }
      currentPopstateTransitionEvent = null;
      return false;
    }
    var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
      return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    } : scheduleTimeout;
    function handleErrorInNextTick(error) {
      setTimeout(function() {
        throw error;
      });
    }
    function clearSuspenseBoundary(parentInstance, suspenseInstance) {
      var node2 = suspenseInstance, depth = 0;
      do {
        var nextNode = node2.nextSibling;
        parentInstance.removeChild(node2);
        if (nextNode && 8 === nextNode.nodeType)
          if (node2 = nextNode.data, "/$" === node2) {
            if (0 === depth) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(suspenseInstance);
              return;
            }
            depth--;
          } else "$" !== node2 && "$?" !== node2 && "$!" !== node2 || depth++;
        node2 = nextNode;
      } while (node2);
      retryIfBlockedOn(suspenseInstance);
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode; ) {
        var node2 = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node2.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node2);
            detachDeletedInstance(node2);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node2.rel.toLowerCase()) continue;
        }
        container.removeChild(node2);
      }
    }
    function canHydrateInstance(instance, type2, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType; ) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type2.toLowerCase()) {
          if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
            break;
        } else if (!inRootOrSingleton)
          if ("input" === type2 && "hidden" === instance.type) {
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
              return instance;
          } else return instance;
        else if (!instance[internalHoistableMarker])
          switch (type2) {
            case "meta":
              if (!instance.hasAttribute("itemprop")) break;
              return instance;
            case "link":
              name = instance.getAttribute("rel");
              if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                break;
              else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                break;
              return instance;
            case "style":
              if (instance.hasAttribute("data-precedence")) break;
              return instance;
            case "script":
              name = instance.getAttribute("src");
              if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                break;
              return instance;
            default:
              return instance;
          }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if ("" === text) return null;
      for (; 3 !== instance.nodeType; ) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function getNextHydratable(node2) {
      for (; null != node2; node2 = node2.nextSibling) {
        var nodeType = node2.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node2.data;
          if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType)
            break;
          if ("/$" === nodeType) return null;
        }
      }
      return node2;
    }
    function getParentSuspenseInstance(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance; ) {
        if (8 === targetInstance.nodeType) {
          var data = targetInstance.data;
          if ("$" === data || "$!" === data || "$?" === data) {
            if (0 === depth) return targetInstance;
            depth--;
          } else "/$" === data && depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function resolveSingletonInstance(type2, props, rootContainerInstance) {
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type2) {
        case "html":
          type2 = props.documentElement;
          if (!type2) throw Error(formatProdErrorMessage(452));
          return type2;
        case "head":
          type2 = props.head;
          if (!type2) throw Error(formatProdErrorMessage(453));
          return type2;
        case "body":
          type2 = props.body;
          if (!type2) throw Error(formatProdErrorMessage(454));
          return type2;
        default:
          throw Error(formatProdErrorMessage(451));
      }
    }
    var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode ? container.getRootNode() : container.ownerDocument;
    }
    var previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: flushSyncWork,
      r: requestFormReset,
      D: prefetchDNS,
      C: preconnect,
      L: preload,
      m: preloadModule,
      X: preinitScript,
      S: preinitStyle,
      M: preinitModuleScript
    };
    function flushSyncWork() {
      var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
      return previousWasRendering || wasRendering;
    }
    function requestFormReset(form) {
      var formInst = getInstanceFromNode(form);
      null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
    }
    var globalDocument = "undefined" === typeof document ? null : document;
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
      }
    }
    function prefetchDNS(href) {
      previousDispatcher.D(href);
      preconnectAs("dns-prefetch", href, null);
    }
    function preconnect(href, crossOrigin) {
      previousDispatcher.C(href, crossOrigin);
      preconnectAs("preconnect", href, crossOrigin);
    }
    function preload(href, as, options2) {
      previousDispatcher.L(href, as, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href && as) {
        var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
        "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSrcSet
        ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSizes
        ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
        var key = preloadSelector;
        switch (as) {
          case "style":
            key = getStyleKey(href);
            break;
          case "script":
            key = getScriptKey(href);
        }
        preloadPropsMap.has(key) || (href = assign(
          {
            rel: "preload",
            href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
            as
          },
          options2
        ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
      }
    }
    function preloadModule(href, options2) {
      previousDispatcher.m(href, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
        switch (as) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            key = getScriptKey(href);
        }
        if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                return;
          }
          as = ownerDocument.createElement("link");
          setInitialProperties(as, "link", href);
          markNodeAsHoistable(as);
          ownerDocument.head.appendChild(as);
        }
      }
    }
    function preinitStyle(href, precedence, options2) {
      previousDispatcher.S(href, precedence, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
        precedence = precedence || "default";
        var resource = styles.get(key);
        if (!resource) {
          var state = { loading: 0, preload: null };
          if (resource = ownerDocument.querySelector(
            getStylesheetSelectorFromKey(key)
          ))
            state.loading = 5;
          else {
            href = assign(
              { rel: "stylesheet", href, "data-precedence": precedence },
              options2
            );
            (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
            var link = resource = ownerDocument.createElement("link");
            markNodeAsHoistable(link);
            setInitialProperties(link, "link", href);
            link._p = new Promise(function(resolve, reject) {
              link.onload = resolve;
              link.onerror = reject;
            });
            link.addEventListener("load", function() {
              state.loading |= 1;
            });
            link.addEventListener("error", function() {
              state.loading |= 2;
            });
            state.loading |= 4;
            insertStylesheet(resource, precedence, ownerDocument);
          }
          resource = {
            type: "stylesheet",
            instance: resource,
            count: 1,
            state
          };
          styles.set(key, resource);
        }
      }
    }
    function preinitScript(src, options2) {
      previousDispatcher.X(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
    function preinitModuleScript(src, options2) {
      previousDispatcher.M(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
    function getResource(type2, currentProps, pendingProps, currentResource) {
      var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
      if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
      switch (type2) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
            type2 = getStyleKey(pendingProps.href);
            var styles$242 = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, resource$243 = styles$242.get(type2);
            resource$243 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$243 = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: 0, preload: null }
            }, styles$242.set(type2, resource$243), (styles$242 = JSCompiler_inline_result.querySelector(
              getStylesheetSelectorFromKey(type2)
            )) && !styles$242._p && (resource$243.instance = styles$242, resource$243.state.loading = 5), preloadPropsMap.has(type2) || (pendingProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            }, preloadPropsMap.set(type2, pendingProps), styles$242 || preloadStylesheet(
              JSCompiler_inline_result,
              type2,
              pendingProps,
              resource$243.state
            )));
            if (currentProps && null === currentResource)
              throw Error(formatProdErrorMessage(528, ""));
            return resource$243;
          }
          if (currentProps && null !== currentResource)
            throw Error(formatProdErrorMessage(529, ""));
          return null;
        case "script":
          return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(formatProdErrorMessage(444, type2));
      }
    }
    function getStyleKey(href) {
      return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
      ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
        return state.loading |= 1;
      }), key.addEventListener("error", function() {
        return state.loading |= 2;
      }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
      return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance)
        switch (resource.type) {
          case "style":
            var instance = hoistableRoot.querySelector(
              'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
            );
            if (instance)
              return resource.instance = instance, markNodeAsHoistable(instance), instance;
            var styleProps = assign({}, props, {
              "data-href": props.href,
              "data-precedence": props.precedence,
              href: null,
              precedence: null
            });
            instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
              "style"
            );
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProps);
            insertStylesheet(instance, props.precedence, hoistableRoot);
            return resource.instance = instance;
          case "stylesheet":
            styleProps = getStyleKey(props.href);
            var instance$248 = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(styleProps)
            );
            if (instance$248)
              return resource.state.loading |= 4, resource.instance = instance$248, markNodeAsHoistable(instance$248), instance$248;
            instance = stylesheetPropsFromRawProps(props);
            (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
            instance$248 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
            markNodeAsHoistable(instance$248);
            var linkInstance = instance$248;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance$248, "link", instance);
            resource.state.loading |= 4;
            insertStylesheet(instance$248, props.precedence, hoistableRoot);
            return resource.instance = instance$248;
          case "script":
            instance$248 = getScriptKey(props.src);
            if (styleProps = hoistableRoot.querySelector(
              getScriptSelectorFromKey(instance$248)
            ))
              return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
            instance = props;
            if (styleProps = preloadPropsMap.get(instance$248))
              instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProps = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProps);
            setInitialProperties(styleProps, "link", instance);
            hoistableRoot.head.appendChild(styleProps);
            return resource.instance = styleProps;
          case "void":
            return null;
          default:
            throw Error(formatProdErrorMessage(443, resource.type));
        }
      else
        "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root2) {
      for (var nodes = root2.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i2 = 0; i2 < nodes.length; i2++) {
        var node2 = nodes[i2];
        if (node2.dataset.precedence === precedence) prior = node2;
        else if (prior !== last) break;
      }
      prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
    }
    var tagCaches = null;
    function getHydratableHoistableCache(type2, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache = /* @__PURE__ */ new Map();
        var caches = tagCaches = /* @__PURE__ */ new Map();
        caches.set(ownerDocument, cache);
      } else
        caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
      if (cache.has(type2)) return cache;
      cache.set(type2, null);
      ownerDocument = ownerDocument.getElementsByTagName(type2);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node2 = ownerDocument[caches];
        if (!(node2[internalHoistableMarker] || node2[internalInstanceKey] || "link" === type2 && "stylesheet" === node2.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node2.namespaceURI) {
          var nodeKey = node2.getAttribute(keyAttribute) || "";
          nodeKey = type2 + nodeKey;
          var existing = cache.get(nodeKey);
          existing ? existing.push(node2) : cache.set(nodeKey, [node2]);
        }
      }
      return cache;
    }
    function mountHoistable(hoistableRoot, type2, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(
        instance,
        "title" === type2 ? hoistableRoot.querySelector("head > title") : null
      );
    }
    function isHostHoistableType(type2, props, hostContext) {
      if (1 === hostContext || null != props.itemProp) return false;
      switch (type2) {
        case "meta":
        case "title":
          return true;
        case "style":
          if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
            break;
          return true;
        case "link":
          if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
            break;
          switch (props.rel) {
            case "stylesheet":
              return type2 = props.disabled, "string" === typeof props.precedence && null == type2;
            default:
              return true;
          }
        case "script":
          if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
            return true;
      }
      return false;
    }
    function preloadResource(resource) {
      return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
    }
    var suspendedState = null;
    function noop$4() {
    }
    function suspendResource(hoistableRoot, resource, props) {
      if (null === suspendedState) throw Error(formatProdErrorMessage(475));
      var state = suspendedState;
      if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
        if (null === resource.instance) {
          var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
            getStylesheetSelectorFromKey(key)
          );
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
            resource.state.loading |= 4;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
      }
    }
    function waitForCommitToBeReady() {
      if (null === suspendedState) throw Error(formatProdErrorMessage(475));
      var state = suspendedState;
      state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count ? function(commit) {
        var stylesheetTimer = setTimeout(function() {
          state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 6e4);
        state.unsuspend = commit;
        return function() {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
        };
      } : null;
    }
    function onUnsuspend() {
      this.count--;
      if (0 === this.count) {
        if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
      }
    }
    var precedencesByRoot = null;
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root2, resource) {
      if (!(resource.state.loading & 4)) {
        var precedences = precedencesByRoot.get(root2);
        if (precedences) var last = precedences.get(null);
        else {
          precedences = /* @__PURE__ */ new Map();
          precedencesByRoot.set(root2, precedences);
          for (var nodes = root2.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), i2 = 0; i2 < nodes.length; i2++) {
            var node2 = nodes[i2];
            if ("LINK" === node2.nodeName || "not all" !== node2.getAttribute("media"))
              precedences.set(node2.dataset.precedence, node2), last = node2;
          }
          last && precedences.set(null, last);
        }
        nodes = resource.instance;
        node2 = nodes.getAttribute("data-precedence");
        i2 = precedences.get(node2) || last;
        i2 === last && precedences.set(null, nodes);
        precedences.set(node2, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        i2 ? i2.parentNode.insertBefore(nodes, i2.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
        resource.state.loading |= 4;
      }
    }
    var HostTransitionContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Provider: null,
      Consumer: null,
      _currentValue: sharedNotPendingObject,
      _currentValue2: sharedNotPendingObject,
      _threadCount: 0
    };
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = /* @__PURE__ */ new Map();
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
      containerInfo = new FiberRootNode(
        containerInfo,
        tag,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        formState
      );
      tag = 1;
      true === isStrictMode && (tag |= 24);
      isStrictMode = createFiberImplClass(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache$1();
      tag.refCount++;
      containerInfo.pooledCache = tag;
      tag.refCount++;
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
      container = createUpdate(lane);
      container.payload = { element };
      callback = void 0 === callback ? null : callback;
      null !== callback && (container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a = fiber.retryLane;
        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    var _enabled = true;
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn)
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          ), clearIfContinuousEvent(domEventName, nativeEvent);
        else if (queueIfContinuousEvent(
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ))
          nativeEvent.stopPropagation();
        else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
          for (; null !== blockedOn; ) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber)
              switch (fiber.tag) {
                case 3:
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (0 !== lanes) {
                      var root2 = fiber;
                      root2.pendingLanes |= 2;
                      for (root2.entangledLanes |= 2; lanes; ) {
                        var lane = 1 << 31 - clz32(lanes);
                        root2.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
                    }
                  }
                  break;
                case 13:
                  root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber && dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            );
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            null,
            targetContainer
          );
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    var return_targetInst = null;
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;
        else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return 2;
            case UserBlockingPriority:
              return 8;
            case NormalPriority$1:
            case LowPriority:
              return 32;
            case IdlePriority:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
        return existingQueuedEvent = {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case "focusin":
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedFocus,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "dragenter":
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedDrag,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "mouseover":
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedMouse,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointers.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          );
          return true;
        case "gotpointercapture":
          return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointerCaptures.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          ), true;
      }
      return false;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted) {
          if (targetInst = nearestMounted.tag, 13 === targetInst) {
            if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                if (13 === nearestMounted.tag) {
                  var lane = requestUpdateLane(), root2 = enqueueConcurrentRenderForLane(nearestMounted, lane);
                  null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
                  markRetryLaneIfNotHydrated(nearestMounted, lane);
                }
              });
              return;
            }
          } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
            queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            return;
          }
        }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return false;
      for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(
            nextBlockedOn.type,
            nextBlockedOn
          );
          currentReplayingEvent = nativeEventClone;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          currentReplayingEvent = null;
        } else
          return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
        targetContainers.shift();
      }
      return true;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = false;
      null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
      null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
      null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        replayUnblockedEvents
      )));
    }
    var lastScheduledReplayQueue = null;
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        function() {
          lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
          for (var i2 = 0; i2 < formReplayingQueue.length; i2 += 3) {
            var form = formReplayingQueue[i2], submitterOrAction = formReplayingQueue[i2 + 1], formData = formReplayingQueue[i2 + 2];
            if ("function" !== typeof submitterOrAction)
              if (null === findInstanceBlockingTarget(submitterOrAction || form))
                continue;
              else break;
            var formInst = getInstanceFromNode(form);
            null !== formInst && (formReplayingQueue.splice(i2, 3), i2 -= 3, startHostTransition(
              formInst,
              {
                pending: true,
                data: formData,
                method: form.method,
                action: submitterOrAction
              },
              submitterOrAction,
              formData
            ));
          }
        }
      ));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length; i2++) {
        var queuedTarget = queuedExplicitHydrationTargets[i2];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (; 0 < queuedExplicitHydrationTargets.length && (i2 = queuedExplicitHydrationTargets[0], null === i2.blockedOn); )
        attemptExplicitHydrationTarget(i2), null === i2.blockedOn && queuedExplicitHydrationTargets.shift();
      i2 = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i2)
        for (queuedTarget = 0; queuedTarget < i2.length; queuedTarget += 3) {
          var form = i2[queuedTarget], submitterOrAction = i2[queuedTarget + 1], formProps = form[internalPropsKey] || null;
          if ("function" === typeof submitterOrAction)
            formProps || scheduleReplayQueueIfNeeded(i2);
          else if (formProps) {
            var action = null;
            if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
              if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                action = formProps.formAction;
              else {
                if (null !== findInstanceBlockingTarget(form)) continue;
              }
            else action = formProps.action;
            "function" === typeof action ? i2[queuedTarget + 1] = action : (i2.splice(queuedTarget, 3), queuedTarget -= 3);
            scheduleReplayQueueIfNeeded(i2);
          }
        }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
      var root2 = this._internalRoot;
      if (null === root2) throw Error(formatProdErrorMessage(409));
      var current = root2.current, lane = requestUpdateLane();
      updateContainerImpl(current, lane, children, root2, null, null);
    };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
      var root2 = this._internalRoot;
      if (null !== root2) {
        this._internalRoot = null;
        var container = root2.containerInfo;
        0 === root2.tag && flushPassiveEffects();
        updateContainerImpl(root2.current, 2, null, root2, null, null);
        flushSyncWork$1();
        container[internalContainerInstanceKey] = null;
      }
    };
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target, priority: updatePriority };
        for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i2].priority; i2++) ;
        queuedExplicitHydrationTargets.splice(i2, 0, target);
        0 === i2 && attemptExplicitHydrationTarget(target);
      }
    };
    var isomorphicReactPackageVersion$jscomp$inline_1686 = React$3.version;
    if ("19.0.0" !== isomorphicReactPackageVersion$jscomp$inline_1686)
      throw Error(
        formatProdErrorMessage(
          527,
          isomorphicReactPackageVersion$jscomp$inline_1686,
          "19.0.0"
        )
      );
    ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render)
          throw Error(formatProdErrorMessage(188));
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error(formatProdErrorMessage(268, componentOrElement));
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
      componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    var internals$jscomp$inline_2165 = {
      bundleType: 0,
      version: "19.0.0",
      rendererPackageName: "react-dom",
      currentDispatcherRef: ReactSharedInternals,
      findFiberByHostInstance: getClosestInstanceFromNode,
      reconcilerVersion: "19.0.0"
    };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var hook$jscomp$inline_2166 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!hook$jscomp$inline_2166.isDisabled && hook$jscomp$inline_2166.supportsFiber)
        try {
          rendererID = hook$jscomp$inline_2166.inject(
            internals$jscomp$inline_2165
          ), injectedHook = hook$jscomp$inline_2166;
        } catch (err) {
        }
    }
    reactDomClient_production.createRoot = function(container, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks));
      options2 = createFiberRoot(
        container,
        1,
        false,
        null,
        null,
        isStrictMode,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        transitionCallbacks,
        null
      );
      container[internalContainerInstanceKey] = options2.current;
      listenToAllSupportedEvents(
        8 === container.nodeType ? container.parentNode : container
      );
      return new ReactDOMRoot(options2);
    };
    reactDomClient_production.hydrateRoot = function(container, initialChildren, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks), void 0 !== options2.formState && (formState = options2.formState));
      initialChildren = createFiberRoot(
        container,
        1,
        true,
        initialChildren,
        null != options2 ? options2 : null,
        isStrictMode,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        transitionCallbacks,
        formState
      );
      initialChildren.context = getContextForSubtree(null);
      options2 = initialChildren.current;
      isStrictMode = requestUpdateLane();
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options2, identifierPrefix, isStrictMode);
      initialChildren.current.lanes = isStrictMode;
      markRootUpdated$1(initialChildren, isStrictMode);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    reactDomClient_production.version = "19.0.0";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      client.exports = reactDomClient_production;
    }
    var clientExports = client.exports;
    function Cache(maxSize) {
      this._maxSize = maxSize;
      this.clear();
    }
    Cache.prototype.clear = function() {
      this._size = 0;
      this._values = /* @__PURE__ */ Object.create(null);
    };
    Cache.prototype.get = function(key) {
      return this._values[key];
    };
    Cache.prototype.set = function(key, value) {
      this._size >= this._maxSize && this.clear();
      if (!(key in this._values)) this._size++;
      return this._values[key] = value;
    };
    var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g, DIGIT_REGEX = /^\d+$/, LEAD_DIGIT_REGEX = /^\d/, SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/, MAX_CACHE_SIZE = 512;
    var pathCache = new Cache(MAX_CACHE_SIZE), setCache = new Cache(MAX_CACHE_SIZE), getCache = new Cache(MAX_CACHE_SIZE);
    var propertyExpr = {
      Cache,
      split,
      normalizePath,
      setter: function(path2) {
        var parts = normalizePath(path2);
        return setCache.get(path2) || setCache.set(path2, function setter(obj, value) {
          var index2 = 0;
          var len = parts.length;
          var data = obj;
          while (index2 < len - 1) {
            var part = parts[index2];
            if (part === "__proto__" || part === "constructor" || part === "prototype") {
              return obj;
            }
            data = data[parts[index2++]];
          }
          data[parts[index2]] = value;
        });
      },
      getter: function(path2, safe) {
        var parts = normalizePath(path2);
        return getCache.get(path2) || getCache.set(path2, function getter(data) {
          var index2 = 0, len = parts.length;
          while (index2 < len) {
            if (data != null || !safe) data = data[parts[index2++]];
            else return;
          }
          return data;
        });
      },
      join: function(segments) {
        return segments.reduce(function(path2, part) {
          return path2 + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path2 ? "." : "") + part);
        }, "");
      },
      forEach: function(path2, cb, thisArg) {
        forEach(Array.isArray(path2) ? path2 : split(path2), cb, thisArg);
      }
    };
    function normalizePath(path2) {
      return pathCache.get(path2) || pathCache.set(
        path2,
        split(path2).map(function(part) {
          return part.replace(CLEAN_QUOTES_REGEX, "$2");
        })
      );
    }
    function split(path2) {
      return path2.match(SPLIT_REGEX) || [""];
    }
    function forEach(parts, iter, thisArg) {
      var len = parts.length, part, idx, isArray2, isBracket;
      for (idx = 0; idx < len; idx++) {
        part = parts[idx];
        if (part) {
          if (shouldBeQuoted(part)) {
            part = '"' + part + '"';
          }
          isBracket = isQuoted(part);
          isArray2 = !isBracket && /^\d+$/.test(part);
          iter.call(thisArg, part, isBracket, isArray2, idx, parts);
        }
      }
    }
    function isQuoted(str) {
      return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
    }
    function hasLeadingNumber(part) {
      return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
    }
    function hasSpecialChars(part) {
      return SPEC_CHAR_REGEX.test(part);
    }
    function shouldBeQuoted(part) {
      return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
    }
    const reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
    const words = (str) => str.match(reWords) || [];
    const upperFirst = (str) => str[0].toUpperCase() + str.slice(1);
    const join = (str, d2) => words(str).join(d2).toLowerCase();
    const camelCase$2 = (str) => words(str).reduce(
      (acc, next2) => `${acc}${!acc ? next2.toLowerCase() : next2[0].toUpperCase() + next2.slice(1).toLowerCase()}`,
      ""
    );
    const pascalCase = (str) => upperFirst(camelCase$2(str));
    const snakeCase = (str) => join(str, "_");
    const kebabCase = (str) => join(str, "-");
    const sentenceCase = (str) => upperFirst(join(str, " "));
    const titleCase = (str) => words(str).map(upperFirst).join(" ");
    var tinyCase = {
      words,
      upperFirst,
      camelCase: camelCase$2,
      pascalCase,
      snakeCase,
      kebabCase,
      sentenceCase,
      titleCase
    };
    var toposort$2 = { exports: {} };
    toposort$2.exports = function(edges) {
      return toposort(uniqueNodes(edges), edges);
    };
    toposort$2.exports.array = toposort;
    function toposort(nodes, edges) {
      var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i2 = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
      edges.forEach(function(edge) {
        if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
          throw new Error("Unknown node. There is an unknown node in the supplied edges.");
        }
      });
      while (i2--) {
        if (!visited[i2]) visit2(nodes[i2], i2, /* @__PURE__ */ new Set());
      }
      return sorted;
      function visit2(node2, i3, predecessors) {
        if (predecessors.has(node2)) {
          var nodeRep;
          try {
            nodeRep = ", node was:" + JSON.stringify(node2);
          } catch (e2) {
            nodeRep = "";
          }
          throw new Error("Cyclic dependency" + nodeRep);
        }
        if (!nodesHash.has(node2)) {
          throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node2));
        }
        if (visited[i3]) return;
        visited[i3] = true;
        var outgoing = outgoingEdges.get(node2) || /* @__PURE__ */ new Set();
        outgoing = Array.from(outgoing);
        if (i3 = outgoing.length) {
          predecessors.add(node2);
          do {
            var child = outgoing[--i3];
            visit2(child, nodesHash.get(child), predecessors);
          } while (i3);
          predecessors.delete(node2);
        }
        sorted[--cursor] = node2;
      }
    }
    function uniqueNodes(arr) {
      var res = /* @__PURE__ */ new Set();
      for (var i2 = 0, len = arr.length; i2 < len; i2++) {
        var edge = arr[i2];
        res.add(edge[0]);
        res.add(edge[1]);
      }
      return Array.from(res);
    }
    function makeOutgoingEdges(arr) {
      var edges = /* @__PURE__ */ new Map();
      for (var i2 = 0, len = arr.length; i2 < len; i2++) {
        var edge = arr[i2];
        if (!edges.has(edge[0])) edges.set(edge[0], /* @__PURE__ */ new Set());
        if (!edges.has(edge[1])) edges.set(edge[1], /* @__PURE__ */ new Set());
        edges.get(edge[0]).add(edge[1]);
      }
      return edges;
    }
    function makeNodesHash(arr) {
      var res = /* @__PURE__ */ new Map();
      for (var i2 = 0, len = arr.length; i2 < len; i2++) {
        res.set(arr[i2], i2);
      }
      return res;
    }
    var toposortExports = toposort$2.exports;
    const toposort$1 = /* @__PURE__ */ getDefaultExportFromCjs(toposortExports);
    const toString$1 = Object.prototype.toString;
    const errorToString = Error.prototype.toString;
    const regExpToString = RegExp.prototype.toString;
    const symbolToString$1 = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
    const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
    function printNumber(val) {
      if (val != +val) return "NaN";
      const isNegativeZero = val === 0 && 1 / val < 0;
      return isNegativeZero ? "-0" : "" + val;
    }
    function printSimpleValue(val, quoteStrings = false) {
      if (val == null || val === true || val === false) return "" + val;
      const typeOf = typeof val;
      if (typeOf === "number") return printNumber(val);
      if (typeOf === "string") return quoteStrings ? `"${val}"` : val;
      if (typeOf === "function") return "[Function " + (val.name || "anonymous") + "]";
      if (typeOf === "symbol") return symbolToString$1.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
      const tag = toString$1.call(val).slice(8, -1);
      if (tag === "Date") return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
      if (tag === "Error" || val instanceof Error) return "[" + errorToString.call(val) + "]";
      if (tag === "RegExp") return regExpToString.call(val);
      return null;
    }
    function printValue(value, quoteStrings) {
      let result = printSimpleValue(value, quoteStrings);
      if (result !== null) return result;
      return JSON.stringify(value, function(key, value2) {
        let result2 = printSimpleValue(this[key], quoteStrings);
        if (result2 !== null) return result2;
        return value2;
      }, 2);
    }
    function toArray$6(value) {
      return value == null ? [] : [].concat(value);
    }
    let _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;
    let strReg = /\$\{\s*(\w+)\s*\}/g;
    _Symbol$toStringTag = Symbol.toStringTag;
    class ValidationErrorNoStack {
      constructor(errorOrErrors, value, field, type2) {
        this.name = void 0;
        this.message = void 0;
        this.value = void 0;
        this.path = void 0;
        this.type = void 0;
        this.params = void 0;
        this.errors = void 0;
        this.inner = void 0;
        this[_Symbol$toStringTag] = "Error";
        this.name = "ValidationError";
        this.value = value;
        this.path = field;
        this.type = type2;
        this.errors = [];
        this.inner = [];
        toArray$6(errorOrErrors).forEach((err) => {
          if (ValidationError.isError(err)) {
            this.errors.push(...err.errors);
            const innerErrors = err.inner.length ? err.inner : [err];
            this.inner.push(...innerErrors);
          } else {
            this.errors.push(err);
          }
        });
        this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
      }
    }
    _Symbol$hasInstance = Symbol.hasInstance;
    _Symbol$toStringTag2 = Symbol.toStringTag;
    class ValidationError extends Error {
      static formatError(message2, params) {
        const path2 = params.label || params.path || "this";
        params = Object.assign({}, params, {
          path: path2,
          originalPath: params.path
        });
        if (typeof message2 === "string") return message2.replace(strReg, (_2, key) => printValue(params[key]));
        if (typeof message2 === "function") return message2(params);
        return message2;
      }
      static isError(err) {
        return err && err.name === "ValidationError";
      }
      constructor(errorOrErrors, value, field, type2, disableStack) {
        const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type2);
        if (disableStack) {
          return errorNoStack;
        }
        super();
        this.value = void 0;
        this.path = void 0;
        this.type = void 0;
        this.params = void 0;
        this.errors = [];
        this.inner = [];
        this[_Symbol$toStringTag2] = "Error";
        this.name = errorNoStack.name;
        this.message = errorNoStack.message;
        this.type = errorNoStack.type;
        this.value = errorNoStack.value;
        this.path = errorNoStack.path;
        this.errors = errorNoStack.errors;
        this.inner = errorNoStack.inner;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, ValidationError);
        }
      }
      static [_Symbol$hasInstance](inst) {
        return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);
      }
    }
    let mixed = {
      default: "${path} is invalid",
      required: "${path} is a required field",
      defined: "${path} must be defined",
      notNull: "${path} cannot be null",
      oneOf: "${path} must be one of the following values: ${values}",
      notOneOf: "${path} must not be one of the following values: ${values}",
      notType: ({
        path: path2,
        type: type2,
        value,
        originalValue
      }) => {
        const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".";
        return type2 !== "mixed" ? `${path2} must be a \`${type2}\` type, but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path2} must match the configured type. The validated value was: \`${printValue(value, true)}\`` + castMsg;
      }
    };
    let string$1 = {
      length: "${path} must be exactly ${length} characters",
      min: "${path} must be at least ${min} characters",
      max: "${path} must be at most ${max} characters",
      matches: '${path} must match the following: "${regex}"',
      email: "${path} must be a valid email",
      url: "${path} must be a valid URL",
      uuid: "${path} must be a valid UUID",
      datetime: "${path} must be a valid ISO date-time",
      datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
      datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
      trim: "${path} must be a trimmed string",
      lowercase: "${path} must be a lowercase string",
      uppercase: "${path} must be a upper case string"
    };
    let number$1 = {
      min: "${path} must be greater than or equal to ${min}",
      max: "${path} must be less than or equal to ${max}",
      lessThan: "${path} must be less than ${less}",
      moreThan: "${path} must be greater than ${more}",
      positive: "${path} must be a positive number",
      negative: "${path} must be a negative number",
      integer: "${path} must be an integer"
    };
    let date$1 = {
      min: "${path} field must be later than ${min}",
      max: "${path} field must be at earlier than ${max}"
    };
    let boolean$1 = {
      isValue: "${path} field must be ${value}"
    };
    let object$1 = {
      noUnknown: "${path} field has unspecified keys: ${unknown}",
      exact: "${path} object contains unknown properties: ${properties}"
    };
    let array$1 = {
      min: "${path} field must have at least ${min} items",
      max: "${path} field must have less than or equal to ${max} items",
      length: "${path} must have ${length} items"
    };
    let tuple = {
      notType: (params) => {
        const {
          path: path2,
          value,
          spec
        } = params;
        const typeLen = spec.types.length;
        if (Array.isArray(value)) {
          if (value.length < typeLen) return `${path2} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
          if (value.length > typeLen) return `${path2} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
        }
        return ValidationError.formatError(mixed.notType, params);
      }
    };
    var locale$5 = Object.assign(/* @__PURE__ */ Object.create(null), {
      mixed,
      string: string$1,
      number: number$1,
      date: date$1,
      object: object$1,
      array: array$1,
      boolean: boolean$1,
      tuple
    });
    const isSchema = (obj) => obj && obj.__isYupSchema__;
    class Condition {
      static fromOptions(refs, config) {
        if (!config.then && !config.otherwise) throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
        let {
          is: is2,
          then,
          otherwise
        } = config;
        let check = typeof is2 === "function" ? is2 : (...values) => values.every((value) => value === is2);
        return new Condition(refs, (values, schema) => {
          var _branch;
          let branch = check(...values) ? then : otherwise;
          return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
        });
      }
      constructor(refs, builder) {
        this.fn = void 0;
        this.refs = refs;
        this.refs = refs;
        this.fn = builder;
      }
      resolve(base, options2) {
        let values = this.refs.map((ref) => (
          // TODO: ? operator here?
          ref.getValue(options2 == null ? void 0 : options2.value, options2 == null ? void 0 : options2.parent, options2 == null ? void 0 : options2.context)
        ));
        let schema = this.fn(values, base, options2);
        if (schema === void 0 || // @ts-ignore this can be base
        schema === base) {
          return base;
        }
        if (!isSchema(schema)) throw new TypeError("conditions must return a schema object");
        return schema.resolve(options2);
      }
    }
    const prefixes = {
      context: "$",
      value: "."
    };
    class Reference {
      constructor(key, options2 = {}) {
        this.key = void 0;
        this.isContext = void 0;
        this.isValue = void 0;
        this.isSibling = void 0;
        this.path = void 0;
        this.getter = void 0;
        this.map = void 0;
        if (typeof key !== "string") throw new TypeError("ref must be a string, got: " + key);
        this.key = key.trim();
        if (key === "") throw new TypeError("ref must be a non-empty string");
        this.isContext = this.key[0] === prefixes.context;
        this.isValue = this.key[0] === prefixes.value;
        this.isSibling = !this.isContext && !this.isValue;
        let prefix2 = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
        this.path = this.key.slice(prefix2.length);
        this.getter = this.path && propertyExpr.getter(this.path, true);
        this.map = options2.map;
      }
      getValue(value, parent, context) {
        let result = this.isContext ? context : this.isValue ? value : parent;
        if (this.getter) result = this.getter(result || {});
        if (this.map) result = this.map(result);
        return result;
      }
      /**
       *
       * @param {*} value
       * @param {Object} options
       * @param {Object=} options.context
       * @param {Object=} options.parent
       */
      cast(value, options2) {
        return this.getValue(value, options2 == null ? void 0 : options2.parent, options2 == null ? void 0 : options2.context);
      }
      resolve() {
        return this;
      }
      describe() {
        return {
          type: "ref",
          key: this.key
        };
      }
      toString() {
        return `Ref(${this.key})`;
      }
      static isRef(value) {
        return value && value.__isYupRef;
      }
    }
    Reference.prototype.__isYupRef = true;
    const isAbsent = (value) => value == null;
    function createValidation(config) {
      function validate({
        value,
        path: path2 = "",
        options: options2,
        originalValue,
        schema
      }, panic, next2) {
        const {
          name,
          test,
          params,
          message: message2,
          skipAbsent
        } = config;
        let {
          parent,
          context,
          abortEarly = schema.spec.abortEarly,
          disableStackTrace = schema.spec.disableStackTrace
        } = options2;
        function resolve(item) {
          return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
        }
        function createError(overrides = {}) {
          const nextParams = Object.assign({
            value,
            originalValue,
            label: schema.spec.label,
            path: overrides.path || path2,
            spec: schema.spec,
            disableStackTrace: overrides.disableStackTrace || disableStackTrace
          }, params, overrides.params);
          for (const key of Object.keys(nextParams)) nextParams[key] = resolve(nextParams[key]);
          const error = new ValidationError(ValidationError.formatError(overrides.message || message2, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);
          error.params = nextParams;
          return error;
        }
        const invalid = abortEarly ? panic : next2;
        let ctx = {
          path: path2,
          parent,
          type: name,
          from: options2.from,
          createError,
          resolve,
          options: options2,
          originalValue,
          schema
        };
        const handleResult = (validOrError) => {
          if (ValidationError.isError(validOrError)) invalid(validOrError);
          else if (!validOrError) invalid(createError());
          else next2(null);
        };
        const handleError = (err) => {
          if (ValidationError.isError(err)) invalid(err);
          else panic(err);
        };
        const shouldSkip = skipAbsent && isAbsent(value);
        if (shouldSkip) {
          return handleResult(true);
        }
        let result;
        try {
          var _result;
          result = test.call(ctx, value, ctx);
          if (typeof ((_result = result) == null ? void 0 : _result.then) === "function") {
            if (options2.sync) {
              throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
            }
            return Promise.resolve(result).then(handleResult, handleError);
          }
        } catch (err) {
          handleError(err);
          return;
        }
        handleResult(result);
      }
      validate.OPTIONS = config;
      return validate;
    }
    function getIn$1(schema, path2, value, context = value) {
      let parent, lastPart, lastPartDebug;
      if (!path2) return {
        parent,
        parentPath: path2,
        schema
      };
      propertyExpr.forEach(path2, (_part, isBracket, isArray2) => {
        let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
        schema = schema.resolve({
          context,
          parent,
          value
        });
        let isTuple = schema.type === "tuple";
        let idx = isArray2 ? parseInt(part, 10) : 0;
        if (schema.innerType || isTuple) {
          if (isTuple && !isArray2) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
          if (value && idx >= value.length) {
            throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path2}. because there is no value at that index. `);
          }
          parent = value;
          value = value && value[idx];
          schema = isTuple ? schema.spec.types[idx] : schema.innerType;
        }
        if (!isArray2) {
          if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path2}. (failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
          parent = value;
          value = value && value[part];
          schema = schema.fields[part];
        }
        lastPart = part;
        lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
      });
      return {
        schema,
        parent,
        parentPath: lastPart
      };
    }
    class ReferenceSet extends Set {
      describe() {
        const description = [];
        for (const item of this.values()) {
          description.push(Reference.isRef(item) ? item.describe() : item);
        }
        return description;
      }
      resolveAll(resolve) {
        let result = [];
        for (const item of this.values()) {
          result.push(resolve(item));
        }
        return result;
      }
      clone() {
        return new ReferenceSet(this.values());
      }
      merge(newItems, removeItems) {
        const next2 = this.clone();
        newItems.forEach((value) => next2.add(value));
        removeItems.forEach((value) => next2.delete(value));
        return next2;
      }
    }
    function clone$1(src, seen = /* @__PURE__ */ new Map()) {
      if (isSchema(src) || !src || typeof src !== "object") return src;
      if (seen.has(src)) return seen.get(src);
      let copy2;
      if (src instanceof Date) {
        copy2 = new Date(src.getTime());
        seen.set(src, copy2);
      } else if (src instanceof RegExp) {
        copy2 = new RegExp(src);
        seen.set(src, copy2);
      } else if (Array.isArray(src)) {
        copy2 = new Array(src.length);
        seen.set(src, copy2);
        for (let i2 = 0; i2 < src.length; i2++) copy2[i2] = clone$1(src[i2], seen);
      } else if (src instanceof Map) {
        copy2 = /* @__PURE__ */ new Map();
        seen.set(src, copy2);
        for (const [k2, v2] of src.entries()) copy2.set(k2, clone$1(v2, seen));
      } else if (src instanceof Set) {
        copy2 = /* @__PURE__ */ new Set();
        seen.set(src, copy2);
        for (const v2 of src) copy2.add(clone$1(v2, seen));
      } else if (src instanceof Object) {
        copy2 = {};
        seen.set(src, copy2);
        for (const [k2, v2] of Object.entries(src)) copy2[k2] = clone$1(v2, seen);
      } else {
        throw Error(`Unable to clone ${src}`);
      }
      return copy2;
    }
    let Schema$2 = class Schema {
      constructor(options2) {
        this.type = void 0;
        this.deps = [];
        this.tests = void 0;
        this.transforms = void 0;
        this.conditions = [];
        this._mutate = void 0;
        this.internalTests = {};
        this._whitelist = new ReferenceSet();
        this._blacklist = new ReferenceSet();
        this.exclusiveTests = /* @__PURE__ */ Object.create(null);
        this._typeCheck = void 0;
        this.spec = void 0;
        this.tests = [];
        this.transforms = [];
        this.withMutation(() => {
          this.typeError(mixed.notType);
        });
        this.type = options2.type;
        this._typeCheck = options2.check;
        this.spec = Object.assign({
          strip: false,
          strict: false,
          abortEarly: true,
          recursive: true,
          disableStackTrace: false,
          nullable: false,
          optional: true,
          coerce: true
        }, options2 == null ? void 0 : options2.spec);
        this.withMutation((s) => {
          s.nonNullable();
        });
      }
      // TODO: remove
      get _type() {
        return this.type;
      }
      clone(spec) {
        if (this._mutate) {
          if (spec) Object.assign(this.spec, spec);
          return this;
        }
        const next2 = Object.create(Object.getPrototypeOf(this));
        next2.type = this.type;
        next2._typeCheck = this._typeCheck;
        next2._whitelist = this._whitelist.clone();
        next2._blacklist = this._blacklist.clone();
        next2.internalTests = Object.assign({}, this.internalTests);
        next2.exclusiveTests = Object.assign({}, this.exclusiveTests);
        next2.deps = [...this.deps];
        next2.conditions = [...this.conditions];
        next2.tests = [...this.tests];
        next2.transforms = [...this.transforms];
        next2.spec = clone$1(Object.assign({}, this.spec, spec));
        return next2;
      }
      label(label) {
        let next2 = this.clone();
        next2.spec.label = label;
        return next2;
      }
      meta(...args) {
        if (args.length === 0) return this.spec.meta;
        let next2 = this.clone();
        next2.spec.meta = Object.assign(next2.spec.meta || {}, args[0]);
        return next2;
      }
      withMutation(fn) {
        let before = this._mutate;
        this._mutate = true;
        let result = fn(this);
        this._mutate = before;
        return result;
      }
      concat(schema) {
        if (!schema || schema === this) return this;
        if (schema.type !== this.type && this.type !== "mixed") throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
        let base = this;
        let combined = schema.clone();
        const mergedSpec = Object.assign({}, base.spec, combined.spec);
        combined.spec = mergedSpec;
        combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);
        combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
        combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
        combined.tests = base.tests;
        combined.exclusiveTests = base.exclusiveTests;
        combined.withMutation((next2) => {
          schema.tests.forEach((fn) => {
            next2.test(fn.OPTIONS);
          });
        });
        combined.transforms = [...base.transforms, ...combined.transforms];
        return combined;
      }
      isType(v2) {
        if (v2 == null) {
          if (this.spec.nullable && v2 === null) return true;
          if (this.spec.optional && v2 === void 0) return true;
          return false;
        }
        return this._typeCheck(v2);
      }
      resolve(options2) {
        let schema = this;
        if (schema.conditions.length) {
          let conditions = schema.conditions;
          schema = schema.clone();
          schema.conditions = [];
          schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options2), schema);
          schema = schema.resolve(options2);
        }
        return schema;
      }
      resolveOptions(options2) {
        var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
        return Object.assign({}, options2, {
          from: options2.from || [],
          strict: (_options$strict = options2.strict) != null ? _options$strict : this.spec.strict,
          abortEarly: (_options$abortEarly = options2.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
          recursive: (_options$recursive = options2.recursive) != null ? _options$recursive : this.spec.recursive,
          disableStackTrace: (_options$disableStack = options2.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
        });
      }
      /**
       * Run the configured transform pipeline over an input value.
       */
      cast(value, options2 = {}) {
        let resolvedSchema = this.resolve(Object.assign({
          value
        }, options2));
        let allowOptionality = options2.assert === "ignore-optionality";
        let result = resolvedSchema._cast(value, options2);
        if (options2.assert !== false && !resolvedSchema.isType(result)) {
          if (allowOptionality && isAbsent(result)) {
            return result;
          }
          let formattedValue = printValue(value);
          let formattedResult = printValue(result);
          throw new TypeError(`The value of ${options2.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema.type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
        }
        return result;
      }
      _cast(rawValue, options2) {
        let value = rawValue === void 0 ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);
        if (value === void 0) {
          value = this.getDefault(options2);
        }
        return value;
      }
      _validate(_value, options2 = {}, panic, next2) {
        let {
          path: path2,
          originalValue = _value,
          strict = this.spec.strict
        } = options2;
        let value = _value;
        if (!strict) {
          value = this._cast(value, Object.assign({
            assert: false
          }, options2));
        }
        let initialTests = [];
        for (let test of Object.values(this.internalTests)) {
          if (test) initialTests.push(test);
        }
        this.runTests({
          path: path2,
          value,
          originalValue,
          options: options2,
          tests: initialTests
        }, panic, (initialErrors) => {
          if (initialErrors.length) {
            return next2(initialErrors, value);
          }
          this.runTests({
            path: path2,
            value,
            originalValue,
            options: options2,
            tests: this.tests
          }, panic, next2);
        });
      }
      /**
       * Executes a set of validations, either schema, produced Tests or a nested
       * schema validate result.
       */
      runTests(runOptions, panic, next2) {
        let fired = false;
        let {
          tests,
          value,
          originalValue,
          path: path2,
          options: options2
        } = runOptions;
        let panicOnce = (arg) => {
          if (fired) return;
          fired = true;
          panic(arg, value);
        };
        let nextOnce = (arg) => {
          if (fired) return;
          fired = true;
          next2(arg, value);
        };
        let count = tests.length;
        let nestedErrors = [];
        if (!count) return nextOnce([]);
        let args = {
          value,
          originalValue,
          path: path2,
          options: options2,
          schema: this
        };
        for (let i2 = 0; i2 < tests.length; i2++) {
          const test = tests[i2];
          test(args, panicOnce, function finishTestRun(err) {
            if (err) {
              Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
            }
            if (--count <= 0) {
              nextOnce(nestedErrors);
            }
          });
        }
      }
      asNestedTest({
        key,
        index: index2,
        parent,
        parentPath,
        originalParent,
        options: options2
      }) {
        const k2 = key != null ? key : index2;
        if (k2 == null) {
          throw TypeError("Must include `key` or `index` for nested validations");
        }
        const isIndex2 = typeof k2 === "number";
        let value = parent[k2];
        const testOptions = Object.assign({}, options2, {
          // Nested validations fields are always strict:
          //    1. parent isn't strict so the casting will also have cast inner values
          //    2. parent is strict in which case the nested values weren't cast either
          strict: true,
          parent,
          value,
          originalValue: originalParent[k2],
          // FIXME: tests depend on `index` being passed around deeply,
          //   we should not let the options.key/index bleed through
          key: void 0,
          // index: undefined,
          [isIndex2 ? "index" : "key"]: k2,
          path: isIndex2 || k2.includes(".") ? `${parentPath || ""}[${isIndex2 ? k2 : `"${k2}"`}]` : (parentPath ? `${parentPath}.` : "") + key
        });
        return (_2, panic, next2) => this.resolve(testOptions)._validate(value, testOptions, panic, next2);
      }
      validate(value, options2) {
        var _options$disableStack2;
        let schema = this.resolve(Object.assign({}, options2, {
          value
        }));
        let disableStackTrace = (_options$disableStack2 = options2 == null ? void 0 : options2.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
        return new Promise((resolve, reject) => schema._validate(value, options2, (error, parsed) => {
          if (ValidationError.isError(error)) error.value = parsed;
          reject(error);
        }, (errors, validated) => {
          if (errors.length) reject(new ValidationError(errors, validated, void 0, void 0, disableStackTrace));
          else resolve(validated);
        }));
      }
      validateSync(value, options2) {
        var _options$disableStack3;
        let schema = this.resolve(Object.assign({}, options2, {
          value
        }));
        let result;
        let disableStackTrace = (_options$disableStack3 = options2 == null ? void 0 : options2.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
        schema._validate(value, Object.assign({}, options2, {
          sync: true
        }), (error, parsed) => {
          if (ValidationError.isError(error)) error.value = parsed;
          throw error;
        }, (errors, validated) => {
          if (errors.length) throw new ValidationError(errors, value, void 0, void 0, disableStackTrace);
          result = validated;
        });
        return result;
      }
      isValid(value, options2) {
        return this.validate(value, options2).then(() => true, (err) => {
          if (ValidationError.isError(err)) return false;
          throw err;
        });
      }
      isValidSync(value, options2) {
        try {
          this.validateSync(value, options2);
          return true;
        } catch (err) {
          if (ValidationError.isError(err)) return false;
          throw err;
        }
      }
      _getDefault(options2) {
        let defaultValue = this.spec.default;
        if (defaultValue == null) {
          return defaultValue;
        }
        return typeof defaultValue === "function" ? defaultValue.call(this, options2) : clone$1(defaultValue);
      }
      getDefault(options2) {
        let schema = this.resolve(options2 || {});
        return schema._getDefault(options2);
      }
      default(def) {
        if (arguments.length === 0) {
          return this._getDefault();
        }
        let next2 = this.clone({
          default: def
        });
        return next2;
      }
      strict(isStrict = true) {
        return this.clone({
          strict: isStrict
        });
      }
      nullability(nullable, message2) {
        const next2 = this.clone({
          nullable
        });
        next2.internalTests.nullable = createValidation({
          message: message2,
          name: "nullable",
          test(value) {
            return value === null ? this.schema.spec.nullable : true;
          }
        });
        return next2;
      }
      optionality(optional, message2) {
        const next2 = this.clone({
          optional
        });
        next2.internalTests.optionality = createValidation({
          message: message2,
          name: "optionality",
          test(value) {
            return value === void 0 ? this.schema.spec.optional : true;
          }
        });
        return next2;
      }
      optional() {
        return this.optionality(true);
      }
      defined(message2 = mixed.defined) {
        return this.optionality(false, message2);
      }
      nullable() {
        return this.nullability(true);
      }
      nonNullable(message2 = mixed.notNull) {
        return this.nullability(false, message2);
      }
      required(message2 = mixed.required) {
        return this.clone().withMutation((next2) => next2.nonNullable(message2).defined(message2));
      }
      notRequired() {
        return this.clone().withMutation((next2) => next2.nullable().optional());
      }
      transform(fn) {
        let next2 = this.clone();
        next2.transforms.push(fn);
        return next2;
      }
      /**
       * Adds a test function to the schema's queue of tests.
       * tests can be exclusive or non-exclusive.
       *
       * - exclusive tests, will replace any existing tests of the same name.
       * - non-exclusive: can be stacked
       *
       * If a non-exclusive test is added to a schema with an exclusive test of the same name
       * the exclusive test is removed and further tests of the same name will be stacked.
       *
       * If an exclusive test is added to a schema with non-exclusive tests of the same name
       * the previous tests are removed and further tests of the same name will replace each other.
       */
      test(...args) {
        let opts;
        if (args.length === 1) {
          if (typeof args[0] === "function") {
            opts = {
              test: args[0]
            };
          } else {
            opts = args[0];
          }
        } else if (args.length === 2) {
          opts = {
            name: args[0],
            test: args[1]
          };
        } else {
          opts = {
            name: args[0],
            message: args[1],
            test: args[2]
          };
        }
        if (opts.message === void 0) opts.message = mixed.default;
        if (typeof opts.test !== "function") throw new TypeError("`test` is a required parameters");
        let next2 = this.clone();
        let validate = createValidation(opts);
        let isExclusive = opts.exclusive || opts.name && next2.exclusiveTests[opts.name] === true;
        if (opts.exclusive) {
          if (!opts.name) throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
        }
        if (opts.name) next2.exclusiveTests[opts.name] = !!opts.exclusive;
        next2.tests = next2.tests.filter((fn) => {
          if (fn.OPTIONS.name === opts.name) {
            if (isExclusive) return false;
            if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
          }
          return true;
        });
        next2.tests.push(validate);
        return next2;
      }
      when(keys2, options2) {
        if (!Array.isArray(keys2) && typeof keys2 !== "string") {
          options2 = keys2;
          keys2 = ".";
        }
        let next2 = this.clone();
        let deps = toArray$6(keys2).map((key) => new Reference(key));
        deps.forEach((dep) => {
          if (dep.isSibling) next2.deps.push(dep.key);
        });
        next2.conditions.push(typeof options2 === "function" ? new Condition(deps, options2) : Condition.fromOptions(deps, options2));
        return next2;
      }
      typeError(message2) {
        let next2 = this.clone();
        next2.internalTests.typeError = createValidation({
          message: message2,
          name: "typeError",
          skipAbsent: true,
          test(value) {
            if (!this.schema._typeCheck(value)) return this.createError({
              params: {
                type: this.schema.type
              }
            });
            return true;
          }
        });
        return next2;
      }
      oneOf(enums, message2 = mixed.oneOf) {
        let next2 = this.clone();
        enums.forEach((val) => {
          next2._whitelist.add(val);
          next2._blacklist.delete(val);
        });
        next2.internalTests.whiteList = createValidation({
          message: message2,
          name: "oneOf",
          skipAbsent: true,
          test(value) {
            let valids = this.schema._whitelist;
            let resolved = valids.resolveAll(this.resolve);
            return resolved.includes(value) ? true : this.createError({
              params: {
                values: Array.from(valids).join(", "),
                resolved
              }
            });
          }
        });
        return next2;
      }
      notOneOf(enums, message2 = mixed.notOneOf) {
        let next2 = this.clone();
        enums.forEach((val) => {
          next2._blacklist.add(val);
          next2._whitelist.delete(val);
        });
        next2.internalTests.blacklist = createValidation({
          message: message2,
          name: "notOneOf",
          test(value) {
            let invalids = this.schema._blacklist;
            let resolved = invalids.resolveAll(this.resolve);
            if (resolved.includes(value)) return this.createError({
              params: {
                values: Array.from(invalids).join(", "),
                resolved
              }
            });
            return true;
          }
        });
        return next2;
      }
      strip(strip = true) {
        let next2 = this.clone();
        next2.spec.strip = strip;
        return next2;
      }
      /**
       * Return a serialized description of the schema including validations, flags, types etc.
       *
       * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
       */
      describe(options2) {
        const next2 = (options2 ? this.resolve(options2) : this).clone();
        const {
          label,
          meta,
          optional,
          nullable
        } = next2.spec;
        const description = {
          meta,
          label,
          optional,
          nullable,
          default: next2.getDefault(options2),
          type: next2.type,
          oneOf: next2._whitelist.describe(),
          notOneOf: next2._blacklist.describe(),
          tests: next2.tests.map((fn) => ({
            name: fn.OPTIONS.name,
            params: fn.OPTIONS.params
          })).filter((n2, idx, list) => list.findIndex((c2) => c2.name === n2.name) === idx)
        };
        return description;
      }
    };
    Schema$2.prototype.__isYupSchema__ = true;
    for (const method2 of ["validate", "validateSync"]) Schema$2.prototype[`${method2}At`] = function(path2, value, options2 = {}) {
      const {
        parent,
        parentPath,
        schema
      } = getIn$1(this, path2, value, options2.context);
      return schema[method2](parent && parent[parentPath], Object.assign({}, options2, {
        parent,
        path: path2
      }));
    };
    for (const alias of ["equals", "is"]) Schema$2.prototype[alias] = Schema$2.prototype.oneOf;
    for (const alias of ["not", "nope"]) Schema$2.prototype[alias] = Schema$2.prototype.notOneOf;
    const returnsTrue = () => true;
    function create$8(spec) {
      return new MixedSchema(spec);
    }
    class MixedSchema extends Schema$2 {
      constructor(spec) {
        super(typeof spec === "function" ? {
          type: "mixed",
          check: spec
        } : Object.assign({
          type: "mixed",
          check: returnsTrue
        }, spec));
      }
    }
    create$8.prototype = MixedSchema.prototype;
    function create$7() {
      return new BooleanSchema();
    }
    class BooleanSchema extends Schema$2 {
      constructor() {
        super({
          type: "boolean",
          check(v2) {
            if (v2 instanceof Boolean) v2 = v2.valueOf();
            return typeof v2 === "boolean";
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (ctx.spec.coerce && !ctx.isType(value)) {
              if (/^(true|1)$/i.test(String(value))) return true;
              if (/^(false|0)$/i.test(String(value))) return false;
            }
            return value;
          });
        });
      }
      isTrue(message2 = boolean$1.isValue) {
        return this.test({
          message: message2,
          name: "is-value",
          exclusive: true,
          params: {
            value: "true"
          },
          test(value) {
            return isAbsent(value) || value === true;
          }
        });
      }
      isFalse(message2 = boolean$1.isValue) {
        return this.test({
          message: message2,
          name: "is-value",
          exclusive: true,
          params: {
            value: "false"
          },
          test(value) {
            return isAbsent(value) || value === false;
          }
        });
      }
      default(def) {
        return super.default(def);
      }
      defined(msg) {
        return super.defined(msg);
      }
      optional() {
        return super.optional();
      }
      required(msg) {
        return super.required(msg);
      }
      notRequired() {
        return super.notRequired();
      }
      nullable() {
        return super.nullable();
      }
      nonNullable(msg) {
        return super.nonNullable(msg);
      }
      strip(v2) {
        return super.strip(v2);
      }
    }
    create$7.prototype = BooleanSchema.prototype;
    const isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
    function parseIsoDate(date2) {
      const struct = parseDateStruct(date2);
      if (!struct) return Date.parse ? Date.parse(date2) : Number.NaN;
      if (struct.z === void 0 && struct.plusMinus === void 0) {
        return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
      }
      let totalMinutesOffset = 0;
      if (struct.z !== "Z" && struct.plusMinus !== void 0) {
        totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
        if (struct.plusMinus === "+") totalMinutesOffset = 0 - totalMinutesOffset;
      }
      return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
    }
    function parseDateStruct(date2) {
      var _regexResult$7$length, _regexResult$;
      const regexResult = isoReg.exec(date2);
      if (!regexResult) return null;
      return {
        year: toNumber(regexResult[1]),
        month: toNumber(regexResult[2], 1) - 1,
        day: toNumber(regexResult[3], 1),
        hour: toNumber(regexResult[4]),
        minute: toNumber(regexResult[5]),
        second: toNumber(regexResult[6]),
        millisecond: regexResult[7] ? (
          // allow arbitrary sub-second precision beyond milliseconds
          toNumber(regexResult[7].substring(0, 3))
        ) : 0,
        precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : void 0,
        z: regexResult[8] || void 0,
        plusMinus: regexResult[9] || void 0,
        hourOffset: toNumber(regexResult[10]),
        minuteOffset: toNumber(regexResult[11])
      };
    }
    function toNumber(str, defaultValue = 0) {
      return Number(str) || defaultValue;
    }
    let rEmail = (
      // eslint-disable-next-line
      /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
    );
    let rUrl = (
      // eslint-disable-next-line
      /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
    );
    let rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    let yearMonthDay = "^\\d{4}-\\d{2}-\\d{2}";
    let hourMinuteSecond = "\\d{2}:\\d{2}:\\d{2}";
    let zOrOffset = "(([+-]\\d{2}(:?\\d{2})?)|Z)";
    let rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\.\\d+)?${zOrOffset}$`);
    let isTrimmed = (value) => isAbsent(value) || value === value.trim();
    let objStringTag = {}.toString();
    function create$6() {
      return new StringSchema();
    }
    class StringSchema extends Schema$2 {
      constructor() {
        super({
          type: "string",
          check(value) {
            if (value instanceof String) value = value.valueOf();
            return typeof value === "string";
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (!ctx.spec.coerce || ctx.isType(value)) return value;
            if (Array.isArray(value)) return value;
            const strValue = value != null && value.toString ? value.toString() : value;
            if (strValue === objStringTag) return value;
            return strValue;
          });
        });
      }
      required(message2) {
        return super.required(message2).withMutation((schema) => schema.test({
          message: message2 || mixed.required,
          name: "required",
          skipAbsent: true,
          test: (value) => !!value.length
        }));
      }
      notRequired() {
        return super.notRequired().withMutation((schema) => {
          schema.tests = schema.tests.filter((t2) => t2.OPTIONS.name !== "required");
          return schema;
        });
      }
      length(length2, message2 = string$1.length) {
        return this.test({
          message: message2,
          name: "length",
          exclusive: true,
          params: {
            length: length2
          },
          skipAbsent: true,
          test(value) {
            return value.length === this.resolve(length2);
          }
        });
      }
      min(min, message2 = string$1.min) {
        return this.test({
          message: message2,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          skipAbsent: true,
          test(value) {
            return value.length >= this.resolve(min);
          }
        });
      }
      max(max, message2 = string$1.max) {
        return this.test({
          name: "max",
          exclusive: true,
          message: message2,
          params: {
            max
          },
          skipAbsent: true,
          test(value) {
            return value.length <= this.resolve(max);
          }
        });
      }
      matches(regex, options2) {
        let excludeEmptyString = false;
        let message2;
        let name;
        if (options2) {
          if (typeof options2 === "object") {
            ({
              excludeEmptyString = false,
              message: message2,
              name
            } = options2);
          } else {
            message2 = options2;
          }
        }
        return this.test({
          name: name || "matches",
          message: message2 || string$1.matches,
          params: {
            regex
          },
          skipAbsent: true,
          test: (value) => value === "" && excludeEmptyString || value.search(regex) !== -1
        });
      }
      email(message2 = string$1.email) {
        return this.matches(rEmail, {
          name: "email",
          message: message2,
          excludeEmptyString: true
        });
      }
      url(message2 = string$1.url) {
        return this.matches(rUrl, {
          name: "url",
          message: message2,
          excludeEmptyString: true
        });
      }
      uuid(message2 = string$1.uuid) {
        return this.matches(rUUID, {
          name: "uuid",
          message: message2,
          excludeEmptyString: false
        });
      }
      datetime(options2) {
        let message2 = "";
        let allowOffset;
        let precision;
        if (options2) {
          if (typeof options2 === "object") {
            ({
              message: message2 = "",
              allowOffset = false,
              precision = void 0
            } = options2);
          } else {
            message2 = options2;
          }
        }
        return this.matches(rIsoDateTime, {
          name: "datetime",
          message: message2 || string$1.datetime,
          excludeEmptyString: true
        }).test({
          name: "datetime_offset",
          message: message2 || string$1.datetime_offset,
          params: {
            allowOffset
          },
          skipAbsent: true,
          test: (value) => {
            if (!value || allowOffset) return true;
            const struct = parseDateStruct(value);
            if (!struct) return false;
            return !!struct.z;
          }
        }).test({
          name: "datetime_precision",
          message: message2 || string$1.datetime_precision,
          params: {
            precision
          },
          skipAbsent: true,
          test: (value) => {
            if (!value || precision == void 0) return true;
            const struct = parseDateStruct(value);
            if (!struct) return false;
            return struct.precision === precision;
          }
        });
      }
      //-- transforms --
      ensure() {
        return this.default("").transform((val) => val === null ? "" : val);
      }
      trim(message2 = string$1.trim) {
        return this.transform((val) => val != null ? val.trim() : val).test({
          message: message2,
          name: "trim",
          test: isTrimmed
        });
      }
      lowercase(message2 = string$1.lowercase) {
        return this.transform((value) => !isAbsent(value) ? value.toLowerCase() : value).test({
          message: message2,
          name: "string_case",
          exclusive: true,
          skipAbsent: true,
          test: (value) => isAbsent(value) || value === value.toLowerCase()
        });
      }
      uppercase(message2 = string$1.uppercase) {
        return this.transform((value) => !isAbsent(value) ? value.toUpperCase() : value).test({
          message: message2,
          name: "string_case",
          exclusive: true,
          skipAbsent: true,
          test: (value) => isAbsent(value) || value === value.toUpperCase()
        });
      }
    }
    create$6.prototype = StringSchema.prototype;
    let isNaN$1 = (value) => value != +value;
    function create$5() {
      return new NumberSchema();
    }
    class NumberSchema extends Schema$2 {
      constructor() {
        super({
          type: "number",
          check(value) {
            if (value instanceof Number) value = value.valueOf();
            return typeof value === "number" && !isNaN$1(value);
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (!ctx.spec.coerce) return value;
            let parsed = value;
            if (typeof parsed === "string") {
              parsed = parsed.replace(/\s/g, "");
              if (parsed === "") return NaN;
              parsed = +parsed;
            }
            if (ctx.isType(parsed) || parsed === null) return parsed;
            return parseFloat(parsed);
          });
        });
      }
      min(min, message2 = number$1.min) {
        return this.test({
          message: message2,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          skipAbsent: true,
          test(value) {
            return value >= this.resolve(min);
          }
        });
      }
      max(max, message2 = number$1.max) {
        return this.test({
          message: message2,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          skipAbsent: true,
          test(value) {
            return value <= this.resolve(max);
          }
        });
      }
      lessThan(less, message2 = number$1.lessThan) {
        return this.test({
          message: message2,
          name: "max",
          exclusive: true,
          params: {
            less
          },
          skipAbsent: true,
          test(value) {
            return value < this.resolve(less);
          }
        });
      }
      moreThan(more, message2 = number$1.moreThan) {
        return this.test({
          message: message2,
          name: "min",
          exclusive: true,
          params: {
            more
          },
          skipAbsent: true,
          test(value) {
            return value > this.resolve(more);
          }
        });
      }
      positive(msg = number$1.positive) {
        return this.moreThan(0, msg);
      }
      negative(msg = number$1.negative) {
        return this.lessThan(0, msg);
      }
      integer(message2 = number$1.integer) {
        return this.test({
          name: "integer",
          message: message2,
          skipAbsent: true,
          test: (val) => Number.isInteger(val)
        });
      }
      truncate() {
        return this.transform((value) => !isAbsent(value) ? value | 0 : value);
      }
      round(method2) {
        var _method;
        let avail = ["ceil", "floor", "round", "trunc"];
        method2 = ((_method = method2) == null ? void 0 : _method.toLowerCase()) || "round";
        if (method2 === "trunc") return this.truncate();
        if (avail.indexOf(method2.toLowerCase()) === -1) throw new TypeError("Only valid options for round() are: " + avail.join(", "));
        return this.transform((value) => !isAbsent(value) ? Math[method2](value) : value);
      }
    }
    create$5.prototype = NumberSchema.prototype;
    let invalidDate = /* @__PURE__ */ new Date("");
    let isDate = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
    function create$4() {
      return new DateSchema();
    }
    class DateSchema extends Schema$2 {
      constructor() {
        super({
          type: "date",
          check(v2) {
            return isDate(v2) && !isNaN(v2.getTime());
          }
        });
        this.withMutation(() => {
          this.transform((value, _raw, ctx) => {
            if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;
            value = parseIsoDate(value);
            return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;
          });
        });
      }
      prepareParam(ref, name) {
        let param;
        if (!Reference.isRef(ref)) {
          let cast = this.cast(ref);
          if (!this._typeCheck(cast)) throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
          param = cast;
        } else {
          param = ref;
        }
        return param;
      }
      min(min, message2 = date$1.min) {
        let limit = this.prepareParam(min, "min");
        return this.test({
          message: message2,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          skipAbsent: true,
          test(value) {
            return value >= this.resolve(limit);
          }
        });
      }
      max(max, message2 = date$1.max) {
        let limit = this.prepareParam(max, "max");
        return this.test({
          message: message2,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          skipAbsent: true,
          test(value) {
            return value <= this.resolve(limit);
          }
        });
      }
    }
    DateSchema.INVALID_DATE = invalidDate;
    create$4.prototype = DateSchema.prototype;
    create$4.INVALID_DATE = invalidDate;
    function sortFields(fields, excludedEdges = []) {
      let edges = [];
      let nodes = /* @__PURE__ */ new Set();
      let excludes = new Set(excludedEdges.map(([a, b2]) => `${a}-${b2}`));
      function addNode(depPath, key) {
        let node2 = propertyExpr.split(depPath)[0];
        nodes.add(node2);
        if (!excludes.has(`${key}-${node2}`)) edges.push([key, node2]);
      }
      for (const key of Object.keys(fields)) {
        let value = fields[key];
        nodes.add(key);
        if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);
        else if (isSchema(value) && "deps" in value) value.deps.forEach((path2) => addNode(path2, key));
      }
      return toposort$1.array(Array.from(nodes), edges).reverse();
    }
    function findIndex(arr, err) {
      let idx = Infinity;
      arr.some((key, ii) => {
        var _err$path;
        if ((_err$path = err.path) != null && _err$path.includes(key)) {
          idx = ii;
          return true;
        }
      });
      return idx;
    }
    function sortByKeyOrder(keys2) {
      return (a, b2) => {
        return findIndex(keys2, a) - findIndex(keys2, b2);
      };
    }
    const parseJson = (value, _2, ctx) => {
      if (typeof value !== "string") {
        return value;
      }
      let parsed = value;
      try {
        parsed = JSON.parse(value);
      } catch (err) {
      }
      return ctx.isType(parsed) ? parsed : value;
    };
    function deepPartial(schema) {
      if ("fields" in schema) {
        const partial = {};
        for (const [key, fieldSchema] of Object.entries(schema.fields)) {
          partial[key] = deepPartial(fieldSchema);
        }
        return schema.setFields(partial);
      }
      if (schema.type === "array") {
        const nextArray = schema.optional();
        if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);
        return nextArray;
      }
      if (schema.type === "tuple") {
        return schema.optional().clone({
          types: schema.spec.types.map(deepPartial)
        });
      }
      if ("optional" in schema) {
        return schema.optional();
      }
      return schema;
    }
    const deepHas = (obj, p2) => {
      const path2 = [...propertyExpr.normalizePath(p2)];
      if (path2.length === 1) return path2[0] in obj;
      let last = path2.pop();
      let parent = propertyExpr.getter(propertyExpr.join(path2), true)(obj);
      return !!(parent && last in parent);
    };
    let isObject$3 = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
    function unknown(ctx, value) {
      let known = Object.keys(ctx.fields);
      return Object.keys(value).filter((key) => known.indexOf(key) === -1);
    }
    const defaultSort = sortByKeyOrder([]);
    function create$3(spec) {
      return new ObjectSchema(spec);
    }
    class ObjectSchema extends Schema$2 {
      constructor(spec) {
        super({
          type: "object",
          check(value) {
            return isObject$3(value) || typeof value === "function";
          }
        });
        this.fields = /* @__PURE__ */ Object.create(null);
        this._sortErrors = defaultSort;
        this._nodes = [];
        this._excludedEdges = [];
        this.withMutation(() => {
          if (spec) {
            this.shape(spec);
          }
        });
      }
      _cast(_value, options2 = {}) {
        var _options$stripUnknown;
        let value = super._cast(_value, options2);
        if (value === void 0) return this.getDefault(options2);
        if (!this._typeCheck(value)) return value;
        let fields = this.fields;
        let strip = (_options$stripUnknown = options2.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
        let props = [].concat(this._nodes, Object.keys(value).filter((v2) => !this._nodes.includes(v2)));
        let intermediateValue = {};
        let innerOptions = Object.assign({}, options2, {
          parent: intermediateValue,
          __validating: options2.__validating || false
        });
        let isChanged = false;
        for (const prop of props) {
          let field = fields[prop];
          let exists = prop in value;
          if (field) {
            let fieldValue;
            let inputValue = value[prop];
            innerOptions.path = (options2.path ? `${options2.path}.` : "") + prop;
            field = field.resolve({
              value: inputValue,
              context: options2.context,
              parent: intermediateValue
            });
            let fieldSpec = field instanceof Schema$2 ? field.spec : void 0;
            let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
            if (fieldSpec != null && fieldSpec.strip) {
              isChanged = isChanged || prop in value;
              continue;
            }
            fieldValue = !options2.__validating || !strict ? (
              // TODO: use _cast, this is double resolving
              field.cast(value[prop], innerOptions)
            ) : value[prop];
            if (fieldValue !== void 0) {
              intermediateValue[prop] = fieldValue;
            }
          } else if (exists && !strip) {
            intermediateValue[prop] = value[prop];
          }
          if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
            isChanged = true;
          }
        }
        return isChanged ? intermediateValue : value;
      }
      _validate(_value, options2 = {}, panic, next2) {
        let {
          from: from2 = [],
          originalValue = _value,
          recursive = this.spec.recursive
        } = options2;
        options2.from = [{
          schema: this,
          value: originalValue
        }, ...from2];
        options2.__validating = true;
        options2.originalValue = originalValue;
        super._validate(_value, options2, panic, (objectErrors, value) => {
          if (!recursive || !isObject$3(value)) {
            next2(objectErrors, value);
            return;
          }
          originalValue = originalValue || value;
          let tests = [];
          for (let key of this._nodes) {
            let field = this.fields[key];
            if (!field || Reference.isRef(field)) {
              continue;
            }
            tests.push(field.asNestedTest({
              options: options2,
              key,
              parent: value,
              parentPath: options2.path,
              originalParent: originalValue
            }));
          }
          this.runTests({
            tests,
            value,
            originalValue,
            options: options2
          }, panic, (fieldErrors) => {
            next2(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
          });
        });
      }
      clone(spec) {
        const next2 = super.clone(spec);
        next2.fields = Object.assign({}, this.fields);
        next2._nodes = this._nodes;
        next2._excludedEdges = this._excludedEdges;
        next2._sortErrors = this._sortErrors;
        return next2;
      }
      concat(schema) {
        let next2 = super.concat(schema);
        let nextFields = next2.fields;
        for (let [field, schemaOrRef] of Object.entries(this.fields)) {
          const target = nextFields[field];
          nextFields[field] = target === void 0 ? schemaOrRef : target;
        }
        return next2.withMutation((s) => (
          // XXX: excludes here is wrong
          s.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges])
        ));
      }
      _getDefault(options2) {
        if ("default" in this.spec) {
          return super._getDefault(options2);
        }
        if (!this._nodes.length) {
          return void 0;
        }
        let dft = {};
        this._nodes.forEach((key) => {
          var _innerOptions;
          const field = this.fields[key];
          let innerOptions = options2;
          if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[key]
            });
          }
          dft[key] = field && "getDefault" in field ? field.getDefault(innerOptions) : void 0;
        });
        return dft;
      }
      setFields(shape, excludedEdges) {
        let next2 = this.clone();
        next2.fields = shape;
        next2._nodes = sortFields(shape, excludedEdges);
        next2._sortErrors = sortByKeyOrder(Object.keys(shape));
        if (excludedEdges) next2._excludedEdges = excludedEdges;
        return next2;
      }
      shape(additions, excludes = []) {
        return this.clone().withMutation((next2) => {
          let edges = next2._excludedEdges;
          if (excludes.length) {
            if (!Array.isArray(excludes[0])) excludes = [excludes];
            edges = [...next2._excludedEdges, ...excludes];
          }
          return next2.setFields(Object.assign(next2.fields, additions), edges);
        });
      }
      partial() {
        const partial = {};
        for (const [key, schema] of Object.entries(this.fields)) {
          partial[key] = "optional" in schema && schema.optional instanceof Function ? schema.optional() : schema;
        }
        return this.setFields(partial);
      }
      deepPartial() {
        const next2 = deepPartial(this);
        return next2;
      }
      pick(keys2) {
        const picked = {};
        for (const key of keys2) {
          if (this.fields[key]) picked[key] = this.fields[key];
        }
        return this.setFields(picked, this._excludedEdges.filter(([a, b2]) => keys2.includes(a) && keys2.includes(b2)));
      }
      omit(keys2) {
        const remaining = [];
        for (const key of Object.keys(this.fields)) {
          if (keys2.includes(key)) continue;
          remaining.push(key);
        }
        return this.pick(remaining);
      }
      from(from2, to, alias) {
        let fromGetter = propertyExpr.getter(from2, true);
        return this.transform((obj) => {
          if (!obj) return obj;
          let newObj = obj;
          if (deepHas(obj, from2)) {
            newObj = Object.assign({}, obj);
            if (!alias) delete newObj[from2];
            newObj[to] = fromGetter(obj);
          }
          return newObj;
        });
      }
      /** Parse an input JSON string to an object */
      json() {
        return this.transform(parseJson);
      }
      /**
       * Similar to `noUnknown` but only validates that an object is the right shape without stripping the unknown keys
       */
      exact(message2) {
        return this.test({
          name: "exact",
          exclusive: true,
          message: message2 || object$1.exact,
          test(value) {
            if (value == null) return true;
            const unknownKeys = unknown(this.schema, value);
            return unknownKeys.length === 0 || this.createError({
              params: {
                properties: unknownKeys.join(", ")
              }
            });
          }
        });
      }
      stripUnknown() {
        return this.clone({
          noUnknown: true
        });
      }
      noUnknown(noAllow = true, message2 = object$1.noUnknown) {
        if (typeof noAllow !== "boolean") {
          message2 = noAllow;
          noAllow = true;
        }
        let next2 = this.test({
          name: "noUnknown",
          exclusive: true,
          message: message2,
          test(value) {
            if (value == null) return true;
            const unknownKeys = unknown(this.schema, value);
            return !noAllow || unknownKeys.length === 0 || this.createError({
              params: {
                unknown: unknownKeys.join(", ")
              }
            });
          }
        });
        next2.spec.noUnknown = noAllow;
        return next2;
      }
      unknown(allow = true, message2 = object$1.noUnknown) {
        return this.noUnknown(!allow, message2);
      }
      transformKeys(fn) {
        return this.transform((obj) => {
          if (!obj) return obj;
          const result = {};
          for (const key of Object.keys(obj)) result[fn(key)] = obj[key];
          return result;
        });
      }
      camelCase() {
        return this.transformKeys(tinyCase.camelCase);
      }
      snakeCase() {
        return this.transformKeys(tinyCase.snakeCase);
      }
      constantCase() {
        return this.transformKeys((key) => tinyCase.snakeCase(key).toUpperCase());
      }
      describe(options2) {
        const next2 = (options2 ? this.resolve(options2) : this).clone();
        const base = super.describe(options2);
        base.fields = {};
        for (const [key, value] of Object.entries(next2.fields)) {
          var _innerOptions2;
          let innerOptions = options2;
          if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[key]
            });
          }
          base.fields[key] = value.describe(innerOptions);
        }
        return base;
      }
    }
    create$3.prototype = ObjectSchema.prototype;
    function create$2(type2) {
      return new ArraySchema(type2);
    }
    class ArraySchema extends Schema$2 {
      constructor(type2) {
        super({
          type: "array",
          spec: {
            types: type2
          },
          check(v2) {
            return Array.isArray(v2);
          }
        });
        this.innerType = void 0;
        this.innerType = type2;
      }
      _cast(_value, _opts) {
        const value = super._cast(_value, _opts);
        if (!this._typeCheck(value) || !this.innerType) {
          return value;
        }
        let isChanged = false;
        const castArray = value.map((v2, idx) => {
          const castElement = this.innerType.cast(v2, Object.assign({}, _opts, {
            path: `${_opts.path || ""}[${idx}]`
          }));
          if (castElement !== v2) {
            isChanged = true;
          }
          return castElement;
        });
        return isChanged ? castArray : value;
      }
      _validate(_value, options2 = {}, panic, next2) {
        var _options$recursive;
        let innerType = this.innerType;
        let recursive = (_options$recursive = options2.recursive) != null ? _options$recursive : this.spec.recursive;
        options2.originalValue != null ? options2.originalValue : _value;
        super._validate(_value, options2, panic, (arrayErrors, value) => {
          var _options$originalValu2;
          if (!recursive || !innerType || !this._typeCheck(value)) {
            next2(arrayErrors, value);
            return;
          }
          let tests = new Array(value.length);
          for (let index2 = 0; index2 < value.length; index2++) {
            var _options$originalValu;
            tests[index2] = innerType.asNestedTest({
              options: options2,
              index: index2,
              parent: value,
              parentPath: options2.path,
              originalParent: (_options$originalValu = options2.originalValue) != null ? _options$originalValu : _value
            });
          }
          this.runTests({
            value,
            tests,
            originalValue: (_options$originalValu2 = options2.originalValue) != null ? _options$originalValu2 : _value,
            options: options2
          }, panic, (innerTypeErrors) => next2(innerTypeErrors.concat(arrayErrors), value));
        });
      }
      clone(spec) {
        const next2 = super.clone(spec);
        next2.innerType = this.innerType;
        return next2;
      }
      /** Parse an input JSON string to an object */
      json() {
        return this.transform(parseJson);
      }
      concat(schema) {
        let next2 = super.concat(schema);
        next2.innerType = this.innerType;
        if (schema.innerType)
          next2.innerType = next2.innerType ? (
            // @ts-expect-error Lazy doesn't have concat and will break
            next2.innerType.concat(schema.innerType)
          ) : schema.innerType;
        return next2;
      }
      of(schema) {
        let next2 = this.clone();
        if (!isSchema(schema)) throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
        next2.innerType = schema;
        next2.spec = Object.assign({}, next2.spec, {
          types: schema
        });
        return next2;
      }
      length(length2, message2 = array$1.length) {
        return this.test({
          message: message2,
          name: "length",
          exclusive: true,
          params: {
            length: length2
          },
          skipAbsent: true,
          test(value) {
            return value.length === this.resolve(length2);
          }
        });
      }
      min(min, message2) {
        message2 = message2 || array$1.min;
        return this.test({
          message: message2,
          name: "min",
          exclusive: true,
          params: {
            min
          },
          skipAbsent: true,
          // FIXME(ts): Array<typeof T>
          test(value) {
            return value.length >= this.resolve(min);
          }
        });
      }
      max(max, message2) {
        message2 = message2 || array$1.max;
        return this.test({
          message: message2,
          name: "max",
          exclusive: true,
          params: {
            max
          },
          skipAbsent: true,
          test(value) {
            return value.length <= this.resolve(max);
          }
        });
      }
      ensure() {
        return this.default(() => []).transform((val, original) => {
          if (this._typeCheck(val)) return val;
          return original == null ? [] : [].concat(original);
        });
      }
      compact(rejector) {
        let reject = !rejector ? (v2) => !!v2 : (v2, i2, a) => !rejector(v2, i2, a);
        return this.transform((values) => values != null ? values.filter(reject) : values);
      }
      describe(options2) {
        const next2 = (options2 ? this.resolve(options2) : this).clone();
        const base = super.describe(options2);
        if (next2.innerType) {
          var _innerOptions;
          let innerOptions = options2;
          if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
            innerOptions = Object.assign({}, innerOptions, {
              parent: innerOptions.value,
              value: innerOptions.value[0]
            });
          }
          base.innerType = next2.innerType.describe(innerOptions);
        }
        return base;
      }
    }
    create$2.prototype = ArraySchema.prototype;
    function create(builder) {
      return new Lazy(builder);
    }
    function catchValidationError(fn) {
      try {
        return fn();
      } catch (err) {
        if (ValidationError.isError(err)) return Promise.reject(err);
        throw err;
      }
    }
    class Lazy {
      constructor(builder) {
        this.type = "lazy";
        this.__isYupSchema__ = true;
        this.spec = void 0;
        this._resolve = (value, options2 = {}) => {
          let schema = this.builder(value, options2);
          if (!isSchema(schema)) throw new TypeError("lazy() functions must return a valid schema");
          if (this.spec.optional) schema = schema.optional();
          return schema.resolve(options2);
        };
        this.builder = builder;
        this.spec = {
          meta: void 0,
          optional: false
        };
      }
      clone(spec) {
        const next2 = new Lazy(this.builder);
        next2.spec = Object.assign({}, this.spec, spec);
        return next2;
      }
      optionality(optional) {
        const next2 = this.clone({
          optional
        });
        return next2;
      }
      optional() {
        return this.optionality(true);
      }
      resolve(options2) {
        return this._resolve(options2.value, options2);
      }
      cast(value, options2) {
        return this._resolve(value, options2).cast(value, options2);
      }
      asNestedTest(config) {
        let {
          key,
          index: index2,
          parent,
          options: options2
        } = config;
        let value = parent[index2 != null ? index2 : key];
        return this._resolve(value, Object.assign({}, options2, {
          value,
          parent
        })).asNestedTest(config);
      }
      validate(value, options2) {
        return catchValidationError(() => this._resolve(value, options2).validate(value, options2));
      }
      validateSync(value, options2) {
        return this._resolve(value, options2).validateSync(value, options2);
      }
      validateAt(path2, value, options2) {
        return catchValidationError(() => this._resolve(value, options2).validateAt(path2, value, options2));
      }
      validateSyncAt(path2, value, options2) {
        return this._resolve(value, options2).validateSyncAt(path2, value, options2);
      }
      isValid(value, options2) {
        try {
          return this._resolve(value, options2).isValid(value, options2);
        } catch (err) {
          if (ValidationError.isError(err)) {
            return Promise.resolve(false);
          }
          throw err;
        }
      }
      isValidSync(value, options2) {
        return this._resolve(value, options2).isValidSync(value, options2);
      }
      describe(options2) {
        return options2 ? this.resolve(options2).describe(options2) : {
          type: "lazy",
          meta: this.spec.meta,
          label: void 0
        };
      }
      meta(...args) {
        if (args.length === 0) return this.spec.meta;
        let next2 = this.clone();
        next2.spec.meta = Object.assign(next2.spec.meta || {}, args[0]);
        return next2;
      }
    }
    function setLocale(custom) {
      Object.keys(custom).forEach((type2) => {
        Object.keys(custom[type2]).forEach((method2) => {
          locale$5[type2][method2] = custom[type2][method2];
        });
      });
    }
    setLocale({
      mixed: {
        required: "This field is required",
        notType: "Invalid value"
      },
      string: {
        email: "Invalid email address",
        min: "Minimum length is ${min}",
        max: "Maximum length is ${max}"
      },
      number: {
        min: "Minimum value is ${min}",
        max: "Maximum value is ${max}"
      },
      array: {
        min: "At least ${min} items are required",
        max: "No more than ${max} items are allowed"
      }
    });
    function createElement(args) {
      return args;
    }
    var classnames = { exports: {} };
    /*!
    	Copyright (c) 2018 Jed Watson.
    	Licensed under the MIT License (MIT), see
    	http://jedwatson.github.io/classnames
    */
    (function(module2) {
      (function() {
        var hasOwn = {}.hasOwnProperty;
        function classNames2() {
          var classes = "";
          for (var i2 = 0; i2 < arguments.length; i2++) {
            var arg = arguments[i2];
            if (arg) {
              classes = appendClass(classes, parseValue(arg));
            }
          }
          return classes;
        }
        function parseValue(arg) {
          if (typeof arg === "string" || typeof arg === "number") {
            return arg;
          }
          if (typeof arg !== "object") {
            return "";
          }
          if (Array.isArray(arg)) {
            return classNames2.apply(null, arg);
          }
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            return arg.toString();
          }
          var classes = "";
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes = appendClass(classes, key);
            }
          }
          return classes;
        }
        function appendClass(value, newClass) {
          if (!newClass) {
            return value;
          }
          if (value) {
            return value + " " + newClass;
          }
          return value + newClass;
        }
        if (module2.exports) {
          classNames2.default = classNames2;
          module2.exports = classNames2;
        } else {
          window.classNames = classNames2;
        }
      })();
    })(classnames);
    var classnamesExports = classnames.exports;
    const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
    function _extends$2() {
      return _extends$2 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e2 = 1; e2 < arguments.length; e2++) {
          var t2 = arguments[e2];
          for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
        }
        return n2;
      }, _extends$2.apply(null, arguments);
    }
    function _typeof$1(o2) {
      "@babel/helpers - typeof";
      return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof$1(o2);
    }
    var REACT_ELEMENT_TYPE_18 = Symbol.for("react.element");
    var REACT_ELEMENT_TYPE_19 = Symbol.for("react.transitional.element");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function isFragment$1(object2) {
      return (
        // Base object type
        object2 && _typeof$1(object2) === "object" && // React Element type
        (object2.$$typeof === REACT_ELEMENT_TYPE_18 || object2.$$typeof === REACT_ELEMENT_TYPE_19) && // React Fragment type
        object2.type === REACT_FRAGMENT_TYPE
      );
    }
    function toArray$5(children) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var ret = [];
      i.Children.forEach(children, function(child) {
        if ((child === void 0 || child === null) && !option.keepEmpty) {
          return;
        }
        if (Array.isArray(child)) {
          ret = ret.concat(toArray$5(child));
        } else if (isFragment$1(child) && child.props) {
          ret = ret.concat(toArray$5(child.props.children, option));
        } else {
          ret.push(child);
        }
      });
      return ret;
    }
    var warned$1 = {};
    var preMessage$1 = function preMessage2(fn) {
    };
    function warning$5(valid, message2) {
    }
    function note$1(valid, message2) {
    }
    function resetWarned$1() {
      warned$1 = {};
    }
    function call$1(method2, valid, message2) {
      if (!valid && !warned$1[message2]) {
        method2(false, message2);
        warned$1[message2] = true;
      }
    }
    function warningOnce$1(valid, message2) {
      call$1(warning$5, valid, message2);
    }
    function noteOnce$1(valid, message2) {
      call$1(note$1, valid, message2);
    }
    warningOnce$1.preMessage = preMessage$1;
    warningOnce$1.resetWarned = resetWarned$1;
    warningOnce$1.noteOnce = noteOnce$1;
    function toPrimitive$1(t2, r2) {
      if ("object" != _typeof$1(t2) || !t2) return t2;
      var e2 = t2[Symbol.toPrimitive];
      if (void 0 !== e2) {
        var i2 = e2.call(t2, r2);
        if ("object" != _typeof$1(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function toPropertyKey$1(t2) {
      var i2 = toPrimitive$1(t2, "string");
      return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
    }
    function _defineProperty(e2, r2, t2) {
      return (r2 = toPropertyKey$1(r2)) in e2 ? Object.defineProperty(e2, r2, {
        value: t2,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e2[r2] = t2, e2;
    }
    function ownKeys(e2, r2) {
      var t2 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(e2);
        r2 && (o2 = o2.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
        })), t2.push.apply(t2, o2);
      }
      return t2;
    }
    function _objectSpread2$3(e2) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
          _defineProperty(e2, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e2;
    }
    function isDOM(node2) {
      return node2 instanceof HTMLElement || node2 instanceof SVGElement;
    }
    function getDOM(node2) {
      if (node2 && _typeof$1(node2) === "object" && isDOM(node2.nativeElement)) {
        return node2.nativeElement;
      }
      if (isDOM(node2)) {
        return node2;
      }
      return null;
    }
    function findDOMNode(node2) {
      var domNode = getDOM(node2);
      if (domNode) {
        return domNode;
      }
      if (node2 instanceof i.Component) {
        var _ReactDOM$findDOMNode;
        return (_ReactDOM$findDOMNode = ReactDOM$1.findDOMNode) === null || _ReactDOM$findDOMNode === void 0 ? void 0 : _ReactDOM$findDOMNode.call(ReactDOM$1, node2);
      }
      return null;
    }
    var reactIs$2 = { exports: {} };
    var reactIs_production_min$1 = {};
    /**
     * @license React
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b$2 = Symbol.for("react.element"), c$1 = Symbol.for("react.portal"), d$2 = Symbol.for("react.fragment"), e$3 = Symbol.for("react.strict_mode"), f$2 = Symbol.for("react.profiler"), g$2 = Symbol.for("react.provider"), h$1 = Symbol.for("react.context"), k$2 = Symbol.for("react.server_context"), l$2 = Symbol.for("react.forward_ref"), m$1 = Symbol.for("react.suspense"), n$2 = Symbol.for("react.suspense_list"), p$2 = Symbol.for("react.memo"), q$2 = Symbol.for("react.lazy"), t$2 = Symbol.for("react.offscreen"), u$1;
    u$1 = Symbol.for("react.module.reference");
    function v$1(a) {
      if ("object" === typeof a && null !== a) {
        var r2 = a.$$typeof;
        switch (r2) {
          case b$2:
            switch (a = a.type, a) {
              case d$2:
              case f$2:
              case e$3:
              case m$1:
              case n$2:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k$2:
                  case h$1:
                  case l$2:
                  case q$2:
                  case p$2:
                  case g$2:
                    return a;
                  default:
                    return r2;
                }
            }
          case c$1:
            return r2;
        }
      }
    }
    reactIs_production_min$1.ContextConsumer = h$1;
    reactIs_production_min$1.ContextProvider = g$2;
    reactIs_production_min$1.Element = b$2;
    reactIs_production_min$1.ForwardRef = l$2;
    reactIs_production_min$1.Fragment = d$2;
    reactIs_production_min$1.Lazy = q$2;
    reactIs_production_min$1.Memo = p$2;
    reactIs_production_min$1.Portal = c$1;
    reactIs_production_min$1.Profiler = f$2;
    reactIs_production_min$1.StrictMode = e$3;
    reactIs_production_min$1.Suspense = m$1;
    reactIs_production_min$1.SuspenseList = n$2;
    reactIs_production_min$1.isAsyncMode = function() {
      return false;
    };
    reactIs_production_min$1.isConcurrentMode = function() {
      return false;
    };
    reactIs_production_min$1.isContextConsumer = function(a) {
      return v$1(a) === h$1;
    };
    reactIs_production_min$1.isContextProvider = function(a) {
      return v$1(a) === g$2;
    };
    reactIs_production_min$1.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === b$2;
    };
    reactIs_production_min$1.isForwardRef = function(a) {
      return v$1(a) === l$2;
    };
    reactIs_production_min$1.isFragment = function(a) {
      return v$1(a) === d$2;
    };
    reactIs_production_min$1.isLazy = function(a) {
      return v$1(a) === q$2;
    };
    reactIs_production_min$1.isMemo = function(a) {
      return v$1(a) === p$2;
    };
    reactIs_production_min$1.isPortal = function(a) {
      return v$1(a) === c$1;
    };
    reactIs_production_min$1.isProfiler = function(a) {
      return v$1(a) === f$2;
    };
    reactIs_production_min$1.isStrictMode = function(a) {
      return v$1(a) === e$3;
    };
    reactIs_production_min$1.isSuspense = function(a) {
      return v$1(a) === m$1;
    };
    reactIs_production_min$1.isSuspenseList = function(a) {
      return v$1(a) === n$2;
    };
    reactIs_production_min$1.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === d$2 || a === f$2 || a === e$3 || a === m$1 || a === n$2 || a === t$2 || "object" === typeof a && null !== a && (a.$$typeof === q$2 || a.$$typeof === p$2 || a.$$typeof === g$2 || a.$$typeof === h$1 || a.$$typeof === l$2 || a.$$typeof === u$1 || void 0 !== a.getModuleId) ? true : false;
    };
    reactIs_production_min$1.typeOf = v$1;
    {
      reactIs$2.exports = reactIs_production_min$1;
    }
    var reactIsExports$1 = reactIs$2.exports;
    function useMemo(getValue2, condition, shouldUpdate) {
      var cacheRef = reactExports.useRef({});
      if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
        cacheRef.current.value = getValue2();
        cacheRef.current.condition = condition;
      }
      return cacheRef.current.value;
    }
    var ReactMajorVersion = Number(reactExports.version.split(".")[0]);
    var fillRef = function fillRef2(ref, node2) {
      if (typeof ref === "function") {
        ref(node2);
      } else if (_typeof$1(ref) === "object" && ref && "current" in ref) {
        ref.current = node2;
      }
    };
    var composeRef = function composeRef2() {
      for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
        refs[_key] = arguments[_key];
      }
      var refList = refs.filter(Boolean);
      if (refList.length <= 1) {
        return refList[0];
      }
      return function(node2) {
        refs.forEach(function(ref) {
          fillRef(ref, node2);
        });
      };
    };
    var useComposeRef = function useComposeRef2() {
      for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        refs[_key2] = arguments[_key2];
      }
      return useMemo(function() {
        return composeRef.apply(void 0, refs);
      }, refs, function(prev2, next2) {
        return prev2.length !== next2.length || prev2.every(function(ref, i2) {
          return ref !== next2[i2];
        });
      });
    };
    var supportRef = function supportRef2(nodeOrComponent) {
      var _type$prototype, _nodeOrComponent$prot;
      if (!nodeOrComponent) {
        return false;
      }
      if (isReactElement$1(nodeOrComponent) && ReactMajorVersion >= 19) {
        return true;
      }
      var type2 = reactIsExports$1.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
      if (typeof type2 === "function" && !((_type$prototype = type2.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render) && type2.$$typeof !== reactIsExports$1.ForwardRef) {
        return false;
      }
      if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render) && nodeOrComponent.$$typeof !== reactIsExports$1.ForwardRef) {
        return false;
      }
      return true;
    };
    function isReactElement$1(node2) {
      return /* @__PURE__ */ reactExports.isValidElement(node2) && !isFragment$1(node2);
    }
    var getNodeRef = function getNodeRef2(node2) {
      if (node2 && isReactElement$1(node2)) {
        var ele = node2;
        return ele.props.propertyIsEnumerable("ref") ? ele.props.ref : ele.ref;
      }
      return null;
    };
    var CollectionContext = /* @__PURE__ */ reactExports.createContext(null);
    function Collection(_ref) {
      var children = _ref.children, onBatchResize = _ref.onBatchResize;
      var resizeIdRef = reactExports.useRef(0);
      var resizeInfosRef = reactExports.useRef([]);
      var onCollectionResize = reactExports.useContext(CollectionContext);
      var onResize2 = reactExports.useCallback(function(size, element, data) {
        resizeIdRef.current += 1;
        var currentId = resizeIdRef.current;
        resizeInfosRef.current.push({
          size,
          element,
          data
        });
        Promise.resolve().then(function() {
          if (currentId === resizeIdRef.current) {
            onBatchResize === null || onBatchResize === void 0 || onBatchResize(resizeInfosRef.current);
            resizeInfosRef.current = [];
          }
        });
        onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(size, element, data);
      }, [onBatchResize, onCollectionResize]);
      return /* @__PURE__ */ reactExports.createElement(CollectionContext.Provider, {
        value: onResize2
      }, children);
    }
    var MapShim = function() {
      if (typeof Map !== "undefined") {
        return Map;
      }
      function getIndex(arr, key) {
        var result = -1;
        arr.some(function(entry, index2) {
          if (entry[0] === key) {
            result = index2;
            return true;
          }
          return false;
        });
        return result;
      }
      return (
        /** @class */
        function() {
          function class_1() {
            this.__entries__ = [];
          }
          Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function() {
              return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
          });
          class_1.prototype.get = function(key) {
            var index2 = getIndex(this.__entries__, key);
            var entry = this.__entries__[index2];
            return entry && entry[1];
          };
          class_1.prototype.set = function(key, value) {
            var index2 = getIndex(this.__entries__, key);
            if (~index2) {
              this.__entries__[index2][1] = value;
            } else {
              this.__entries__.push([key, value]);
            }
          };
          class_1.prototype.delete = function(key) {
            var entries = this.__entries__;
            var index2 = getIndex(entries, key);
            if (~index2) {
              entries.splice(index2, 1);
            }
          };
          class_1.prototype.has = function(key) {
            return !!~getIndex(this.__entries__, key);
          };
          class_1.prototype.clear = function() {
            this.__entries__.splice(0);
          };
          class_1.prototype.forEach = function(callback, ctx) {
            if (ctx === void 0) {
              ctx = null;
            }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
              var entry = _a[_i];
              callback.call(ctx, entry[1], entry[0]);
            }
          };
          return class_1;
        }()
      );
    }();
    var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
    var global$1 = function() {
      if (typeof global !== "undefined" && global.Math === Math) {
        return global;
      }
      if (typeof self !== "undefined" && self.Math === Math) {
        return self;
      }
      if (typeof window !== "undefined" && window.Math === Math) {
        return window;
      }
      return Function("return this")();
    }();
    var requestAnimationFrame$1 = function() {
      if (typeof requestAnimationFrame === "function") {
        return requestAnimationFrame.bind(global$1);
      }
      return function(callback) {
        return setTimeout(function() {
          return callback(Date.now());
        }, 1e3 / 60);
      };
    }();
    var trailingTimeout = 2;
    function throttle$1(callback, delay) {
      var leadingCall = false, trailingCall = false, lastCallTime = 0;
      function resolvePending() {
        if (leadingCall) {
          leadingCall = false;
          callback();
        }
        if (trailingCall) {
          proxy();
        }
      }
      function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
      }
      function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
          if (timeStamp - lastCallTime < trailingTimeout) {
            return;
          }
          trailingCall = true;
        } else {
          leadingCall = true;
          trailingCall = false;
          setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
      }
      return proxy;
    }
    var REFRESH_DELAY = 20;
    var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
    var mutationObserverSupported = typeof MutationObserver !== "undefined";
    var ResizeObserverController = (
      /** @class */
      function() {
        function ResizeObserverController2() {
          this.connected_ = false;
          this.mutationEventsAdded_ = false;
          this.mutationsObserver_ = null;
          this.observers_ = [];
          this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
          this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
        }
        ResizeObserverController2.prototype.addObserver = function(observer) {
          if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
          }
          if (!this.connected_) {
            this.connect_();
          }
        };
        ResizeObserverController2.prototype.removeObserver = function(observer) {
          var observers2 = this.observers_;
          var index2 = observers2.indexOf(observer);
          if (~index2) {
            observers2.splice(index2, 1);
          }
          if (!observers2.length && this.connected_) {
            this.disconnect_();
          }
        };
        ResizeObserverController2.prototype.refresh = function() {
          var changesDetected = this.updateObservers_();
          if (changesDetected) {
            this.refresh();
          }
        };
        ResizeObserverController2.prototype.updateObservers_ = function() {
          var activeObservers = this.observers_.filter(function(observer) {
            return observer.gatherActive(), observer.hasActive();
          });
          activeObservers.forEach(function(observer) {
            return observer.broadcastActive();
          });
          return activeObservers.length > 0;
        };
        ResizeObserverController2.prototype.connect_ = function() {
          if (!isBrowser || this.connected_) {
            return;
          }
          document.addEventListener("transitionend", this.onTransitionEnd_);
          window.addEventListener("resize", this.refresh);
          if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });
          } else {
            document.addEventListener("DOMSubtreeModified", this.refresh);
            this.mutationEventsAdded_ = true;
          }
          this.connected_ = true;
        };
        ResizeObserverController2.prototype.disconnect_ = function() {
          if (!isBrowser || !this.connected_) {
            return;
          }
          document.removeEventListener("transitionend", this.onTransitionEnd_);
          window.removeEventListener("resize", this.refresh);
          if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
          }
          if (this.mutationEventsAdded_) {
            document.removeEventListener("DOMSubtreeModified", this.refresh);
          }
          this.mutationsObserver_ = null;
          this.mutationEventsAdded_ = false;
          this.connected_ = false;
        };
        ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
          var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
          var isReflowProperty = transitionKeys.some(function(key) {
            return !!~propertyName.indexOf(key);
          });
          if (isReflowProperty) {
            this.refresh();
          }
        };
        ResizeObserverController2.getInstance = function() {
          if (!this.instance_) {
            this.instance_ = new ResizeObserverController2();
          }
          return this.instance_;
        };
        ResizeObserverController2.instance_ = null;
        return ResizeObserverController2;
      }()
    );
    var defineConfigurable = function(target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
          value: props[key],
          enumerable: false,
          writable: false,
          configurable: true
        });
      }
      return target;
    };
    var getWindowOf = function(target) {
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      return ownerGlobal || global$1;
    };
    var emptyRect = createRectInit(0, 0, 0, 0);
    function toFloat(value) {
      return parseFloat(value) || 0;
    }
    function getBordersSize(styles) {
      var positions = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
      }
      return positions.reduce(function(size, position2) {
        var value = styles["border-" + position2 + "-width"];
        return size + toFloat(value);
      }, 0);
    }
    function getPaddings(styles) {
      var positions = ["top", "right", "bottom", "left"];
      var paddings = {};
      for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position2 = positions_1[_i];
        var value = styles["padding-" + position2];
        paddings[position2] = toFloat(value);
      }
      return paddings;
    }
    function getSVGContentRect(target) {
      var bbox = target.getBBox();
      return createRectInit(0, 0, bbox.width, bbox.height);
    }
    function getHTMLElementContentRect(target) {
      var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
      if (!clientWidth && !clientHeight) {
        return emptyRect;
      }
      var styles = getWindowOf(target).getComputedStyle(target);
      var paddings = getPaddings(styles);
      var horizPad = paddings.left + paddings.right;
      var vertPad = paddings.top + paddings.bottom;
      var width = toFloat(styles.width), height = toFloat(styles.height);
      if (styles.boxSizing === "border-box") {
        if (Math.round(width + horizPad) !== clientWidth) {
          width -= getBordersSize(styles, "left", "right") + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
          height -= getBordersSize(styles, "top", "bottom") + vertPad;
        }
      }
      if (!isDocumentElement(target)) {
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        if (Math.abs(vertScrollbar) !== 1) {
          width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
          height -= horizScrollbar;
        }
      }
      return createRectInit(paddings.left, paddings.top, width, height);
    }
    var isSVGGraphicsElement = function() {
      if (typeof SVGGraphicsElement !== "undefined") {
        return function(target) {
          return target instanceof getWindowOf(target).SVGGraphicsElement;
        };
      }
      return function(target) {
        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
      };
    }();
    function isDocumentElement(target) {
      return target === getWindowOf(target).document.documentElement;
    }
    function getContentRect(target) {
      if (!isBrowser) {
        return emptyRect;
      }
      if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
      }
      return getHTMLElementContentRect(target);
    }
    function createReadOnlyRect(_a) {
      var x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
      var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
      var rect = Object.create(Constr.prototype);
      defineConfigurable(rect, {
        x: x2,
        y: y2,
        width,
        height,
        top: y2,
        right: x2 + width,
        bottom: height + y2,
        left: x2
      });
      return rect;
    }
    function createRectInit(x2, y2, width, height) {
      return { x: x2, y: y2, width, height };
    }
    var ResizeObservation = (
      /** @class */
      function() {
        function ResizeObservation2(target) {
          this.broadcastWidth = 0;
          this.broadcastHeight = 0;
          this.contentRect_ = createRectInit(0, 0, 0, 0);
          this.target = target;
        }
        ResizeObservation2.prototype.isActive = function() {
          var rect = getContentRect(this.target);
          this.contentRect_ = rect;
          return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
        };
        ResizeObservation2.prototype.broadcastRect = function() {
          var rect = this.contentRect_;
          this.broadcastWidth = rect.width;
          this.broadcastHeight = rect.height;
          return rect;
        };
        return ResizeObservation2;
      }()
    );
    var ResizeObserverEntry = (
      /** @class */
      /* @__PURE__ */ function() {
        function ResizeObserverEntry2(target, rectInit) {
          var contentRect = createReadOnlyRect(rectInit);
          defineConfigurable(this, { target, contentRect });
        }
        return ResizeObserverEntry2;
      }()
    );
    var ResizeObserverSPI = (
      /** @class */
      function() {
        function ResizeObserverSPI2(callback, controller, callbackCtx) {
          this.activeObservations_ = [];
          this.observations_ = new MapShim();
          if (typeof callback !== "function") {
            throw new TypeError("The callback provided as parameter 1 is not a function.");
          }
          this.callback_ = callback;
          this.controller_ = controller;
          this.callbackCtx_ = callbackCtx;
        }
        ResizeObserverSPI2.prototype.observe = function(target) {
          if (!arguments.length) {
            throw new TypeError("1 argument required, but only 0 present.");
          }
          if (typeof Element === "undefined" || !(Element instanceof Object)) {
            return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          if (observations.has(target)) {
            return;
          }
          observations.set(target, new ResizeObservation(target));
          this.controller_.addObserver(this);
          this.controller_.refresh();
        };
        ResizeObserverSPI2.prototype.unobserve = function(target) {
          if (!arguments.length) {
            throw new TypeError("1 argument required, but only 0 present.");
          }
          if (typeof Element === "undefined" || !(Element instanceof Object)) {
            return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          if (!observations.has(target)) {
            return;
          }
          observations.delete(target);
          if (!observations.size) {
            this.controller_.removeObserver(this);
          }
        };
        ResizeObserverSPI2.prototype.disconnect = function() {
          this.clearActive();
          this.observations_.clear();
          this.controller_.removeObserver(this);
        };
        ResizeObserverSPI2.prototype.gatherActive = function() {
          var _this = this;
          this.clearActive();
          this.observations_.forEach(function(observation) {
            if (observation.isActive()) {
              _this.activeObservations_.push(observation);
            }
          });
        };
        ResizeObserverSPI2.prototype.broadcastActive = function() {
          if (!this.hasActive()) {
            return;
          }
          var ctx = this.callbackCtx_;
          var entries = this.activeObservations_.map(function(observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
          });
          this.callback_.call(ctx, entries, ctx);
          this.clearActive();
        };
        ResizeObserverSPI2.prototype.clearActive = function() {
          this.activeObservations_.splice(0);
        };
        ResizeObserverSPI2.prototype.hasActive = function() {
          return this.activeObservations_.length > 0;
        };
        return ResizeObserverSPI2;
      }()
    );
    var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
    var ResizeObserver$2 = (
      /** @class */
      /* @__PURE__ */ function() {
        function ResizeObserver2(callback) {
          if (!(this instanceof ResizeObserver2)) {
            throw new TypeError("Cannot call a class as a function.");
          }
          if (!arguments.length) {
            throw new TypeError("1 argument required, but only 0 present.");
          }
          var controller = ResizeObserverController.getInstance();
          var observer = new ResizeObserverSPI(callback, controller, this);
          observers.set(this, observer);
        }
        return ResizeObserver2;
      }()
    );
    [
      "observe",
      "unobserve",
      "disconnect"
    ].forEach(function(method2) {
      ResizeObserver$2.prototype[method2] = function() {
        var _a;
        return (_a = observers.get(this))[method2].apply(_a, arguments);
      };
    });
    var index = function() {
      if (typeof global$1.ResizeObserver !== "undefined") {
        return global$1.ResizeObserver;
      }
      return ResizeObserver$2;
    }();
    var elementListeners = /* @__PURE__ */ new Map();
    function onResize(entities) {
      entities.forEach(function(entity) {
        var _elementListeners$get;
        var target = entity.target;
        (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 || _elementListeners$get.forEach(function(listener) {
          return listener(target);
        });
      });
    }
    var resizeObserver = new index(onResize);
    function observe(element, callback) {
      if (!elementListeners.has(element)) {
        elementListeners.set(element, /* @__PURE__ */ new Set());
        resizeObserver.observe(element);
      }
      elementListeners.get(element).add(callback);
    }
    function unobserve(element, callback) {
      if (elementListeners.has(element)) {
        elementListeners.get(element).delete(callback);
        if (!elementListeners.get(element).size) {
          resizeObserver.unobserve(element);
          elementListeners.delete(element);
        }
      }
    }
    function _classCallCheck(a, n2) {
      if (!(a instanceof n2)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e2, r2) {
      for (var t2 = 0; t2 < r2.length; t2++) {
        var o2 = r2[t2];
        o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, toPropertyKey$1(o2.key), o2);
      }
    }
    function _createClass(e2, r2, t2) {
      return r2 && _defineProperties(e2.prototype, r2), t2 && _defineProperties(e2, t2), Object.defineProperty(e2, "prototype", {
        writable: false
      }), e2;
    }
    function _setPrototypeOf(t2, e2) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
        return t3.__proto__ = e3, t3;
      }, _setPrototypeOf(t2, e2);
    }
    function _inherits(t2, e2) {
      if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
      t2.prototype = Object.create(e2 && e2.prototype, {
        constructor: {
          value: t2,
          writable: true,
          configurable: true
        }
      }), Object.defineProperty(t2, "prototype", {
        writable: false
      }), e2 && _setPrototypeOf(t2, e2);
    }
    function _getPrototypeOf(t2) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
        return t3.__proto__ || Object.getPrototypeOf(t3);
      }, _getPrototypeOf(t2);
    }
    function _isNativeReflectConstruct() {
      try {
        var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t3) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t2;
      })();
    }
    function _assertThisInitialized(e2) {
      if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e2;
    }
    function _possibleConstructorReturn(t2, e2) {
      if (e2 && ("object" == _typeof$1(e2) || "function" == typeof e2)) return e2;
      if (void 0 !== e2) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t2);
    }
    function _createSuper(t2) {
      var r2 = _isNativeReflectConstruct();
      return function() {
        var e2, o2 = _getPrototypeOf(t2);
        if (r2) {
          var s = _getPrototypeOf(this).constructor;
          e2 = Reflect.construct(o2, arguments, s);
        } else e2 = o2.apply(this, arguments);
        return _possibleConstructorReturn(this, e2);
      };
    }
    var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
      _inherits(DomWrapper2, _React$Component);
      var _super = _createSuper(DomWrapper2);
      function DomWrapper2() {
        _classCallCheck(this, DomWrapper2);
        return _super.apply(this, arguments);
      }
      _createClass(DomWrapper2, [{
        key: "render",
        value: function render2() {
          return this.props.children;
        }
      }]);
      return DomWrapper2;
    }(reactExports.Component);
    function SingleObserver(props, ref) {
      var children = props.children, disabled = props.disabled;
      var elementRef = reactExports.useRef(null);
      var wrapperRef = reactExports.useRef(null);
      var onCollectionResize = reactExports.useContext(CollectionContext);
      var isRenderProps = typeof children === "function";
      var mergedChildren = isRenderProps ? children(elementRef) : children;
      var sizeRef = reactExports.useRef({
        width: -1,
        height: -1,
        offsetWidth: -1,
        offsetHeight: -1
      });
      var canRef = !isRenderProps && /* @__PURE__ */ reactExports.isValidElement(mergedChildren) && supportRef(mergedChildren);
      var originRef = canRef ? getNodeRef(mergedChildren) : null;
      var mergedRef = useComposeRef(originRef, elementRef);
      var getDom = function getDom2() {
        var _elementRef$current;
        return findDOMNode(elementRef.current) || // Support `nativeElement` format
        (elementRef.current && _typeof$1(elementRef.current) === "object" ? findDOMNode((_elementRef$current = elementRef.current) === null || _elementRef$current === void 0 ? void 0 : _elementRef$current.nativeElement) : null) || findDOMNode(wrapperRef.current);
      };
      reactExports.useImperativeHandle(ref, function() {
        return getDom();
      });
      var propsRef = reactExports.useRef(props);
      propsRef.current = props;
      var onInternalResize = reactExports.useCallback(function(target) {
        var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data = _propsRef$current.data;
        var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
        var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
        var fixedWidth = Math.floor(width);
        var fixedHeight = Math.floor(height);
        if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
          var size = {
            width: fixedWidth,
            height: fixedHeight,
            offsetWidth,
            offsetHeight
          };
          sizeRef.current = size;
          var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
          var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
          var sizeInfo = _objectSpread2$3(_objectSpread2$3({}, size), {}, {
            offsetWidth: mergedOffsetWidth,
            offsetHeight: mergedOffsetHeight
          });
          onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(sizeInfo, target, data);
          if (onResize2) {
            Promise.resolve().then(function() {
              onResize2(sizeInfo, target);
            });
          }
        }
      }, []);
      reactExports.useEffect(function() {
        var currentElement = getDom();
        if (currentElement && !disabled) {
          observe(currentElement, onInternalResize);
        }
        return function() {
          return unobserve(currentElement, onInternalResize);
        };
      }, [elementRef.current, disabled]);
      return /* @__PURE__ */ reactExports.createElement(DomWrapper$1, {
        ref: wrapperRef
      }, canRef ? /* @__PURE__ */ reactExports.cloneElement(mergedChildren, {
        ref: mergedRef
      }) : mergedChildren);
    }
    var RefSingleObserver = /* @__PURE__ */ reactExports.forwardRef(SingleObserver);
    var INTERNAL_PREFIX_KEY = "rc-observer-key";
    function ResizeObserver$1(props, ref) {
      var children = props.children;
      var childNodes = typeof children === "function" ? [children] : toArray$5(children);
      return childNodes.map(function(child, index2) {
        var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
        return /* @__PURE__ */ reactExports.createElement(RefSingleObserver, _extends$2({}, props, {
          key,
          ref: index2 === 0 ? ref : void 0
        }), child);
      });
    }
    var RefResizeObserver = /* @__PURE__ */ reactExports.forwardRef(ResizeObserver$1);
    RefResizeObserver.Collection = Collection;
    function _arrayLikeToArray(r2, a) {
      (null == a || a > r2.length) && (a = r2.length);
      for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r2[e2];
      return n2;
    }
    function _arrayWithoutHoles(r2) {
      if (Array.isArray(r2)) return _arrayLikeToArray(r2);
    }
    function _iterableToArray(r2) {
      if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
    }
    function _unsupportedIterableToArray(r2, a) {
      if (r2) {
        if ("string" == typeof r2) return _arrayLikeToArray(r2, a);
        var t2 = {}.toString.call(r2).slice(8, -1);
        return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a) : void 0;
      }
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray(r2) {
      return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
    }
    var raf = function raf2(callback) {
      return +setTimeout(callback, 16);
    };
    var caf = function caf2(num) {
      return clearTimeout(num);
    };
    if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
      raf = function raf3(callback) {
        return window.requestAnimationFrame(callback);
      };
      caf = function caf3(handle) {
        return window.cancelAnimationFrame(handle);
      };
    }
    var rafUUID = 0;
    var rafIds = /* @__PURE__ */ new Map();
    function cleanup(id) {
      rafIds.delete(id);
    }
    var wrapperRaf = function wrapperRaf2(callback) {
      var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      rafUUID += 1;
      var id = rafUUID;
      function callRef(leftTimes) {
        if (leftTimes === 0) {
          cleanup(id);
          callback();
        } else {
          var realId = raf(function() {
            callRef(leftTimes - 1);
          });
          rafIds.set(id, realId);
        }
      }
      callRef(times);
      return id;
    };
    wrapperRaf.cancel = function(id) {
      var realId = rafIds.get(id);
      cleanup(id);
      return caf(realId);
    };
    function throttleByAnimationFrame(fn) {
      let requestId;
      const later = (args) => () => {
        requestId = null;
        fn.apply(void 0, _toConsumableArray(args));
      };
      const throttled = function() {
        if (requestId == null) {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          requestId = wrapperRaf(later(args));
        }
      };
      throttled.cancel = () => {
        wrapperRaf.cancel(requestId);
        requestId = null;
      };
      return throttled;
    }
    function _arrayWithHoles(r2) {
      if (Array.isArray(r2)) return r2;
    }
    function _iterableToArrayLimit(r2, l2) {
      var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t2) {
        var e2, n2, i2, u2, a = [], f2 = true, o2 = false;
        try {
          if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
            if (Object(t2) !== t2) return;
            f2 = false;
          } else for (; !(f2 = (e2 = i2.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true) ;
        } catch (r3) {
          o2 = true, n2 = r3;
        } finally {
          try {
            if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
          } finally {
            if (o2) throw n2;
          }
        }
        return a;
      }
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _slicedToArray(r2, e2) {
      return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
    }
    function murmur2(str) {
      var h2 = 0;
      var k2, i2 = 0, len = str.length;
      for (; len >= 4; ++i2, len -= 4) {
        k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
        k2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
        k2 ^= /* k >>> r: */
        k2 >>> 24;
        h2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i2) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    function canUseDom$2() {
      return !!(typeof window !== "undefined" && window.document && window.document.createElement);
    }
    function contains$2(root2, n2) {
      if (!root2) {
        return false;
      }
      if (root2.contains) {
        return root2.contains(n2);
      }
      var node2 = n2;
      while (node2) {
        if (node2 === root2) {
          return true;
        }
        node2 = node2.parentNode;
      }
      return false;
    }
    var APPEND_ORDER$1 = "data-rc-order";
    var APPEND_PRIORITY$1 = "data-rc-priority";
    var MARK_KEY$1 = "rc-util-key";
    var containerCache$1 = /* @__PURE__ */ new Map();
    function getMark$1() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
      if (mark) {
        return mark.startsWith("data-") ? mark : "data-".concat(mark);
      }
      return MARK_KEY$1;
    }
    function getContainer$1(option) {
      if (option.attachTo) {
        return option.attachTo;
      }
      var head = document.querySelector("head");
      return head || document.body;
    }
    function getOrder$1(prepend) {
      if (prepend === "queue") {
        return "prependQueue";
      }
      return prepend ? "prepend" : "append";
    }
    function findStyles$1(container) {
      return Array.from((containerCache$1.get(container) || container).children).filter(function(node2) {
        return node2.tagName === "STYLE";
      });
    }
    function injectCSS$1(css) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!canUseDom$2()) {
        return null;
      }
      var csp = option.csp, prepend = option.prepend, _option$priority = option.priority, priority = _option$priority === void 0 ? 0 : _option$priority;
      var mergedOrder = getOrder$1(prepend);
      var isPrependQueue = mergedOrder === "prependQueue";
      var styleNode = document.createElement("style");
      styleNode.setAttribute(APPEND_ORDER$1, mergedOrder);
      if (isPrependQueue && priority) {
        styleNode.setAttribute(APPEND_PRIORITY$1, "".concat(priority));
      }
      if (csp !== null && csp !== void 0 && csp.nonce) {
        styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
      }
      styleNode.innerHTML = css;
      var container = getContainer$1(option);
      var firstChild = container.firstChild;
      if (prepend) {
        if (isPrependQueue) {
          var existStyle = (option.styles || findStyles$1(container)).filter(function(node2) {
            if (!["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER$1))) {
              return false;
            }
            var nodePriority = Number(node2.getAttribute(APPEND_PRIORITY$1) || 0);
            return priority >= nodePriority;
          });
          if (existStyle.length) {
            container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
            return styleNode;
          }
        }
        container.insertBefore(styleNode, firstChild);
      } else {
        container.appendChild(styleNode);
      }
      return styleNode;
    }
    function findExistNode$1(key) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var container = getContainer$1(option);
      return (option.styles || findStyles$1(container)).find(function(node2) {
        return node2.getAttribute(getMark$1(option)) === key;
      });
    }
    function removeCSS$1(key) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var existNode = findExistNode$1(key, option);
      if (existNode) {
        var container = getContainer$1(option);
        container.removeChild(existNode);
      }
    }
    function syncRealContainer$1(container, option) {
      var cachedRealContainer = containerCache$1.get(container);
      if (!cachedRealContainer || !contains$2(document, cachedRealContainer)) {
        var placeholderStyle = injectCSS$1("", option);
        var parentNode = placeholderStyle.parentNode;
        containerCache$1.set(container, parentNode);
        container.removeChild(placeholderStyle);
      }
    }
    function updateCSS$1(css, key) {
      var originOption = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var container = getContainer$1(originOption);
      var styles = findStyles$1(container);
      var option = _objectSpread2$3(_objectSpread2$3({}, originOption), {}, {
        styles
      });
      syncRealContainer$1(container, option);
      var existNode = findExistNode$1(key, option);
      if (existNode) {
        var _option$csp, _option$csp2;
        if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
          var _option$csp3;
          existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
        }
        if (existNode.innerHTML !== css) {
          existNode.innerHTML = css;
        }
        return existNode;
      }
      var newNode = injectCSS$1(css, option);
      newNode.setAttribute(getMark$1(option), key);
      return newNode;
    }
    function _objectWithoutPropertiesLoose$1(r2, e2) {
      if (null == r2) return {};
      var t2 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (-1 !== e2.indexOf(n2)) continue;
        t2[n2] = r2[n2];
      }
      return t2;
    }
    function _objectWithoutProperties(e2, t2) {
      if (null == e2) return {};
      var o2, r2, i2 = _objectWithoutPropertiesLoose$1(e2, t2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e2, o2) && (i2[o2] = e2[o2]);
      }
      return i2;
    }
    function isEqual$1(obj1, obj2) {
      var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var refSet = /* @__PURE__ */ new Set();
      function deepEqual(a, b2) {
        var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        var circular = refSet.has(a);
        warningOnce$1(!circular, "Warning: There may be circular references");
        if (circular) {
          return false;
        }
        if (a === b2) {
          return true;
        }
        if (shallow && level > 1) {
          return false;
        }
        refSet.add(a);
        var newLevel = level + 1;
        if (Array.isArray(a)) {
          if (!Array.isArray(b2) || a.length !== b2.length) {
            return false;
          }
          for (var i2 = 0; i2 < a.length; i2++) {
            if (!deepEqual(a[i2], b2[i2], newLevel)) {
              return false;
            }
          }
          return true;
        }
        if (a && b2 && _typeof$1(a) === "object" && _typeof$1(b2) === "object") {
          var keys2 = Object.keys(a);
          if (keys2.length !== Object.keys(b2).length) {
            return false;
          }
          return keys2.every(function(key) {
            return deepEqual(a[key], b2[key], newLevel);
          });
        }
        return false;
      }
      return deepEqual(obj1, obj2);
    }
    var SPLIT$1 = "%";
    function pathKey(keys2) {
      return keys2.join(SPLIT$1);
    }
    var Entity = /* @__PURE__ */ function() {
      function Entity2(instanceId) {
        _classCallCheck(this, Entity2);
        _defineProperty(this, "instanceId", void 0);
        _defineProperty(this, "cache", /* @__PURE__ */ new Map());
        this.instanceId = instanceId;
      }
      _createClass(Entity2, [{
        key: "get",
        value: function get2(keys2) {
          return this.opGet(pathKey(keys2));
        }
        /** A fast get cache with `get` concat. */
      }, {
        key: "opGet",
        value: function opGet(keyPathStr) {
          return this.cache.get(keyPathStr) || null;
        }
      }, {
        key: "update",
        value: function update(keys2, valueFn) {
          return this.opUpdate(pathKey(keys2), valueFn);
        }
        /** A fast get cache with `get` concat. */
      }, {
        key: "opUpdate",
        value: function opUpdate(keyPathStr, valueFn) {
          var prevValue = this.cache.get(keyPathStr);
          var nextValue = valueFn(prevValue);
          if (nextValue === null) {
            this.cache.delete(keyPathStr);
          } else {
            this.cache.set(keyPathStr, nextValue);
          }
        }
      }]);
      return Entity2;
    }();
    var ATTR_TOKEN = "data-token-hash";
    var ATTR_MARK = "data-css-hash";
    var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
    function createCache() {
      var cssinjsInstanceId = Math.random().toString(12).slice(2);
      if (typeof document !== "undefined" && document.head && document.body) {
        var styles = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
        var firstChild = document.head.firstChild;
        Array.from(styles).forEach(function(style2) {
          style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
          if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
            document.head.insertBefore(style2, firstChild);
          }
        });
        var styleHash = {};
        Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(style2) {
          var hash = style2.getAttribute(ATTR_MARK);
          if (styleHash[hash]) {
            if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
              var _style$parentNode;
              (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style2);
            }
          } else {
            styleHash[hash] = true;
          }
        });
      }
      return new Entity(cssinjsInstanceId);
    }
    var StyleContext = /* @__PURE__ */ reactExports.createContext({
      hashPriority: "low",
      cache: createCache(),
      defaultCache: true
    });
    function sameDerivativeOption(left, right) {
      if (left.length !== right.length) {
        return false;
      }
      for (var i2 = 0; i2 < left.length; i2++) {
        if (left[i2] !== right[i2]) {
          return false;
        }
      }
      return true;
    }
    var ThemeCache = /* @__PURE__ */ function() {
      function ThemeCache2() {
        _classCallCheck(this, ThemeCache2);
        _defineProperty(this, "cache", void 0);
        _defineProperty(this, "keys", void 0);
        _defineProperty(this, "cacheCallTimes", void 0);
        this.cache = /* @__PURE__ */ new Map();
        this.keys = [];
        this.cacheCallTimes = 0;
      }
      _createClass(ThemeCache2, [{
        key: "size",
        value: function size() {
          return this.keys.length;
        }
      }, {
        key: "internalGet",
        value: function internalGet(derivativeOption) {
          var _cache2, _cache3;
          var updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var cache = {
            map: this.cache
          };
          derivativeOption.forEach(function(derivative2) {
            if (!cache) {
              cache = void 0;
            } else {
              var _cache;
              cache = (_cache = cache) === null || _cache === void 0 || (_cache = _cache.map) === null || _cache === void 0 ? void 0 : _cache.get(derivative2);
            }
          });
          if ((_cache2 = cache) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) {
            cache.value[1] = this.cacheCallTimes++;
          }
          return (_cache3 = cache) === null || _cache3 === void 0 ? void 0 : _cache3.value;
        }
      }, {
        key: "get",
        value: function get2(derivativeOption) {
          var _this$internalGet;
          return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
        }
      }, {
        key: "has",
        value: function has(derivativeOption) {
          return !!this.internalGet(derivativeOption);
        }
      }, {
        key: "set",
        value: function set2(derivativeOption, value) {
          var _this = this;
          if (!this.has(derivativeOption)) {
            if (this.size() + 1 > ThemeCache2.MAX_CACHE_SIZE + ThemeCache2.MAX_CACHE_OFFSET) {
              var _this$keys$reduce = this.keys.reduce(function(result, key) {
                var _result = _slicedToArray(result, 2), callTimes = _result[1];
                if (_this.internalGet(key)[1] < callTimes) {
                  return [key, _this.internalGet(key)[1]];
                }
                return result;
              }, [this.keys[0], this.cacheCallTimes]), _this$keys$reduce2 = _slicedToArray(_this$keys$reduce, 1), targetKey = _this$keys$reduce2[0];
              this.delete(targetKey);
            }
            this.keys.push(derivativeOption);
          }
          var cache = this.cache;
          derivativeOption.forEach(function(derivative2, index2) {
            if (index2 === derivativeOption.length - 1) {
              cache.set(derivative2, {
                value: [value, _this.cacheCallTimes++]
              });
            } else {
              var cacheValue = cache.get(derivative2);
              if (!cacheValue) {
                cache.set(derivative2, {
                  map: /* @__PURE__ */ new Map()
                });
              } else if (!cacheValue.map) {
                cacheValue.map = /* @__PURE__ */ new Map();
              }
              cache = cache.get(derivative2).map;
            }
          });
        }
      }, {
        key: "deleteByPath",
        value: function deleteByPath(currentCache, derivatives) {
          var cache = currentCache.get(derivatives[0]);
          if (derivatives.length === 1) {
            var _cache$value;
            if (!cache.map) {
              currentCache.delete(derivatives[0]);
            } else {
              currentCache.set(derivatives[0], {
                map: cache.map
              });
            }
            return (_cache$value = cache.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
          }
          var result = this.deleteByPath(cache.map, derivatives.slice(1));
          if ((!cache.map || cache.map.size === 0) && !cache.value) {
            currentCache.delete(derivatives[0]);
          }
          return result;
        }
      }, {
        key: "delete",
        value: function _delete(derivativeOption) {
          if (this.has(derivativeOption)) {
            this.keys = this.keys.filter(function(item) {
              return !sameDerivativeOption(item, derivativeOption);
            });
            return this.deleteByPath(this.cache, derivativeOption);
          }
          return void 0;
        }
      }]);
      return ThemeCache2;
    }();
    _defineProperty(ThemeCache, "MAX_CACHE_SIZE", 20);
    _defineProperty(ThemeCache, "MAX_CACHE_OFFSET", 5);
    var uuid$5 = 0;
    var Theme = /* @__PURE__ */ function() {
      function Theme2(derivatives) {
        _classCallCheck(this, Theme2);
        _defineProperty(this, "derivatives", void 0);
        _defineProperty(this, "id", void 0);
        this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
        this.id = uuid$5;
        if (derivatives.length === 0) {
          warning$5(derivatives.length > 0);
        }
        uuid$5 += 1;
      }
      _createClass(Theme2, [{
        key: "getDerivativeToken",
        value: function getDerivativeToken(token2) {
          return this.derivatives.reduce(function(result, derivative2) {
            return derivative2(token2, result);
          }, void 0);
        }
      }]);
      return Theme2;
    }();
    var cacheThemes = new ThemeCache();
    function createTheme(derivatives) {
      var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
      if (!cacheThemes.has(derivativeArr)) {
        cacheThemes.set(derivativeArr, new Theme(derivativeArr));
      }
      return cacheThemes.get(derivativeArr);
    }
    var resultCache = /* @__PURE__ */ new WeakMap();
    var RESULT_VALUE = {};
    function memoResult(callback, deps) {
      var current = resultCache;
      for (var i2 = 0; i2 < deps.length; i2 += 1) {
        var dep = deps[i2];
        if (!current.has(dep)) {
          current.set(dep, /* @__PURE__ */ new WeakMap());
        }
        current = current.get(dep);
      }
      if (!current.has(RESULT_VALUE)) {
        current.set(RESULT_VALUE, callback());
      }
      return current.get(RESULT_VALUE);
    }
    var flattenTokenCache = /* @__PURE__ */ new WeakMap();
    function flattenToken(token2) {
      var str = flattenTokenCache.get(token2) || "";
      if (!str) {
        Object.keys(token2).forEach(function(key) {
          var value = token2[key];
          str += key;
          if (value instanceof Theme) {
            str += value.id;
          } else if (value && _typeof$1(value) === "object") {
            str += flattenToken(value);
          } else {
            str += value;
          }
        });
        str = murmur2(str);
        flattenTokenCache.set(token2, str);
      }
      return str;
    }
    function token2key(token2, salt) {
      return murmur2("".concat(salt, "_").concat(flattenToken(token2)));
    }
    var isClientSide = canUseDom$2();
    function unit$1(num) {
      if (typeof num === "number") {
        return "".concat(num, "px");
      }
      return num;
    }
    function toStyleStr(style2, tokenKey, styleId) {
      var _objectSpread22;
      var customizeAttrs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var plain = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      if (plain) {
        return style2;
      }
      var attrs = _objectSpread2$3(_objectSpread2$3({}, customizeAttrs), {}, (_objectSpread22 = {}, _defineProperty(_objectSpread22, ATTR_TOKEN, tokenKey), _defineProperty(_objectSpread22, ATTR_MARK, styleId), _objectSpread22));
      var attrStr = Object.keys(attrs).map(function(attr) {
        var val = attrs[attr];
        return val ? "".concat(attr, '="').concat(val, '"') : null;
      }).filter(function(v2) {
        return v2;
      }).join(" ");
      return "<style ".concat(attrStr, ">").concat(style2, "</style>");
    }
    var token2CSSVar = function token2CSSVar2(token2) {
      var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      return "--".concat(prefix2 ? "".concat(prefix2, "-") : "").concat(token2).replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
    };
    var serializeCSSVar = function serializeCSSVar2(cssVars, hashId, options2) {
      if (!Object.keys(cssVars).length) {
        return "";
      }
      return ".".concat(hashId).concat(options2 !== null && options2 !== void 0 && options2.scope ? ".".concat(options2.scope) : "", "{").concat(Object.entries(cssVars).map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
        return "".concat(key, ":").concat(value, ";");
      }).join(""), "}");
    };
    var transformToken = function transformToken2(token2, themeKey, config) {
      var cssVars = {};
      var result = {};
      Object.entries(token2).forEach(function(_ref3) {
        var _config$preserve, _config$ignore;
        var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], value = _ref4[1];
        if (config !== null && config !== void 0 && (_config$preserve = config.preserve) !== null && _config$preserve !== void 0 && _config$preserve[key]) {
          result[key] = value;
        } else if ((typeof value === "string" || typeof value === "number") && !(config !== null && config !== void 0 && (_config$ignore = config.ignore) !== null && _config$ignore !== void 0 && _config$ignore[key])) {
          var _config$unitless;
          var cssVar = token2CSSVar(key, config === null || config === void 0 ? void 0 : config.prefix);
          cssVars[cssVar] = typeof value === "number" && !(config !== null && config !== void 0 && (_config$unitless = config.unitless) !== null && _config$unitless !== void 0 && _config$unitless[key]) ? "".concat(value, "px") : String(value);
          result[key] = "var(".concat(cssVar, ")");
        }
      });
      return [result, serializeCSSVar(cssVars, themeKey, {
        scope: config === null || config === void 0 ? void 0 : config.scope
      })];
    };
    var useInternalLayoutEffect = canUseDom$2() ? reactExports.useLayoutEffect : reactExports.useEffect;
    var useLayoutEffect$1 = function useLayoutEffect2(callback, deps) {
      var firstMountRef = reactExports.useRef(true);
      useInternalLayoutEffect(function() {
        return callback(firstMountRef.current);
      }, deps);
      useInternalLayoutEffect(function() {
        firstMountRef.current = false;
        return function() {
          firstMountRef.current = true;
        };
      }, []);
    };
    var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
      useLayoutEffect$1(function(firstMount) {
        if (!firstMount) {
          return callback();
        }
      }, deps);
    };
    var fullClone$3 = _objectSpread2$3({}, React$5);
    var useInsertionEffect$1 = fullClone$3.useInsertionEffect;
    var useInsertionEffectPolyfill = function useInsertionEffectPolyfill2(renderEffect, effect, deps) {
      reactExports.useMemo(renderEffect, deps);
      useLayoutEffect$1(function() {
        return effect(true);
      }, deps);
    };
    var useCompatibleInsertionEffect = useInsertionEffect$1 ? function(renderEffect, effect, deps) {
      return useInsertionEffect$1(function() {
        renderEffect();
        return effect();
      }, deps);
    } : useInsertionEffectPolyfill;
    var fullClone$2 = _objectSpread2$3({}, React$5);
    var useInsertionEffect = fullClone$2.useInsertionEffect;
    var useCleanupRegister = function useCleanupRegister2(deps) {
      var effectCleanups = [];
      var cleanupFlag = false;
      function register(fn) {
        if (cleanupFlag) {
          return;
        }
        effectCleanups.push(fn);
      }
      reactExports.useEffect(function() {
        cleanupFlag = false;
        return function() {
          cleanupFlag = true;
          if (effectCleanups.length) {
            effectCleanups.forEach(function(fn) {
              return fn();
            });
          }
        };
      }, deps);
      return register;
    };
    var useRun = function useRun2() {
      return function(fn) {
        fn();
      };
    };
    var useEffectCleanupRegister = typeof useInsertionEffect !== "undefined" ? useCleanupRegister : useRun;
    function useGlobalCache(prefix2, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
      var _React$useContext = reactExports.useContext(StyleContext), globalCache = _React$useContext.cache;
      var fullPath = [prefix2].concat(_toConsumableArray(keyPath));
      var fullPathStr = pathKey(fullPath);
      var register = useEffectCleanupRegister([fullPathStr]);
      var buildCache = function buildCache2(updater) {
        globalCache.opUpdate(fullPathStr, function(prevCache) {
          var _ref = prevCache || [void 0, void 0], _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], times = _ref2$ === void 0 ? 0 : _ref2$, cache = _ref2[1];
          var tmpCache = cache;
          var mergedCache = tmpCache || cacheFn();
          var data = [times, mergedCache];
          return updater ? updater(data) : data;
        });
      };
      reactExports.useMemo(
        function() {
          buildCache();
        },
        /* eslint-disable react-hooks/exhaustive-deps */
        [fullPathStr]
        /* eslint-enable */
      );
      var cacheEntity = globalCache.opGet(fullPathStr);
      var cacheContent = cacheEntity[1];
      useCompatibleInsertionEffect(function() {
        onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);
      }, function(polyfill) {
        buildCache(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), times = _ref4[0], cache = _ref4[1];
          if (polyfill && times === 0) {
            onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);
          }
          return [times + 1, cache];
        });
        return function() {
          globalCache.opUpdate(fullPathStr, function(prevCache) {
            var _ref5 = prevCache || [], _ref6 = _slicedToArray(_ref5, 2), _ref6$ = _ref6[0], times = _ref6$ === void 0 ? 0 : _ref6$, cache = _ref6[1];
            var nextCount = times - 1;
            if (nextCount === 0) {
              register(function() {
                if (polyfill || !globalCache.opGet(fullPathStr)) {
                  onCacheRemove === null || onCacheRemove === void 0 || onCacheRemove(cache, false);
                }
              });
              return null;
            }
            return [times - 1, cache];
          });
        };
      }, [fullPathStr]);
      return cacheContent;
    }
    var EMPTY_OVERRIDE = {};
    var hashPrefix = "css";
    var tokenKeys = /* @__PURE__ */ new Map();
    function recordCleanToken(tokenKey) {
      tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
    }
    function removeStyleTags(key, instanceId) {
      if (typeof document !== "undefined") {
        var styles = document.querySelectorAll("style[".concat(ATTR_TOKEN, '="').concat(key, '"]'));
        styles.forEach(function(style2) {
          if (style2[CSS_IN_JS_INSTANCE] === instanceId) {
            var _style$parentNode;
            (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style2);
          }
        });
      }
    }
    var TOKEN_THRESHOLD = 0;
    function cleanTokenStyle(tokenKey, instanceId) {
      tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
      var tokenKeyList = Array.from(tokenKeys.keys());
      var cleanableKeyList = tokenKeyList.filter(function(key) {
        var count = tokenKeys.get(key) || 0;
        return count <= 0;
      });
      if (tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD) {
        cleanableKeyList.forEach(function(key) {
          removeStyleTags(key, instanceId);
          tokenKeys.delete(key);
        });
      }
    }
    var getComputedToken$1 = function getComputedToken2(originToken, overrideToken, theme, format2) {
      var derivativeToken = theme.getDerivativeToken(originToken);
      var mergedDerivativeToken = _objectSpread2$3(_objectSpread2$3({}, derivativeToken), overrideToken);
      if (format2) {
        mergedDerivativeToken = format2(mergedDerivativeToken);
      }
      return mergedDerivativeToken;
    };
    var TOKEN_PREFIX = "token";
    function useCacheToken(theme, tokens) {
      var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var _useContext = reactExports.useContext(StyleContext), instanceId = _useContext.cache.instanceId, container = _useContext.container;
      var _option$salt = option.salt, salt = _option$salt === void 0 ? "" : _option$salt, _option$override = option.override, override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override, formatToken2 = option.formatToken, compute = option.getComputedToken, cssVar = option.cssVar;
      var mergedToken = memoResult(function() {
        return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
      }, tokens);
      var tokenStr = flattenToken(mergedToken);
      var overrideTokenStr = flattenToken(override);
      var cssVarStr = cssVar ? flattenToken(cssVar) : "";
      var cachedToken = useGlobalCache(TOKEN_PREFIX, [salt, theme.id, tokenStr, overrideTokenStr, cssVarStr], function() {
        var _cssVar$key;
        var mergedDerivativeToken = compute ? compute(mergedToken, override, theme) : getComputedToken$1(mergedToken, override, theme, formatToken2);
        var actualToken = _objectSpread2$3({}, mergedDerivativeToken);
        var cssVarsStr = "";
        if (!!cssVar) {
          var _transformToken = transformToken(mergedDerivativeToken, cssVar.key, {
            prefix: cssVar.prefix,
            ignore: cssVar.ignore,
            unitless: cssVar.unitless,
            preserve: cssVar.preserve
          });
          var _transformToken2 = _slicedToArray(_transformToken, 2);
          mergedDerivativeToken = _transformToken2[0];
          cssVarsStr = _transformToken2[1];
        }
        var tokenKey = token2key(mergedDerivativeToken, salt);
        mergedDerivativeToken._tokenKey = tokenKey;
        actualToken._tokenKey = token2key(actualToken, salt);
        var themeKey = (_cssVar$key = cssVar === null || cssVar === void 0 ? void 0 : cssVar.key) !== null && _cssVar$key !== void 0 ? _cssVar$key : tokenKey;
        mergedDerivativeToken._themeKey = themeKey;
        recordCleanToken(themeKey);
        var hashId = "".concat(hashPrefix, "-").concat(murmur2(tokenKey));
        mergedDerivativeToken._hashId = hashId;
        return [mergedDerivativeToken, hashId, actualToken, cssVarsStr, (cssVar === null || cssVar === void 0 ? void 0 : cssVar.key) || ""];
      }, function(cache) {
        cleanTokenStyle(cache[0]._themeKey, instanceId);
      }, function(_ref) {
        var _ref2 = _slicedToArray(_ref, 4), token2 = _ref2[0], cssVarsStr = _ref2[3];
        if (cssVar && cssVarsStr) {
          var style2 = updateCSS$1(cssVarsStr, murmur2("css-variables-".concat(token2._themeKey)), {
            mark: ATTR_MARK,
            prepend: "queue",
            attachTo: container,
            priority: -999
          });
          style2[CSS_IN_JS_INSTANCE] = instanceId;
          style2.setAttribute(ATTR_TOKEN, token2._themeKey);
        }
      });
      return cachedToken;
    }
    var extract$2 = function extract2(cache, effectStyles, options2) {
      var _cache = _slicedToArray(cache, 5), realToken = _cache[2], styleStr = _cache[3], cssVarKey = _cache[4];
      var _ref3 = options2 || {}, plain = _ref3.plain;
      if (!styleStr) {
        return null;
      }
      var styleId = realToken._tokenKey;
      var order = -999;
      var sharedAttrs = {
        "data-rc-order": "prependQueue",
        "data-rc-priority": "".concat(order)
      };
      var styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
      return [order, styleId, styleText];
    };
    var unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    var COMMENT = "comm";
    var RULESET = "rule";
    var DECLARATION = "decl";
    var IMPORT = "@import";
    var NAMESPACE = "@namespace";
    var KEYFRAMES = "@keyframes";
    var LAYER = "@layer";
    var abs = Math.abs;
    var from = String.fromCharCode;
    function trim(value) {
      return value.trim();
    }
    function replace(value, pattern2, replacement) {
      return value.replace(pattern2, replacement);
    }
    function indexof(value, search, position2) {
      return value.indexOf(search, position2);
    }
    function charat(value, index2) {
      return value.charCodeAt(index2) | 0;
    }
    function substr(value, begin, end) {
      return value.slice(begin, end);
    }
    function strlen(value) {
      return value.length;
    }
    function sizeof(value) {
      return value.length;
    }
    function append(value, array2) {
      return array2.push(value), value;
    }
    var line = 1;
    var column = 1;
    var length = 0;
    var position$1 = 0;
    var character = 0;
    var characters = "";
    function node(value, root2, parent, type2, props, children, length2, siblings) {
      return { value, root: root2, parent, type: type2, props, children, line, column, length: length2, return: "", siblings };
    }
    function char() {
      return character;
    }
    function prev() {
      character = position$1 > 0 ? charat(characters, --position$1) : 0;
      if (column--, character === 10)
        column = 1, line--;
      return character;
    }
    function next() {
      character = position$1 < length ? charat(characters, position$1++) : 0;
      if (column++, character === 10)
        column = 1, line++;
      return character;
    }
    function peek() {
      return charat(characters, position$1);
    }
    function caret() {
      return position$1;
    }
    function slice(begin, end) {
      return substr(characters, begin, end);
    }
    function token(type2) {
      switch (type2) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
          return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
          return 4;
        case 58:
          return 3;
        case 34:
        case 39:
        case 40:
        case 91:
          return 2;
        case 41:
        case 93:
          return 1;
      }
      return 0;
    }
    function alloc(value) {
      return line = column = 1, length = strlen(characters = value), position$1 = 0, [];
    }
    function dealloc(value) {
      return characters = "", value;
    }
    function delimit(type2) {
      return trim(slice(position$1 - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
    }
    function whitespace$1(type2) {
      while (character = peek())
        if (character < 33)
          next();
        else
          break;
      return token(type2) > 2 || token(character) > 3 ? "" : " ";
    }
    function escaping(index2, count) {
      while (--count && next())
        if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
          break;
      return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
    }
    function delimiter(type2) {
      while (next())
        switch (character) {
          case type2:
            return position$1;
          case 34:
          case 39:
            if (type2 !== 34 && type2 !== 39)
              delimiter(character);
            break;
          case 40:
            if (type2 === 41)
              delimiter(type2);
            break;
          case 92:
            next();
            break;
        }
      return position$1;
    }
    function commenter(type2, index2) {
      while (next())
        if (type2 + character === 47 + 10)
          break;
        else if (type2 + character === 42 + 42 && peek() === 47)
          break;
      return "/*" + slice(index2, position$1 - 1) + "*" + from(type2 === 47 ? type2 : next());
    }
    function identifier(index2) {
      while (!token(peek()))
        next();
      return slice(index2, position$1);
    }
    function compile(value) {
      return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
    }
    function parse(value, root2, parent, rule, rules2, rulesets, pseudo, points, declarations) {
      var index2 = 0;
      var offset2 = 0;
      var length2 = pseudo;
      var atrule = 0;
      var property = 0;
      var previous = 0;
      var variable = 1;
      var scanning = 1;
      var ampersand = 1;
      var character2 = 0;
      var type2 = "";
      var props = rules2;
      var children = rulesets;
      var reference = rule;
      var characters2 = type2;
      while (scanning)
        switch (previous = character2, character2 = next()) {
          case 40:
            if (previous != 108 && charat(characters2, length2 - 1) == 58) {
              if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index2 ? points[index2 - 1] : 0)) != -1)
                ampersand = -1;
              break;
            }
          case 34:
          case 39:
          case 91:
            characters2 += delimit(character2);
            break;
          case 9:
          case 10:
          case 13:
          case 32:
            characters2 += whitespace$1(previous);
            break;
          case 92:
            characters2 += escaping(caret() - 1, 7);
            continue;
          case 47:
            switch (peek()) {
              case 42:
              case 47:
                append(comment(commenter(next(), caret()), root2, parent, declarations), declarations);
                if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters2) && substr(characters2, -1, void 0) !== " ") characters2 += " ";
                break;
              default:
                characters2 += "/";
            }
            break;
          case 123 * variable:
            points[index2++] = strlen(characters2) * ampersand;
          case 125 * variable:
          case 59:
          case 0:
            switch (character2) {
              case 0:
              case 125:
                scanning = 0;
              case 59 + offset2:
                if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
                if (property > 0 && (strlen(characters2) - length2 || variable === 0 && previous === 47))
                  append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
                break;
              case 59:
                characters2 += ";";
              default:
                append(reference = ruleset(characters2, root2, parent, index2, offset2, rules2, points, type2, props = [], children = [], length2, rulesets), rulesets);
                if (character2 === 123)
                  if (offset2 === 0)
                    parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
                  else {
                    switch (atrule) {
                      case 99:
                        if (charat(characters2, 3) === 110) break;
                      case 108:
                        if (charat(characters2, 2) === 97) break;
                      default:
                        offset2 = 0;
                      case 100:
                      case 109:
                      case 115:
                    }
                    if (offset2) parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type2, rules2, props = [], length2, children), children), rules2, children, length2, points, rule ? props : children);
                    else parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                  }
            }
            index2 = offset2 = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
            break;
          case 58:
            length2 = 1 + strlen(characters2), property = previous;
          default:
            if (variable < 1) {
              if (character2 == 123)
                --variable;
              else if (character2 == 125 && variable++ == 0 && prev() == 125)
                continue;
            }
            switch (characters2 += from(character2), character2 * variable) {
              case 38:
                ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
                break;
              case 44:
                points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
                break;
              case 64:
                if (peek() === 45)
                  characters2 += delimit(next());
                atrule = peek(), offset2 = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
                break;
              case 45:
                if (previous === 45 && strlen(characters2) == 2)
                  variable = 0;
            }
        }
      return rulesets;
    }
    function ruleset(value, root2, parent, index2, offset2, rules2, points, type2, props, children, length2, siblings) {
      var post = offset2 - 1;
      var rule = offset2 === 0 ? rules2 : [""];
      var size = sizeof(rule);
      for (var i2 = 0, j2 = 0, k2 = 0; i2 < index2; ++i2)
        for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size; ++x2)
          if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
            props[k2++] = z2;
      return node(value, root2, parent, offset2 === 0 ? RULESET : type2, props, children, length2, siblings);
    }
    function comment(value, root2, parent, siblings) {
      return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
    }
    function declaration(value, root2, parent, length2, siblings) {
      return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
    }
    function serialize(children, callback) {
      var output = "";
      for (var i2 = 0; i2 < children.length; i2++)
        output += callback(children[i2], i2, children, callback) || "";
      return output;
    }
    function stringify$2(element, index2, children, callback) {
      switch (element.type) {
        case LAYER:
          if (element.children.length) break;
        case IMPORT:
        case NAMESPACE:
        case DECLARATION:
          return element.return = element.return || element.value;
        case COMMENT:
          return "";
        case KEYFRAMES:
          return element.return = element.value + "{" + serialize(element.children, callback) + "}";
        case RULESET:
          if (!strlen(element.value = element.props.join(","))) return "";
      }
      return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
    }
    var ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
    var CSS_FILE_STYLE = "_FILE_STYLE__";
    var cachePathMap;
    var fromCSSFile = true;
    function prepare() {
      if (!cachePathMap) {
        cachePathMap = {};
        if (canUseDom$2()) {
          var div = document.createElement("div");
          div.className = ATTR_CACHE_MAP;
          div.style.position = "fixed";
          div.style.visibility = "hidden";
          div.style.top = "-9999px";
          document.body.appendChild(div);
          var content = getComputedStyle(div).content || "";
          content = content.replace(/^"/, "").replace(/"$/, "");
          content.split(";").forEach(function(item) {
            var _item$split = item.split(":"), _item$split2 = _slicedToArray(_item$split, 2), path2 = _item$split2[0], hash = _item$split2[1];
            cachePathMap[path2] = hash;
          });
          var inlineMapStyle = document.querySelector("style[".concat(ATTR_CACHE_MAP, "]"));
          if (inlineMapStyle) {
            var _inlineMapStyle$paren;
            fromCSSFile = false;
            (_inlineMapStyle$paren = inlineMapStyle.parentNode) === null || _inlineMapStyle$paren === void 0 || _inlineMapStyle$paren.removeChild(inlineMapStyle);
          }
          document.body.removeChild(div);
        }
      }
    }
    function existPath(path2) {
      prepare();
      return !!cachePathMap[path2];
    }
    function getStyleAndHash(path2) {
      var hash = cachePathMap[path2];
      var styleStr = null;
      if (hash && canUseDom$2()) {
        if (fromCSSFile) {
          styleStr = CSS_FILE_STYLE;
        } else {
          var _style = document.querySelector("style[".concat(ATTR_MARK, '="').concat(cachePathMap[path2], '"]'));
          if (_style) {
            styleStr = _style.innerHTML;
          } else {
            delete cachePathMap[path2];
          }
        }
      }
      return [styleStr, hash];
    }
    var SKIP_CHECK = "_skip_check_";
    var MULTI_VALUE = "_multi_value_";
    function normalizeStyle(styleStr) {
      var serialized = serialize(compile(styleStr), stringify$2);
      return serialized.replace(/\{%%%\:[^;];}/g, ";");
    }
    function isCompoundCSSProperty(value) {
      return _typeof$1(value) === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
    }
    function injectSelectorHash(key, hashId, hashPriority) {
      if (!hashId) {
        return key;
      }
      var hashClassName = ".".concat(hashId);
      var hashSelector = hashPriority === "low" ? ":where(".concat(hashClassName, ")") : hashClassName;
      var keys2 = key.split(",").map(function(k2) {
        var _firstPath$match;
        var fullPath = k2.trim().split(/\s+/);
        var firstPath = fullPath[0] || "";
        var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || "";
        firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
        return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
      });
      return keys2.join(",");
    }
    var parseStyle = function parseStyle2(interpolation) {
      var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        root: true,
        parentSelectors: []
      }, root2 = _ref.root, injectHash = _ref.injectHash, parentSelectors = _ref.parentSelectors;
      var hashId = config.hashId, layer = config.layer;
      config.path;
      var hashPriority = config.hashPriority, _config$transformers = config.transformers, transformers = _config$transformers === void 0 ? [] : _config$transformers;
      config.linters;
      var styleStr = "";
      var effectStyle = {};
      function parseKeyframes(keyframes) {
        var animationName = keyframes.getName(hashId);
        if (!effectStyle[animationName]) {
          var _parseStyle = parseStyle2(keyframes.style, config, {
            root: false,
            parentSelectors
          }), _parseStyle2 = _slicedToArray(_parseStyle, 1), _parsedStr = _parseStyle2[0];
          effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
        }
      }
      function flattenList(list) {
        var fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        list.forEach(function(item) {
          if (Array.isArray(item)) {
            flattenList(item, fullList);
          } else if (item) {
            fullList.push(item);
          }
        });
        return fullList;
      }
      var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
      flattenStyleList.forEach(function(originStyle) {
        var style2 = typeof originStyle === "string" && !root2 ? {} : originStyle;
        if (typeof style2 === "string") {
          styleStr += "".concat(style2, "\n");
        } else if (style2._keyframe) {
          parseKeyframes(style2);
        } else {
          var mergedStyle = transformers.reduce(function(prev2, trans) {
            var _trans$visit;
            return (trans === null || trans === void 0 || (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev2)) || prev2;
          }, style2);
          Object.keys(mergedStyle).forEach(function(key) {
            var value = mergedStyle[key];
            if (_typeof$1(value) === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
              var subInjectHash = false;
              var mergedKey = key.trim();
              var nextRoot = false;
              if ((root2 || injectHash) && hashId) {
                if (mergedKey.startsWith("@")) {
                  subInjectHash = true;
                } else if (mergedKey === "&") {
                  mergedKey = injectSelectorHash("", hashId, hashPriority);
                } else {
                  mergedKey = injectSelectorHash(key, hashId, hashPriority);
                }
              } else if (root2 && !hashId && (mergedKey === "&" || mergedKey === "")) {
                mergedKey = "";
                nextRoot = true;
              }
              var _parseStyle3 = parseStyle2(value, config, {
                root: nextRoot,
                injectHash: subInjectHash,
                parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
              }), _parseStyle4 = _slicedToArray(_parseStyle3, 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
              effectStyle = _objectSpread2$3(_objectSpread2$3({}, effectStyle), childEffectStyle);
              styleStr += "".concat(mergedKey).concat(_parsedStr2);
            } else {
              let appendStyle = function(cssKey, cssValue) {
                var styleName = cssKey.replace(/[A-Z]/g, function(match2) {
                  return "-".concat(match2.toLowerCase());
                });
                var formatValue2 = cssValue;
                if (!unitlessKeys[cssKey] && typeof formatValue2 === "number" && formatValue2 !== 0) {
                  formatValue2 = "".concat(formatValue2, "px");
                }
                if (cssKey === "animationName" && cssValue !== null && cssValue !== void 0 && cssValue._keyframe) {
                  parseKeyframes(cssValue);
                  formatValue2 = cssValue.getName(hashId);
                }
                styleStr += "".concat(styleName, ":").concat(formatValue2, ";");
              };
              var _value;
              var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
              if (_typeof$1(value) === "object" && value !== null && value !== void 0 && value[MULTI_VALUE] && Array.isArray(actualValue)) {
                actualValue.forEach(function(item) {
                  appendStyle(key, item);
                });
              } else {
                appendStyle(key, actualValue);
              }
            }
          });
        }
      });
      if (!root2) {
        styleStr = "{".concat(styleStr, "}");
      } else if (layer) {
        if (styleStr) {
          styleStr = "@layer ".concat(layer.name, " {").concat(styleStr, "}");
        }
        if (layer.dependencies) {
          effectStyle["@layer ".concat(layer.name)] = layer.dependencies.map(function(deps) {
            return "@layer ".concat(deps, ", ").concat(layer.name, ";");
          }).join("\n");
        }
      }
      return [styleStr, effectStyle];
    };
    function uniqueHash(path2, styleStr) {
      return murmur2("".concat(path2.join("%")).concat(styleStr));
    }
    function Empty$2() {
      return null;
    }
    var STYLE_PREFIX = "style";
    function useStyleRegister(info, styleFn) {
      var token2 = info.token, path2 = info.path, hashId = info.hashId, layer = info.layer, nonce = info.nonce, clientOnly = info.clientOnly, _info$order = info.order, order = _info$order === void 0 ? 0 : _info$order;
      var _React$useContext = reactExports.useContext(StyleContext), autoClear = _React$useContext.autoClear;
      _React$useContext.mock;
      var defaultCache = _React$useContext.defaultCache, hashPriority = _React$useContext.hashPriority, container = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters, cache = _React$useContext.cache, enableLayer = _React$useContext.layer;
      var tokenKey = token2._tokenKey;
      var fullPath = [tokenKey];
      if (enableLayer) {
        fullPath.push("layer");
      }
      fullPath.push.apply(fullPath, _toConsumableArray(path2));
      var isMergedClientSide = isClientSide;
      var _useGlobalCache = useGlobalCache(
        STYLE_PREFIX,
        fullPath,
        // Create cache if needed
        function() {
          var cachePath = fullPath.join("|");
          if (existPath(cachePath)) {
            var _getStyleAndHash = getStyleAndHash(cachePath), _getStyleAndHash2 = _slicedToArray(_getStyleAndHash, 2), inlineCacheStyleStr = _getStyleAndHash2[0], styleHash = _getStyleAndHash2[1];
            if (inlineCacheStyleStr) {
              return [inlineCacheStyleStr, tokenKey, styleHash, {}, clientOnly, order];
            }
          }
          var styleObj = styleFn();
          var _parseStyle5 = parseStyle(styleObj, {
            hashId,
            hashPriority,
            layer: enableLayer ? layer : void 0,
            path: path2.join("-"),
            transformers,
            linters
          }), _parseStyle6 = _slicedToArray(_parseStyle5, 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1];
          var styleStr = normalizeStyle(parsedStyle);
          var styleId = uniqueHash(fullPath, styleStr);
          return [styleStr, tokenKey, styleId, effectStyle, clientOnly, order];
        },
        // Remove cache if no need
        function(_ref2, fromHMR) {
          var _ref3 = _slicedToArray(_ref2, 3), styleId = _ref3[2];
          if ((fromHMR || autoClear) && isClientSide) {
            removeCSS$1(styleId, {
              mark: ATTR_MARK
            });
          }
        },
        // Effect: Inject style here
        function(_ref4) {
          var _ref5 = _slicedToArray(_ref4, 4), styleStr = _ref5[0];
          _ref5[1];
          var styleId = _ref5[2], effectStyle = _ref5[3];
          if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
            var mergedCSSConfig = {
              mark: ATTR_MARK,
              prepend: enableLayer ? false : "queue",
              attachTo: container,
              priority: order
            };
            var nonceStr = typeof nonce === "function" ? nonce() : nonce;
            if (nonceStr) {
              mergedCSSConfig.csp = {
                nonce: nonceStr
              };
            }
            var effectLayerKeys = [];
            var effectRestKeys = [];
            Object.keys(effectStyle).forEach(function(key) {
              if (key.startsWith("@layer")) {
                effectLayerKeys.push(key);
              } else {
                effectRestKeys.push(key);
              }
            });
            effectLayerKeys.forEach(function(effectKey) {
              updateCSS$1(normalizeStyle(effectStyle[effectKey]), "_layer-".concat(effectKey), _objectSpread2$3(_objectSpread2$3({}, mergedCSSConfig), {}, {
                prepend: true
              }));
            });
            var style2 = updateCSS$1(styleStr, styleId, mergedCSSConfig);
            style2[CSS_IN_JS_INSTANCE] = cache.instanceId;
            style2.setAttribute(ATTR_TOKEN, tokenKey);
            effectRestKeys.forEach(function(effectKey) {
              updateCSS$1(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), mergedCSSConfig);
            });
          }
        }
      ), _useGlobalCache2 = _slicedToArray(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
      return function(node2) {
        var styleNode;
        if (!ssrInline || isMergedClientSide || !defaultCache) {
          styleNode = /* @__PURE__ */ reactExports.createElement(Empty$2, null);
        } else {
          var _ref6;
          styleNode = /* @__PURE__ */ reactExports.createElement("style", _extends$2({}, (_ref6 = {}, _defineProperty(_ref6, ATTR_TOKEN, cachedTokenKey), _defineProperty(_ref6, ATTR_MARK, cachedStyleId), _ref6), {
            dangerouslySetInnerHTML: {
              __html: cachedStyleStr
            }
          }));
        }
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, styleNode, node2);
      };
    }
    var extract$1 = function extract2(cache, effectStyles, options2) {
      var _cache = _slicedToArray(cache, 6), styleStr = _cache[0], tokenKey = _cache[1], styleId = _cache[2], effectStyle = _cache[3], clientOnly = _cache[4], order = _cache[5];
      var _ref7 = options2 || {}, plain = _ref7.plain;
      if (clientOnly) {
        return null;
      }
      var keyStyleText = styleStr;
      var sharedAttrs = {
        "data-rc-order": "prependQueue",
        "data-rc-priority": "".concat(order)
      };
      keyStyleText = toStyleStr(styleStr, tokenKey, styleId, sharedAttrs, plain);
      if (effectStyle) {
        Object.keys(effectStyle).forEach(function(effectKey) {
          if (!effectStyles[effectKey]) {
            effectStyles[effectKey] = true;
            var effectStyleStr = normalizeStyle(effectStyle[effectKey]);
            var effectStyleHTML = toStyleStr(effectStyleStr, tokenKey, "_effect-".concat(effectKey), sharedAttrs, plain);
            if (effectKey.startsWith("@layer")) {
              keyStyleText = effectStyleHTML + keyStyleText;
            } else {
              keyStyleText += effectStyleHTML;
            }
          }
        });
      }
      return [order, styleId, keyStyleText];
    };
    var CSS_VAR_PREFIX = "cssVar";
    var useCSSVarRegister = function useCSSVarRegister2(config, fn) {
      var key = config.key, prefix2 = config.prefix, unitless2 = config.unitless, ignore2 = config.ignore, token2 = config.token, _config$scope = config.scope, scope = _config$scope === void 0 ? "" : _config$scope;
      var _useContext = reactExports.useContext(StyleContext), instanceId = _useContext.cache.instanceId, container = _useContext.container;
      var tokenKey = token2._tokenKey;
      var stylePath = [].concat(_toConsumableArray(config.path), [key, scope, tokenKey]);
      var cache = useGlobalCache(CSS_VAR_PREFIX, stylePath, function() {
        var originToken = fn();
        var _transformToken = transformToken(originToken, key, {
          prefix: prefix2,
          unitless: unitless2,
          ignore: ignore2,
          scope
        }), _transformToken2 = _slicedToArray(_transformToken, 2), mergedToken = _transformToken2[0], cssVarsStr = _transformToken2[1];
        var styleId = uniqueHash(stylePath, cssVarsStr);
        return [mergedToken, cssVarsStr, styleId, key];
      }, function(_ref) {
        var _ref2 = _slicedToArray(_ref, 3), styleId = _ref2[2];
        if (isClientSide) {
          removeCSS$1(styleId, {
            mark: ATTR_MARK
          });
        }
      }, function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 3), cssVarsStr = _ref4[1], styleId = _ref4[2];
        if (!cssVarsStr) {
          return;
        }
        var style2 = updateCSS$1(cssVarsStr, styleId, {
          mark: ATTR_MARK,
          prepend: "queue",
          attachTo: container,
          priority: -999
        });
        style2[CSS_IN_JS_INSTANCE] = instanceId;
        style2.setAttribute(ATTR_TOKEN, key);
      });
      return cache;
    };
    var extract = function extract2(cache, effectStyles, options2) {
      var _cache = _slicedToArray(cache, 4), styleStr = _cache[1], styleId = _cache[2], cssVarKey = _cache[3];
      var _ref5 = options2 || {}, plain = _ref5.plain;
      if (!styleStr) {
        return null;
      }
      var order = -999;
      var sharedAttrs = {
        "data-rc-order": "prependQueue",
        "data-rc-priority": "".concat(order)
      };
      var styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
      return [order, styleId, styleText];
    };
    var _ExtractStyleFns;
    _ExtractStyleFns = {}, _defineProperty(_ExtractStyleFns, STYLE_PREFIX, extract$1), _defineProperty(_ExtractStyleFns, TOKEN_PREFIX, extract$2), _defineProperty(_ExtractStyleFns, CSS_VAR_PREFIX, extract), _ExtractStyleFns;
    var Keyframe = /* @__PURE__ */ function() {
      function Keyframe2(name, style2) {
        _classCallCheck(this, Keyframe2);
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "style", void 0);
        _defineProperty(this, "_keyframe", true);
        this.name = name;
        this.style = style2;
      }
      _createClass(Keyframe2, [{
        key: "getName",
        value: function getName() {
          var hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
        }
      }]);
      return Keyframe2;
    }();
    function noSplit(list) {
      list.notSplit = true;
      return list;
    }
    ({
      // Border
      borderBlock: noSplit(["borderTop", "borderBottom"]),
      borderBlockStart: noSplit(["borderTop"]),
      borderBlockEnd: noSplit(["borderBottom"]),
      borderInline: noSplit(["borderLeft", "borderRight"]),
      borderInlineStart: noSplit(["borderLeft"]),
      borderInlineEnd: noSplit(["borderRight"])
    });
    var IconContext$1 = /* @__PURE__ */ reactExports.createContext({});
    function _toArray(r2) {
      return _arrayWithHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableRest();
    }
    function get(entity, path2) {
      var current = entity;
      for (var i2 = 0; i2 < path2.length; i2 += 1) {
        if (current === null || current === void 0) {
          return void 0;
        }
        current = current[path2[i2]];
      }
      return current;
    }
    function internalSet(entity, paths, value, removeIfUndefined) {
      if (!paths.length) {
        return value;
      }
      var _paths = _toArray(paths), path2 = _paths[0], restPath = _paths.slice(1);
      var clone2;
      if (!entity && typeof path2 === "number") {
        clone2 = [];
      } else if (Array.isArray(entity)) {
        clone2 = _toConsumableArray(entity);
      } else {
        clone2 = _objectSpread2$3({}, entity);
      }
      if (removeIfUndefined && value === void 0 && restPath.length === 1) {
        delete clone2[path2][restPath[0]];
      } else {
        clone2[path2] = internalSet(clone2[path2], restPath, value, removeIfUndefined);
      }
      return clone2;
    }
    function set(entity, paths, value) {
      var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
        return entity;
      }
      return internalSet(entity, paths, value, removeIfUndefined);
    }
    function isObject$2(obj) {
      return _typeof$1(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
    }
    function createEmpty(source) {
      return Array.isArray(source) ? [] : {};
    }
    var keys$1 = typeof Reflect === "undefined" ? Object.keys : Reflect.ownKeys;
    function merge$1() {
      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      var clone2 = createEmpty(sources[0]);
      sources.forEach(function(src) {
        function internalMerge(path2, parentLoopSet) {
          var loopSet = new Set(parentLoopSet);
          var value = get(src, path2);
          var isArr = Array.isArray(value);
          if (isArr || isObject$2(value)) {
            if (!loopSet.has(value)) {
              loopSet.add(value);
              var originValue = get(clone2, path2);
              if (isArr) {
                clone2 = set(clone2, path2, []);
              } else if (!originValue || _typeof$1(originValue) !== "object") {
                clone2 = set(clone2, path2, createEmpty(value));
              }
              keys$1(value).forEach(function(key) {
                internalMerge([].concat(_toConsumableArray(path2), [key]), loopSet);
              });
            }
          } else {
            clone2 = set(clone2, path2, value);
          }
        }
        internalMerge([]);
      });
      return clone2;
    }
    function noop$2() {
    }
    const WarningContext = /* @__PURE__ */ reactExports.createContext({});
    const devUseWarning = () => {
      const noopWarning = () => {
      };
      noopWarning.deprecated = noop$2;
      return noopWarning;
    };
    const ValidateMessagesContext = /* @__PURE__ */ reactExports.createContext(void 0);
    var locale$4 = {
      // Options
      items_per_page: "/ page",
      jump_to: "Go to",
      jump_to_confirm: "confirm",
      page: "Page",
      // Pagination
      prev_page: "Previous Page",
      next_page: "Next Page",
      prev_5: "Previous 5 Pages",
      next_5: "Next 5 Pages",
      prev_3: "Previous 3 Pages",
      next_3: "Next 3 Pages",
      page_size: "Page Size"
    };
    var commonLocale = {
      yearFormat: "YYYY",
      dayFormat: "D",
      cellMeridiemFormat: "A",
      monthBeforeYear: true
    };
    var locale$3 = _objectSpread2$3(_objectSpread2$3({}, commonLocale), {}, {
      locale: "en_US",
      today: "Today",
      now: "Now",
      backToToday: "Back to today",
      ok: "OK",
      clear: "Clear",
      week: "Week",
      month: "Month",
      year: "Year",
      timeSelect: "select time",
      dateSelect: "select date",
      weekSelect: "Choose a week",
      monthSelect: "Choose a month",
      yearSelect: "Choose a year",
      decadeSelect: "Choose a decade",
      dateFormat: "M/D/YYYY",
      dateTimeFormat: "M/D/YYYY HH:mm:ss",
      previousMonth: "Previous month (PageUp)",
      nextMonth: "Next month (PageDown)",
      previousYear: "Last year (Control + left)",
      nextYear: "Next year (Control + right)",
      previousDecade: "Last decade",
      nextDecade: "Next decade",
      previousCentury: "Last century",
      nextCentury: "Next century"
    });
    const locale$2 = {
      placeholder: "Select time",
      rangePlaceholder: ["Start time", "End time"]
    };
    const locale$1 = {
      lang: Object.assign({
        placeholder: "Select date",
        yearPlaceholder: "Select year",
        quarterPlaceholder: "Select quarter",
        monthPlaceholder: "Select month",
        weekPlaceholder: "Select week",
        rangePlaceholder: ["Start date", "End date"],
        rangeYearPlaceholder: ["Start year", "End year"],
        rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
        rangeMonthPlaceholder: ["Start month", "End month"],
        rangeWeekPlaceholder: ["Start week", "End week"]
      }, locale$3),
      timePickerLocale: Object.assign({}, locale$2)
    };
    const typeTemplate$1 = "${label} is not a valid ${type}";
    const localeValues = {
      locale: "en",
      Pagination: locale$4,
      DatePicker: locale$1,
      TimePicker: locale$2,
      Calendar: locale$1,
      global: {
        placeholder: "Please select"
      },
      Table: {
        filterTitle: "Filter menu",
        filterConfirm: "OK",
        filterReset: "Reset",
        filterEmptyText: "No filters",
        filterCheckAll: "Select all items",
        filterSearchPlaceholder: "Search in filters",
        emptyText: "No data",
        selectAll: "Select current page",
        selectInvert: "Invert current page",
        selectNone: "Clear all data",
        selectionAll: "Select all data",
        sortTitle: "Sort",
        expand: "Expand row",
        collapse: "Collapse row",
        triggerDesc: "Click to sort descending",
        triggerAsc: "Click to sort ascending",
        cancelSort: "Click to cancel sorting"
      },
      Tour: {
        Next: "Next",
        Previous: "Previous",
        Finish: "Finish"
      },
      Modal: {
        okText: "OK",
        cancelText: "Cancel",
        justOkText: "OK"
      },
      Popconfirm: {
        okText: "OK",
        cancelText: "Cancel"
      },
      Transfer: {
        titles: ["", ""],
        searchPlaceholder: "Search here",
        itemUnit: "item",
        itemsUnit: "items",
        remove: "Remove",
        selectCurrent: "Select current page",
        removeCurrent: "Remove current page",
        selectAll: "Select all data",
        deselectAll: "Deselect all data",
        removeAll: "Remove all data",
        selectInvert: "Invert current page"
      },
      Upload: {
        uploading: "Uploading...",
        removeFile: "Remove file",
        uploadError: "Upload error",
        previewFile: "Preview file",
        downloadFile: "Download file"
      },
      Empty: {
        description: "No data"
      },
      Icon: {
        icon: "icon"
      },
      Text: {
        edit: "Edit",
        copy: "Copy",
        copied: "Copied",
        expand: "Expand",
        collapse: "Collapse"
      },
      Form: {
        optional: "(optional)",
        defaultValidateMessages: {
          default: "Field validation error for ${label}",
          required: "Please enter ${label}",
          enum: "${label} must be one of [${enum}]",
          whitespace: "${label} cannot be a blank character",
          date: {
            format: "${label} date format is invalid",
            parse: "${label} cannot be converted to a date",
            invalid: "${label} is an invalid date"
          },
          types: {
            string: typeTemplate$1,
            method: typeTemplate$1,
            array: typeTemplate$1,
            object: typeTemplate$1,
            number: typeTemplate$1,
            date: typeTemplate$1,
            boolean: typeTemplate$1,
            integer: typeTemplate$1,
            float: typeTemplate$1,
            regexp: typeTemplate$1,
            email: typeTemplate$1,
            url: typeTemplate$1,
            hex: typeTemplate$1
          },
          string: {
            len: "${label} must be ${len} characters",
            min: "${label} must be at least ${min} characters",
            max: "${label} must be up to ${max} characters",
            range: "${label} must be between ${min}-${max} characters"
          },
          number: {
            len: "${label} must be equal to ${len}",
            min: "${label} must be minimum ${min}",
            max: "${label} must be maximum ${max}",
            range: "${label} must be between ${min}-${max}"
          },
          array: {
            len: "Must be ${len} ${label}",
            min: "At least ${min} ${label}",
            max: "At most ${max} ${label}",
            range: "The amount of ${label} must be between ${min}-${max}"
          },
          pattern: {
            mismatch: "${label} does not match the pattern ${pattern}"
          }
        }
      },
      Image: {
        preview: "Preview"
      },
      QRCode: {
        expired: "QR code expired",
        refresh: "Refresh",
        scanned: "Scanned"
      },
      ColorPicker: {
        presetEmpty: "Empty",
        transparent: "Transparent",
        singleColor: "Single",
        gradientColor: "Gradient"
      }
    };
    let runtimeLocale = Object.assign({}, localeValues.Modal);
    let localeList = [];
    const generateLocale = () => localeList.reduce((merged, locale2) => Object.assign(Object.assign({}, merged), locale2), localeValues.Modal);
    function changeConfirmLocale(newLocale) {
      if (newLocale) {
        const cloneLocale = Object.assign({}, newLocale);
        localeList.push(cloneLocale);
        runtimeLocale = generateLocale();
        return () => {
          localeList = localeList.filter((locale2) => locale2 !== cloneLocale);
          runtimeLocale = generateLocale();
        };
      }
      runtimeLocale = Object.assign({}, localeValues.Modal);
    }
    function getConfirmLocale() {
      return runtimeLocale;
    }
    const LocaleContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const useLocale$1 = (componentName, defaultLocale) => {
      const fullLocale = reactExports.useContext(LocaleContext);
      const getLocale = reactExports.useMemo(() => {
        var _a;
        const locale2 = defaultLocale || localeValues[componentName];
        const localeFromContext = (_a = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a !== void 0 ? _a : {};
        return Object.assign(Object.assign({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {});
      }, [componentName, defaultLocale, fullLocale]);
      const getLocaleCode = reactExports.useMemo(() => {
        const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
        if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) {
          return localeValues.locale;
        }
        return localeCode;
      }, [fullLocale]);
      return [getLocale, getLocaleCode];
    };
    const ANT_MARK = "internalMark";
    const LocaleProvider = (props) => {
      const {
        locale: locale2 = {},
        children,
        _ANT_MARK__
      } = props;
      reactExports.useEffect(() => {
        const clearLocale = changeConfirmLocale(locale2 === null || locale2 === void 0 ? void 0 : locale2.Modal);
        return clearLocale;
      }, [locale2]);
      const getMemoizedContextValue = reactExports.useMemo(() => Object.assign(Object.assign({}, locale2), {
        exist: true
      }), [locale2]);
      return /* @__PURE__ */ reactExports.createElement(LocaleContext.Provider, {
        value: getMemoizedContextValue
      }, children);
    };
    const defaultPresetColors = {
      blue: "#1677FF",
      purple: "#722ED1",
      cyan: "#13C2C2",
      green: "#52C41A",
      magenta: "#EB2F96",
      /**
       * @deprecated Use magenta instead
       */
      pink: "#EB2F96",
      red: "#F5222D",
      orange: "#FA8C16",
      yellow: "#FADB14",
      volcano: "#FA541C",
      geekblue: "#2F54EB",
      gold: "#FAAD14",
      lime: "#A0D911"
    };
    const seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
      // Color
      colorPrimary: "#1677ff",
      colorSuccess: "#52c41a",
      colorWarning: "#faad14",
      colorError: "#ff4d4f",
      colorInfo: "#1677ff",
      colorLink: "",
      colorTextBase: "",
      colorBgBase: "",
      // Font
      fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
      fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
      fontSize: 14,
      // Line
      lineWidth: 1,
      lineType: "solid",
      // Motion
      motionUnit: 0.1,
      motionBase: 0,
      motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
      motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
      motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
      motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
      motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
      motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
      motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
      motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
      // Radius
      borderRadius: 6,
      // Size
      sizeUnit: 4,
      sizeStep: 4,
      sizePopupArrow: 16,
      // Control Base
      controlHeight: 32,
      // zIndex
      zIndexBase: 0,
      zIndexPopupBase: 1e3,
      // Image
      opacityImage: 1,
      // Wireframe
      wireframe: false,
      // Motion
      motion: true
    });
    const round = Math.round;
    function splitColorStr(str, parseNum) {
      const match2 = str.replace(/^[^(]*\((.*)/, "$1").replace(/\).*/, "").match(/\d*\.?\d+%?/g) || [];
      const numList = match2.map((item) => parseFloat(item));
      for (let i2 = 0; i2 < 3; i2 += 1) {
        numList[i2] = parseNum(numList[i2] || 0, match2[i2] || "", i2);
      }
      if (match2[3]) {
        numList[3] = match2[3].includes("%") ? numList[3] / 100 : numList[3];
      } else {
        numList[3] = 1;
      }
      return numList;
    }
    const parseHSVorHSL = (num, _2, index2) => index2 === 0 ? num : num / 100;
    function limitRange(value, max) {
      const mergedMax = max || 255;
      if (value > mergedMax) {
        return mergedMax;
      }
      if (value < 0) {
        return 0;
      }
      return value;
    }
    class FastColor {
      constructor(input) {
        _defineProperty(this, "isValid", true);
        _defineProperty(this, "r", 0);
        _defineProperty(this, "g", 0);
        _defineProperty(this, "b", 0);
        _defineProperty(this, "a", 1);
        _defineProperty(this, "_h", void 0);
        _defineProperty(this, "_s", void 0);
        _defineProperty(this, "_l", void 0);
        _defineProperty(this, "_v", void 0);
        _defineProperty(this, "_max", void 0);
        _defineProperty(this, "_min", void 0);
        _defineProperty(this, "_brightness", void 0);
        function matchFormat(str) {
          return str[0] in input && str[1] in input && str[2] in input;
        }
        if (!input) ;
        else if (typeof input === "string") {
          let matchPrefix2 = function(prefix2) {
            return trimStr.startsWith(prefix2);
          };
          var matchPrefix = matchPrefix2;
          const trimStr = input.trim();
          if (/^#?[A-F\d]{3,8}$/i.test(trimStr)) {
            this.fromHexString(trimStr);
          } else if (matchPrefix2("rgb")) {
            this.fromRgbString(trimStr);
          } else if (matchPrefix2("hsl")) {
            this.fromHslString(trimStr);
          } else if (matchPrefix2("hsv") || matchPrefix2("hsb")) {
            this.fromHsvString(trimStr);
          }
        } else if (input instanceof FastColor) {
          this.r = input.r;
          this.g = input.g;
          this.b = input.b;
          this.a = input.a;
          this._h = input._h;
          this._s = input._s;
          this._l = input._l;
          this._v = input._v;
        } else if (matchFormat("rgb")) {
          this.r = limitRange(input.r);
          this.g = limitRange(input.g);
          this.b = limitRange(input.b);
          this.a = typeof input.a === "number" ? limitRange(input.a, 1) : 1;
        } else if (matchFormat("hsl")) {
          this.fromHsl(input);
        } else if (matchFormat("hsv")) {
          this.fromHsv(input);
        } else {
          throw new Error("@ant-design/fast-color: unsupported input " + JSON.stringify(input));
        }
      }
      // ======================= Setter =======================
      setR(value) {
        return this._sc("r", value);
      }
      setG(value) {
        return this._sc("g", value);
      }
      setB(value) {
        return this._sc("b", value);
      }
      setA(value) {
        return this._sc("a", value, 1);
      }
      setHue(value) {
        const hsv = this.toHsv();
        hsv.h = value;
        return this._c(hsv);
      }
      // ======================= Getter =======================
      /**
       * Returns the perceived luminance of a color, from 0-1.
       * @see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
       */
      getLuminance() {
        function adjustGamma(raw) {
          const val = raw / 255;
          return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
        }
        const R2 = adjustGamma(this.r);
        const G = adjustGamma(this.g);
        const B2 = adjustGamma(this.b);
        return 0.2126 * R2 + 0.7152 * G + 0.0722 * B2;
      }
      getHue() {
        if (typeof this._h === "undefined") {
          const delta = this.getMax() - this.getMin();
          if (delta === 0) {
            this._h = 0;
          } else {
            this._h = round(60 * (this.r === this.getMax() ? (this.g - this.b) / delta + (this.g < this.b ? 6 : 0) : this.g === this.getMax() ? (this.b - this.r) / delta + 2 : (this.r - this.g) / delta + 4));
          }
        }
        return this._h;
      }
      getSaturation() {
        if (typeof this._s === "undefined") {
          const delta = this.getMax() - this.getMin();
          if (delta === 0) {
            this._s = 0;
          } else {
            this._s = delta / this.getMax();
          }
        }
        return this._s;
      }
      getLightness() {
        if (typeof this._l === "undefined") {
          this._l = (this.getMax() + this.getMin()) / 510;
        }
        return this._l;
      }
      getValue() {
        if (typeof this._v === "undefined") {
          this._v = this.getMax() / 255;
        }
        return this._v;
      }
      /**
       * Returns the perceived brightness of the color, from 0-255.
       * Note: this is not the b of HSB
       * @see http://www.w3.org/TR/AERT#color-contrast
       */
      getBrightness() {
        if (typeof this._brightness === "undefined") {
          this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1e3;
        }
        return this._brightness;
      }
      // ======================== Func ========================
      darken(amount = 10) {
        const h2 = this.getHue();
        const s = this.getSaturation();
        let l2 = this.getLightness() - amount / 100;
        if (l2 < 0) {
          l2 = 0;
        }
        return this._c({
          h: h2,
          s,
          l: l2,
          a: this.a
        });
      }
      lighten(amount = 10) {
        const h2 = this.getHue();
        const s = this.getSaturation();
        let l2 = this.getLightness() + amount / 100;
        if (l2 > 1) {
          l2 = 1;
        }
        return this._c({
          h: h2,
          s,
          l: l2,
          a: this.a
        });
      }
      /**
       * Mix the current color a given amount with another color, from 0 to 100.
       * 0 means no mixing (return current color).
       */
      mix(input, amount = 50) {
        const color = this._c(input);
        const p2 = amount / 100;
        const calc = (key) => (color[key] - this[key]) * p2 + this[key];
        const rgba = {
          r: round(calc("r")),
          g: round(calc("g")),
          b: round(calc("b")),
          a: round(calc("a") * 100) / 100
        };
        return this._c(rgba);
      }
      /**
       * Mix the color with pure white, from 0 to 100.
       * Providing 0 will do nothing, providing 100 will always return white.
       */
      tint(amount = 10) {
        return this.mix({
          r: 255,
          g: 255,
          b: 255,
          a: 1
        }, amount);
      }
      /**
       * Mix the color with pure black, from 0 to 100.
       * Providing 0 will do nothing, providing 100 will always return black.
       */
      shade(amount = 10) {
        return this.mix({
          r: 0,
          g: 0,
          b: 0,
          a: 1
        }, amount);
      }
      onBackground(background) {
        const bg = this._c(background);
        const alpha = this.a + bg.a * (1 - this.a);
        const calc = (key) => {
          return round((this[key] * this.a + bg[key] * bg.a * (1 - this.a)) / alpha);
        };
        return this._c({
          r: calc("r"),
          g: calc("g"),
          b: calc("b"),
          a: alpha
        });
      }
      // ======================= Status =======================
      isDark() {
        return this.getBrightness() < 128;
      }
      isLight() {
        return this.getBrightness() >= 128;
      }
      // ======================== MISC ========================
      equals(other) {
        return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
      }
      clone() {
        return this._c(this);
      }
      // ======================= Format =======================
      toHexString() {
        let hex = "#";
        const rHex = (this.r || 0).toString(16);
        hex += rHex.length === 2 ? rHex : "0" + rHex;
        const gHex = (this.g || 0).toString(16);
        hex += gHex.length === 2 ? gHex : "0" + gHex;
        const bHex = (this.b || 0).toString(16);
        hex += bHex.length === 2 ? bHex : "0" + bHex;
        if (typeof this.a === "number" && this.a >= 0 && this.a < 1) {
          const aHex = round(this.a * 255).toString(16);
          hex += aHex.length === 2 ? aHex : "0" + aHex;
        }
        return hex;
      }
      /** CSS support color pattern */
      toHsl() {
        return {
          h: this.getHue(),
          s: this.getSaturation(),
          l: this.getLightness(),
          a: this.a
        };
      }
      /** CSS support color pattern */
      toHslString() {
        const h2 = this.getHue();
        const s = round(this.getSaturation() * 100);
        const l2 = round(this.getLightness() * 100);
        return this.a !== 1 ? `hsla(${h2},${s}%,${l2}%,${this.a})` : `hsl(${h2},${s}%,${l2}%)`;
      }
      /** Same as toHsb */
      toHsv() {
        return {
          h: this.getHue(),
          s: this.getSaturation(),
          v: this.getValue(),
          a: this.a
        };
      }
      toRgb() {
        return {
          r: this.r,
          g: this.g,
          b: this.b,
          a: this.a
        };
      }
      toRgbString() {
        return this.a !== 1 ? `rgba(${this.r},${this.g},${this.b},${this.a})` : `rgb(${this.r},${this.g},${this.b})`;
      }
      toString() {
        return this.toRgbString();
      }
      // ====================== Privates ======================
      /** Return a new FastColor object with one channel changed */
      _sc(rgb, value, max) {
        const clone2 = this.clone();
        clone2[rgb] = limitRange(value, max);
        return clone2;
      }
      _c(input) {
        return new this.constructor(input);
      }
      getMax() {
        if (typeof this._max === "undefined") {
          this._max = Math.max(this.r, this.g, this.b);
        }
        return this._max;
      }
      getMin() {
        if (typeof this._min === "undefined") {
          this._min = Math.min(this.r, this.g, this.b);
        }
        return this._min;
      }
      fromHexString(trimStr) {
        const withoutPrefix = trimStr.replace("#", "");
        function connectNum(index1, index2) {
          return parseInt(withoutPrefix[index1] + withoutPrefix[index2 || index1], 16);
        }
        if (withoutPrefix.length < 6) {
          this.r = connectNum(0);
          this.g = connectNum(1);
          this.b = connectNum(2);
          this.a = withoutPrefix[3] ? connectNum(3) / 255 : 1;
        } else {
          this.r = connectNum(0, 1);
          this.g = connectNum(2, 3);
          this.b = connectNum(4, 5);
          this.a = withoutPrefix[6] ? connectNum(6, 7) / 255 : 1;
        }
      }
      fromHsl({
        h: h2,
        s,
        l: l2,
        a
      }) {
        this._h = h2 % 360;
        this._s = s;
        this._l = l2;
        this.a = typeof a === "number" ? a : 1;
        if (s <= 0) {
          const rgb = round(l2 * 255);
          this.r = rgb;
          this.g = rgb;
          this.b = rgb;
        }
        let r2 = 0, g2 = 0, b2 = 0;
        const huePrime = h2 / 60;
        const chroma = (1 - Math.abs(2 * l2 - 1)) * s;
        const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
        if (huePrime >= 0 && huePrime < 1) {
          r2 = chroma;
          g2 = secondComponent;
        } else if (huePrime >= 1 && huePrime < 2) {
          r2 = secondComponent;
          g2 = chroma;
        } else if (huePrime >= 2 && huePrime < 3) {
          g2 = chroma;
          b2 = secondComponent;
        } else if (huePrime >= 3 && huePrime < 4) {
          g2 = secondComponent;
          b2 = chroma;
        } else if (huePrime >= 4 && huePrime < 5) {
          r2 = secondComponent;
          b2 = chroma;
        } else if (huePrime >= 5 && huePrime < 6) {
          r2 = chroma;
          b2 = secondComponent;
        }
        const lightnessModification = l2 - chroma / 2;
        this.r = round((r2 + lightnessModification) * 255);
        this.g = round((g2 + lightnessModification) * 255);
        this.b = round((b2 + lightnessModification) * 255);
      }
      fromHsv({
        h: h2,
        s,
        v: v2,
        a
      }) {
        this._h = h2 % 360;
        this._s = s;
        this._v = v2;
        this.a = typeof a === "number" ? a : 1;
        const vv = round(v2 * 255);
        this.r = vv;
        this.g = vv;
        this.b = vv;
        if (s <= 0) {
          return;
        }
        const hh = h2 / 60;
        const i2 = Math.floor(hh);
        const ff = hh - i2;
        const p2 = round(v2 * (1 - s) * 255);
        const q2 = round(v2 * (1 - s * ff) * 255);
        const t2 = round(v2 * (1 - s * (1 - ff)) * 255);
        switch (i2) {
          case 0:
            this.g = t2;
            this.b = p2;
            break;
          case 1:
            this.r = q2;
            this.b = p2;
            break;
          case 2:
            this.r = p2;
            this.b = t2;
            break;
          case 3:
            this.r = p2;
            this.g = q2;
            break;
          case 4:
            this.r = t2;
            this.g = p2;
            break;
          case 5:
          default:
            this.g = p2;
            this.b = q2;
            break;
        }
      }
      fromHsvString(trimStr) {
        const cells = splitColorStr(trimStr, parseHSVorHSL);
        this.fromHsv({
          h: cells[0],
          s: cells[1],
          v: cells[2],
          a: cells[3]
        });
      }
      fromHslString(trimStr) {
        const cells = splitColorStr(trimStr, parseHSVorHSL);
        this.fromHsl({
          h: cells[0],
          s: cells[1],
          l: cells[2],
          a: cells[3]
        });
      }
      fromRgbString(trimStr) {
        const cells = splitColorStr(trimStr, (num, txt) => (
          // Convert percentage to number. e.g. 50% -> 128
          txt.includes("%") ? round(num / 100 * 255) : num
        ));
        this.r = cells[0];
        this.g = cells[1];
        this.b = cells[2];
        this.a = cells[3];
      }
    }
    var hueStep = 2;
    var saturationStep = 0.16;
    var saturationStep2 = 0.05;
    var brightnessStep1 = 0.05;
    var brightnessStep2 = 0.15;
    var lightColorCount = 5;
    var darkColorCount = 4;
    var darkColorMap = [{
      index: 7,
      amount: 15
    }, {
      index: 6,
      amount: 25
    }, {
      index: 5,
      amount: 30
    }, {
      index: 5,
      amount: 45
    }, {
      index: 5,
      amount: 65
    }, {
      index: 5,
      amount: 85
    }, {
      index: 4,
      amount: 90
    }, {
      index: 3,
      amount: 95
    }, {
      index: 2,
      amount: 97
    }, {
      index: 1,
      amount: 98
    }];
    function getHue(hsv, i2, light) {
      var hue;
      if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
        hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
      } else {
        hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
      }
      if (hue < 0) {
        hue += 360;
      } else if (hue >= 360) {
        hue -= 360;
      }
      return hue;
    }
    function getSaturation(hsv, i2, light) {
      if (hsv.h === 0 && hsv.s === 0) {
        return hsv.s;
      }
      var saturation;
      if (light) {
        saturation = hsv.s - saturationStep * i2;
      } else if (i2 === darkColorCount) {
        saturation = hsv.s + saturationStep;
      } else {
        saturation = hsv.s + saturationStep2 * i2;
      }
      if (saturation > 1) {
        saturation = 1;
      }
      if (light && i2 === lightColorCount && saturation > 0.1) {
        saturation = 0.1;
      }
      if (saturation < 0.06) {
        saturation = 0.06;
      }
      return Math.round(saturation * 100) / 100;
    }
    function getValue$2(hsv, i2, light) {
      var value;
      if (light) {
        value = hsv.v + brightnessStep1 * i2;
      } else {
        value = hsv.v - brightnessStep2 * i2;
      }
      value = Math.max(0, Math.min(1, value));
      return Math.round(value * 100) / 100;
    }
    function generate$2(color) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var patterns = [];
      var pColor = new FastColor(color);
      var hsv = pColor.toHsv();
      for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
        var c2 = new FastColor({
          h: getHue(hsv, i2, true),
          s: getSaturation(hsv, i2, true),
          v: getValue$2(hsv, i2, true)
        });
        patterns.push(c2);
      }
      patterns.push(pColor);
      for (var _i = 1; _i <= darkColorCount; _i += 1) {
        var _c = new FastColor({
          h: getHue(hsv, _i),
          s: getSaturation(hsv, _i),
          v: getValue$2(hsv, _i)
        });
        patterns.push(_c);
      }
      if (opts.theme === "dark") {
        return darkColorMap.map(function(_ref) {
          var index2 = _ref.index, amount = _ref.amount;
          return new FastColor(opts.backgroundColor || "#141414").mix(patterns[index2], amount).toHexString();
        });
      }
      return patterns.map(function(c3) {
        return c3.toHexString();
      });
    }
    var presetPrimaryColors = {
      "red": "#F5222D",
      "volcano": "#FA541C",
      "orange": "#FA8C16",
      "gold": "#FAAD14",
      "yellow": "#FADB14",
      "lime": "#A0D911",
      "green": "#52C41A",
      "cyan": "#13C2C2",
      "blue": "#1677FF",
      "geekblue": "#2F54EB",
      "purple": "#722ED1",
      "magenta": "#EB2F96",
      "grey": "#666666"
    };
    var red = ["#fff1f0", "#ffccc7", "#ffa39e", "#ff7875", "#ff4d4f", "#f5222d", "#cf1322", "#a8071a", "#820014", "#5c0011"];
    red.primary = red[5];
    var volcano = ["#fff2e8", "#ffd8bf", "#ffbb96", "#ff9c6e", "#ff7a45", "#fa541c", "#d4380d", "#ad2102", "#871400", "#610b00"];
    volcano.primary = volcano[5];
    var orange = ["#fff7e6", "#ffe7ba", "#ffd591", "#ffc069", "#ffa940", "#fa8c16", "#d46b08", "#ad4e00", "#873800", "#612500"];
    orange.primary = orange[5];
    var gold = ["#fffbe6", "#fff1b8", "#ffe58f", "#ffd666", "#ffc53d", "#faad14", "#d48806", "#ad6800", "#874d00", "#613400"];
    gold.primary = gold[5];
    var yellow = ["#feffe6", "#ffffb8", "#fffb8f", "#fff566", "#ffec3d", "#fadb14", "#d4b106", "#ad8b00", "#876800", "#614700"];
    yellow.primary = yellow[5];
    var lime = ["#fcffe6", "#f4ffb8", "#eaff8f", "#d3f261", "#bae637", "#a0d911", "#7cb305", "#5b8c00", "#3f6600", "#254000"];
    lime.primary = lime[5];
    var green = ["#f6ffed", "#d9f7be", "#b7eb8f", "#95de64", "#73d13d", "#52c41a", "#389e0d", "#237804", "#135200", "#092b00"];
    green.primary = green[5];
    var cyan = ["#e6fffb", "#b5f5ec", "#87e8de", "#5cdbd3", "#36cfc9", "#13c2c2", "#08979c", "#006d75", "#00474f", "#002329"];
    cyan.primary = cyan[5];
    var blue = ["#e6f4ff", "#bae0ff", "#91caff", "#69b1ff", "#4096ff", "#1677ff", "#0958d9", "#003eb3", "#002c8c", "#001d66"];
    blue.primary = blue[5];
    var geekblue = ["#f0f5ff", "#d6e4ff", "#adc6ff", "#85a5ff", "#597ef7", "#2f54eb", "#1d39c4", "#10239e", "#061178", "#030852"];
    geekblue.primary = geekblue[5];
    var purple = ["#f9f0ff", "#efdbff", "#d3adf7", "#b37feb", "#9254de", "#722ed1", "#531dab", "#391085", "#22075e", "#120338"];
    purple.primary = purple[5];
    var magenta = ["#fff0f6", "#ffd6e7", "#ffadd2", "#ff85c0", "#f759ab", "#eb2f96", "#c41d7f", "#9e1068", "#780650", "#520339"];
    magenta.primary = magenta[5];
    var grey = ["#a6a6a6", "#999999", "#8c8c8c", "#808080", "#737373", "#666666", "#404040", "#1a1a1a", "#000000", "#000000"];
    grey.primary = grey[5];
    var gray = grey;
    var presetPalettes = {
      red,
      volcano,
      orange,
      gold,
      yellow,
      lime,
      green,
      cyan,
      blue,
      geekblue,
      purple,
      magenta,
      grey
    };
    var redDark = ["#2a1215", "#431418", "#58181c", "#791a1f", "#a61d24", "#d32029", "#e84749", "#f37370", "#f89f9a", "#fac8c3"];
    redDark.primary = redDark[5];
    var volcanoDark = ["#2b1611", "#441d12", "#592716", "#7c3118", "#aa3e19", "#d84a1b", "#e87040", "#f3956a", "#f8b692", "#fad4bc"];
    volcanoDark.primary = volcanoDark[5];
    var orangeDark = ["#2b1d11", "#442a11", "#593815", "#7c4a15", "#aa6215", "#d87a16", "#e89a3c", "#f3b765", "#f8cf8d", "#fae3b7"];
    orangeDark.primary = orangeDark[5];
    var goldDark = ["#2b2111", "#443111", "#594214", "#7c5914", "#aa7714", "#d89614", "#e8b339", "#f3cc62", "#f8df8b", "#faedb5"];
    goldDark.primary = goldDark[5];
    var yellowDark = ["#2b2611", "#443b11", "#595014", "#7c6e14", "#aa9514", "#d8bd14", "#e8d639", "#f3ea62", "#f8f48b", "#fafab5"];
    yellowDark.primary = yellowDark[5];
    var limeDark = ["#1f2611", "#2e3c10", "#3e4f13", "#536d13", "#6f9412", "#8bbb11", "#a9d134", "#c9e75d", "#e4f88b", "#f0fab5"];
    limeDark.primary = limeDark[5];
    var greenDark = ["#162312", "#1d3712", "#274916", "#306317", "#3c8618", "#49aa19", "#6abe39", "#8fd460", "#b2e58b", "#d5f2bb"];
    greenDark.primary = greenDark[5];
    var cyanDark = ["#112123", "#113536", "#144848", "#146262", "#138585", "#13a8a8", "#33bcb7", "#58d1c9", "#84e2d8", "#b2f1e8"];
    cyanDark.primary = cyanDark[5];
    var blueDark = ["#111a2c", "#112545", "#15325b", "#15417e", "#1554ad", "#1668dc", "#3c89e8", "#65a9f3", "#8dc5f8", "#b7dcfa"];
    blueDark.primary = blueDark[5];
    var geekblueDark = ["#131629", "#161d40", "#1c2755", "#203175", "#263ea0", "#2b4acb", "#5273e0", "#7f9ef3", "#a8c1f8", "#d2e0fa"];
    geekblueDark.primary = geekblueDark[5];
    var purpleDark = ["#1a1325", "#24163a", "#301c4d", "#3e2069", "#51258f", "#642ab5", "#854eca", "#ab7ae0", "#cda8f0", "#ebd7fa"];
    purpleDark.primary = purpleDark[5];
    var magentaDark = ["#291321", "#40162f", "#551c3b", "#75204f", "#a02669", "#cb2b83", "#e0529c", "#f37fb7", "#f8a8cc", "#fad2e3"];
    magentaDark.primary = magentaDark[5];
    var greyDark = ["#151515", "#1f1f1f", "#2d2d2d", "#393939", "#494949", "#5a5a5a", "#6a6a6a", "#7b7b7b", "#888888", "#969696"];
    greyDark.primary = greyDark[5];
    var presetDarkPalettes = {
      red: redDark,
      volcano: volcanoDark,
      orange: orangeDark,
      gold: goldDark,
      yellow: yellowDark,
      lime: limeDark,
      green: greenDark,
      cyan: cyanDark,
      blue: blueDark,
      geekblue: geekblueDark,
      purple: purpleDark,
      magenta: magentaDark,
      grey: greyDark
    };
    const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      blue,
      blueDark,
      cyan,
      cyanDark,
      geekblue,
      geekblueDark,
      generate: generate$2,
      gold,
      goldDark,
      gray,
      green,
      greenDark,
      grey,
      greyDark,
      lime,
      limeDark,
      magenta,
      magentaDark,
      orange,
      orangeDark,
      presetDarkPalettes,
      presetPalettes,
      presetPrimaryColors,
      purple,
      purpleDark,
      red,
      redDark,
      volcano,
      volcanoDark,
      yellow,
      yellowDark
    }, Symbol.toStringTag, { value: "Module" }));
    function genColorMapToken(seed, _ref) {
      let {
        generateColorPalettes: generateColorPalettes2,
        generateNeutralColorPalettes: generateNeutralColorPalettes2
      } = _ref;
      const {
        colorSuccess: colorSuccessBase,
        colorWarning: colorWarningBase,
        colorError: colorErrorBase,
        colorInfo: colorInfoBase,
        colorPrimary: colorPrimaryBase,
        colorBgBase,
        colorTextBase
      } = seed;
      const primaryColors = generateColorPalettes2(colorPrimaryBase);
      const successColors = generateColorPalettes2(colorSuccessBase);
      const warningColors = generateColorPalettes2(colorWarningBase);
      const errorColors = generateColorPalettes2(colorErrorBase);
      const infoColors = generateColorPalettes2(colorInfoBase);
      const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
      const colorLink = seed.colorLink || seed.colorInfo;
      const linkColors = generateColorPalettes2(colorLink);
      const colorErrorBgFilledHover = new FastColor(errorColors[1]).mix(new FastColor(errorColors[3]), 50).toHexString();
      return Object.assign(Object.assign({}, neutralColors), {
        colorPrimaryBg: primaryColors[1],
        colorPrimaryBgHover: primaryColors[2],
        colorPrimaryBorder: primaryColors[3],
        colorPrimaryBorderHover: primaryColors[4],
        colorPrimaryHover: primaryColors[5],
        colorPrimary: primaryColors[6],
        colorPrimaryActive: primaryColors[7],
        colorPrimaryTextHover: primaryColors[8],
        colorPrimaryText: primaryColors[9],
        colorPrimaryTextActive: primaryColors[10],
        colorSuccessBg: successColors[1],
        colorSuccessBgHover: successColors[2],
        colorSuccessBorder: successColors[3],
        colorSuccessBorderHover: successColors[4],
        colorSuccessHover: successColors[4],
        colorSuccess: successColors[6],
        colorSuccessActive: successColors[7],
        colorSuccessTextHover: successColors[8],
        colorSuccessText: successColors[9],
        colorSuccessTextActive: successColors[10],
        colorErrorBg: errorColors[1],
        colorErrorBgHover: errorColors[2],
        colorErrorBgFilledHover,
        colorErrorBgActive: errorColors[3],
        colorErrorBorder: errorColors[3],
        colorErrorBorderHover: errorColors[4],
        colorErrorHover: errorColors[5],
        colorError: errorColors[6],
        colorErrorActive: errorColors[7],
        colorErrorTextHover: errorColors[8],
        colorErrorText: errorColors[9],
        colorErrorTextActive: errorColors[10],
        colorWarningBg: warningColors[1],
        colorWarningBgHover: warningColors[2],
        colorWarningBorder: warningColors[3],
        colorWarningBorderHover: warningColors[4],
        colorWarningHover: warningColors[4],
        colorWarning: warningColors[6],
        colorWarningActive: warningColors[7],
        colorWarningTextHover: warningColors[8],
        colorWarningText: warningColors[9],
        colorWarningTextActive: warningColors[10],
        colorInfoBg: infoColors[1],
        colorInfoBgHover: infoColors[2],
        colorInfoBorder: infoColors[3],
        colorInfoBorderHover: infoColors[4],
        colorInfoHover: infoColors[4],
        colorInfo: infoColors[6],
        colorInfoActive: infoColors[7],
        colorInfoTextHover: infoColors[8],
        colorInfoText: infoColors[9],
        colorInfoTextActive: infoColors[10],
        colorLinkHover: linkColors[4],
        colorLink: linkColors[6],
        colorLinkActive: linkColors[7],
        colorBgMask: new FastColor("#000").setA(0.45).toRgbString(),
        colorWhite: "#fff"
      });
    }
    const genRadius = (radiusBase) => {
      let radiusLG = radiusBase;
      let radiusSM = radiusBase;
      let radiusXS = radiusBase;
      let radiusOuter = radiusBase;
      if (radiusBase < 6 && radiusBase >= 5) {
        radiusLG = radiusBase + 1;
      } else if (radiusBase < 16 && radiusBase >= 6) {
        radiusLG = radiusBase + 2;
      } else if (radiusBase >= 16) {
        radiusLG = 16;
      }
      if (radiusBase < 7 && radiusBase >= 5) {
        radiusSM = 4;
      } else if (radiusBase < 8 && radiusBase >= 7) {
        radiusSM = 5;
      } else if (radiusBase < 14 && radiusBase >= 8) {
        radiusSM = 6;
      } else if (radiusBase < 16 && radiusBase >= 14) {
        radiusSM = 7;
      } else if (radiusBase >= 16) {
        radiusSM = 8;
      }
      if (radiusBase < 6 && radiusBase >= 2) {
        radiusXS = 1;
      } else if (radiusBase >= 6) {
        radiusXS = 2;
      }
      if (radiusBase > 4 && radiusBase < 8) {
        radiusOuter = 4;
      } else if (radiusBase >= 8) {
        radiusOuter = 6;
      }
      return {
        borderRadius: radiusBase,
        borderRadiusXS: radiusXS,
        borderRadiusSM: radiusSM,
        borderRadiusLG: radiusLG,
        borderRadiusOuter: radiusOuter
      };
    };
    function genCommonMapToken(token2) {
      const {
        motionUnit,
        motionBase,
        borderRadius,
        lineWidth
      } = token2;
      return Object.assign({
        // motion
        motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
        motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
        motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
        // line
        lineWidthBold: lineWidth + 1
      }, genRadius(borderRadius));
    }
    const genControlHeight = (token2) => {
      const {
        controlHeight
      } = token2;
      return {
        controlHeightSM: controlHeight * 0.75,
        controlHeightXS: controlHeight * 0.5,
        controlHeightLG: controlHeight * 1.25
      };
    };
    function getLineHeight(fontSize) {
      return (fontSize + 8) / fontSize;
    }
    function getFontSizes(base) {
      const fontSizes = Array.from({
        length: 10
      }).map((_2, index2) => {
        const i2 = index2 - 1;
        const baseSize = base * Math.pow(Math.E, i2 / 5);
        const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
        return Math.floor(intSize / 2) * 2;
      });
      fontSizes[1] = base;
      return fontSizes.map((size) => ({
        size,
        lineHeight: getLineHeight(size)
      }));
    }
    const genFontMapToken = (fontSize) => {
      const fontSizePairs = getFontSizes(fontSize);
      const fontSizes = fontSizePairs.map((pair) => pair.size);
      const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
      const fontSizeMD = fontSizes[1];
      const fontSizeSM = fontSizes[0];
      const fontSizeLG = fontSizes[2];
      const lineHeight = lineHeights[1];
      const lineHeightSM = lineHeights[0];
      const lineHeightLG = lineHeights[2];
      return {
        fontSizeSM,
        fontSize: fontSizeMD,
        fontSizeLG,
        fontSizeXL: fontSizes[3],
        fontSizeHeading1: fontSizes[6],
        fontSizeHeading2: fontSizes[5],
        fontSizeHeading3: fontSizes[4],
        fontSizeHeading4: fontSizes[3],
        fontSizeHeading5: fontSizes[2],
        lineHeight,
        lineHeightLG,
        lineHeightSM,
        fontHeight: Math.round(lineHeight * fontSizeMD),
        fontHeightLG: Math.round(lineHeightLG * fontSizeLG),
        fontHeightSM: Math.round(lineHeightSM * fontSizeSM),
        lineHeightHeading1: lineHeights[6],
        lineHeightHeading2: lineHeights[5],
        lineHeightHeading3: lineHeights[4],
        lineHeightHeading4: lineHeights[3],
        lineHeightHeading5: lineHeights[2]
      };
    };
    function genSizeMapToken(token2) {
      const {
        sizeUnit,
        sizeStep
      } = token2;
      return {
        sizeXXL: sizeUnit * (sizeStep + 8),
        // 48
        sizeXL: sizeUnit * (sizeStep + 4),
        // 32
        sizeLG: sizeUnit * (sizeStep + 2),
        // 24
        sizeMD: sizeUnit * (sizeStep + 1),
        // 20
        sizeMS: sizeUnit * sizeStep,
        // 16
        size: sizeUnit * sizeStep,
        // 16
        sizeSM: sizeUnit * (sizeStep - 1),
        // 12
        sizeXS: sizeUnit * (sizeStep - 2),
        // 8
        sizeXXS: sizeUnit * (sizeStep - 3)
        // 4
      };
    }
    const getAlphaColor$1 = (baseColor, alpha) => new FastColor(baseColor).setA(alpha).toRgbString();
    const getSolidColor = (baseColor, brightness) => {
      const instance = new FastColor(baseColor);
      return instance.darken(brightness).toHexString();
    };
    const generateColorPalettes = (baseColor) => {
      const colors = generate$2(baseColor);
      return {
        1: colors[0],
        2: colors[1],
        3: colors[2],
        4: colors[3],
        5: colors[4],
        6: colors[5],
        7: colors[6],
        8: colors[4],
        9: colors[5],
        10: colors[6]
        // 8: colors[7],
        // 9: colors[8],
        // 10: colors[9],
      };
    };
    const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
      const colorBgBase = bgBaseColor || "#fff";
      const colorTextBase = textBaseColor || "#000";
      return {
        colorBgBase,
        colorTextBase,
        colorText: getAlphaColor$1(colorTextBase, 0.88),
        colorTextSecondary: getAlphaColor$1(colorTextBase, 0.65),
        colorTextTertiary: getAlphaColor$1(colorTextBase, 0.45),
        colorTextQuaternary: getAlphaColor$1(colorTextBase, 0.25),
        colorFill: getAlphaColor$1(colorTextBase, 0.15),
        colorFillSecondary: getAlphaColor$1(colorTextBase, 0.06),
        colorFillTertiary: getAlphaColor$1(colorTextBase, 0.04),
        colorFillQuaternary: getAlphaColor$1(colorTextBase, 0.02),
        colorBgSolid: getAlphaColor$1(colorTextBase, 1),
        colorBgSolidHover: getAlphaColor$1(colorTextBase, 0.75),
        colorBgSolidActive: getAlphaColor$1(colorTextBase, 0.95),
        colorBgLayout: getSolidColor(colorBgBase, 4),
        colorBgContainer: getSolidColor(colorBgBase, 0),
        colorBgElevated: getSolidColor(colorBgBase, 0),
        colorBgSpotlight: getAlphaColor$1(colorTextBase, 0.85),
        colorBgBlur: "transparent",
        colorBorder: getSolidColor(colorBgBase, 15),
        colorBorderSecondary: getSolidColor(colorBgBase, 6)
      };
    };
    function derivative(token2) {
      presetPrimaryColors.pink = presetPrimaryColors.magenta;
      presetPalettes.pink = presetPalettes.magenta;
      const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
        const colors = token2[colorKey] === presetPrimaryColors[colorKey] ? presetPalettes[colorKey] : generate$2(token2[colorKey]);
        return Array.from({
          length: 10
        }, () => 1).reduce((prev2, _2, i2) => {
          prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
          prev2[`${colorKey}${i2 + 1}`] = colors[i2];
          return prev2;
        }, {});
      }).reduce((prev2, cur) => {
        prev2 = Object.assign(Object.assign({}, prev2), cur);
        return prev2;
      }, {});
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token2), colorPalettes), genColorMapToken(token2, {
        generateColorPalettes,
        generateNeutralColorPalettes
      })), genFontMapToken(token2.fontSize)), genSizeMapToken(token2)), genControlHeight(token2)), genCommonMapToken(token2));
    }
    const defaultTheme = createTheme(derivative);
    const defaultConfig = {
      token: seedToken,
      override: {
        override: seedToken
      },
      hashed: true
    };
    const DesignTokenContext = /* @__PURE__ */ i.createContext(defaultConfig);
    const defaultPrefixCls = "ant";
    const defaultIconPrefixCls = "anticon";
    const Variants = ["outlined", "borderless", "filled", "underlined"];
    const defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls) {
        return customizePrefixCls;
      }
      return suffixCls ? `${defaultPrefixCls}-${suffixCls}` : defaultPrefixCls;
    };
    const ConfigContext = /* @__PURE__ */ reactExports.createContext({
      // We provide a default function for Context without provider
      getPrefixCls: defaultGetPrefixCls,
      iconPrefixCls: defaultIconPrefixCls
    });
    const {
      Consumer: ConfigConsumer
    } = ConfigContext;
    const EMPTY_OBJECT = {};
    function useComponentConfig(propName) {
      const context = reactExports.useContext(ConfigContext);
      const {
        getPrefixCls,
        direction,
        getPopupContainer
      } = context;
      const propValue = context[propName];
      return Object.assign(Object.assign({
        classNames: EMPTY_OBJECT,
        styles: EMPTY_OBJECT
      }, propValue), {
        getPrefixCls,
        direction,
        getPopupContainer
      });
    }
    const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
    function getStyle$1(globalPrefixCls2, theme) {
      const variables = {};
      const formatColor = (color, updater) => {
        let clone2 = color.clone();
        clone2 = (updater === null || updater === void 0 ? void 0 : updater(clone2)) || clone2;
        return clone2.toRgbString();
      };
      const fillColor = (colorVal, type2) => {
        const baseColor = new FastColor(colorVal);
        const colorPalettes = generate$2(baseColor.toRgbString());
        variables[`${type2}-color`] = formatColor(baseColor);
        variables[`${type2}-color-disabled`] = colorPalettes[1];
        variables[`${type2}-color-hover`] = colorPalettes[4];
        variables[`${type2}-color-active`] = colorPalettes[6];
        variables[`${type2}-color-outline`] = baseColor.clone().setA(0.2).toRgbString();
        variables[`${type2}-color-deprecated-bg`] = colorPalettes[0];
        variables[`${type2}-color-deprecated-border`] = colorPalettes[2];
      };
      if (theme.primaryColor) {
        fillColor(theme.primaryColor, "primary");
        const primaryColor = new FastColor(theme.primaryColor);
        const primaryColors = generate$2(primaryColor.toRgbString());
        primaryColors.forEach((color, index2) => {
          variables[`primary-${index2 + 1}`] = color;
        });
        variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
        variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
        variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
        variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
        variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setA(c2.a * 0.12));
        const primaryActiveColor = new FastColor(primaryColors[0]);
        variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setA(c2.a * 0.3));
        variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
      }
      if (theme.successColor) {
        fillColor(theme.successColor, "success");
      }
      if (theme.warningColor) {
        fillColor(theme.warningColor, "warning");
      }
      if (theme.errorColor) {
        fillColor(theme.errorColor, "error");
      }
      if (theme.infoColor) {
        fillColor(theme.infoColor, "info");
      }
      const cssList = Object.keys(variables).map((key) => `--${globalPrefixCls2}-${key}: ${variables[key]};`);
      return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
    }
    function registerTheme(globalPrefixCls2, theme) {
      const style2 = getStyle$1(globalPrefixCls2, theme);
      if (canUseDom$2()) {
        updateCSS$1(style2, `${dynamicStyleMark}-dynamic-theme`);
      }
    }
    const DisabledContext = /* @__PURE__ */ reactExports.createContext(false);
    const DisabledContextProvider = (_ref) => {
      let {
        children,
        disabled
      } = _ref;
      const originDisabled = reactExports.useContext(DisabledContext);
      return /* @__PURE__ */ reactExports.createElement(DisabledContext.Provider, {
        value: disabled !== null && disabled !== void 0 ? disabled : originDisabled
      }, children);
    };
    const SizeContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const SizeContextProvider = (_ref) => {
      let {
        children,
        size
      } = _ref;
      const originSize = reactExports.useContext(SizeContext);
      return /* @__PURE__ */ reactExports.createElement(SizeContext.Provider, {
        value: size || originSize
      }, children);
    };
    function useConfig() {
      const componentDisabled = reactExports.useContext(DisabledContext);
      const componentSize = reactExports.useContext(SizeContext);
      return {
        componentDisabled,
        componentSize
      };
    }
    var AbstractCalculator = /* @__PURE__ */ _createClass(function AbstractCalculator2() {
      _classCallCheck(this, AbstractCalculator2);
    });
    var CALC_UNIT = "CALC_UNIT";
    var regexp$1 = new RegExp(CALC_UNIT, "g");
    function unit(value) {
      if (typeof value === "number") {
        return "".concat(value).concat(CALC_UNIT);
      }
      return value;
    }
    var CSSCalculator = /* @__PURE__ */ function(_AbstractCalculator) {
      _inherits(CSSCalculator2, _AbstractCalculator);
      var _super = _createSuper(CSSCalculator2);
      function CSSCalculator2(num, unitlessCssVar) {
        var _this;
        _classCallCheck(this, CSSCalculator2);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "result", "");
        _defineProperty(_assertThisInitialized(_this), "unitlessCssVar", void 0);
        _defineProperty(_assertThisInitialized(_this), "lowPriority", void 0);
        var numType = _typeof$1(num);
        _this.unitlessCssVar = unitlessCssVar;
        if (num instanceof CSSCalculator2) {
          _this.result = "(".concat(num.result, ")");
        } else if (numType === "number") {
          _this.result = unit(num);
        } else if (numType === "string") {
          _this.result = num;
        }
        return _this;
      }
      _createClass(CSSCalculator2, [{
        key: "add",
        value: function add(num) {
          if (num instanceof CSSCalculator2) {
            this.result = "".concat(this.result, " + ").concat(num.getResult());
          } else if (typeof num === "number" || typeof num === "string") {
            this.result = "".concat(this.result, " + ").concat(unit(num));
          }
          this.lowPriority = true;
          return this;
        }
      }, {
        key: "sub",
        value: function sub(num) {
          if (num instanceof CSSCalculator2) {
            this.result = "".concat(this.result, " - ").concat(num.getResult());
          } else if (typeof num === "number" || typeof num === "string") {
            this.result = "".concat(this.result, " - ").concat(unit(num));
          }
          this.lowPriority = true;
          return this;
        }
      }, {
        key: "mul",
        value: function mul(num) {
          if (this.lowPriority) {
            this.result = "(".concat(this.result, ")");
          }
          if (num instanceof CSSCalculator2) {
            this.result = "".concat(this.result, " * ").concat(num.getResult(true));
          } else if (typeof num === "number" || typeof num === "string") {
            this.result = "".concat(this.result, " * ").concat(num);
          }
          this.lowPriority = false;
          return this;
        }
      }, {
        key: "div",
        value: function div(num) {
          if (this.lowPriority) {
            this.result = "(".concat(this.result, ")");
          }
          if (num instanceof CSSCalculator2) {
            this.result = "".concat(this.result, " / ").concat(num.getResult(true));
          } else if (typeof num === "number" || typeof num === "string") {
            this.result = "".concat(this.result, " / ").concat(num);
          }
          this.lowPriority = false;
          return this;
        }
      }, {
        key: "getResult",
        value: function getResult(force) {
          return this.lowPriority || force ? "(".concat(this.result, ")") : this.result;
        }
      }, {
        key: "equal",
        value: function equal2(options2) {
          var _this2 = this;
          var _ref = options2 || {}, cssUnit = _ref.unit;
          var mergedUnit = true;
          if (typeof cssUnit === "boolean") {
            mergedUnit = cssUnit;
          } else if (Array.from(this.unitlessCssVar).some(function(cssVar) {
            return _this2.result.includes(cssVar);
          })) {
            mergedUnit = false;
          }
          this.result = this.result.replace(regexp$1, mergedUnit ? "px" : "");
          if (typeof this.lowPriority !== "undefined") {
            return "calc(".concat(this.result, ")");
          }
          return this.result;
        }
      }]);
      return CSSCalculator2;
    }(AbstractCalculator);
    var NumCalculator = /* @__PURE__ */ function(_AbstractCalculator) {
      _inherits(NumCalculator2, _AbstractCalculator);
      var _super = _createSuper(NumCalculator2);
      function NumCalculator2(num) {
        var _this;
        _classCallCheck(this, NumCalculator2);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "result", 0);
        if (num instanceof NumCalculator2) {
          _this.result = num.result;
        } else if (typeof num === "number") {
          _this.result = num;
        }
        return _this;
      }
      _createClass(NumCalculator2, [{
        key: "add",
        value: function add(num) {
          if (num instanceof NumCalculator2) {
            this.result += num.result;
          } else if (typeof num === "number") {
            this.result += num;
          }
          return this;
        }
      }, {
        key: "sub",
        value: function sub(num) {
          if (num instanceof NumCalculator2) {
            this.result -= num.result;
          } else if (typeof num === "number") {
            this.result -= num;
          }
          return this;
        }
      }, {
        key: "mul",
        value: function mul(num) {
          if (num instanceof NumCalculator2) {
            this.result *= num.result;
          } else if (typeof num === "number") {
            this.result *= num;
          }
          return this;
        }
      }, {
        key: "div",
        value: function div(num) {
          if (num instanceof NumCalculator2) {
            this.result /= num.result;
          } else if (typeof num === "number") {
            this.result /= num;
          }
          return this;
        }
      }, {
        key: "equal",
        value: function equal2() {
          return this.result;
        }
      }]);
      return NumCalculator2;
    }(AbstractCalculator);
    var genCalc = function genCalc2(type2, unitlessCssVar) {
      var Calculator = type2 === "css" ? CSSCalculator : NumCalculator;
      return function(num) {
        return new Calculator(num, unitlessCssVar);
      };
    };
    var getCompVarPrefix = function getCompVarPrefix2(component, prefix2) {
      return "".concat([prefix2, component.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-"));
    };
    function useEvent(callback) {
      var fnRef = reactExports.useRef();
      fnRef.current = callback;
      var memoFn = reactExports.useCallback(function() {
        var _fnRef$current;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
      }, []);
      return memoFn;
    }
    function useSafeState(defaultValue) {
      var destroyRef = reactExports.useRef(false);
      var _React$useState = reactExports.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue = _React$useState2[1];
      reactExports.useEffect(function() {
        destroyRef.current = false;
        return function() {
          destroyRef.current = true;
        };
      }, []);
      function safeSetState(updater, ignoreDestroy) {
        if (ignoreDestroy && destroyRef.current) {
          return;
        }
        setValue(updater);
      }
      return [value, safeSetState];
    }
    function hasValue$1(value) {
      return value !== void 0;
    }
    function useMergedState(defaultStateValue, option) {
      var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState;
      var _useState = useSafeState(function() {
        if (hasValue$1(value)) {
          return value;
        } else if (hasValue$1(defaultValue)) {
          return typeof defaultValue === "function" ? defaultValue() : defaultValue;
        } else {
          return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
        }
      }), _useState2 = _slicedToArray(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
      var mergedValue = value !== void 0 ? value : innerValue;
      var postMergedValue = postState ? postState(mergedValue) : mergedValue;
      var onChangeFn = useEvent(onChange);
      var _useState3 = useSafeState([mergedValue]), _useState4 = _slicedToArray(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
      useLayoutUpdateEffect(function() {
        var prev2 = prevValue[0];
        if (innerValue !== prev2) {
          onChangeFn(innerValue, prev2);
        }
      }, [prevValue]);
      useLayoutUpdateEffect(function() {
        if (!hasValue$1(value)) {
          setInnerValue(value);
        }
      }, [value]);
      var triggerChange = useEvent(function(updater, ignoreDestroy) {
        setInnerValue(updater, ignoreDestroy);
        setPrevValue([mergedValue], ignoreDestroy);
      });
      return [postMergedValue, triggerChange];
    }
    function getComponentToken(component, token2, defaultToken, options2) {
      var customToken = _objectSpread2$3({}, token2[component]);
      if (options2 !== null && options2 !== void 0 && options2.deprecatedTokens) {
        var deprecatedTokens = options2.deprecatedTokens;
        deprecatedTokens.forEach(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), oldTokenKey = _ref2[0], newTokenKey = _ref2[1];
          if (customToken !== null && customToken !== void 0 && customToken[oldTokenKey] || customToken !== null && customToken !== void 0 && customToken[newTokenKey]) {
            var _customToken$newToken;
            (_customToken$newToken = customToken[newTokenKey]) !== null && _customToken$newToken !== void 0 ? _customToken$newToken : customToken[newTokenKey] = customToken === null || customToken === void 0 ? void 0 : customToken[oldTokenKey];
          }
        });
      }
      var mergedToken = _objectSpread2$3(_objectSpread2$3({}, defaultToken), customToken);
      Object.keys(mergedToken).forEach(function(key) {
        if (mergedToken[key] === token2[key]) {
          delete mergedToken[key];
        }
      });
      return mergedToken;
    }
    var enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
    var recording = true;
    function merge() {
      for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
        objs[_key] = arguments[_key];
      }
      if (!enableStatistic) {
        return Object.assign.apply(Object, [{}].concat(objs));
      }
      recording = false;
      var ret = {};
      objs.forEach(function(obj) {
        if (_typeof$1(obj) !== "object") {
          return;
        }
        var keys2 = Object.keys(obj);
        keys2.forEach(function(key) {
          Object.defineProperty(ret, key, {
            configurable: true,
            enumerable: true,
            get: function get2() {
              return obj[key];
            }
          });
        });
      });
      recording = true;
      return ret;
    }
    var statistic = {};
    function noop$1() {
    }
    var statisticToken = function statisticToken2(token2) {
      var tokenKeys2;
      var proxy = token2;
      var flush = noop$1;
      if (enableStatistic && typeof Proxy !== "undefined") {
        tokenKeys2 = /* @__PURE__ */ new Set();
        proxy = new Proxy(token2, {
          get: function get2(obj, prop) {
            if (recording) {
              var _tokenKeys;
              (_tokenKeys = tokenKeys2) === null || _tokenKeys === void 0 || _tokenKeys.add(prop);
            }
            return obj[prop];
          }
        });
        flush = function flush2(componentName, componentToken) {
          var _statistic$componentN;
          statistic[componentName] = {
            global: Array.from(tokenKeys2),
            component: _objectSpread2$3(_objectSpread2$3({}, (_statistic$componentN = statistic[componentName]) === null || _statistic$componentN === void 0 ? void 0 : _statistic$componentN.component), componentToken)
          };
        };
      }
      return {
        token: proxy,
        keys: tokenKeys2,
        flush
      };
    };
    function getDefaultComponentToken(component, token2, getDefaultToken) {
      if (typeof getDefaultToken === "function") {
        var _token$component;
        return getDefaultToken(merge(token2, (_token$component = token2[component]) !== null && _token$component !== void 0 ? _token$component : {}));
      }
      return getDefaultToken !== null && getDefaultToken !== void 0 ? getDefaultToken : {};
    }
    function genMaxMin(type2) {
      if (type2 === "js") {
        return {
          max: Math.max,
          min: Math.min
        };
      }
      return {
        max: function max() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return "max(".concat(args.map(function(value) {
            return unit$1(value);
          }).join(","), ")");
        },
        min: function min() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return "min(".concat(args.map(function(value) {
            return unit$1(value);
          }).join(","), ")");
        }
      };
    }
    var BEAT_LIMIT = 1e3 * 60 * 10;
    var ArrayKeyMap = /* @__PURE__ */ function() {
      function ArrayKeyMap2() {
        _classCallCheck(this, ArrayKeyMap2);
        _defineProperty(this, "map", /* @__PURE__ */ new Map());
        _defineProperty(this, "objectIDMap", /* @__PURE__ */ new WeakMap());
        _defineProperty(this, "nextID", 0);
        _defineProperty(this, "lastAccessBeat", /* @__PURE__ */ new Map());
        _defineProperty(this, "accessBeat", 0);
      }
      _createClass(ArrayKeyMap2, [{
        key: "set",
        value: function set2(keys2, value) {
          this.clear();
          var compositeKey = this.getCompositeKey(keys2);
          this.map.set(compositeKey, value);
          this.lastAccessBeat.set(compositeKey, Date.now());
        }
      }, {
        key: "get",
        value: function get2(keys2) {
          var compositeKey = this.getCompositeKey(keys2);
          var cache = this.map.get(compositeKey);
          this.lastAccessBeat.set(compositeKey, Date.now());
          this.accessBeat += 1;
          return cache;
        }
      }, {
        key: "getCompositeKey",
        value: function getCompositeKey(keys2) {
          var _this = this;
          var ids = keys2.map(function(key) {
            if (key && _typeof$1(key) === "object") {
              return "obj_".concat(_this.getObjectID(key));
            }
            return "".concat(_typeof$1(key), "_").concat(key);
          });
          return ids.join("|");
        }
      }, {
        key: "getObjectID",
        value: function getObjectID(obj) {
          if (this.objectIDMap.has(obj)) {
            return this.objectIDMap.get(obj);
          }
          var id = this.nextID;
          this.objectIDMap.set(obj, id);
          this.nextID += 1;
          return id;
        }
      }, {
        key: "clear",
        value: function clear() {
          var _this2 = this;
          if (this.accessBeat > 1e4) {
            var now2 = Date.now();
            this.lastAccessBeat.forEach(function(beat, key) {
              if (now2 - beat > BEAT_LIMIT) {
                _this2.map.delete(key);
                _this2.lastAccessBeat.delete(key);
              }
            });
            this.accessBeat = 0;
          }
        }
      }]);
      return ArrayKeyMap2;
    }();
    var uniqueMap = new ArrayKeyMap();
    function useUniqueMemo(memoFn, deps) {
      return i.useMemo(function() {
        var cachedValue = uniqueMap.get(deps);
        if (cachedValue) {
          return cachedValue;
        }
        var newValue = memoFn();
        uniqueMap.set(deps, newValue);
        return newValue;
      }, deps);
    }
    var useDefaultCSP = function useDefaultCSP2() {
      return {};
    };
    function genStyleUtils(config) {
      var _config$useCSP = config.useCSP, useCSP = _config$useCSP === void 0 ? useDefaultCSP : _config$useCSP, useToken2 = config.useToken, usePrefix = config.usePrefix, getResetStyles2 = config.getResetStyles, getCommonStyle = config.getCommonStyle, getCompUnitless = config.getCompUnitless;
      function genStyleHooks2(component, styleFn, getDefaultToken, options2) {
        var componentName = Array.isArray(component) ? component[0] : component;
        function prefixToken(key) {
          return "".concat(String(componentName)).concat(key.slice(0, 1).toUpperCase()).concat(key.slice(1));
        }
        var originUnitless = (options2 === null || options2 === void 0 ? void 0 : options2.unitless) || {};
        var originCompUnitless = typeof getCompUnitless === "function" ? getCompUnitless(component) : {};
        var compUnitless = _objectSpread2$3(_objectSpread2$3({}, originCompUnitless), {}, _defineProperty({}, prefixToken("zIndexPopup"), true));
        Object.keys(originUnitless).forEach(function(key) {
          compUnitless[prefixToken(key)] = originUnitless[key];
        });
        var mergedOptions = _objectSpread2$3(_objectSpread2$3({}, options2), {}, {
          unitless: compUnitless,
          prefixToken
        });
        var useStyle2 = genComponentStyleHook2(component, styleFn, getDefaultToken, mergedOptions);
        var useCSSVar = genCSSVarRegister(componentName, getDefaultToken, mergedOptions);
        return function(prefixCls) {
          var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
          var _useStyle = useStyle2(prefixCls, rootCls), _useStyle2 = _slicedToArray(_useStyle, 2), hashId = _useStyle2[1];
          var _useCSSVar = useCSSVar(rootCls), _useCSSVar2 = _slicedToArray(_useCSSVar, 2), wrapCSSVar = _useCSSVar2[0], cssVarCls = _useCSSVar2[1];
          return [wrapCSSVar, hashId, cssVarCls];
        };
      }
      function genCSSVarRegister(component, getDefaultToken, options2) {
        var compUnitless = options2.unitless, _options$injectStyle = options2.injectStyle, injectStyle = _options$injectStyle === void 0 ? true : _options$injectStyle, prefixToken = options2.prefixToken, ignore2 = options2.ignore;
        var CSSVarRegister = function CSSVarRegister2(_ref) {
          var rootCls = _ref.rootCls, _ref$cssVar = _ref.cssVar, cssVar = _ref$cssVar === void 0 ? {} : _ref$cssVar;
          var _useToken = useToken2(), realToken = _useToken.realToken;
          useCSSVarRegister({
            path: [component],
            prefix: cssVar.prefix,
            key: cssVar.key,
            unitless: compUnitless,
            ignore: ignore2,
            token: realToken,
            scope: rootCls
          }, function() {
            var defaultToken = getDefaultComponentToken(component, realToken, getDefaultToken);
            var componentToken = getComponentToken(component, realToken, defaultToken, {
              deprecatedTokens: options2 === null || options2 === void 0 ? void 0 : options2.deprecatedTokens
            });
            Object.keys(defaultToken).forEach(function(key) {
              componentToken[prefixToken(key)] = componentToken[key];
              delete componentToken[key];
            });
            return componentToken;
          });
          return null;
        };
        var useCSSVar = function useCSSVar2(rootCls) {
          var _useToken2 = useToken2(), cssVar = _useToken2.cssVar;
          return [function(node2) {
            return injectStyle && cssVar ? /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(CSSVarRegister, {
              rootCls,
              cssVar,
              component
            }), node2) : node2;
          }, cssVar === null || cssVar === void 0 ? void 0 : cssVar.key];
        };
        return useCSSVar;
      }
      function genComponentStyleHook2(componentName, styleFn, getDefaultToken) {
        var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        var cells = Array.isArray(componentName) ? componentName : [componentName, componentName];
        var _cells = _slicedToArray(cells, 1), component = _cells[0];
        var concatComponent = cells.join("-");
        var mergedLayer = config.layer || {
          name: "antd"
        };
        return function(prefixCls) {
          var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
          var _useToken3 = useToken2(), theme = _useToken3.theme, realToken = _useToken3.realToken, hashId = _useToken3.hashId, token2 = _useToken3.token, cssVar = _useToken3.cssVar;
          var _usePrefix = usePrefix(), rootPrefixCls = _usePrefix.rootPrefixCls, iconPrefixCls = _usePrefix.iconPrefixCls;
          var csp = useCSP();
          var type2 = cssVar ? "css" : "js";
          var calc = useUniqueMemo(function() {
            var unitlessCssVar = /* @__PURE__ */ new Set();
            if (cssVar) {
              Object.keys(options2.unitless || {}).forEach(function(key) {
                unitlessCssVar.add(token2CSSVar(key, cssVar.prefix));
                unitlessCssVar.add(token2CSSVar(key, getCompVarPrefix(component, cssVar.prefix)));
              });
            }
            return genCalc(type2, unitlessCssVar);
          }, [type2, component, cssVar === null || cssVar === void 0 ? void 0 : cssVar.prefix]);
          var _genMaxMin = genMaxMin(type2), max = _genMaxMin.max, min = _genMaxMin.min;
          var sharedConfig = {
            theme,
            token: token2,
            hashId,
            nonce: function nonce() {
              return csp.nonce;
            },
            clientOnly: options2.clientOnly,
            layer: mergedLayer,
            // antd is always at top of styles
            order: options2.order || -999
          };
          if (typeof getResetStyles2 === "function") {
            useStyleRegister(_objectSpread2$3(_objectSpread2$3({}, sharedConfig), {}, {
              clientOnly: false,
              path: ["Shared", rootPrefixCls]
            }), function() {
              return getResetStyles2(token2, {
                prefix: {
                  rootPrefixCls,
                  iconPrefixCls
                },
                csp
              });
            });
          }
          var wrapSSR = useStyleRegister(_objectSpread2$3(_objectSpread2$3({}, sharedConfig), {}, {
            path: [concatComponent, prefixCls, iconPrefixCls]
          }), function() {
            if (options2.injectStyle === false) {
              return [];
            }
            var _statisticToken = statisticToken(token2), proxyToken = _statisticToken.token, flush = _statisticToken.flush;
            var defaultComponentToken = getDefaultComponentToken(component, realToken, getDefaultToken);
            var componentCls = ".".concat(prefixCls);
            var componentToken = getComponentToken(component, realToken, defaultComponentToken, {
              deprecatedTokens: options2.deprecatedTokens
            });
            if (cssVar && defaultComponentToken && _typeof$1(defaultComponentToken) === "object") {
              Object.keys(defaultComponentToken).forEach(function(key) {
                defaultComponentToken[key] = "var(".concat(token2CSSVar(key, getCompVarPrefix(component, cssVar.prefix)), ")");
              });
            }
            var mergedToken = merge(proxyToken, {
              componentCls,
              prefixCls,
              iconCls: ".".concat(iconPrefixCls),
              antCls: ".".concat(rootPrefixCls),
              calc,
              // @ts-ignore
              max,
              // @ts-ignore
              min
            }, cssVar ? defaultComponentToken : componentToken);
            var styleInterpolation = styleFn(mergedToken, {
              hashId,
              prefixCls,
              rootPrefixCls,
              iconPrefixCls
            });
            flush(component, componentToken);
            var commonStyle = typeof getCommonStyle === "function" ? getCommonStyle(mergedToken, prefixCls, rootCls, options2.resetFont) : null;
            return [options2.resetStyle === false ? null : commonStyle, styleInterpolation];
          });
          return [wrapSSR, hashId];
        };
      }
      function genSubStyleComponent2(componentName, styleFn, getDefaultToken) {
        var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        var useStyle2 = genComponentStyleHook2(componentName, styleFn, getDefaultToken, _objectSpread2$3({
          resetStyle: false,
          // Sub Style should default after root one
          order: -998
        }, options2));
        var StyledComponent = function StyledComponent2(_ref2) {
          var prefixCls = _ref2.prefixCls, _ref2$rootCls = _ref2.rootCls, rootCls = _ref2$rootCls === void 0 ? prefixCls : _ref2$rootCls;
          useStyle2(prefixCls, rootCls);
          return null;
        };
        return StyledComponent;
      }
      return {
        genStyleHooks: genStyleHooks2,
        genSubStyleComponent: genSubStyleComponent2,
        genComponentStyleHook: genComponentStyleHook2
      };
    }
    const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
    const version$1 = "5.24.5";
    function isStableColor(color) {
      return color >= 0 && color <= 255;
    }
    function getAlphaColor(frontColor, backgroundColor) {
      const {
        r: fR,
        g: fG,
        b: fB,
        a: originAlpha
      } = new FastColor(frontColor).toRgb();
      if (originAlpha < 1) {
        return frontColor;
      }
      const {
        r: bR,
        g: bG,
        b: bB
      } = new FastColor(backgroundColor).toRgb();
      for (let fA = 0.01; fA <= 1; fA += 0.01) {
        const r2 = Math.round((fR - bR * (1 - fA)) / fA);
        const g2 = Math.round((fG - bG * (1 - fA)) / fA);
        const b2 = Math.round((fB - bB * (1 - fA)) / fA);
        if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) {
          return new FastColor({
            r: r2,
            g: g2,
            b: b2,
            a: Math.round(fA * 100) / 100
          }).toRgbString();
        }
      }
      return new FastColor({
        r: fR,
        g: fG,
        b: fB,
        a: 1
      }).toRgbString();
    }
    var __rest$W = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function formatToken(derivativeToken) {
      const {
        override
      } = derivativeToken, restToken = __rest$W(derivativeToken, ["override"]);
      const overrideTokens = Object.assign({}, override);
      Object.keys(seedToken).forEach((token2) => {
        delete overrideTokens[token2];
      });
      const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
      const screenXS = 480;
      const screenSM = 576;
      const screenMD = 768;
      const screenLG = 992;
      const screenXL = 1200;
      const screenXXL = 1600;
      if (mergedToken.motion === false) {
        const fastDuration = "0s";
        mergedToken.motionDurationFast = fastDuration;
        mergedToken.motionDurationMid = fastDuration;
        mergedToken.motionDurationSlow = fastDuration;
      }
      const aliasToken = Object.assign(Object.assign(Object.assign({}, mergedToken), {
        // ============== Background ============== //
        colorFillContent: mergedToken.colorFillSecondary,
        colorFillContentHover: mergedToken.colorFill,
        colorFillAlter: mergedToken.colorFillQuaternary,
        colorBgContainerDisabled: mergedToken.colorFillTertiary,
        // ============== Split ============== //
        colorBorderBg: mergedToken.colorBgContainer,
        colorSplit: getAlphaColor(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
        // ============== Text ============== //
        colorTextPlaceholder: mergedToken.colorTextQuaternary,
        colorTextDisabled: mergedToken.colorTextQuaternary,
        colorTextHeading: mergedToken.colorText,
        colorTextLabel: mergedToken.colorTextSecondary,
        colorTextDescription: mergedToken.colorTextTertiary,
        colorTextLightSolid: mergedToken.colorWhite,
        colorHighlight: mergedToken.colorError,
        colorBgTextHover: mergedToken.colorFillSecondary,
        colorBgTextActive: mergedToken.colorFill,
        colorIcon: mergedToken.colorTextTertiary,
        colorIconHover: mergedToken.colorText,
        colorErrorOutline: getAlphaColor(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
        colorWarningOutline: getAlphaColor(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
        // Font
        fontSizeIcon: mergedToken.fontSizeSM,
        // Line
        lineWidthFocus: mergedToken.lineWidth * 3,
        // Control
        lineWidth: mergedToken.lineWidth,
        controlOutlineWidth: mergedToken.lineWidth * 2,
        // Checkbox size and expand icon size
        controlInteractiveSize: mergedToken.controlHeight / 2,
        controlItemBgHover: mergedToken.colorFillTertiary,
        controlItemBgActive: mergedToken.colorPrimaryBg,
        controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
        controlItemBgActiveDisabled: mergedToken.colorFill,
        controlTmpOutline: mergedToken.colorFillQuaternary,
        controlOutline: getAlphaColor(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
        lineType: mergedToken.lineType,
        borderRadius: mergedToken.borderRadius,
        borderRadiusXS: mergedToken.borderRadiusXS,
        borderRadiusSM: mergedToken.borderRadiusSM,
        borderRadiusLG: mergedToken.borderRadiusLG,
        fontWeightStrong: 600,
        opacityLoading: 0.65,
        linkDecoration: "none",
        linkHoverDecoration: "none",
        linkFocusDecoration: "none",
        controlPaddingHorizontal: 12,
        controlPaddingHorizontalSM: 8,
        paddingXXS: mergedToken.sizeXXS,
        paddingXS: mergedToken.sizeXS,
        paddingSM: mergedToken.sizeSM,
        padding: mergedToken.size,
        paddingMD: mergedToken.sizeMD,
        paddingLG: mergedToken.sizeLG,
        paddingXL: mergedToken.sizeXL,
        paddingContentHorizontalLG: mergedToken.sizeLG,
        paddingContentVerticalLG: mergedToken.sizeMS,
        paddingContentHorizontal: mergedToken.sizeMS,
        paddingContentVertical: mergedToken.sizeSM,
        paddingContentHorizontalSM: mergedToken.size,
        paddingContentVerticalSM: mergedToken.sizeXS,
        marginXXS: mergedToken.sizeXXS,
        marginXS: mergedToken.sizeXS,
        marginSM: mergedToken.sizeSM,
        margin: mergedToken.size,
        marginMD: mergedToken.sizeMD,
        marginLG: mergedToken.sizeLG,
        marginXL: mergedToken.sizeXL,
        marginXXL: mergedToken.sizeXXL,
        boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
        screenXS,
        screenXSMin: screenXS,
        screenXSMax: screenSM - 1,
        screenSM,
        screenSMMin: screenSM,
        screenSMMax: screenMD - 1,
        screenMD,
        screenMDMin: screenMD,
        screenMDMax: screenLG - 1,
        screenLG,
        screenLGMin: screenLG,
        screenLGMax: screenXL - 1,
        screenXL,
        screenXLMin: screenXL,
        screenXLMax: screenXXL - 1,
        screenXXL,
        screenXXLMin: screenXXL,
        boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
        boxShadowCard: `
      0 1px 2px -2px ${new FastColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new FastColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new FastColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
        boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
      }), overrideTokens);
      return aliasToken;
    }
    var __rest$V = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const unitless = {
      lineHeight: true,
      lineHeightSM: true,
      lineHeightLG: true,
      lineHeightHeading1: true,
      lineHeightHeading2: true,
      lineHeightHeading3: true,
      lineHeightHeading4: true,
      lineHeightHeading5: true,
      opacityLoading: true,
      fontWeightStrong: true,
      zIndexPopupBase: true,
      zIndexBase: true,
      opacityImage: true
    };
    const ignore = {
      size: true,
      sizeSM: true,
      sizeLG: true,
      sizeMD: true,
      sizeXS: true,
      sizeXXS: true,
      sizeMS: true,
      sizeXL: true,
      sizeXXL: true,
      sizeUnit: true,
      sizeStep: true,
      motionBase: true,
      motionUnit: true
    };
    const preserve = {
      screenXS: true,
      screenXSMin: true,
      screenXSMax: true,
      screenSM: true,
      screenSMMin: true,
      screenSMMax: true,
      screenMD: true,
      screenMDMin: true,
      screenMDMax: true,
      screenLG: true,
      screenLGMin: true,
      screenLGMax: true,
      screenXL: true,
      screenXLMin: true,
      screenXLMax: true,
      screenXXL: true,
      screenXXLMin: true
    };
    const getComputedToken = (originToken, overrideToken, theme) => {
      const derivativeToken = theme.getDerivativeToken(originToken);
      const {
        override
      } = overrideToken, components = __rest$V(overrideToken, ["override"]);
      let mergedDerivativeToken = Object.assign(Object.assign({}, derivativeToken), {
        override
      });
      mergedDerivativeToken = formatToken(mergedDerivativeToken);
      if (components) {
        Object.entries(components).forEach((_ref) => {
          let [key, value] = _ref;
          const {
            theme: componentTheme
          } = value, componentTokens = __rest$V(value, ["theme"]);
          let mergedComponentToken = componentTokens;
          if (componentTheme) {
            mergedComponentToken = getComputedToken(Object.assign(Object.assign({}, mergedDerivativeToken), componentTokens), {
              override: componentTokens
            }, componentTheme);
          }
          mergedDerivativeToken[key] = mergedComponentToken;
        });
      }
      return mergedDerivativeToken;
    };
    function useToken() {
      const {
        token: rootDesignToken,
        hashed,
        theme,
        override,
        cssVar
      } = i.useContext(DesignTokenContext);
      const salt = `${version$1}-${hashed || ""}`;
      const mergedTheme = theme || defaultTheme;
      const [token2, hashId, realToken] = useCacheToken(mergedTheme, [seedToken, rootDesignToken], {
        salt,
        override,
        getComputedToken,
        // formatToken will not be consumed after 1.15.0 with getComputedToken.
        // But token will break if @ant-design/cssinjs is under 1.15.0 without it
        formatToken,
        cssVar: cssVar && {
          prefix: cssVar.prefix,
          key: cssVar.key,
          unitless,
          ignore,
          preserve
        }
      });
      return [mergedTheme, realToken, hashed ? hashId : "", token2, cssVar];
    }
    const textEllipsis = {
      overflow: "hidden",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis"
    };
    const resetComponent = function(token2) {
      let needInheritFontFamily = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return {
        boxSizing: "border-box",
        margin: 0,
        padding: 0,
        color: token2.colorText,
        fontSize: token2.fontSize,
        // font-variant: @font-variant-base;
        lineHeight: token2.lineHeight,
        listStyle: "none",
        // font-feature-settings: @font-feature-settings-base;
        fontFamily: needInheritFontFamily ? "inherit" : token2.fontFamily
      };
    };
    const resetIcon = () => ({
      display: "inline-flex",
      alignItems: "center",
      color: "inherit",
      fontStyle: "normal",
      lineHeight: 0,
      textAlign: "center",
      textTransform: "none",
      // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
      verticalAlign: "-0.125em",
      textRendering: "optimizeLegibility",
      "-webkit-font-smoothing": "antialiased",
      "-moz-osx-font-smoothing": "grayscale",
      "> *": {
        lineHeight: 1
      },
      svg: {
        display: "inline-block"
      }
    });
    const clearFix = () => ({
      // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
      "&::before": {
        display: "table",
        content: '""'
      },
      "&::after": {
        // https://github.com/ant-design/ant-design/issues/21864
        display: "table",
        clear: "both",
        content: '""'
      }
    });
    const genLinkStyle$1 = (token2) => ({
      a: {
        color: token2.colorLink,
        textDecoration: token2.linkDecoration,
        backgroundColor: "transparent",
        // remove the gray background on active links in IE 10.
        outline: "none",
        cursor: "pointer",
        transition: `color ${token2.motionDurationSlow}`,
        "-webkit-text-decoration-skip": "objects",
        // remove gaps in links underline in iOS 8+ and Safari 8+.
        "&:hover": {
          color: token2.colorLinkHover
        },
        "&:active": {
          color: token2.colorLinkActive
        },
        "&:active, &:hover": {
          textDecoration: token2.linkHoverDecoration,
          outline: 0
        },
        // https://github.com/ant-design/ant-design/issues/22503
        "&:focus": {
          textDecoration: token2.linkFocusDecoration,
          outline: 0
        },
        "&[disabled]": {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    });
    const genCommonStyle = (token2, componentPrefixCls, rootCls, resetFont) => {
      const prefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
      const rootPrefixSelector = rootCls ? `.${rootCls}` : prefixSelector;
      const resetStyle = {
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        }
      };
      let resetFontStyle = {};
      if (resetFont !== false) {
        resetFontStyle = {
          fontFamily: token2.fontFamily,
          fontSize: token2.fontSize
        };
      }
      return {
        [rootPrefixSelector]: Object.assign(Object.assign(Object.assign({}, resetFontStyle), resetStyle), {
          [prefixSelector]: resetStyle
        })
      };
    };
    const genFocusOutline = (token2, offset2) => ({
      outline: `${unit$1(token2.lineWidthFocus)} solid ${token2.colorPrimaryBorder}`,
      outlineOffset: offset2 !== null && offset2 !== void 0 ? offset2 : 1,
      transition: "outline-offset 0s, outline 0s"
    });
    const genFocusStyle = (token2, offset2) => ({
      "&:focus-visible": Object.assign({}, genFocusOutline(token2, offset2))
    });
    const genIconStyle = (iconPrefixCls) => ({
      [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), {
        [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
          display: "block"
        }
      })
    });
    const operationUnit = (token2) => Object.assign(Object.assign({
      // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
      // And Typography use this to generate link style which should not do this.
      color: token2.colorLink,
      textDecoration: token2.linkDecoration,
      outline: "none",
      cursor: "pointer",
      transition: `all ${token2.motionDurationSlow}`,
      border: 0,
      padding: 0,
      background: "none",
      userSelect: "none"
    }, genFocusStyle(token2)), {
      "&:focus, &:hover": {
        color: token2.colorLinkHover
      },
      "&:active": {
        color: token2.colorLinkActive
      }
    });
    const {
      genStyleHooks,
      genComponentStyleHook,
      genSubStyleComponent
    } = genStyleUtils({
      usePrefix: () => {
        const {
          getPrefixCls,
          iconPrefixCls
        } = reactExports.useContext(ConfigContext);
        const rootPrefixCls = getPrefixCls();
        return {
          rootPrefixCls,
          iconPrefixCls
        };
      },
      useToken: () => {
        const [theme, realToken, hashId, token2, cssVar] = useToken();
        return {
          theme,
          realToken,
          hashId,
          token: token2,
          cssVar
        };
      },
      useCSP: () => {
        const {
          csp
        } = reactExports.useContext(ConfigContext);
        return csp !== null && csp !== void 0 ? csp : {};
      },
      getResetStyles: (token2, config) => {
        var _a;
        const linkStyle = genLinkStyle$1(token2);
        return [linkStyle, {
          "&": linkStyle
        }, genIconStyle((_a = config === null || config === void 0 ? void 0 : config.prefix.iconPrefixCls) !== null && _a !== void 0 ? _a : defaultIconPrefixCls)];
      },
      getCommonStyle: genCommonStyle,
      getCompUnitless: () => unitless
    });
    function genPresetColor(token2, genCss) {
      return PresetColors.reduce((prev2, colorKey) => {
        const lightColor = token2[`${colorKey}1`];
        const lightBorderColor = token2[`${colorKey}3`];
        const darkColor = token2[`${colorKey}6`];
        const textColor = token2[`${colorKey}7`];
        return Object.assign(Object.assign({}, prev2), genCss(colorKey, {
          lightColor,
          lightBorderColor,
          darkColor,
          textColor
        }));
      }, {});
    }
    const useResetIconStyle = (iconPrefixCls, csp) => {
      const [theme, token2] = useToken();
      return useStyleRegister({
        token: token2,
        hashId: "",
        path: ["ant-design-icons", iconPrefixCls],
        nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce,
        layer: {
          name: "antd"
        }
      }, () => [genIconStyle(iconPrefixCls)]);
    };
    const fullClone$1 = Object.assign({}, React$5);
    const {
      useId: useId$2
    } = fullClone$1;
    const useEmptyId = () => "";
    const useThemeKey = typeof useId$2 === "undefined" ? useEmptyId : useId$2;
    function useTheme(theme, parentTheme, config) {
      var _a;
      devUseWarning();
      const themeConfig = theme || {};
      const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? Object.assign(Object.assign({}, defaultConfig), {
        hashed: (_a = parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.hashed) !== null && _a !== void 0 ? _a : defaultConfig.hashed,
        cssVar: parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.cssVar
      }) : parentTheme;
      const themeKey = useThemeKey();
      return useMemo(() => {
        var _a2, _b2;
        if (!theme) {
          return parentTheme;
        }
        const mergedComponents = Object.assign({}, parentThemeConfig.components);
        Object.keys(theme.components || {}).forEach((componentName) => {
          mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme.components[componentName]);
        });
        const cssVarKey = `css-var-${themeKey.replace(/:/g, "")}`;
        const mergedCssVar = ((_a2 = themeConfig.cssVar) !== null && _a2 !== void 0 ? _a2 : parentThemeConfig.cssVar) && Object.assign(Object.assign(Object.assign({
          prefix: config === null || config === void 0 ? void 0 : config.prefixCls
        }, typeof parentThemeConfig.cssVar === "object" ? parentThemeConfig.cssVar : {}), typeof themeConfig.cssVar === "object" ? themeConfig.cssVar : {}), {
          key: typeof themeConfig.cssVar === "object" && ((_b2 = themeConfig.cssVar) === null || _b2 === void 0 ? void 0 : _b2.key) || cssVarKey
        });
        return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
          token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
          components: mergedComponents,
          cssVar: mergedCssVar
        });
      }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index2) => {
        const nextTheme = next2[index2];
        return !isEqual$1(prevTheme, nextTheme, true);
      }));
    }
    var _excluded$K = ["children"];
    var Context$2 = /* @__PURE__ */ reactExports.createContext({});
    function MotionProvider(_ref) {
      var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded$K);
      return /* @__PURE__ */ reactExports.createElement(Context$2.Provider, {
        value: props
      }, children);
    }
    var DomWrapper = /* @__PURE__ */ function(_React$Component) {
      _inherits(DomWrapper2, _React$Component);
      var _super = _createSuper(DomWrapper2);
      function DomWrapper2() {
        _classCallCheck(this, DomWrapper2);
        return _super.apply(this, arguments);
      }
      _createClass(DomWrapper2, [{
        key: "render",
        value: function render2() {
          return this.props.children;
        }
      }]);
      return DomWrapper2;
    }(reactExports.Component);
    function useSyncState$2(defaultValue) {
      var _React$useReducer = reactExports.useReducer(function(x2) {
        return x2 + 1;
      }, 0), _React$useReducer2 = _slicedToArray(_React$useReducer, 2), forceUpdate = _React$useReducer2[1];
      var currentValueRef = reactExports.useRef(defaultValue);
      var getValue2 = useEvent(function() {
        return currentValueRef.current;
      });
      var setValue = useEvent(function(updater) {
        currentValueRef.current = typeof updater === "function" ? updater(currentValueRef.current) : updater;
        forceUpdate();
      });
      return [getValue2, setValue];
    }
    var STATUS_NONE = "none";
    var STATUS_APPEAR = "appear";
    var STATUS_ENTER = "enter";
    var STATUS_LEAVE = "leave";
    var STEP_NONE = "none";
    var STEP_PREPARE = "prepare";
    var STEP_START = "start";
    var STEP_ACTIVE = "active";
    var STEP_ACTIVATED = "end";
    var STEP_PREPARED = "prepared";
    function makePrefixMap(styleProp, eventName) {
      var prefixes2 = {};
      prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes2["Webkit".concat(styleProp)] = "webkit".concat(eventName);
      prefixes2["Moz".concat(styleProp)] = "moz".concat(eventName);
      prefixes2["ms".concat(styleProp)] = "MS".concat(eventName);
      prefixes2["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
      return prefixes2;
    }
    function getVendorPrefixes(domSupport, win) {
      var prefixes2 = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      if (domSupport) {
        if (!("AnimationEvent" in win)) {
          delete prefixes2.animationend.animation;
        }
        if (!("TransitionEvent" in win)) {
          delete prefixes2.transitionend.transition;
        }
      }
      return prefixes2;
    }
    var vendorPrefixes = getVendorPrefixes(canUseDom$2(), typeof window !== "undefined" ? window : {});
    var style = {};
    if (canUseDom$2()) {
      var _document$createEleme = document.createElement("div");
      style = _document$createEleme.style;
    }
    var prefixedEventNames = {};
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) {
        return prefixedEventNames[eventName];
      }
      var prefixMap = vendorPrefixes[eventName];
      if (prefixMap) {
        var stylePropList = Object.keys(prefixMap);
        var len = stylePropList.length;
        for (var i2 = 0; i2 < len; i2 += 1) {
          var styleProp = stylePropList[i2];
          if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
            prefixedEventNames[eventName] = prefixMap[styleProp];
            return prefixedEventNames[eventName];
          }
        }
      }
      return "";
    }
    var internalAnimationEndName = getVendorPrefixedEventName("animationend");
    var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
    var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
    var animationEndName = internalAnimationEndName || "animationend";
    var transitionEndName = internalTransitionEndName || "transitionend";
    function getTransitionName$1(transitionName, transitionType) {
      if (!transitionName) return null;
      if (_typeof$1(transitionName) === "object") {
        var type2 = transitionType.replace(/-\w/g, function(match2) {
          return match2[1].toUpperCase();
        });
        return transitionName[type2];
      }
      return "".concat(transitionName, "-").concat(transitionType);
    }
    const useDomMotionEvents = function(onInternalMotionEnd) {
      var cacheElementRef = reactExports.useRef();
      function removeMotionEvents(element) {
        if (element) {
          element.removeEventListener(transitionEndName, onInternalMotionEnd);
          element.removeEventListener(animationEndName, onInternalMotionEnd);
        }
      }
      function patchMotionEvents(element) {
        if (cacheElementRef.current && cacheElementRef.current !== element) {
          removeMotionEvents(cacheElementRef.current);
        }
        if (element && element !== cacheElementRef.current) {
          element.addEventListener(transitionEndName, onInternalMotionEnd);
          element.addEventListener(animationEndName, onInternalMotionEnd);
          cacheElementRef.current = element;
        }
      }
      reactExports.useEffect(function() {
        return function() {
          removeMotionEvents(cacheElementRef.current);
        };
      }, []);
      return [patchMotionEvents, removeMotionEvents];
    };
    var useIsomorphicLayoutEffect$1 = canUseDom$2() ? reactExports.useLayoutEffect : reactExports.useEffect;
    const useNextFrame = function() {
      var nextFrameRef = reactExports.useRef(null);
      function cancelNextFrame() {
        wrapperRaf.cancel(nextFrameRef.current);
      }
      function nextFrame(callback) {
        var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        cancelNextFrame();
        var nextFrameId = wrapperRaf(function() {
          if (delay <= 1) {
            callback({
              isCanceled: function isCanceled() {
                return nextFrameId !== nextFrameRef.current;
              }
            });
          } else {
            nextFrame(callback, delay - 1);
          }
        });
        nextFrameRef.current = nextFrameId;
      }
      reactExports.useEffect(function() {
        return function() {
          cancelNextFrame();
        };
      }, []);
      return [nextFrame, cancelNextFrame];
    };
    var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
    var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
    var SkipStep = false;
    var DoStep = true;
    function isActive(step) {
      return step === STEP_ACTIVE || step === STEP_ACTIVATED;
    }
    const useStepQueue = function(status, prepareOnly, callback) {
      var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray(_useState, 2), step = _useState2[0], setStep = _useState2[1];
      var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
      function startQueue() {
        setStep(STEP_PREPARE, true);
      }
      var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
      useIsomorphicLayoutEffect$1(function() {
        if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
          var index2 = STEP_QUEUE.indexOf(step);
          var nextStep = STEP_QUEUE[index2 + 1];
          var result = callback(step);
          if (result === SkipStep) {
            setStep(nextStep, true);
          } else if (nextStep) {
            nextFrame(function(info) {
              function doNext() {
                if (info.isCanceled()) return;
                setStep(nextStep, true);
              }
              if (result === true) {
                doNext();
              } else {
                Promise.resolve(result).then(doNext);
              }
            });
          }
        }
      }, [status, step]);
      reactExports.useEffect(function() {
        return function() {
          cancelNextFrame();
        };
      }, []);
      return [startQueue, step];
    };
    function useStatus(supportMotion, visible, getElement, _ref) {
      var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
      var _useState = useSafeState(), _useState2 = _slicedToArray(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
      var _useSyncState = useSyncState$2(STATUS_NONE), _useSyncState2 = _slicedToArray(_useSyncState, 2), getStatus2 = _useSyncState2[0], setStatus = _useSyncState2[1];
      var _useState3 = useSafeState(null), _useState4 = _slicedToArray(_useState3, 2), style2 = _useState4[0], setStyle = _useState4[1];
      var currentStatus = getStatus2();
      var mountedRef = reactExports.useRef(false);
      var deadlineRef = reactExports.useRef(null);
      function getDomElement() {
        return getElement();
      }
      var activeRef = reactExports.useRef(false);
      function updateMotionEndStatus() {
        setStatus(STATUS_NONE);
        setStyle(null, true);
      }
      var onInternalMotionEnd = useEvent(function(event) {
        var status = getStatus2();
        if (status === STATUS_NONE) {
          return;
        }
        var element = getDomElement();
        if (event && !event.deadline && event.target !== element) {
          return;
        }
        var currentActive = activeRef.current;
        var canEnd;
        if (status === STATUS_APPEAR && currentActive) {
          canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
        } else if (status === STATUS_ENTER && currentActive) {
          canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
        } else if (status === STATUS_LEAVE && currentActive) {
          canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
        }
        if (currentActive && canEnd !== false) {
          updateMotionEndStatus();
        }
      });
      var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
      var getEventHandlers = function getEventHandlers2(targetStatus) {
        switch (targetStatus) {
          case STATUS_APPEAR:
            return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onAppearPrepare), STEP_START, onAppearStart), STEP_ACTIVE, onAppearActive);
          case STATUS_ENTER:
            return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onEnterPrepare), STEP_START, onEnterStart), STEP_ACTIVE, onEnterActive);
          case STATUS_LEAVE:
            return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onLeavePrepare), STEP_START, onLeaveStart), STEP_ACTIVE, onLeaveActive);
          default:
            return {};
        }
      };
      var eventHandlers = reactExports.useMemo(function() {
        return getEventHandlers(currentStatus);
      }, [currentStatus]);
      var _useStepQueue = useStepQueue(currentStatus, !supportMotion, function(newStep) {
        if (newStep === STEP_PREPARE) {
          var onPrepare = eventHandlers[STEP_PREPARE];
          if (!onPrepare) {
            return SkipStep;
          }
          return onPrepare(getDomElement());
        }
        if (step in eventHandlers) {
          var _eventHandlers$step;
          setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
        }
        if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {
          patchMotionEvents(getDomElement());
          if (motionDeadline > 0) {
            clearTimeout(deadlineRef.current);
            deadlineRef.current = setTimeout(function() {
              onInternalMotionEnd({
                deadline: true
              });
            }, motionDeadline);
          }
        }
        if (step === STEP_PREPARED) {
          updateMotionEndStatus();
        }
        return DoStep;
      }), _useStepQueue2 = _slicedToArray(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
      var active = isActive(step);
      activeRef.current = active;
      var visibleRef = reactExports.useRef(null);
      useIsomorphicLayoutEffect$1(function() {
        if (mountedRef.current && visibleRef.current === visible) {
          return;
        }
        setAsyncVisible(visible);
        var isMounted = mountedRef.current;
        mountedRef.current = true;
        var nextStatus;
        if (!isMounted && visible && motionAppear) {
          nextStatus = STATUS_APPEAR;
        }
        if (isMounted && visible && motionEnter) {
          nextStatus = STATUS_ENTER;
        }
        if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
          nextStatus = STATUS_LEAVE;
        }
        var nextEventHandlers = getEventHandlers(nextStatus);
        if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
          setStatus(nextStatus);
          startStep();
        } else {
          setStatus(STATUS_NONE);
        }
        visibleRef.current = visible;
      }, [visible]);
      reactExports.useEffect(function() {
        if (
          // Cancel appear
          currentStatus === STATUS_APPEAR && !motionAppear || // Cancel enter
          currentStatus === STATUS_ENTER && !motionEnter || // Cancel leave
          currentStatus === STATUS_LEAVE && !motionLeave
        ) {
          setStatus(STATUS_NONE);
        }
      }, [motionAppear, motionEnter, motionLeave]);
      reactExports.useEffect(function() {
        return function() {
          mountedRef.current = false;
          clearTimeout(deadlineRef.current);
        };
      }, []);
      var firstMountChangeRef = reactExports.useRef(false);
      reactExports.useEffect(function() {
        if (asyncVisible) {
          firstMountChangeRef.current = true;
        }
        if (asyncVisible !== void 0 && currentStatus === STATUS_NONE) {
          if (firstMountChangeRef.current || asyncVisible) {
            onVisibleChanged === null || onVisibleChanged === void 0 || onVisibleChanged(asyncVisible);
          }
          firstMountChangeRef.current = true;
        }
      }, [asyncVisible, currentStatus]);
      var mergedStyle = style2;
      if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
        mergedStyle = _objectSpread2$3({
          transition: "none"
        }, mergedStyle);
      }
      return [currentStatus, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
    }
    function genCSSMotion(config) {
      var transitionSupport = config;
      if (_typeof$1(config) === "object") {
        transitionSupport = config.transitionSupport;
      }
      function isSupportTransition(props, contextMotion) {
        return !!(props.motionName && transitionSupport && contextMotion !== false);
      }
      var CSSMotion2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
        var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
        var _React$useContext = reactExports.useContext(Context$2), contextMotion = _React$useContext.motion;
        var supportMotion = isSupportTransition(props, contextMotion);
        var nodeRef = reactExports.useRef();
        var wrapperNodeRef = reactExports.useRef();
        function getDomElement() {
          try {
            return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
          } catch (e2) {
            return null;
          }
        }
        var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
        var renderedRef = reactExports.useRef(mergedVisible);
        if (mergedVisible) {
          renderedRef.current = true;
        }
        var setNodeRef = reactExports.useCallback(function(node2) {
          nodeRef.current = node2;
          fillRef(ref, node2);
        }, [ref]);
        var motionChildren;
        var mergedProps = _objectSpread2$3(_objectSpread2$3({}, eventProps), {}, {
          visible
        });
        if (!children) {
          motionChildren = null;
        } else if (status === STATUS_NONE) {
          if (mergedVisible) {
            motionChildren = children(_objectSpread2$3({}, mergedProps), setNodeRef);
          } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
            motionChildren = children(_objectSpread2$3(_objectSpread2$3({}, mergedProps), {}, {
              className: leavedClassName
            }), setNodeRef);
          } else if (forceRender || !removeOnLeave && !leavedClassName) {
            motionChildren = children(_objectSpread2$3(_objectSpread2$3({}, mergedProps), {}, {
              style: {
                display: "none"
              }
            }), setNodeRef);
          } else {
            motionChildren = null;
          }
        } else {
          var statusSuffix;
          if (statusStep === STEP_PREPARE) {
            statusSuffix = "prepare";
          } else if (isActive(statusStep)) {
            statusSuffix = "active";
          } else if (statusStep === STEP_START) {
            statusSuffix = "start";
          }
          var motionCls = getTransitionName$1(motionName, "".concat(status, "-").concat(statusSuffix));
          motionChildren = children(_objectSpread2$3(_objectSpread2$3({}, mergedProps), {}, {
            className: classNames(getTransitionName$1(motionName, status), _defineProperty(_defineProperty({}, motionCls, motionCls && statusSuffix), motionName, typeof motionName === "string")),
            style: statusStyle
          }), setNodeRef);
        }
        if (/* @__PURE__ */ reactExports.isValidElement(motionChildren) && supportRef(motionChildren)) {
          var originNodeRef = getNodeRef(motionChildren);
          if (!originNodeRef) {
            motionChildren = /* @__PURE__ */ reactExports.cloneElement(motionChildren, {
              ref: setNodeRef
            });
          }
        }
        return /* @__PURE__ */ reactExports.createElement(DomWrapper, {
          ref: wrapperNodeRef
        }, motionChildren);
      });
      CSSMotion2.displayName = "CSSMotion";
      return CSSMotion2;
    }
    const CSSMotion = genCSSMotion(supportTransition);
    var STATUS_ADD = "add";
    var STATUS_KEEP = "keep";
    var STATUS_REMOVE = "remove";
    var STATUS_REMOVED = "removed";
    function wrapKeyToObject(key) {
      var keyObj;
      if (key && _typeof$1(key) === "object" && "key" in key) {
        keyObj = key;
      } else {
        keyObj = {
          key
        };
      }
      return _objectSpread2$3(_objectSpread2$3({}, keyObj), {}, {
        key: String(keyObj.key)
      });
    }
    function parseKeys() {
      var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return keys2.map(wrapKeyToObject);
    }
    function diffKeys() {
      var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var list = [];
      var currentIndex = 0;
      var currentLen = currentKeys.length;
      var prevKeyObjects = parseKeys(prevKeys);
      var currentKeyObjects = parseKeys(currentKeys);
      prevKeyObjects.forEach(function(keyObj) {
        var hit = false;
        for (var i2 = currentIndex; i2 < currentLen; i2 += 1) {
          var currentKeyObj = currentKeyObjects[i2];
          if (currentKeyObj.key === keyObj.key) {
            if (currentIndex < i2) {
              list = list.concat(currentKeyObjects.slice(currentIndex, i2).map(function(obj) {
                return _objectSpread2$3(_objectSpread2$3({}, obj), {}, {
                  status: STATUS_ADD
                });
              }));
              currentIndex = i2;
            }
            list.push(_objectSpread2$3(_objectSpread2$3({}, currentKeyObj), {}, {
              status: STATUS_KEEP
            }));
            currentIndex += 1;
            hit = true;
            break;
          }
        }
        if (!hit) {
          list.push(_objectSpread2$3(_objectSpread2$3({}, keyObj), {}, {
            status: STATUS_REMOVE
          }));
        }
      });
      if (currentIndex < currentLen) {
        list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
          return _objectSpread2$3(_objectSpread2$3({}, obj), {}, {
            status: STATUS_ADD
          });
        }));
      }
      var keys2 = {};
      list.forEach(function(_ref) {
        var key = _ref.key;
        keys2[key] = (keys2[key] || 0) + 1;
      });
      var duplicatedKeys = Object.keys(keys2).filter(function(key) {
        return keys2[key] > 1;
      });
      duplicatedKeys.forEach(function(matchKey) {
        list = list.filter(function(_ref2) {
          var key = _ref2.key, status = _ref2.status;
          return key !== matchKey || status !== STATUS_REMOVE;
        });
        list.forEach(function(node2) {
          if (node2.key === matchKey) {
            node2.status = STATUS_KEEP;
          }
        });
      });
      return list;
    }
    var _excluded$J = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2$9 = ["status"];
    var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
    function genCSSMotionList(transitionSupport) {
      var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;
      var CSSMotionList2 = /* @__PURE__ */ function(_React$Component) {
        _inherits(CSSMotionList3, _React$Component);
        var _super = _createSuper(CSSMotionList3);
        function CSSMotionList3() {
          var _this;
          _classCallCheck(this, CSSMotionList3);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "state", {
            keyEntities: []
          });
          _defineProperty(_assertThisInitialized(_this), "removeKey", function(removeKey) {
            _this.setState(function(prevState) {
              var nextKeyEntities = prevState.keyEntities.map(function(entity) {
                if (entity.key !== removeKey) return entity;
                return _objectSpread2$3(_objectSpread2$3({}, entity), {}, {
                  status: STATUS_REMOVED
                });
              });
              return {
                keyEntities: nextKeyEntities
              };
            }, function() {
              var keyEntities = _this.state.keyEntities;
              var restKeysCount = keyEntities.filter(function(_ref) {
                var status = _ref.status;
                return status !== STATUS_REMOVED;
              }).length;
              if (restKeysCount === 0 && _this.props.onAllRemoved) {
                _this.props.onAllRemoved();
              }
            });
          });
          return _this;
        }
        _createClass(CSSMotionList3, [{
          key: "render",
          value: function render2() {
            var _this2 = this;
            var keyEntities = this.state.keyEntities;
            var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged;
            _this$props.onAllRemoved;
            var restProps = _objectWithoutProperties(_this$props, _excluded$J);
            var Component2 = component || reactExports.Fragment;
            var motionProps = {};
            MOTION_PROP_NAMES.forEach(function(prop) {
              motionProps[prop] = restProps[prop];
              delete restProps[prop];
            });
            delete restProps.keys;
            return /* @__PURE__ */ reactExports.createElement(Component2, restProps, keyEntities.map(function(_ref2, index2) {
              var status = _ref2.status, eventProps = _objectWithoutProperties(_ref2, _excluded2$9);
              var visible = status === STATUS_ADD || status === STATUS_KEEP;
              return /* @__PURE__ */ reactExports.createElement(CSSMotion$1, _extends$2({}, motionProps, {
                key: eventProps.key,
                visible,
                eventProps,
                onVisibleChanged: function onVisibleChanged(changedVisible) {
                  _onVisibleChanged === null || _onVisibleChanged === void 0 || _onVisibleChanged(changedVisible, {
                    key: eventProps.key
                  });
                  if (!changedVisible) {
                    _this2.removeKey(eventProps.key);
                  }
                }
              }), function(props, ref) {
                return children(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
                  index: index2
                }), ref);
              });
            }));
          }
        }], [{
          key: "getDerivedStateFromProps",
          value: function getDerivedStateFromProps(_ref3, _ref4) {
            var keys2 = _ref3.keys;
            var keyEntities = _ref4.keyEntities;
            var parsedKeyObjects = parseKeys(keys2);
            var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
            return {
              keyEntities: mixedKeyEntities.filter(function(entity) {
                var prevEntity = keyEntities.find(function(_ref5) {
                  var key = _ref5.key;
                  return entity.key === key;
                });
                if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
                  return false;
                }
                return true;
              })
            };
          }
        }]);
        return CSSMotionList3;
      }(reactExports.Component);
      _defineProperty(CSSMotionList2, "defaultProps", {
        component: "div"
      });
      return CSSMotionList2;
    }
    const CSSMotionList = genCSSMotionList(supportTransition);
    function MotionWrapper(props) {
      const {
        children
      } = props;
      const [, token2] = useToken();
      const {
        motion: motion2
      } = token2;
      const needWrapMotionProviderRef = reactExports.useRef(false);
      needWrapMotionProviderRef.current = needWrapMotionProviderRef.current || motion2 === false;
      if (needWrapMotionProviderRef.current) {
        return /* @__PURE__ */ reactExports.createElement(MotionProvider, {
          motion: motion2
        }, children);
      }
      return children;
    }
    const PropWarning = () => null;
    var __rest$U = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"];
    let globalPrefixCls;
    let globalIconPrefixCls;
    let globalTheme;
    let globalHolderRender;
    function getGlobalPrefixCls() {
      return globalPrefixCls || defaultPrefixCls;
    }
    function getGlobalIconPrefixCls() {
      return globalIconPrefixCls || defaultIconPrefixCls;
    }
    function isLegacyTheme(theme) {
      return Object.keys(theme).some((key) => key.endsWith("Color"));
    }
    const setGlobalConfig = (props) => {
      const {
        prefixCls,
        iconPrefixCls,
        theme,
        holderRender
      } = props;
      if (prefixCls !== void 0) {
        globalPrefixCls = prefixCls;
      }
      if (iconPrefixCls !== void 0) {
        globalIconPrefixCls = iconPrefixCls;
      }
      if ("holderRender" in props) {
        globalHolderRender = holderRender;
      }
      if (theme) {
        if (isLegacyTheme(theme)) {
          registerTheme(getGlobalPrefixCls(), theme);
        } else {
          globalTheme = theme;
        }
      }
    };
    const globalConfig = () => ({
      getPrefixCls: (suffixCls, customizePrefixCls) => {
        if (customizePrefixCls) {
          return customizePrefixCls;
        }
        return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
      },
      getIconPrefixCls: getGlobalIconPrefixCls,
      getRootPrefixCls: () => {
        if (globalPrefixCls) {
          return globalPrefixCls;
        }
        return getGlobalPrefixCls();
      },
      getTheme: () => globalTheme,
      holderRender: globalHolderRender
    });
    const ProviderChildren = (props) => {
      const {
        children,
        csp: customCsp,
        autoInsertSpaceInButton,
        alert,
        anchor,
        form,
        locale: locale2,
        componentSize,
        direction,
        space,
        splitter,
        virtual,
        dropdownMatchSelectWidth,
        popupMatchSelectWidth,
        popupOverflow,
        legacyLocale,
        parentContext,
        iconPrefixCls: customIconPrefixCls,
        theme,
        componentDisabled,
        segmented,
        statistic: statistic2,
        spin,
        calendar,
        carousel,
        cascader,
        collapse,
        typography,
        checkbox,
        descriptions,
        divider,
        drawer,
        skeleton,
        steps,
        image,
        layout,
        list,
        mentions,
        modal,
        progress,
        result,
        slider,
        breadcrumb,
        menu,
        pagination,
        input,
        textArea,
        empty,
        badge,
        radio,
        rate,
        switch: SWITCH,
        transfer,
        avatar,
        message: message2,
        tag,
        table,
        card,
        tabs,
        timeline,
        timePicker,
        upload,
        notification,
        tree,
        colorPicker,
        datePicker,
        rangePicker,
        flex,
        wave,
        dropdown,
        warning: warningConfig,
        tour,
        tooltip,
        popover,
        popconfirm,
        floatButtonGroup,
        variant,
        inputNumber,
        treeSelect
      } = props;
      const getPrefixCls = reactExports.useCallback((suffixCls, customizePrefixCls) => {
        const {
          prefixCls
        } = props;
        if (customizePrefixCls) {
          return customizePrefixCls;
        }
        const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
        return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
      }, [parentContext.getPrefixCls, props.prefixCls]);
      const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
      const csp = customCsp || parentContext.csp;
      useResetIconStyle(iconPrefixCls, csp);
      const mergedTheme = useTheme(theme, parentContext.theme, {
        prefixCls: getPrefixCls("")
      });
      const baseConfig = {
        csp,
        autoInsertSpaceInButton,
        alert,
        anchor,
        locale: locale2 || legacyLocale,
        direction,
        space,
        splitter,
        virtual,
        popupMatchSelectWidth: popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth,
        popupOverflow,
        getPrefixCls,
        iconPrefixCls,
        theme: mergedTheme,
        segmented,
        statistic: statistic2,
        spin,
        calendar,
        carousel,
        cascader,
        collapse,
        typography,
        checkbox,
        descriptions,
        divider,
        drawer,
        skeleton,
        steps,
        image,
        input,
        textArea,
        layout,
        list,
        mentions,
        modal,
        progress,
        result,
        slider,
        breadcrumb,
        menu,
        pagination,
        empty,
        badge,
        radio,
        rate,
        switch: SWITCH,
        transfer,
        avatar,
        message: message2,
        tag,
        table,
        card,
        tabs,
        timeline,
        timePicker,
        upload,
        notification,
        tree,
        colorPicker,
        datePicker,
        rangePicker,
        flex,
        wave,
        dropdown,
        warning: warningConfig,
        tour,
        tooltip,
        popover,
        popconfirm,
        floatButtonGroup,
        variant,
        inputNumber,
        treeSelect
      };
      const config = Object.assign({}, parentContext);
      Object.keys(baseConfig).forEach((key) => {
        if (baseConfig[key] !== void 0) {
          config[key] = baseConfig[key];
        }
      });
      PASSED_PROPS.forEach((propName) => {
        const propValue = props[propName];
        if (propValue) {
          config[propName] = propValue;
        }
      });
      if (typeof autoInsertSpaceInButton !== "undefined") {
        config.button = Object.assign({
          autoInsertSpace: autoInsertSpaceInButton
        }, config.button);
      }
      const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
        const prevKeys = Object.keys(prevConfig);
        const currentKeys = Object.keys(currentConfig);
        return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
      });
      const {
        layer
      } = reactExports.useContext(StyleContext);
      const memoIconContextValue = reactExports.useMemo(() => ({
        prefixCls: iconPrefixCls,
        csp,
        layer: layer ? "antd" : void 0
      }), [iconPrefixCls, csp, layer]);
      let childNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(PropWarning, {
        dropdownMatchSelectWidth
      }), children);
      const validateMessages = reactExports.useMemo(() => {
        var _a, _b, _c, _d;
        return merge$1(((_a = localeValues.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, ((_d = memoedConfig.form) === null || _d === void 0 ? void 0 : _d.validateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
      }, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
      if (Object.keys(validateMessages).length > 0) {
        childNode = /* @__PURE__ */ reactExports.createElement(ValidateMessagesContext.Provider, {
          value: validateMessages
        }, childNode);
      }
      if (locale2) {
        childNode = /* @__PURE__ */ reactExports.createElement(LocaleProvider, {
          locale: locale2,
          _ANT_MARK__: ANT_MARK
        }, childNode);
      }
      {
        childNode = /* @__PURE__ */ reactExports.createElement(IconContext$1.Provider, {
          value: memoIconContextValue
        }, childNode);
      }
      if (componentSize) {
        childNode = /* @__PURE__ */ reactExports.createElement(SizeContextProvider, {
          size: componentSize
        }, childNode);
      }
      childNode = /* @__PURE__ */ reactExports.createElement(MotionWrapper, null, childNode);
      const memoTheme = reactExports.useMemo(() => {
        const _a = mergedTheme || {}, {
          algorithm,
          token: token2,
          components,
          cssVar
        } = _a, rest = __rest$U(_a, ["algorithm", "token", "components", "cssVar"]);
        const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : defaultTheme;
        const parsedComponents = {};
        Object.entries(components || {}).forEach((_ref) => {
          let [componentName, componentToken] = _ref;
          const parsedToken = Object.assign({}, componentToken);
          if ("algorithm" in parsedToken) {
            if (parsedToken.algorithm === true) {
              parsedToken.theme = themeObj;
            } else if (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm === "function") {
              parsedToken.theme = createTheme(parsedToken.algorithm);
            }
            delete parsedToken.algorithm;
          }
          parsedComponents[componentName] = parsedToken;
        });
        const mergedToken = Object.assign(Object.assign({}, seedToken), token2);
        return Object.assign(Object.assign({}, rest), {
          theme: themeObj,
          token: mergedToken,
          components: parsedComponents,
          override: Object.assign({
            override: mergedToken
          }, parsedComponents),
          cssVar
        });
      }, [mergedTheme]);
      if (theme) {
        childNode = /* @__PURE__ */ reactExports.createElement(DesignTokenContext.Provider, {
          value: memoTheme
        }, childNode);
      }
      if (memoedConfig.warning) {
        childNode = /* @__PURE__ */ reactExports.createElement(WarningContext.Provider, {
          value: memoedConfig.warning
        }, childNode);
      }
      if (componentDisabled !== void 0) {
        childNode = /* @__PURE__ */ reactExports.createElement(DisabledContextProvider, {
          disabled: componentDisabled
        }, childNode);
      }
      return /* @__PURE__ */ reactExports.createElement(ConfigContext.Provider, {
        value: memoedConfig
      }, childNode);
    };
    const ConfigProvider = (props) => {
      const context = reactExports.useContext(ConfigContext);
      const antLocale = reactExports.useContext(LocaleContext);
      return /* @__PURE__ */ reactExports.createElement(ProviderChildren, Object.assign({
        parentContext: context,
        legacyLocale: antLocale
      }, props));
    };
    ConfigProvider.ConfigContext = ConfigContext;
    ConfigProvider.SizeContext = SizeContext;
    ConfigProvider.config = setGlobalConfig;
    ConfigProvider.useConfig = useConfig;
    Object.defineProperty(ConfigProvider, "SizeContext", {
      get: () => {
        return SizeContext;
      }
    });
    const genSharedAffixStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          position: "fixed",
          zIndex: token2.zIndexPopup
        }
      };
    };
    const prepareComponentToken$m = (token2) => ({
      zIndexPopup: token2.zIndexBase + 10
    });
    const useStyle$s = genStyleHooks("Affix", genSharedAffixStyle, prepareComponentToken$m);
    function getTargetRect(target) {
      return target !== window ? target.getBoundingClientRect() : {
        top: 0,
        bottom: window.innerHeight
      };
    }
    function getFixedTop(placeholderRect, targetRect, offsetTop) {
      if (offsetTop !== void 0 && Math.round(targetRect.top) > Math.round(placeholderRect.top) - offsetTop) {
        return offsetTop + targetRect.top;
      }
      return void 0;
    }
    function getFixedBottom(placeholderRect, targetRect, offsetBottom) {
      if (offsetBottom !== void 0 && Math.round(targetRect.bottom) < Math.round(placeholderRect.bottom) + offsetBottom) {
        const targetBottomOffset = window.innerHeight - targetRect.bottom;
        return offsetBottom + targetBottomOffset;
      }
      return void 0;
    }
    var __rest$T = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const TRIGGER_EVENTS = ["resize", "scroll", "touchstart", "touchmove", "touchend", "pageshow", "load"];
    function getDefaultTarget() {
      return typeof window !== "undefined" ? window : null;
    }
    const AFFIX_STATUS_NONE = 0;
    const AFFIX_STATUS_PREPARE = 1;
    const Affix = /* @__PURE__ */ i.forwardRef((props, ref) => {
      var _a;
      const {
        style: style2,
        offsetTop,
        offsetBottom,
        prefixCls,
        className,
        rootClassName,
        children,
        target,
        onChange,
        onTestUpdatePosition
      } = props, restProps = __rest$T(props, ["style", "offsetTop", "offsetBottom", "prefixCls", "className", "rootClassName", "children", "target", "onChange", "onTestUpdatePosition"]);
      const {
        getPrefixCls,
        getTargetContainer
      } = i.useContext(ConfigContext);
      const affixPrefixCls = getPrefixCls("affix", prefixCls);
      const [lastAffix, setLastAffix] = i.useState(false);
      const [affixStyle, setAffixStyle] = i.useState();
      const [placeholderStyle, setPlaceholderStyle] = i.useState();
      const status = i.useRef(AFFIX_STATUS_NONE);
      const prevTarget = i.useRef(null);
      const prevListener = i.useRef(null);
      const placeholderNodeRef = i.useRef(null);
      const fixedNodeRef = i.useRef(null);
      const timer = i.useRef(null);
      const targetFunc = (_a = target !== null && target !== void 0 ? target : getTargetContainer) !== null && _a !== void 0 ? _a : getDefaultTarget;
      const internalOffsetTop = offsetBottom === void 0 && offsetTop === void 0 ? 0 : offsetTop;
      const measure = () => {
        if (status.current !== AFFIX_STATUS_PREPARE || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) {
          return;
        }
        const targetNode = targetFunc();
        if (targetNode) {
          const newState = {
            status: AFFIX_STATUS_NONE
          };
          const placeholderRect = getTargetRect(placeholderNodeRef.current);
          if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {
            return;
          }
          const targetRect = getTargetRect(targetNode);
          const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);
          const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);
          if (fixedTop !== void 0) {
            newState.affixStyle = {
              position: "fixed",
              top: fixedTop,
              width: placeholderRect.width,
              height: placeholderRect.height
            };
            newState.placeholderStyle = {
              width: placeholderRect.width,
              height: placeholderRect.height
            };
          } else if (fixedBottom !== void 0) {
            newState.affixStyle = {
              position: "fixed",
              bottom: fixedBottom,
              width: placeholderRect.width,
              height: placeholderRect.height
            };
            newState.placeholderStyle = {
              width: placeholderRect.width,
              height: placeholderRect.height
            };
          }
          newState.lastAffix = !!newState.affixStyle;
          if (lastAffix !== newState.lastAffix) {
            onChange === null || onChange === void 0 ? void 0 : onChange(newState.lastAffix);
          }
          status.current = newState.status;
          setAffixStyle(newState.affixStyle);
          setPlaceholderStyle(newState.placeholderStyle);
          setLastAffix(newState.lastAffix);
        }
      };
      const prepareMeasure = () => {
        status.current = AFFIX_STATUS_PREPARE;
        measure();
      };
      const updatePosition = throttleByAnimationFrame(() => {
        prepareMeasure();
      });
      const lazyUpdatePosition = throttleByAnimationFrame(() => {
        if (targetFunc && affixStyle) {
          const targetNode = targetFunc();
          if (targetNode && placeholderNodeRef.current) {
            const targetRect = getTargetRect(targetNode);
            const placeholderRect = getTargetRect(placeholderNodeRef.current);
            const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);
            const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);
            if (fixedTop !== void 0 && affixStyle.top === fixedTop || fixedBottom !== void 0 && affixStyle.bottom === fixedBottom) {
              return;
            }
          }
        }
        prepareMeasure();
      });
      const addListeners = () => {
        const listenerTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();
        if (!listenerTarget) {
          return;
        }
        TRIGGER_EVENTS.forEach((eventName) => {
          var _a2;
          if (prevListener.current) {
            (_a2 = prevTarget.current) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(eventName, prevListener.current);
          }
          listenerTarget === null || listenerTarget === void 0 ? void 0 : listenerTarget.addEventListener(eventName, lazyUpdatePosition);
        });
        prevTarget.current = listenerTarget;
        prevListener.current = lazyUpdatePosition;
      };
      const removeListeners = () => {
        if (timer.current) {
          clearTimeout(timer.current);
          timer.current = null;
        }
        const newTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();
        TRIGGER_EVENTS.forEach((eventName) => {
          var _a2;
          newTarget === null || newTarget === void 0 ? void 0 : newTarget.removeEventListener(eventName, lazyUpdatePosition);
          if (prevListener.current) {
            (_a2 = prevTarget.current) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(eventName, prevListener.current);
          }
        });
        updatePosition.cancel();
        lazyUpdatePosition.cancel();
      };
      i.useImperativeHandle(ref, () => ({
        updatePosition
      }));
      i.useEffect(() => {
        timer.current = setTimeout(addListeners);
        return () => removeListeners();
      }, []);
      i.useEffect(() => {
        addListeners();
      }, [target, affixStyle, lastAffix]);
      i.useEffect(() => {
        updatePosition();
      }, [target, offsetTop, offsetBottom]);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$s(affixPrefixCls);
      const rootCls = classNames(rootClassName, hashId, affixPrefixCls, cssVarCls);
      const mergedCls = classNames({
        [rootCls]: affixStyle
      });
      return wrapCSSVar(/* @__PURE__ */ i.createElement(RefResizeObserver, {
        onResize: updatePosition
      }, /* @__PURE__ */ i.createElement("div", Object.assign({
        style: style2,
        className,
        ref: placeholderNodeRef
      }, restProps), affixStyle && /* @__PURE__ */ i.createElement("div", {
        style: placeholderStyle,
        "aria-hidden": "true"
      }), /* @__PURE__ */ i.createElement("div", {
        className: mergedCls,
        ref: fixedNodeRef,
        style: affixStyle
      }, /* @__PURE__ */ i.createElement(RefResizeObserver, {
        onResize: updatePosition
      }, children)))));
    });
    var CheckCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
    function getRoot$1(ele) {
      var _ele$getRootNode;
      return ele === null || ele === void 0 || (_ele$getRootNode = ele.getRootNode) === null || _ele$getRootNode === void 0 ? void 0 : _ele$getRootNode.call(ele);
    }
    function inShadow$1(ele) {
      return getRoot$1(ele) instanceof ShadowRoot;
    }
    function getShadowRoot$1(ele) {
      return inShadow$1(ele) ? getRoot$1(ele) : null;
    }
    function camelCase$1(input) {
      return input.replace(/-(.)/g, function(match2, g2) {
        return g2.toUpperCase();
      });
    }
    function warning$4(valid, message2) {
      warningOnce$1(valid, "[@ant-design/icons] ".concat(message2));
    }
    function isIconDefinition$1(target) {
      return _typeof$1(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof$1(target.icon) === "object" || typeof target.icon === "function");
    }
    function normalizeAttrs$1() {
      var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return Object.keys(attrs).reduce(function(acc, key) {
        var val = attrs[key];
        switch (key) {
          case "class":
            acc.className = val;
            delete acc.class;
            break;
          default:
            delete acc[key];
            acc[camelCase$1(key)] = val;
        }
        return acc;
      }, {});
    }
    function generate$1(node2, key, rootProps) {
      if (!rootProps) {
        return /* @__PURE__ */ i.createElement(node2.tag, _objectSpread2$3({
          key
        }, normalizeAttrs$1(node2.attrs)), (node2.children || []).map(function(child, index2) {
          return generate$1(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
        }));
      }
      return /* @__PURE__ */ i.createElement(node2.tag, _objectSpread2$3(_objectSpread2$3({
        key
      }, normalizeAttrs$1(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
        return generate$1(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
      }));
    }
    function getSecondaryColor$1(primaryColor) {
      return generate$2(primaryColor)[0];
    }
    function normalizeTwoToneColors$1(twoToneColor) {
      if (!twoToneColor) {
        return [];
      }
      return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
    }
    var iconStyles$1 = "\n.anticon {\n  display: inline-flex;\n  align-items: center;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
    var useInsertStyles = function useInsertStyles2(eleRef) {
      var _useContext = reactExports.useContext(IconContext$1), csp = _useContext.csp, prefixCls = _useContext.prefixCls, layer = _useContext.layer;
      var mergedStyleStr = iconStyles$1;
      if (prefixCls) {
        mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
      }
      if (layer) {
        mergedStyleStr = "@layer ".concat(layer, " {\n").concat(mergedStyleStr, "\n}");
      }
      reactExports.useEffect(function() {
        var ele = eleRef.current;
        var shadowRoot = getShadowRoot$1(ele);
        updateCSS$1(mergedStyleStr, "@ant-design-icons", {
          prepend: !layer,
          csp,
          attachTo: shadowRoot
        });
      }, []);
    };
    var _excluded$I = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
    var twoToneColorPalette$1 = {
      primaryColor: "#333",
      secondaryColor: "#E6E6E6",
      calculated: false
    };
    function setTwoToneColors$1(_ref) {
      var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
      twoToneColorPalette$1.primaryColor = primaryColor;
      twoToneColorPalette$1.secondaryColor = secondaryColor || getSecondaryColor$1(primaryColor);
      twoToneColorPalette$1.calculated = !!secondaryColor;
    }
    function getTwoToneColors$1() {
      return _objectSpread2$3({}, twoToneColorPalette$1);
    }
    var IconBase$2 = function IconBase2(props) {
      var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties(props, _excluded$I);
      var svgRef = reactExports.useRef();
      var colors = twoToneColorPalette$1;
      if (primaryColor) {
        colors = {
          primaryColor,
          secondaryColor: secondaryColor || getSecondaryColor$1(primaryColor)
        };
      }
      useInsertStyles(svgRef);
      warning$4(isIconDefinition$1(icon), "icon should be icon definiton, but got ".concat(icon));
      if (!isIconDefinition$1(icon)) {
        return null;
      }
      var target = icon;
      if (target && typeof target.icon === "function") {
        target = _objectSpread2$3(_objectSpread2$3({}, target), {}, {
          icon: target.icon(colors.primaryColor, colors.secondaryColor)
        });
      }
      return generate$1(target.icon, "svg-".concat(target.name), _objectSpread2$3(_objectSpread2$3({
        className,
        onClick,
        style: style2,
        "data-icon": target.name,
        width: "1em",
        height: "1em",
        fill: "currentColor",
        "aria-hidden": "true"
      }, restProps), {}, {
        ref: svgRef
      }));
    };
    IconBase$2.displayName = "IconReact";
    IconBase$2.getTwoToneColors = getTwoToneColors$1;
    IconBase$2.setTwoToneColors = setTwoToneColors$1;
    function setTwoToneColor$1(twoToneColor) {
      var _normalizeTwoToneColo = normalizeTwoToneColors$1(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
      return IconBase$2.setTwoToneColors({
        primaryColor,
        secondaryColor
      });
    }
    function getTwoToneColor$1() {
      var colors = IconBase$2.getTwoToneColors();
      if (!colors.calculated) {
        return colors.primaryColor;
      }
      return [colors.primaryColor, colors.secondaryColor];
    }
    var _excluded$H = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
    setTwoToneColor$1(blue.primary);
    var Icon$3 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties(props, _excluded$H);
      var _React$useContext = reactExports.useContext(IconContext$1), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
      var classString = classNames(rootClassName, prefixCls, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), className);
      var iconTabIndex = tabIndex;
      if (iconTabIndex === void 0 && onClick) {
        iconTabIndex = -1;
      }
      var svgStyle = rotate ? {
        msTransform: "rotate(".concat(rotate, "deg)"),
        transform: "rotate(".concat(rotate, "deg)")
      } : void 0;
      var _normalizeTwoToneColo = normalizeTwoToneColors$1(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
      return /* @__PURE__ */ reactExports.createElement("span", _extends$2({
        role: "img",
        "aria-label": icon.name
      }, restProps, {
        ref,
        tabIndex: iconTabIndex,
        onClick,
        className: classString
      }), /* @__PURE__ */ reactExports.createElement(IconBase$2, {
        icon,
        primaryColor,
        secondaryColor,
        style: svgStyle
      }));
    });
    Icon$3.displayName = "AntdIcon";
    Icon$3.getTwoToneColor = getTwoToneColor$1;
    Icon$3.setTwoToneColor = setTwoToneColor$1;
    var CheckCircleFilled = function CheckCircleFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: CheckCircleFilled$1
      }));
    };
    var RefIcon$C = /* @__PURE__ */ reactExports.forwardRef(CheckCircleFilled);
    var CloseCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, "name": "close-circle", "theme": "filled" };
    var CloseCircleFilled = function CloseCircleFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: CloseCircleFilled$1
      }));
    };
    var RefIcon$B = /* @__PURE__ */ reactExports.forwardRef(CloseCircleFilled);
    var CloseOutlined$1 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, "name": "close", "theme": "outlined" };
    var CloseOutlined = function CloseOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: CloseOutlined$1
      }));
    };
    var RefIcon$A = /* @__PURE__ */ reactExports.forwardRef(CloseOutlined);
    var ExclamationCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
    var ExclamationCircleFilled = function ExclamationCircleFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: ExclamationCircleFilled$1
      }));
    };
    var RefIcon$z = /* @__PURE__ */ reactExports.forwardRef(ExclamationCircleFilled);
    var InfoCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
    var InfoCircleFilled = function InfoCircleFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: InfoCircleFilled$1
      }));
    };
    var RefIcon$y = /* @__PURE__ */ reactExports.forwardRef(InfoCircleFilled);
    var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
    var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
    var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
    var ariaPrefix = "aria-";
    var dataPrefix = "data-";
    function match(key, prefix2) {
      return key.indexOf(prefix2) === 0;
    }
    function pickAttrs(props) {
      var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var mergedConfig;
      if (ariaOnly === false) {
        mergedConfig = {
          aria: true,
          data: true,
          attr: true
        };
      } else if (ariaOnly === true) {
        mergedConfig = {
          aria: true
        };
      } else {
        mergedConfig = _objectSpread2$3({}, ariaOnly);
      }
      var attrs = {};
      Object.keys(props).forEach(function(key) {
        if (
          // Aria
          mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || // Data
          mergedConfig.data && match(key, dataPrefix) || // Attr
          mergedConfig.attr && propList.includes(key)
        ) {
          attrs[key] = props[key];
        }
      });
      return attrs;
    }
    function isFragment(child) {
      return child && /* @__PURE__ */ i.isValidElement(child) && child.type === i.Fragment;
    }
    const replaceElement = (element, replacement, props) => {
      if (!/* @__PURE__ */ i.isValidElement(element)) {
        return replacement;
      }
      return /* @__PURE__ */ i.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
    };
    function cloneElement(element, props) {
      return replaceElement(element, element, props);
    }
    const t$1 = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType, e$2 = (t2, e2) => (!e2 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2), n$1 = (t2, n2) => {
      if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
        const o2 = getComputedStyle(t2, null);
        return e$2(o2.overflowY, n2) || e$2(o2.overflowX, n2) || ((t3) => {
          const e2 = ((t4) => {
            if (!t4.ownerDocument || !t4.ownerDocument.defaultView) return null;
            try {
              return t4.ownerDocument.defaultView.frameElement;
            } catch (t5) {
              return null;
            }
          })(t3);
          return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
        })(t2);
      }
      return false;
    }, o$1 = (t2, e2, n2, o2, l2, r2, i2, s) => r2 < t2 && i2 > e2 || r2 > t2 && i2 < e2 ? 0 : r2 <= t2 && s <= n2 || i2 >= e2 && s >= n2 ? r2 - t2 - o2 : i2 > e2 && s < n2 || r2 < t2 && s > n2 ? i2 - e2 + l2 : 0, l$1 = (t2) => {
      const e2 = t2.parentElement;
      return null == e2 ? t2.getRootNode().host || null : e2;
    }, r$1 = (e2, r2) => {
      var i2, s, d2, h2;
      if ("undefined" == typeof document) return [];
      const { scrollMode: c2, block: f2, inline: u2, boundary: a, skipOverflowHiddenElements: g2 } = r2, p2 = "function" == typeof a ? a : (t2) => t2 !== a;
      if (!t$1(e2)) throw new TypeError("Invalid target");
      const m2 = document.scrollingElement || document.documentElement, w2 = [];
      let W2 = e2;
      for (; t$1(W2) && p2(W2); ) {
        if (W2 = l$1(W2), W2 === m2) {
          w2.push(W2);
          break;
        }
        null != W2 && W2 === document.body && n$1(W2) && !n$1(document.documentElement) || null != W2 && n$1(W2, g2) && w2.push(W2);
      }
      const b2 = null != (s = null == (i2 = window.visualViewport) ? void 0 : i2.width) ? s : innerWidth, H2 = null != (h2 = null == (d2 = window.visualViewport) ? void 0 : d2.height) ? h2 : innerHeight, { scrollX: y2, scrollY: M2 } = window, { height: v2, width: E2, top: x2, right: C2, bottom: I2, left: R2 } = e2.getBoundingClientRect(), { top: T2, right: B2, bottom: F, left: V2 } = ((t2) => {
        const e3 = window.getComputedStyle(t2);
        return { top: parseFloat(e3.scrollMarginTop) || 0, right: parseFloat(e3.scrollMarginRight) || 0, bottom: parseFloat(e3.scrollMarginBottom) || 0, left: parseFloat(e3.scrollMarginLeft) || 0 };
      })(e2);
      let k2 = "start" === f2 || "nearest" === f2 ? x2 - T2 : "end" === f2 ? I2 + F : x2 + v2 / 2 - T2 + F, D2 = "center" === u2 ? R2 + E2 / 2 - V2 + B2 : "end" === u2 ? C2 + B2 : R2 - V2;
      const L2 = [];
      for (let t2 = 0; t2 < w2.length; t2++) {
        const e3 = w2[t2], { height: l2, width: r3, top: i3, right: s2, bottom: d3, left: h3 } = e3.getBoundingClientRect();
        if ("if-needed" === c2 && x2 >= 0 && R2 >= 0 && I2 <= H2 && C2 <= b2 && (e3 === m2 && !n$1(e3) || x2 >= i3 && I2 <= d3 && R2 >= h3 && C2 <= s2)) return L2;
        const a2 = getComputedStyle(e3), g3 = parseInt(a2.borderLeftWidth, 10), p3 = parseInt(a2.borderTopWidth, 10), W3 = parseInt(a2.borderRightWidth, 10), T3 = parseInt(a2.borderBottomWidth, 10);
        let B3 = 0, F2 = 0;
        const V3 = "offsetWidth" in e3 ? e3.offsetWidth - e3.clientWidth - g3 - W3 : 0, S = "offsetHeight" in e3 ? e3.offsetHeight - e3.clientHeight - p3 - T3 : 0, X2 = "offsetWidth" in e3 ? 0 === e3.offsetWidth ? 0 : r3 / e3.offsetWidth : 0, Y2 = "offsetHeight" in e3 ? 0 === e3.offsetHeight ? 0 : l2 / e3.offsetHeight : 0;
        if (m2 === e3) B3 = "start" === f2 ? k2 : "end" === f2 ? k2 - H2 : "nearest" === f2 ? o$1(M2, M2 + H2, H2, p3, T3, M2 + k2, M2 + k2 + v2, v2) : k2 - H2 / 2, F2 = "start" === u2 ? D2 : "center" === u2 ? D2 - b2 / 2 : "end" === u2 ? D2 - b2 : o$1(y2, y2 + b2, b2, g3, W3, y2 + D2, y2 + D2 + E2, E2), B3 = Math.max(0, B3 + M2), F2 = Math.max(0, F2 + y2);
        else {
          B3 = "start" === f2 ? k2 - i3 - p3 : "end" === f2 ? k2 - d3 + T3 + S : "nearest" === f2 ? o$1(i3, d3, l2, p3, T3 + S, k2, k2 + v2, v2) : k2 - (i3 + l2 / 2) + S / 2, F2 = "start" === u2 ? D2 - h3 - g3 : "center" === u2 ? D2 - (h3 + r3 / 2) + V3 / 2 : "end" === u2 ? D2 - s2 + W3 + V3 : o$1(h3, s2, r3, g3, W3 + V3, D2, D2 + E2, E2);
          const { scrollLeft: t3, scrollTop: n2 } = e3;
          B3 = 0 === Y2 ? 0 : Math.max(0, Math.min(n2 + B3 / Y2, e3.scrollHeight - l2 / Y2 + S)), F2 = 0 === X2 ? 0 : Math.max(0, Math.min(t3 + F2 / X2, e3.scrollWidth - r3 / X2 + V3)), k2 += n2 - B3, D2 += t3 - F2;
        }
        L2.push({ el: e3, top: B3, left: F2 });
      }
      return L2;
    };
    const o = (t2) => false === t2 ? { block: "end", inline: "nearest" } : ((t3) => t3 === Object(t3) && 0 !== Object.keys(t3).length)(t2) ? t2 : { block: "start", inline: "nearest" };
    function e$1(e2, r2) {
      if (!e2.isConnected || !((t2) => {
        let o2 = t2;
        for (; o2 && o2.parentNode; ) {
          if (o2.parentNode === document) return true;
          o2 = o2.parentNode instanceof ShadowRoot ? o2.parentNode.host : o2.parentNode;
        }
        return false;
      })(e2)) return;
      const n2 = ((t2) => {
        const o2 = window.getComputedStyle(t2);
        return { top: parseFloat(o2.scrollMarginTop) || 0, right: parseFloat(o2.scrollMarginRight) || 0, bottom: parseFloat(o2.scrollMarginBottom) || 0, left: parseFloat(o2.scrollMarginLeft) || 0 };
      })(e2);
      if (((t2) => "object" == typeof t2 && "function" == typeof t2.behavior)(r2)) return r2.behavior(r$1(e2, r2));
      const l2 = "boolean" == typeof r2 || null == r2 ? void 0 : r2.behavior;
      for (const { el: a, top: i2, left: s } of r$1(e2, o(r2))) {
        const t2 = i2 - n2.top + n2.bottom, o2 = s - n2.left + n2.right;
        a.scroll({ top: t2, left: o2, behavior: l2 });
      }
    }
    const useCSSVarCls = (prefixCls) => {
      const [, , , , cssVar] = useToken();
      return cssVar ? `${prefixCls}-css-var` : "";
    };
    var KeyCode = {
      /**
       * BACKSPACE
       */
      BACKSPACE: 8,
      /**
       * TAB
       */
      TAB: 9,
      // NUMLOCK on FF/Safari Mac
      /**
       * ENTER
       */
      ENTER: 13,
      /**
       * SHIFT
       */
      SHIFT: 16,
      /**
       * CTRL
       */
      CTRL: 17,
      /**
       * ALT
       */
      ALT: 18,
      /**
       * CAPS_LOCK
       */
      CAPS_LOCK: 20,
      /**
       * ESC
       */
      ESC: 27,
      /**
       * SPACE
       */
      SPACE: 32,
      // also NUM_SOUTH_EAST
      /**
       * END
       */
      END: 35,
      // also NUM_SOUTH_WEST
      /**
       * HOME
       */
      HOME: 36,
      // also NUM_NORTH_WEST
      /**
       * LEFT
       */
      LEFT: 37,
      // also NUM_WEST
      /**
       * UP
       */
      UP: 38,
      // also NUM_NORTH
      /**
       * RIGHT
       */
      RIGHT: 39,
      // also NUM_EAST
      /**
       * DOWN
       */
      DOWN: 40,
      /**
       * N
       */
      N: 78,
      /**
       * P
       */
      P: 80,
      /**
       * META
       */
      META: 91,
      // WIN_KEY_LEFT
      /**
       * WIN_KEY_RIGHT
       */
      WIN_KEY_RIGHT: 92,
      /**
       * CONTEXT_MENU
       */
      CONTEXT_MENU: 93,
      /**
       * F1
       */
      F1: 112,
      /**
       * F2
       */
      F2: 113,
      /**
       * F3
       */
      F3: 114,
      /**
       * F4
       */
      F4: 115,
      /**
       * F5
       */
      F5: 116,
      /**
       * F6
       */
      F6: 117,
      /**
       * F7
       */
      F7: 118,
      /**
       * F8
       */
      F8: 119,
      /**
       * F9
       */
      F9: 120,
      /**
       * F10
       */
      F10: 121,
      /**
       * F11
       */
      F11: 122,
      /**
       * F12
       */
      F12: 123,
      /**
       * SEMICOLON
       */
      SEMICOLON: 186,
      // needs localization
      /**
       * EQUALS
       */
      EQUALS: 187,
      // needs localization
      /**
       * WIN_KEY
       */
      WIN_KEY: 224
    };
    var Notify = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, style2 = props.style, className = props.className, _props$duration = props.duration, duration = _props$duration === void 0 ? 4.5 : _props$duration, showProgress = props.showProgress, _props$pauseOnHover = props.pauseOnHover, pauseOnHover = _props$pauseOnHover === void 0 ? true : _props$pauseOnHover, eventKey = props.eventKey, content = props.content, closable = props.closable, _props$closeIcon = props.closeIcon, closeIcon = _props$closeIcon === void 0 ? "x" : _props$closeIcon, divProps = props.props, onClick = props.onClick, onNoticeClose = props.onNoticeClose, times = props.times, forcedHovering = props.hovering;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), hovering = _React$useState2[0], setHovering = _React$useState2[1];
      var _React$useState3 = reactExports.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), percent = _React$useState4[0], setPercent = _React$useState4[1];
      var _React$useState5 = reactExports.useState(0), _React$useState6 = _slicedToArray(_React$useState5, 2), spentTime = _React$useState6[0], setSpentTime = _React$useState6[1];
      var mergedHovering = forcedHovering || hovering;
      var mergedShowProgress = duration > 0 && showProgress;
      var onInternalClose = function onInternalClose2() {
        onNoticeClose(eventKey);
      };
      var onCloseKeyDown = function onCloseKeyDown2(e2) {
        if (e2.key === "Enter" || e2.code === "Enter" || e2.keyCode === KeyCode.ENTER) {
          onInternalClose();
        }
      };
      reactExports.useEffect(function() {
        if (!mergedHovering && duration > 0) {
          var start = Date.now() - spentTime;
          var timeout = setTimeout(function() {
            onInternalClose();
          }, duration * 1e3 - spentTime);
          return function() {
            if (pauseOnHover) {
              clearTimeout(timeout);
            }
            setSpentTime(Date.now() - start);
          };
        }
      }, [duration, mergedHovering, times]);
      reactExports.useEffect(function() {
        if (!mergedHovering && mergedShowProgress && (pauseOnHover || spentTime === 0)) {
          var start = performance.now();
          var animationFrame;
          var calculate = function calculate2() {
            cancelAnimationFrame(animationFrame);
            animationFrame = requestAnimationFrame(function(timestamp) {
              var runtime = timestamp + spentTime - start;
              var progress = Math.min(runtime / (duration * 1e3), 1);
              setPercent(progress * 100);
              if (progress < 1) {
                calculate2();
              }
            });
          };
          calculate();
          return function() {
            if (pauseOnHover) {
              cancelAnimationFrame(animationFrame);
            }
          };
        }
      }, [duration, spentTime, mergedHovering, mergedShowProgress, times]);
      var closableObj = reactExports.useMemo(function() {
        if (_typeof$1(closable) === "object" && closable !== null) {
          return closable;
        }
        if (closable) {
          return {
            closeIcon
          };
        }
        return {};
      }, [closable, closeIcon]);
      var ariaProps = pickAttrs(closableObj, true);
      var validPercent = 100 - (!percent || percent < 0 ? 0 : percent > 100 ? 100 : percent);
      var noticePrefixCls = "".concat(prefixCls, "-notice");
      return /* @__PURE__ */ reactExports.createElement("div", _extends$2({}, divProps, {
        ref,
        className: classNames(noticePrefixCls, className, _defineProperty({}, "".concat(noticePrefixCls, "-closable"), closable)),
        style: style2,
        onMouseEnter: function onMouseEnter(e2) {
          var _divProps$onMouseEnte;
          setHovering(true);
          divProps === null || divProps === void 0 || (_divProps$onMouseEnte = divProps.onMouseEnter) === null || _divProps$onMouseEnte === void 0 || _divProps$onMouseEnte.call(divProps, e2);
        },
        onMouseLeave: function onMouseLeave(e2) {
          var _divProps$onMouseLeav;
          setHovering(false);
          divProps === null || divProps === void 0 || (_divProps$onMouseLeav = divProps.onMouseLeave) === null || _divProps$onMouseLeav === void 0 || _divProps$onMouseLeav.call(divProps, e2);
        },
        onClick
      }), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(noticePrefixCls, "-content")
      }, content), closable && /* @__PURE__ */ reactExports.createElement("a", _extends$2({
        tabIndex: 0,
        className: "".concat(noticePrefixCls, "-close"),
        onKeyDown: onCloseKeyDown,
        "aria-label": "Close"
      }, ariaProps, {
        onClick: function onClick2(e2) {
          e2.preventDefault();
          e2.stopPropagation();
          onInternalClose();
        }
      }), closableObj.closeIcon), mergedShowProgress && /* @__PURE__ */ reactExports.createElement("progress", {
        className: "".concat(noticePrefixCls, "-progress"),
        max: "100",
        value: validPercent
      }, validPercent + "%"));
    });
    var NotificationContext = /* @__PURE__ */ i.createContext({});
    var NotificationProvider = function NotificationProvider2(_ref) {
      var children = _ref.children, classNames2 = _ref.classNames;
      return /* @__PURE__ */ i.createElement(NotificationContext.Provider, {
        value: {
          classNames: classNames2
        }
      }, children);
    };
    var DEFAULT_OFFSET$1 = 8;
    var DEFAULT_THRESHOLD = 3;
    var DEFAULT_GAP = 16;
    var useStack = function useStack2(config) {
      var result = {
        offset: DEFAULT_OFFSET$1,
        threshold: DEFAULT_THRESHOLD,
        gap: DEFAULT_GAP
      };
      if (config && _typeof$1(config) === "object") {
        var _config$offset, _config$threshold, _config$gap;
        result.offset = (_config$offset = config.offset) !== null && _config$offset !== void 0 ? _config$offset : DEFAULT_OFFSET$1;
        result.threshold = (_config$threshold = config.threshold) !== null && _config$threshold !== void 0 ? _config$threshold : DEFAULT_THRESHOLD;
        result.gap = (_config$gap = config.gap) !== null && _config$gap !== void 0 ? _config$gap : DEFAULT_GAP;
      }
      return [!!config, result];
    };
    var _excluded$G = ["className", "style", "classNames", "styles"];
    var NoticeList = function NoticeList2(props) {
      var configList = props.configList, placement = props.placement, prefixCls = props.prefixCls, className = props.className, style2 = props.style, motion2 = props.motion, onAllNoticeRemoved = props.onAllNoticeRemoved, onNoticeClose = props.onNoticeClose, stackConfig = props.stack;
      var _useContext = reactExports.useContext(NotificationContext), ctxCls = _useContext.classNames;
      var dictRef = reactExports.useRef({});
      var _useState = reactExports.useState(null), _useState2 = _slicedToArray(_useState, 2), latestNotice = _useState2[0], setLatestNotice = _useState2[1];
      var _useState3 = reactExports.useState([]), _useState4 = _slicedToArray(_useState3, 2), hoverKeys = _useState4[0], setHoverKeys = _useState4[1];
      var keys2 = configList.map(function(config) {
        return {
          config,
          key: String(config.key)
        };
      });
      var _useStack = useStack(stackConfig), _useStack2 = _slicedToArray(_useStack, 2), stack = _useStack2[0], _useStack2$ = _useStack2[1], offset2 = _useStack2$.offset, threshold = _useStack2$.threshold, gap = _useStack2$.gap;
      var expanded = stack && (hoverKeys.length > 0 || keys2.length <= threshold);
      var placementMotion = typeof motion2 === "function" ? motion2(placement) : motion2;
      reactExports.useEffect(function() {
        if (stack && hoverKeys.length > 1) {
          setHoverKeys(function(prev2) {
            return prev2.filter(function(key) {
              return keys2.some(function(_ref) {
                var dataKey = _ref.key;
                return key === dataKey;
              });
            });
          });
        }
      }, [hoverKeys, keys2, stack]);
      reactExports.useEffect(function() {
        var _keys;
        if (stack && dictRef.current[(_keys = keys2[keys2.length - 1]) === null || _keys === void 0 ? void 0 : _keys.key]) {
          var _keys2;
          setLatestNotice(dictRef.current[(_keys2 = keys2[keys2.length - 1]) === null || _keys2 === void 0 ? void 0 : _keys2.key]);
        }
      }, [keys2, stack]);
      return /* @__PURE__ */ i.createElement(CSSMotionList, _extends$2({
        key: placement,
        className: classNames(prefixCls, "".concat(prefixCls, "-").concat(placement), ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.list, className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-stack"), !!stack), "".concat(prefixCls, "-stack-expanded"), expanded)),
        style: style2,
        keys: keys2,
        motionAppear: true
      }, placementMotion, {
        onAllRemoved: function onAllRemoved() {
          onAllNoticeRemoved(placement);
        }
      }), function(_ref2, nodeRef) {
        var config = _ref2.config, motionClassName = _ref2.className, motionStyle = _ref2.style, motionIndex = _ref2.index;
        var _ref3 = config, key = _ref3.key, times = _ref3.times;
        var strKey = String(key);
        var _ref4 = config, configClassName = _ref4.className, configStyle = _ref4.style, configClassNames = _ref4.classNames, configStyles = _ref4.styles, restConfig = _objectWithoutProperties(_ref4, _excluded$G);
        var dataIndex = keys2.findIndex(function(item) {
          return item.key === strKey;
        });
        var stackStyle = {};
        if (stack) {
          var index2 = keys2.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);
          var transformX = placement === "top" || placement === "bottom" ? "-50%" : "0";
          if (index2 > 0) {
            var _dictRef$current$strK, _dictRef$current$strK2, _dictRef$current$strK3;
            stackStyle.height = expanded ? (_dictRef$current$strK = dictRef.current[strKey]) === null || _dictRef$current$strK === void 0 ? void 0 : _dictRef$current$strK.offsetHeight : latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetHeight;
            var verticalOffset = 0;
            for (var i$1 = 0; i$1 < index2; i$1++) {
              var _dictRef$current$keys;
              verticalOffset += ((_dictRef$current$keys = dictRef.current[keys2[keys2.length - 1 - i$1].key]) === null || _dictRef$current$keys === void 0 ? void 0 : _dictRef$current$keys.offsetHeight) + gap;
            }
            var transformY = (expanded ? verticalOffset : index2 * offset2) * (placement.startsWith("top") ? 1 : -1);
            var scaleX = !expanded && latestNotice !== null && latestNotice !== void 0 && latestNotice.offsetWidth && (_dictRef$current$strK2 = dictRef.current[strKey]) !== null && _dictRef$current$strK2 !== void 0 && _dictRef$current$strK2.offsetWidth ? ((latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetWidth) - offset2 * 2 * (index2 < 3 ? index2 : 3)) / ((_dictRef$current$strK3 = dictRef.current[strKey]) === null || _dictRef$current$strK3 === void 0 ? void 0 : _dictRef$current$strK3.offsetWidth) : 1;
            stackStyle.transform = "translate3d(".concat(transformX, ", ").concat(transformY, "px, 0) scaleX(").concat(scaleX, ")");
          } else {
            stackStyle.transform = "translate3d(".concat(transformX, ", 0, 0)");
          }
        }
        return /* @__PURE__ */ i.createElement("div", {
          ref: nodeRef,
          className: classNames("".concat(prefixCls, "-notice-wrapper"), motionClassName, configClassNames === null || configClassNames === void 0 ? void 0 : configClassNames.wrapper),
          style: _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, motionStyle), stackStyle), configStyles === null || configStyles === void 0 ? void 0 : configStyles.wrapper),
          onMouseEnter: function onMouseEnter() {
            return setHoverKeys(function(prev2) {
              return prev2.includes(strKey) ? prev2 : [].concat(_toConsumableArray(prev2), [strKey]);
            });
          },
          onMouseLeave: function onMouseLeave() {
            return setHoverKeys(function(prev2) {
              return prev2.filter(function(k2) {
                return k2 !== strKey;
              });
            });
          }
        }, /* @__PURE__ */ i.createElement(Notify, _extends$2({}, restConfig, {
          ref: function ref(node2) {
            if (dataIndex > -1) {
              dictRef.current[strKey] = node2;
            } else {
              delete dictRef.current[strKey];
            }
          },
          prefixCls,
          classNames: configClassNames,
          styles: configStyles,
          className: classNames(configClassName, ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.notice),
          style: configStyle,
          times,
          key,
          eventKey: key,
          onNoticeClose,
          hovering: stack && hoverKeys.length > 0
        })));
      });
    };
    var Notifications = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-notification" : _props$prefixCls, container = props.container, motion2 = props.motion, maxCount = props.maxCount, className = props.className, style2 = props.style, onAllRemoved = props.onAllRemoved, stack = props.stack, renderNotifications2 = props.renderNotifications;
      var _React$useState = reactExports.useState([]), _React$useState2 = _slicedToArray(_React$useState, 2), configList = _React$useState2[0], setConfigList = _React$useState2[1];
      var onNoticeClose = function onNoticeClose2(key) {
        var _config$onClose;
        var config = configList.find(function(item) {
          return item.key === key;
        });
        config === null || config === void 0 || (_config$onClose = config.onClose) === null || _config$onClose === void 0 || _config$onClose.call(config);
        setConfigList(function(list) {
          return list.filter(function(item) {
            return item.key !== key;
          });
        });
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          open: function open2(config) {
            setConfigList(function(list) {
              var clone2 = _toConsumableArray(list);
              var index2 = clone2.findIndex(function(item) {
                return item.key === config.key;
              });
              var innerConfig = _objectSpread2$3({}, config);
              if (index2 >= 0) {
                var _list$index;
                innerConfig.times = (((_list$index = list[index2]) === null || _list$index === void 0 ? void 0 : _list$index.times) || 0) + 1;
                clone2[index2] = innerConfig;
              } else {
                innerConfig.times = 0;
                clone2.push(innerConfig);
              }
              if (maxCount > 0 && clone2.length > maxCount) {
                clone2 = clone2.slice(-maxCount);
              }
              return clone2;
            });
          },
          close: function close(key) {
            onNoticeClose(key);
          },
          destroy: function destroy2() {
            setConfigList([]);
          }
        };
      });
      var _React$useState3 = reactExports.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), placements2 = _React$useState4[0], setPlacements = _React$useState4[1];
      reactExports.useEffect(function() {
        var nextPlacements = {};
        configList.forEach(function(config) {
          var _config$placement = config.placement, placement = _config$placement === void 0 ? "topRight" : _config$placement;
          if (placement) {
            nextPlacements[placement] = nextPlacements[placement] || [];
            nextPlacements[placement].push(config);
          }
        });
        Object.keys(placements2).forEach(function(placement) {
          nextPlacements[placement] = nextPlacements[placement] || [];
        });
        setPlacements(nextPlacements);
      }, [configList]);
      var onAllNoticeRemoved = function onAllNoticeRemoved2(placement) {
        setPlacements(function(originPlacements) {
          var clone2 = _objectSpread2$3({}, originPlacements);
          var list = clone2[placement] || [];
          if (!list.length) {
            delete clone2[placement];
          }
          return clone2;
        });
      };
      var emptyRef = reactExports.useRef(false);
      reactExports.useEffect(function() {
        if (Object.keys(placements2).length > 0) {
          emptyRef.current = true;
        } else if (emptyRef.current) {
          onAllRemoved === null || onAllRemoved === void 0 || onAllRemoved();
          emptyRef.current = false;
        }
      }, [placements2]);
      if (!container) {
        return null;
      }
      var placementList = Object.keys(placements2);
      return /* @__PURE__ */ reactDomExports.createPortal(/* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, placementList.map(function(placement) {
        var placementConfigList = placements2[placement];
        var list = /* @__PURE__ */ reactExports.createElement(NoticeList, {
          key: placement,
          configList: placementConfigList,
          placement,
          prefixCls,
          className: className === null || className === void 0 ? void 0 : className(placement),
          style: style2 === null || style2 === void 0 ? void 0 : style2(placement),
          motion: motion2,
          onNoticeClose,
          onAllNoticeRemoved,
          stack
        });
        return renderNotifications2 ? renderNotifications2(list, {
          prefixCls,
          key: placement
        }) : list;
      })), container);
    });
    var _excluded$F = ["getContainer", "motion", "prefixCls", "maxCount", "className", "style", "onAllRemoved", "stack", "renderNotifications"];
    var defaultGetContainer = function defaultGetContainer2() {
      return document.body;
    };
    var uniqueKey = 0;
    function mergeConfig() {
      var clone2 = {};
      for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
        objList[_key] = arguments[_key];
      }
      objList.forEach(function(obj) {
        if (obj) {
          Object.keys(obj).forEach(function(key) {
            var val = obj[key];
            if (val !== void 0) {
              clone2[key] = val;
            }
          });
        }
      });
      return clone2;
    }
    function useNotification() {
      var rootConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _rootConfig$getContai = rootConfig.getContainer, getContainer2 = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai, motion2 = rootConfig.motion, prefixCls = rootConfig.prefixCls, maxCount = rootConfig.maxCount, className = rootConfig.className, style2 = rootConfig.style, onAllRemoved = rootConfig.onAllRemoved, stack = rootConfig.stack, renderNotifications2 = rootConfig.renderNotifications, shareConfig = _objectWithoutProperties(rootConfig, _excluded$F);
      var _React$useState = reactExports.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), container = _React$useState2[0], setContainer = _React$useState2[1];
      var notificationsRef = reactExports.useRef();
      var contextHolder = /* @__PURE__ */ reactExports.createElement(Notifications, {
        container,
        ref: notificationsRef,
        prefixCls,
        motion: motion2,
        maxCount,
        className,
        style: style2,
        onAllRemoved,
        stack,
        renderNotifications: renderNotifications2
      });
      var _React$useState3 = reactExports.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), taskQueue2 = _React$useState4[0], setTaskQueue = _React$useState4[1];
      var api = reactExports.useMemo(function() {
        return {
          open: function open2(config) {
            var mergedConfig = mergeConfig(shareConfig, config);
            if (mergedConfig.key === null || mergedConfig.key === void 0) {
              mergedConfig.key = "rc-notification-".concat(uniqueKey);
              uniqueKey += 1;
            }
            setTaskQueue(function(queue) {
              return [].concat(_toConsumableArray(queue), [{
                type: "open",
                config: mergedConfig
              }]);
            });
          },
          close: function close(key) {
            setTaskQueue(function(queue) {
              return [].concat(_toConsumableArray(queue), [{
                type: "close",
                key
              }]);
            });
          },
          destroy: function destroy2() {
            setTaskQueue(function(queue) {
              return [].concat(_toConsumableArray(queue), [{
                type: "destroy"
              }]);
            });
          }
        };
      }, []);
      reactExports.useEffect(function() {
        setContainer(getContainer2());
      });
      reactExports.useEffect(function() {
        if (notificationsRef.current && taskQueue2.length) {
          taskQueue2.forEach(function(task) {
            switch (task.type) {
              case "open":
                notificationsRef.current.open(task.config);
                break;
              case "close":
                notificationsRef.current.close(task.key);
                break;
              case "destroy":
                notificationsRef.current.destroy();
                break;
            }
          });
          var oriTaskQueue;
          var tgtTaskQueue;
          setTaskQueue(function(oriQueue) {
            if (oriTaskQueue !== oriQueue || !tgtTaskQueue) {
              oriTaskQueue = oriQueue;
              tgtTaskQueue = oriQueue.filter(function(task) {
                return !taskQueue2.includes(task);
              });
            }
            return tgtTaskQueue;
          });
        }
      }, [taskQueue2]);
      return [api, contextHolder];
    }
    var LoadingOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
    var LoadingOutlined = function LoadingOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: LoadingOutlined$1
      }));
    };
    var RefIcon$x = /* @__PURE__ */ reactExports.forwardRef(LoadingOutlined);
    const zIndexContext = /* @__PURE__ */ i.createContext(void 0);
    const CONTAINER_OFFSET = 100;
    const CONTAINER_OFFSET_MAX_COUNT = 10;
    const CONTAINER_MAX_OFFSET = CONTAINER_OFFSET * CONTAINER_OFFSET_MAX_COUNT;
    const containerBaseZIndexOffset = {
      Modal: CONTAINER_OFFSET,
      Drawer: CONTAINER_OFFSET,
      Popover: CONTAINER_OFFSET,
      Popconfirm: CONTAINER_OFFSET,
      Tooltip: CONTAINER_OFFSET,
      Tour: CONTAINER_OFFSET,
      FloatButton: CONTAINER_OFFSET
    };
    const consumerBaseZIndexOffset = {
      SelectLike: 50,
      Dropdown: 50,
      DatePicker: 50,
      Menu: 50,
      ImagePreview: 1
    };
    function isContainerType(type2) {
      return type2 in containerBaseZIndexOffset;
    }
    const useZIndex = (componentType, customZIndex) => {
      const [, token2] = useToken();
      const parentZIndex = i.useContext(zIndexContext);
      const isContainer = isContainerType(componentType);
      let result;
      if (customZIndex !== void 0) {
        result = [customZIndex, customZIndex];
      } else {
        let zIndex = parentZIndex !== null && parentZIndex !== void 0 ? parentZIndex : 0;
        if (isContainer) {
          zIndex += // Use preset token zIndex by default but not stack when has parent container
          (parentZIndex ? 0 : token2.zIndexPopupBase) + // Container offset
          containerBaseZIndexOffset[componentType];
        } else {
          zIndex += consumerBaseZIndexOffset[componentType];
        }
        result = [parentZIndex === void 0 ? customZIndex : zIndex, zIndex];
      }
      return result;
    };
    const genMessageStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        boxShadow,
        colorText,
        colorSuccess,
        colorError,
        colorWarning,
        colorInfo,
        fontSizeLG,
        motionEaseInOutCirc,
        motionDurationSlow,
        marginXS,
        paddingXS,
        borderRadiusLG,
        zIndexPopup,
        // Custom token
        contentPadding,
        contentBg
      } = token2;
      const noticeCls = `${componentCls}-notice`;
      const messageMoveIn = new Keyframe("MessageMoveIn", {
        "0%": {
          padding: 0,
          transform: "translateY(-100%)",
          opacity: 0
        },
        "100%": {
          padding: paddingXS,
          transform: "translateY(0)",
          opacity: 1
        }
      });
      const messageMoveOut = new Keyframe("MessageMoveOut", {
        "0%": {
          maxHeight: token2.height,
          padding: paddingXS,
          opacity: 1
        },
        "100%": {
          maxHeight: 0,
          padding: 0,
          opacity: 0
        }
      });
      const noticeStyle = {
        padding: paddingXS,
        textAlign: "center",
        [`${componentCls}-custom-content`]: {
          display: "flex",
          alignItems: "center"
        },
        [`${componentCls}-custom-content > ${iconCls}`]: {
          marginInlineEnd: marginXS,
          // affected by ltr or rtl
          fontSize: fontSizeLG
        },
        [`${noticeCls}-content`]: {
          display: "inline-block",
          padding: contentPadding,
          background: contentBg,
          borderRadius: borderRadiusLG,
          boxShadow,
          pointerEvents: "all"
        },
        [`${componentCls}-success > ${iconCls}`]: {
          color: colorSuccess
        },
        [`${componentCls}-error > ${iconCls}`]: {
          color: colorError
        },
        [`${componentCls}-warning > ${iconCls}`]: {
          color: colorWarning
        },
        [`${componentCls}-info > ${iconCls},
      ${componentCls}-loading > ${iconCls}`]: {
          color: colorInfo
        }
      };
      return [
        // ============================ Holder ============================
        {
          [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
            color: colorText,
            position: "fixed",
            top: marginXS,
            width: "100%",
            pointerEvents: "none",
            zIndex: zIndexPopup,
            [`${componentCls}-move-up`]: {
              animationFillMode: "forwards"
            },
            [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
              animationName: messageMoveIn,
              animationDuration: motionDurationSlow,
              animationPlayState: "paused",
              animationTimingFunction: motionEaseInOutCirc
            },
            [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
              animationPlayState: "running"
            },
            [`${componentCls}-move-up-leave`]: {
              animationName: messageMoveOut,
              animationDuration: motionDurationSlow,
              animationPlayState: "paused",
              animationTimingFunction: motionEaseInOutCirc
            },
            [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
              animationPlayState: "running"
            },
            "&-rtl": {
              direction: "rtl",
              span: {
                direction: "rtl"
              }
            }
          })
        },
        // ============================ Notice ============================
        {
          [componentCls]: {
            [`${noticeCls}-wrapper`]: Object.assign({}, noticeStyle)
          }
        },
        // ============================= Pure =============================
        {
          [`${componentCls}-notice-pure-panel`]: Object.assign(Object.assign({}, noticeStyle), {
            padding: 0,
            textAlign: "start"
          })
        }
      ];
    };
    const prepareComponentToken$l = (token2) => ({
      zIndexPopup: token2.zIndexPopupBase + CONTAINER_MAX_OFFSET + 10,
      contentBg: token2.colorBgElevated,
      contentPadding: `${(token2.controlHeightLG - token2.fontSize * token2.lineHeight) / 2}px ${token2.paddingSM}px`
    });
    const useStyle$r = genStyleHooks("Message", (token2) => {
      const combinedToken = merge(token2, {
        height: 150
      });
      return [genMessageStyle(combinedToken)];
    }, prepareComponentToken$l);
    var __rest$S = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const TypeIcon = {
      info: /* @__PURE__ */ reactExports.createElement(RefIcon$y, null),
      success: /* @__PURE__ */ reactExports.createElement(RefIcon$C, null),
      error: /* @__PURE__ */ reactExports.createElement(RefIcon$B, null),
      warning: /* @__PURE__ */ reactExports.createElement(RefIcon$z, null),
      loading: /* @__PURE__ */ reactExports.createElement(RefIcon$x, null)
    };
    const PureContent = (_ref) => {
      let {
        prefixCls,
        type: type2,
        icon,
        children
      } = _ref;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-custom-content`, `${prefixCls}-${type2}`)
      }, icon || TypeIcon[type2], /* @__PURE__ */ reactExports.createElement("span", null, children));
    };
    const PurePanel$6 = (props) => {
      const {
        prefixCls: staticPrefixCls,
        className,
        type: type2,
        icon,
        content
      } = props, restProps = __rest$S(props, ["prefixCls", "className", "type", "icon", "content"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = staticPrefixCls || getPrefixCls("message");
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$r(prefixCls, rootCls);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(Notify, Object.assign({}, restProps, {
        prefixCls,
        className: classNames(className, hashId, `${prefixCls}-notice-pure-panel`, cssVarCls, rootCls),
        eventKey: "pure",
        duration: null,
        content: /* @__PURE__ */ reactExports.createElement(PureContent, {
          prefixCls,
          type: type2,
          icon
        }, content)
      })));
    };
    function getMotion$2(prefixCls, transitionName) {
      return {
        motionName: transitionName !== null && transitionName !== void 0 ? transitionName : `${prefixCls}-move-up`
      };
    }
    function wrapPromiseFn(openFn) {
      let closeFn;
      const closePromise = new Promise((resolve) => {
        closeFn = openFn(() => {
          resolve(true);
        });
      });
      const result = () => {
        closeFn === null || closeFn === void 0 ? void 0 : closeFn();
      };
      result.then = (filled, rejected) => closePromise.then(filled, rejected);
      result.promise = closePromise;
      return result;
    }
    var __rest$R = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const DEFAULT_OFFSET = 8;
    const DEFAULT_DURATION = 3;
    const Wrapper = (_ref) => {
      let {
        children,
        prefixCls
      } = _ref;
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$r(prefixCls, rootCls);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(NotificationProvider, {
        classNames: {
          list: classNames(hashId, cssVarCls, rootCls)
        }
      }, children));
    };
    const renderNotifications = (node2, _ref2) => {
      let {
        prefixCls,
        key
      } = _ref2;
      return /* @__PURE__ */ reactExports.createElement(Wrapper, {
        prefixCls,
        key
      }, node2);
    };
    const Holder = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        top,
        prefixCls: staticPrefixCls,
        getContainer: staticGetContainer,
        maxCount,
        duration = DEFAULT_DURATION,
        rtl,
        transitionName,
        onAllRemoved
      } = props;
      const {
        getPrefixCls,
        getPopupContainer,
        message: message2,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = staticPrefixCls || getPrefixCls("message");
      const getStyle2 = () => ({
        left: "50%",
        transform: "translateX(-50%)",
        top: top !== null && top !== void 0 ? top : DEFAULT_OFFSET
      });
      const getClassName = () => classNames({
        [`${prefixCls}-rtl`]: rtl !== null && rtl !== void 0 ? rtl : direction === "rtl"
      });
      const getNotificationMotion = () => getMotion$2(prefixCls, transitionName);
      const mergedCloseIcon = /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-close-x`
      }, /* @__PURE__ */ reactExports.createElement(RefIcon$A, {
        className: `${prefixCls}-close-icon`
      }));
      const [api, holder] = useNotification({
        prefixCls,
        style: getStyle2,
        className: getClassName,
        motion: getNotificationMotion,
        closable: false,
        closeIcon: mergedCloseIcon,
        duration,
        getContainer: () => (staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body,
        maxCount,
        onAllRemoved,
        renderNotifications
      });
      reactExports.useImperativeHandle(ref, () => Object.assign(Object.assign({}, api), {
        prefixCls,
        message: message2
      }));
      return holder;
    });
    let keyIndex = 0;
    function useInternalMessage(messageConfig) {
      const holderRef = reactExports.useRef(null);
      devUseWarning();
      const wrapAPI = reactExports.useMemo(() => {
        const close = (key) => {
          var _a;
          (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.close(key);
        };
        const open2 = (config) => {
          if (!holderRef.current) {
            const fakeResult = () => {
            };
            fakeResult.then = () => {
            };
            return fakeResult;
          }
          const {
            open: originOpen,
            prefixCls,
            message: message2
          } = holderRef.current;
          const noticePrefixCls = `${prefixCls}-notice`;
          const {
            content,
            icon,
            type: type2,
            key,
            className,
            style: style2,
            onClose
          } = config, restConfig = __rest$R(config, ["content", "icon", "type", "key", "className", "style", "onClose"]);
          let mergedKey = key;
          if (mergedKey === void 0 || mergedKey === null) {
            keyIndex += 1;
            mergedKey = `antd-message-${keyIndex}`;
          }
          return wrapPromiseFn((resolve) => {
            originOpen(Object.assign(Object.assign({}, restConfig), {
              key: mergedKey,
              content: /* @__PURE__ */ reactExports.createElement(PureContent, {
                prefixCls,
                type: type2,
                icon
              }, content),
              placement: "top",
              className: classNames(type2 && `${noticePrefixCls}-${type2}`, className, message2 === null || message2 === void 0 ? void 0 : message2.className),
              style: Object.assign(Object.assign({}, message2 === null || message2 === void 0 ? void 0 : message2.style), style2),
              onClose: () => {
                onClose === null || onClose === void 0 ? void 0 : onClose();
                resolve();
              }
            }));
            return () => {
              close(mergedKey);
            };
          });
        };
        const destroy2 = (key) => {
          var _a;
          if (key !== void 0) {
            close(key);
          } else {
            (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
          }
        };
        const clone2 = {
          open: open2,
          destroy: destroy2
        };
        const keys2 = ["info", "success", "warning", "error", "loading"];
        keys2.forEach((type2) => {
          const typeOpen2 = (jointContent, duration, onClose) => {
            let config;
            if (jointContent && typeof jointContent === "object" && "content" in jointContent) {
              config = jointContent;
            } else {
              config = {
                content: jointContent
              };
            }
            let mergedDuration;
            let mergedOnClose;
            if (typeof duration === "function") {
              mergedOnClose = duration;
            } else {
              mergedDuration = duration;
              mergedOnClose = onClose;
            }
            const mergedConfig = Object.assign(Object.assign({
              onClose: mergedOnClose,
              duration: mergedDuration
            }, config), {
              type: type2
            });
            return open2(mergedConfig);
          };
          clone2[type2] = typeOpen2;
        });
        return clone2;
      }, []);
      return [wrapAPI, /* @__PURE__ */ reactExports.createElement(Holder, Object.assign({
        key: "message-holder"
      }, messageConfig, {
        ref: holderRef
      }))];
    }
    function useMessage(messageConfig) {
      return useInternalMessage(messageConfig);
    }
    function usePatchElement() {
      const [elements, setElements] = reactExports.useState([]);
      const patchElement = reactExports.useCallback((element) => {
        setElements((originElements) => [].concat(_toConsumableArray(originElements), [element]));
        return () => {
          setElements((originElements) => originElements.filter((ele) => ele !== element));
        };
      }, []);
      return [elements, patchElement];
    }
    function _regeneratorRuntime() {
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e2;
      };
      var t2, e2 = {}, r2 = Object.prototype, n2 = r2.hasOwnProperty, o2 = Object.defineProperty || function(t3, e3, r3) {
        t3[e3] = r3.value;
      }, i2 = "function" == typeof Symbol ? Symbol : {}, a = i2.iterator || "@@iterator", c2 = i2.asyncIterator || "@@asyncIterator", u2 = i2.toStringTag || "@@toStringTag";
      function define(t3, e3, r3) {
        return Object.defineProperty(t3, e3, {
          value: r3,
          enumerable: true,
          configurable: true,
          writable: true
        }), t3[e3];
      }
      try {
        define({}, "");
      } catch (t3) {
        define = function define2(t4, e3, r3) {
          return t4[e3] = r3;
        };
      }
      function wrap(t3, e3, r3, n3) {
        var i3 = e3 && e3.prototype instanceof Generator ? e3 : Generator, a2 = Object.create(i3.prototype), c3 = new Context2(n3 || []);
        return o2(a2, "_invoke", {
          value: makeInvokeMethod(t3, r3, c3)
        }), a2;
      }
      function tryCatch(t3, e3, r3) {
        try {
          return {
            type: "normal",
            arg: t3.call(e3, r3)
          };
        } catch (t4) {
          return {
            type: "throw",
            arg: t4
          };
        }
      }
      e2.wrap = wrap;
      var h2 = "suspendedStart", l2 = "suspendedYield", f2 = "executing", s = "completed", y2 = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p2 = {};
      define(p2, a, function() {
        return this;
      });
      var d2 = Object.getPrototypeOf, v2 = d2 && d2(d2(values([])));
      v2 && v2 !== r2 && n2.call(v2, a) && (p2 = v2);
      var g2 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p2);
      function defineIteratorMethods(t3) {
        ["next", "throw", "return"].forEach(function(e3) {
          define(t3, e3, function(t4) {
            return this._invoke(e3, t4);
          });
        });
      }
      function AsyncIterator(t3, e3) {
        function invoke(r4, o3, i3, a2) {
          var c3 = tryCatch(t3[r4], t3, o3);
          if ("throw" !== c3.type) {
            var u3 = c3.arg, h3 = u3.value;
            return h3 && "object" == _typeof$1(h3) && n2.call(h3, "__await") ? e3.resolve(h3.__await).then(function(t4) {
              invoke("next", t4, i3, a2);
            }, function(t4) {
              invoke("throw", t4, i3, a2);
            }) : e3.resolve(h3).then(function(t4) {
              u3.value = t4, i3(u3);
            }, function(t4) {
              return invoke("throw", t4, i3, a2);
            });
          }
          a2(c3.arg);
        }
        var r3;
        o2(this, "_invoke", {
          value: function value(t4, n3) {
            function callInvokeWithMethodAndArg() {
              return new e3(function(e4, r4) {
                invoke(t4, n3, e4, r4);
              });
            }
            return r3 = r3 ? r3.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e3, r3, n3) {
        var o3 = h2;
        return function(i3, a2) {
          if (o3 === f2) throw Error("Generator is already running");
          if (o3 === s) {
            if ("throw" === i3) throw a2;
            return {
              value: t2,
              done: true
            };
          }
          for (n3.method = i3, n3.arg = a2; ; ) {
            var c3 = n3.delegate;
            if (c3) {
              var u3 = maybeInvokeDelegate(c3, n3);
              if (u3) {
                if (u3 === y2) continue;
                return u3;
              }
            }
            if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
            else if ("throw" === n3.method) {
              if (o3 === h2) throw o3 = s, n3.arg;
              n3.dispatchException(n3.arg);
            } else "return" === n3.method && n3.abrupt("return", n3.arg);
            o3 = f2;
            var p3 = tryCatch(e3, r3, n3);
            if ("normal" === p3.type) {
              if (o3 = n3.done ? s : l2, p3.arg === y2) continue;
              return {
                value: p3.arg,
                done: n3.done
              };
            }
            "throw" === p3.type && (o3 = s, n3.method = "throw", n3.arg = p3.arg);
          }
        };
      }
      function maybeInvokeDelegate(e3, r3) {
        var n3 = r3.method, o3 = e3.iterator[n3];
        if (o3 === t2) return r3.delegate = null, "throw" === n3 && e3.iterator["return"] && (r3.method = "return", r3.arg = t2, maybeInvokeDelegate(e3, r3), "throw" === r3.method) || "return" !== n3 && (r3.method = "throw", r3.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), y2;
        var i3 = tryCatch(o3, e3.iterator, r3.arg);
        if ("throw" === i3.type) return r3.method = "throw", r3.arg = i3.arg, r3.delegate = null, y2;
        var a2 = i3.arg;
        return a2 ? a2.done ? (r3[e3.resultName] = a2.value, r3.next = e3.nextLoc, "return" !== r3.method && (r3.method = "next", r3.arg = t2), r3.delegate = null, y2) : a2 : (r3.method = "throw", r3.arg = new TypeError("iterator result is not an object"), r3.delegate = null, y2);
      }
      function pushTryEntry(t3) {
        var e3 = {
          tryLoc: t3[0]
        };
        1 in t3 && (e3.catchLoc = t3[1]), 2 in t3 && (e3.finallyLoc = t3[2], e3.afterLoc = t3[3]), this.tryEntries.push(e3);
      }
      function resetTryEntry(t3) {
        var e3 = t3.completion || {};
        e3.type = "normal", delete e3.arg, t3.completion = e3;
      }
      function Context2(t3) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t3.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e3) {
        if (e3 || "" === e3) {
          var r3 = e3[a];
          if (r3) return r3.call(e3);
          if ("function" == typeof e3.next) return e3;
          if (!isNaN(e3.length)) {
            var o3 = -1, i3 = function next2() {
              for (; ++o3 < e3.length; ) if (n2.call(e3, o3)) return next2.value = e3[o3], next2.done = false, next2;
              return next2.value = t2, next2.done = true, next2;
            };
            return i3.next = i3;
          }
        }
        throw new TypeError(_typeof$1(e3) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o2(g2, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o2(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u2, "GeneratorFunction"), e2.isGeneratorFunction = function(t3) {
        var e3 = "function" == typeof t3 && t3.constructor;
        return !!e3 && (e3 === GeneratorFunction || "GeneratorFunction" === (e3.displayName || e3.name));
      }, e2.mark = function(t3) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t3, GeneratorFunctionPrototype) : (t3.__proto__ = GeneratorFunctionPrototype, define(t3, u2, "GeneratorFunction")), t3.prototype = Object.create(g2), t3;
      }, e2.awrap = function(t3) {
        return {
          __await: t3
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c2, function() {
        return this;
      }), e2.AsyncIterator = AsyncIterator, e2.async = function(t3, r3, n3, o3, i3) {
        void 0 === i3 && (i3 = Promise);
        var a2 = new AsyncIterator(wrap(t3, r3, n3, o3), i3);
        return e2.isGeneratorFunction(r3) ? a2 : a2.next().then(function(t4) {
          return t4.done ? t4.value : a2.next();
        });
      }, defineIteratorMethods(g2), define(g2, u2, "Generator"), define(g2, a, function() {
        return this;
      }), define(g2, "toString", function() {
        return "[object Generator]";
      }), e2.keys = function(t3) {
        var e3 = Object(t3), r3 = [];
        for (var n3 in e3) r3.push(n3);
        return r3.reverse(), function next2() {
          for (; r3.length; ) {
            var t4 = r3.pop();
            if (t4 in e3) return next2.value = t4, next2.done = false, next2;
          }
          return next2.done = true, next2;
        };
      }, e2.values = values, Context2.prototype = {
        constructor: Context2,
        reset: function reset(e3) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t2, this.done = false, this.delegate = null, this.method = "next", this.arg = t2, this.tryEntries.forEach(resetTryEntry), !e3) for (var r3 in this) "t" === r3.charAt(0) && n2.call(this, r3) && !isNaN(+r3.slice(1)) && (this[r3] = t2);
        },
        stop: function stop() {
          this.done = true;
          var t3 = this.tryEntries[0].completion;
          if ("throw" === t3.type) throw t3.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e3) {
          if (this.done) throw e3;
          var r3 = this;
          function handle(n3, o4) {
            return a2.type = "throw", a2.arg = e3, r3.next = n3, o4 && (r3.method = "next", r3.arg = t2), !!o4;
          }
          for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
            var i3 = this.tryEntries[o3], a2 = i3.completion;
            if ("root" === i3.tryLoc) return handle("end");
            if (i3.tryLoc <= this.prev) {
              var c3 = n2.call(i3, "catchLoc"), u3 = n2.call(i3, "finallyLoc");
              if (c3 && u3) {
                if (this.prev < i3.catchLoc) return handle(i3.catchLoc, true);
                if (this.prev < i3.finallyLoc) return handle(i3.finallyLoc);
              } else if (c3) {
                if (this.prev < i3.catchLoc) return handle(i3.catchLoc, true);
              } else {
                if (!u3) throw Error("try statement without catch or finally");
                if (this.prev < i3.finallyLoc) return handle(i3.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t3, e3) {
          for (var r3 = this.tryEntries.length - 1; r3 >= 0; --r3) {
            var o3 = this.tryEntries[r3];
            if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
              var i3 = o3;
              break;
            }
          }
          i3 && ("break" === t3 || "continue" === t3) && i3.tryLoc <= e3 && e3 <= i3.finallyLoc && (i3 = null);
          var a2 = i3 ? i3.completion : {};
          return a2.type = t3, a2.arg = e3, i3 ? (this.method = "next", this.next = i3.finallyLoc, y2) : this.complete(a2);
        },
        complete: function complete(t3, e3) {
          if ("throw" === t3.type) throw t3.arg;
          return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && e3 && (this.next = e3), y2;
        },
        finish: function finish(t3) {
          for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
            var r3 = this.tryEntries[e3];
            if (r3.finallyLoc === t3) return this.complete(r3.completion, r3.afterLoc), resetTryEntry(r3), y2;
          }
        },
        "catch": function _catch(t3) {
          for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
            var r3 = this.tryEntries[e3];
            if (r3.tryLoc === t3) {
              var n3 = r3.completion;
              if ("throw" === n3.type) {
                var o3 = n3.arg;
                resetTryEntry(r3);
              }
              return o3;
            }
          }
          throw Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e3, r3, n3) {
          return this.delegate = {
            iterator: values(e3),
            resultName: r3,
            nextLoc: n3
          }, "next" === this.method && (this.arg = t2), y2;
        }
      }, e2;
    }
    function asyncGeneratorStep(n2, t2, e2, r2, o2, a, c2) {
      try {
        var i2 = n2[a](c2), u2 = i2.value;
      } catch (n3) {
        return void e2(n3);
      }
      i2.done ? t2(u2) : Promise.resolve(u2).then(r2, o2);
    }
    function _asyncToGenerator(n2) {
      return function() {
        var t2 = this, e2 = arguments;
        return new Promise(function(r2, o2) {
          var a = n2.apply(t2, e2);
          function _next(n3) {
            asyncGeneratorStep(a, r2, o2, _next, _throw, "next", n3);
          }
          function _throw(n3) {
            asyncGeneratorStep(a, r2, o2, _next, _throw, "throw", n3);
          }
          _next(void 0);
        });
      };
    }
    var fullClone = _objectSpread2$3({}, ReactDOM$2);
    var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
    var createRoot;
    try {
      var mainVersion = Number((version || "").split(".")[0]);
      if (mainVersion >= 18) {
        createRoot = fullClone.createRoot;
      }
    } catch (e2) {
    }
    function toggleWarning(skip) {
      var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof$1(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
      }
    }
    var MARK = "__rc_react_root__";
    function modernRender(node2, container) {
      toggleWarning(true);
      var root2 = container[MARK] || createRoot(container);
      toggleWarning(false);
      root2.render(node2);
      container[MARK] = root2;
    }
    function legacyRender(node2, container) {
      reactRender === null || reactRender === void 0 || reactRender(node2, container);
    }
    function render(node2, container) {
      if (createRoot) {
        modernRender(node2, container);
        return;
      }
      legacyRender(node2, container);
    }
    function modernUnmount(_x) {
      return _modernUnmount.apply(this, arguments);
    }
    function _modernUnmount() {
      _modernUnmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(container) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", Promise.resolve().then(function() {
                var _container$MARK;
                (_container$MARK = container[MARK]) === null || _container$MARK === void 0 || _container$MARK.unmount();
                delete container[MARK];
              }));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _modernUnmount.apply(this, arguments);
    }
    function legacyUnmount(container) {
      unmountComponentAtNode(container);
    }
    function unmount(_x2) {
      return _unmount.apply(this, arguments);
    }
    function _unmount() {
      _unmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(container) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(createRoot !== void 0)) {
                _context2.next = 2;
                break;
              }
              return _context2.abrupt("return", modernUnmount(container));
            case 2:
              legacyUnmount(container);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return _unmount.apply(this, arguments);
    }
    const defaultReactRender = (node2, container) => {
      render(node2, container);
      return () => {
        return unmount(container);
      };
    };
    let unstableRender = defaultReactRender;
    function getReactRender() {
      return unstableRender;
    }
    const getCollapsedHeight = () => ({
      height: 0,
      opacity: 0
    });
    const getRealHeight = (node2) => {
      const {
        scrollHeight
      } = node2;
      return {
        height: scrollHeight,
        opacity: 1
      };
    };
    const getCurrentHeight = (node2) => ({
      height: node2 ? node2.offsetHeight : 0
    });
    const skipOpacityTransition = (_2, event) => (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === "height";
    const initCollapseMotion = function() {
      let rootCls = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultPrefixCls;
      return {
        motionName: `${rootCls}-motion-collapse`,
        onAppearStart: getCollapsedHeight,
        onEnterStart: getCollapsedHeight,
        onAppearActive: getRealHeight,
        onEnterActive: getRealHeight,
        onLeaveStart: getCurrentHeight,
        onLeaveActive: getCollapsedHeight,
        onAppearEnd: skipOpacityTransition,
        onEnterEnd: skipOpacityTransition,
        onLeaveEnd: skipOpacityTransition,
        motionDeadline: 500
      };
    };
    const getTransitionName = (rootPrefixCls, motion2, transitionName) => {
      if (transitionName !== void 0) {
        return transitionName;
      }
      return `${rootPrefixCls}-${motion2}`;
    };
    function omit(obj, fields) {
      var clone2 = Object.assign({}, obj);
      if (Array.isArray(fields)) {
        fields.forEach(function(key) {
          delete clone2[key];
        });
      }
      return clone2;
    }
    const isVisible = function(element) {
      if (!element) {
        return false;
      }
      if (element instanceof Element) {
        if (element.offsetParent) {
          return true;
        }
        if (element.getBBox) {
          var _getBBox = element.getBBox(), width = _getBBox.width, height = _getBBox.height;
          if (width || height) {
            return true;
          }
        }
        if (element.getBoundingClientRect) {
          var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
          if (_width || _height) {
            return true;
          }
        }
      }
      return false;
    };
    const genWaveStyle = (token2) => {
      const {
        componentCls,
        colorPrimary
      } = token2;
      return {
        [componentCls]: {
          position: "absolute",
          background: "transparent",
          pointerEvents: "none",
          boxSizing: "border-box",
          color: `var(--wave-color, ${colorPrimary})`,
          boxShadow: `0 0 0 0 currentcolor`,
          opacity: 0.2,
          // =================== Motion ===================
          "&.wave-motion-appear": {
            transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
            "&-active": {
              boxShadow: `0 0 0 6px currentcolor`,
              opacity: 0
            },
            "&.wave-quick": {
              transition: [`box-shadow ${token2.motionDurationSlow} ${token2.motionEaseInOut}`, `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`].join(",")
            }
          }
        }
      };
    };
    const useStyle$q = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);
    const TARGET_CLS = `${defaultPrefixCls}-wave-target`;
    function isValidWaveColor(color) {
      return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
      color !== "transparent";
    }
    function getTargetWaveColor(node2) {
      const {
        borderTopColor,
        borderColor,
        backgroundColor
      } = getComputedStyle(node2);
      if (isValidWaveColor(borderTopColor)) {
        return borderTopColor;
      }
      if (isValidWaveColor(borderColor)) {
        return borderColor;
      }
      if (isValidWaveColor(backgroundColor)) {
        return backgroundColor;
      }
      return null;
    }
    function validateNum(value) {
      return Number.isNaN(value) ? 0 : value;
    }
    const WaveEffect = (props) => {
      const {
        className,
        target,
        component,
        registerUnmount
      } = props;
      const divRef = reactExports.useRef(null);
      const unmountRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        unmountRef.current = registerUnmount();
      }, []);
      const [color, setWaveColor] = reactExports.useState(null);
      const [borderRadius, setBorderRadius] = reactExports.useState([]);
      const [left, setLeft] = reactExports.useState(0);
      const [top, setTop] = reactExports.useState(0);
      const [width, setWidth] = reactExports.useState(0);
      const [height, setHeight] = reactExports.useState(0);
      const [enabled, setEnabled] = reactExports.useState(false);
      const waveStyle = {
        left,
        top,
        width,
        height,
        borderRadius: borderRadius.map((radius2) => `${radius2}px`).join(" ")
      };
      if (color) {
        waveStyle["--wave-color"] = color;
      }
      function syncPos() {
        const nodeStyle = getComputedStyle(target);
        setWaveColor(getTargetWaveColor(target));
        const isStatic = nodeStyle.position === "static";
        const {
          borderLeftWidth,
          borderTopWidth
        } = nodeStyle;
        setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
        setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
        setWidth(target.offsetWidth);
        setHeight(target.offsetHeight);
        const {
          borderTopLeftRadius,
          borderTopRightRadius,
          borderBottomLeftRadius,
          borderBottomRightRadius
        } = nodeStyle;
        setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius2) => validateNum(parseFloat(radius2))));
      }
      reactExports.useEffect(() => {
        if (target) {
          const id = wrapperRaf(() => {
            syncPos();
            setEnabled(true);
          });
          let resizeObserver2;
          if (typeof ResizeObserver !== "undefined") {
            resizeObserver2 = new ResizeObserver(syncPos);
            resizeObserver2.observe(target);
          }
          return () => {
            wrapperRaf.cancel(id);
            resizeObserver2 === null || resizeObserver2 === void 0 ? void 0 : resizeObserver2.disconnect();
          };
        }
      }, []);
      if (!enabled) {
        return null;
      }
      const isSmallComponent = (component === "Checkbox" || component === "Radio") && (target === null || target === void 0 ? void 0 : target.classList.contains(TARGET_CLS));
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, {
        visible: true,
        motionAppear: true,
        motionName: "wave-motion",
        motionDeadline: 5e3,
        onAppearEnd: (_2, event) => {
          var _a, _b;
          if (event.deadline || event.propertyName === "opacity") {
            const holder = (_a = divRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
            (_b = unmountRef.current) === null || _b === void 0 ? void 0 : _b.call(unmountRef).then(() => {
              holder === null || holder === void 0 ? void 0 : holder.remove();
            });
          }
          return false;
        }
      }, (_ref, ref) => {
        let {
          className: motionClassName
        } = _ref;
        return /* @__PURE__ */ reactExports.createElement("div", {
          ref: composeRef(divRef, ref),
          className: classNames(className, motionClassName, {
            "wave-quick": isSmallComponent
          }),
          style: waveStyle
        });
      });
    };
    const showWaveEffect = (target, info) => {
      var _a;
      const {
        component
      } = info;
      if (component === "Checkbox" && !((_a = target.querySelector("input")) === null || _a === void 0 ? void 0 : _a.checked)) {
        return;
      }
      const holder = document.createElement("div");
      holder.style.position = "absolute";
      holder.style.left = "0px";
      holder.style.top = "0px";
      target === null || target === void 0 ? void 0 : target.insertBefore(holder, target === null || target === void 0 ? void 0 : target.firstChild);
      const reactRender2 = getReactRender();
      let unmountCallback = null;
      function registerUnmount() {
        return unmountCallback;
      }
      unmountCallback = reactRender2(/* @__PURE__ */ reactExports.createElement(WaveEffect, Object.assign({}, info, {
        target,
        registerUnmount
      })), holder);
    };
    const useWave = (nodeRef, className, component) => {
      const {
        wave
      } = reactExports.useContext(ConfigContext);
      const [, token2, hashId] = useToken();
      const showWave = useEvent((event) => {
        const node2 = nodeRef.current;
        if ((wave === null || wave === void 0 ? void 0 : wave.disabled) || !node2) {
          return;
        }
        const targetNode = node2.querySelector(`.${TARGET_CLS}`) || node2;
        const {
          showEffect
        } = wave || {};
        (showEffect || showWaveEffect)(targetNode, {
          className,
          token: token2,
          component,
          event,
          hashId
        });
      });
      const rafId = reactExports.useRef(null);
      const showDebounceWave = (event) => {
        wrapperRaf.cancel(rafId.current);
        rafId.current = wrapperRaf(() => {
          showWave(event);
        });
      };
      return showDebounceWave;
    };
    const Wave = (props) => {
      const {
        children,
        disabled,
        component
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const containerRef = reactExports.useRef(null);
      const prefixCls = getPrefixCls("wave");
      const [, hashId] = useStyle$q(prefixCls);
      const showWave = useWave(containerRef, classNames(prefixCls, hashId), component);
      i.useEffect(() => {
        const node2 = containerRef.current;
        if (!node2 || node2.nodeType !== 1 || disabled) {
          return;
        }
        const onClick = (e2) => {
          if (!isVisible(e2.target) || // No need wave
          !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
            return;
          }
          showWave(e2);
        };
        node2.addEventListener("click", onClick, true);
        return () => {
          node2.removeEventListener("click", onClick, true);
        };
      }, [disabled]);
      if (!/* @__PURE__ */ i.isValidElement(children)) {
        return children !== null && children !== void 0 ? children : null;
      }
      const ref = supportRef(children) ? composeRef(getNodeRef(children), containerRef) : containerRef;
      return cloneElement(children, {
        ref
      });
    };
    const useSize = (customSize) => {
      const size = i.useContext(SizeContext);
      const mergedSize = i.useMemo(() => {
        if (!customSize) {
          return size;
        }
        if (typeof customSize === "string") {
          return customSize !== null && customSize !== void 0 ? customSize : size;
        }
        if (typeof customSize === "function") {
          return customSize(size);
        }
        return size;
      }, [customSize, size]);
      return mergedSize;
    };
    const genSpaceCompactStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          "&-block": {
            display: "flex",
            width: "100%"
          },
          "&-vertical": {
            flexDirection: "column"
          }
        }
      };
    };
    const genSpaceStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      return {
        [componentCls]: {
          display: "inline-flex",
          "&-rtl": {
            direction: "rtl"
          },
          "&-vertical": {
            flexDirection: "column"
          },
          "&-align": {
            flexDirection: "column",
            "&-center": {
              alignItems: "center"
            },
            "&-start": {
              alignItems: "flex-start"
            },
            "&-end": {
              alignItems: "flex-end"
            },
            "&-baseline": {
              alignItems: "baseline"
            }
          },
          [`${componentCls}-item:empty`]: {
            display: "none"
          },
          // https://github.com/ant-design/ant-design/issues/47875
          [`${componentCls}-item > ${antCls}-badge-not-a-wrapper:only-child`]: {
            display: "block"
          }
        }
      };
    };
    const genSpaceGapStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          "&-gap-row-small": {
            rowGap: token2.spaceGapSmallSize
          },
          "&-gap-row-middle": {
            rowGap: token2.spaceGapMiddleSize
          },
          "&-gap-row-large": {
            rowGap: token2.spaceGapLargeSize
          },
          "&-gap-col-small": {
            columnGap: token2.spaceGapSmallSize
          },
          "&-gap-col-middle": {
            columnGap: token2.spaceGapMiddleSize
          },
          "&-gap-col-large": {
            columnGap: token2.spaceGapLargeSize
          }
        }
      };
    };
    const useStyle$p = genStyleHooks("Space", (token2) => {
      const spaceToken = merge(token2, {
        spaceGapSmallSize: token2.paddingXS,
        spaceGapMiddleSize: token2.padding,
        spaceGapLargeSize: token2.paddingLG
      });
      return [genSpaceStyle(spaceToken), genSpaceGapStyle(spaceToken), genSpaceCompactStyle(spaceToken)];
    }, () => ({}), {
      // Space component don't apply extra font style
      // https://github.com/ant-design/ant-design/issues/40315
      resetStyle: false
    });
    var __rest$Q = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const SpaceCompactItemContext = /* @__PURE__ */ reactExports.createContext(null);
    const useCompactItemContext = (prefixCls, direction) => {
      const compactItemContext = reactExports.useContext(SpaceCompactItemContext);
      const compactItemClassnames = reactExports.useMemo(() => {
        if (!compactItemContext) {
          return "";
        }
        const {
          compactDirection,
          isFirstItem,
          isLastItem
        } = compactItemContext;
        const separator = compactDirection === "vertical" ? "-vertical-" : "-";
        return classNames(`${prefixCls}-compact${separator}item`, {
          [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
          [`${prefixCls}-compact${separator}last-item`]: isLastItem,
          [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
        });
      }, [prefixCls, direction, compactItemContext]);
      return {
        compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
        compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
        compactItemClassnames
      };
    };
    const NoCompactStyle = (props) => {
      const {
        children
      } = props;
      return /* @__PURE__ */ reactExports.createElement(SpaceCompactItemContext.Provider, {
        value: null
      }, children);
    };
    const CompactItem = (props) => {
      const {
        children
      } = props, others = __rest$Q(props, ["children"]);
      return /* @__PURE__ */ reactExports.createElement(SpaceCompactItemContext.Provider, {
        value: reactExports.useMemo(() => others, [others])
      }, children);
    };
    const Compact$1 = (props) => {
      const {
        getPrefixCls,
        direction: directionConfig
      } = reactExports.useContext(ConfigContext);
      const {
        size,
        direction,
        block,
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        children
      } = props, restProps = __rest$Q(props, ["size", "direction", "block", "prefixCls", "className", "rootClassName", "children"]);
      const mergedSize = useSize((ctx) => size !== null && size !== void 0 ? size : ctx);
      const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
      const [wrapCSSVar, hashId] = useStyle$p(prefixCls);
      const clx2 = classNames(prefixCls, hashId, {
        [`${prefixCls}-rtl`]: directionConfig === "rtl",
        [`${prefixCls}-block`]: block,
        [`${prefixCls}-vertical`]: direction === "vertical"
      }, className, rootClassName);
      const compactItemContext = reactExports.useContext(SpaceCompactItemContext);
      const childNodes = toArray$5(children);
      const nodes = reactExports.useMemo(() => childNodes.map((child, i2) => {
        const key = (child === null || child === void 0 ? void 0 : child.key) || `${prefixCls}-item-${i2}`;
        return /* @__PURE__ */ reactExports.createElement(CompactItem, {
          key,
          compactSize: mergedSize,
          compactDirection: direction,
          isFirstItem: i2 === 0 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isFirstItem)),
          isLastItem: i2 === childNodes.length - 1 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isLastItem))
        }, child);
      }), [size, childNodes, compactItemContext]);
      if (childNodes.length === 0) {
        return null;
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: clx2
      }, restProps), nodes));
    };
    var __rest$P = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const GroupSizeContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const ButtonGroup = (props) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        size,
        className
      } = props, others = __rest$P(props, ["prefixCls", "size", "className"]);
      const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
      const [, , hashId] = useToken();
      const sizeCls = reactExports.useMemo(() => {
        switch (size) {
          case "large":
            return "lg";
          case "small":
            return "sm";
          default:
            return "";
        }
      }, [size]);
      const classes = classNames(prefixCls, {
        [`${prefixCls}-${sizeCls}`]: sizeCls,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, hashId);
      return /* @__PURE__ */ reactExports.createElement(GroupSizeContext.Provider, {
        value: size
      }, /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, others, {
        className: classes
      })));
    };
    const rxTwoCNChar = /^[\u4E00-\u9FA5]{2}$/;
    const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
    function convertLegacyProps(type2) {
      if (type2 === "danger") {
        return {
          danger: true
        };
      }
      return {
        type: type2
      };
    }
    function isString$1(str) {
      return typeof str === "string";
    }
    function isUnBorderedButtonVariant(type2) {
      return type2 === "text" || type2 === "link";
    }
    function splitCNCharsBySpace(child, needInserted) {
      if (child === null || child === void 0) {
        return;
      }
      const SPACE = needInserted ? " " : "";
      if (typeof child !== "string" && typeof child !== "number" && isString$1(child.type) && isTwoCNChar(child.props.children)) {
        return cloneElement(child, {
          children: child.props.children.split("").join(SPACE)
        });
      }
      if (isString$1(child)) {
        return isTwoCNChar(child) ? /* @__PURE__ */ i.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ i.createElement("span", null, child);
      }
      if (isFragment(child)) {
        return /* @__PURE__ */ i.createElement("span", null, child);
      }
      return child;
    }
    function spaceChildren(children, needInserted) {
      let isPrevChildPure = false;
      const childList = [];
      i.Children.forEach(children, (child) => {
        const type2 = typeof child;
        const isCurrentChildPure = type2 === "string" || type2 === "number";
        if (isPrevChildPure && isCurrentChildPure) {
          const lastIndex = childList.length - 1;
          const lastChild = childList[lastIndex];
          childList[lastIndex] = `${lastChild}${child}`;
        } else {
          childList.push(child);
        }
        isPrevChildPure = isCurrentChildPure;
      });
      return i.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted));
    }
    ["default", "primary", "danger"].concat(_toConsumableArray(PresetColors));
    const IconWrapper = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        className,
        style: style2,
        children,
        prefixCls
      } = props;
      const iconWrapperCls = classNames(`${prefixCls}-icon`, className);
      return /* @__PURE__ */ i.createElement("span", {
        ref,
        className: iconWrapperCls,
        style: style2
      }, children);
    });
    const InnerLoadingIcon = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls,
        className,
        style: style2,
        iconClassName
      } = props;
      const mergedIconCls = classNames(`${prefixCls}-loading-icon`, className);
      return /* @__PURE__ */ i.createElement(IconWrapper, {
        prefixCls,
        className: mergedIconCls,
        style: style2,
        ref
      }, /* @__PURE__ */ i.createElement(RefIcon$x, {
        className: iconClassName
      }));
    });
    const getCollapsedWidth = () => ({
      width: 0,
      opacity: 0,
      transform: "scale(0)"
    });
    const getRealWidth = (node2) => ({
      width: node2.scrollWidth,
      opacity: 1,
      transform: "scale(1)"
    });
    const DefaultLoadingIcon = (props) => {
      const {
        prefixCls,
        loading,
        existIcon,
        className,
        style: style2,
        mount
      } = props;
      const visible = !!loading;
      if (existIcon) {
        return /* @__PURE__ */ i.createElement(InnerLoadingIcon, {
          prefixCls,
          className,
          style: style2
        });
      }
      return /* @__PURE__ */ i.createElement(CSSMotion, {
        visible,
        // Used for minus flex gap style only
        motionName: `${prefixCls}-loading-icon-motion`,
        motionAppear: !mount,
        motionEnter: !mount,
        motionLeave: !mount,
        removeOnLeave: true,
        onAppearStart: getCollapsedWidth,
        onAppearActive: getRealWidth,
        onEnterStart: getCollapsedWidth,
        onEnterActive: getRealWidth,
        onLeaveStart: getRealWidth,
        onLeaveActive: getCollapsedWidth
      }, (_ref, ref) => {
        let {
          className: motionCls,
          style: motionStyle
        } = _ref;
        const mergedStyle = Object.assign(Object.assign({}, style2), motionStyle);
        return /* @__PURE__ */ i.createElement(InnerLoadingIcon, {
          prefixCls,
          className: classNames(className, motionCls),
          style: mergedStyle,
          ref
        });
      });
    };
    const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
      // Border
      [`> span, > ${buttonTypeCls}`]: {
        "&:not(:last-child)": {
          [`&, & > ${buttonTypeCls}`]: {
            "&:not(:disabled)": {
              borderInlineEndColor: borderColor
            }
          }
        },
        "&:not(:first-child)": {
          [`&, & > ${buttonTypeCls}`]: {
            "&:not(:disabled)": {
              borderInlineStartColor: borderColor
            }
          }
        }
      }
    });
    const genGroupStyle$1 = (token2) => {
      const {
        componentCls,
        fontSize,
        lineWidth,
        groupBorderColor,
        colorErrorHover
      } = token2;
      return {
        [`${componentCls}-group`]: [
          {
            position: "relative",
            display: "inline-flex",
            // Border
            [`> span, > ${componentCls}`]: {
              "&:not(:last-child)": {
                [`&, & > ${componentCls}`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0
                }
              },
              "&:not(:first-child)": {
                marginInlineStart: token2.calc(lineWidth).mul(-1).equal(),
                [`&, & > ${componentCls}`]: {
                  borderStartStartRadius: 0,
                  borderEndStartRadius: 0
                }
              }
            },
            [componentCls]: {
              position: "relative",
              zIndex: 1,
              "&:hover, &:focus, &:active": {
                zIndex: 2
              },
              "&[disabled]": {
                zIndex: 0
              }
            },
            [`${componentCls}-icon-only`]: {
              fontSize
            }
          },
          // Border Color
          genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor),
          genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
        ]
      };
    };
    var _excluded$E = ["b"], _excluded2$8 = ["v"];
    var getRoundNumber = function getRoundNumber2(value) {
      return Math.round(Number(value || 0));
    };
    var convertHsb2Hsv = function convertHsb2Hsv2(color) {
      if (color instanceof FastColor) {
        return color;
      }
      if (color && _typeof$1(color) === "object" && "h" in color && "b" in color) {
        var _ref = color, b2 = _ref.b, resets = _objectWithoutProperties(_ref, _excluded$E);
        return _objectSpread2$3(_objectSpread2$3({}, resets), {}, {
          v: b2
        });
      }
      if (typeof color === "string" && /hsb/.test(color)) {
        return color.replace(/hsb/, "hsv");
      }
      return color;
    };
    var Color = /* @__PURE__ */ function(_FastColor) {
      _inherits(Color2, _FastColor);
      var _super = _createSuper(Color2);
      function Color2(color) {
        _classCallCheck(this, Color2);
        return _super.call(this, convertHsb2Hsv(color));
      }
      _createClass(Color2, [{
        key: "toHsbString",
        value: function toHsbString() {
          var hsb = this.toHsb();
          var saturation = getRoundNumber(hsb.s * 100);
          var lightness = getRoundNumber(hsb.b * 100);
          var hue = getRoundNumber(hsb.h);
          var alpha = hsb.a;
          var hsbString = "hsb(".concat(hue, ", ").concat(saturation, "%, ").concat(lightness, "%)");
          var hsbaString = "hsba(".concat(hue, ", ").concat(saturation, "%, ").concat(lightness, "%, ").concat(alpha.toFixed(alpha === 0 ? 0 : 2), ")");
          return alpha === 1 ? hsbString : hsbaString;
        }
      }, {
        key: "toHsb",
        value: function toHsb() {
          var _this$toHsv = this.toHsv(), v2 = _this$toHsv.v, resets = _objectWithoutProperties(_this$toHsv, _excluded2$8);
          return _objectSpread2$3(_objectSpread2$3({}, resets), {}, {
            b: v2,
            a: this.a
          });
        }
      }]);
      return Color2;
    }(FastColor);
    var generateColor = function generateColor2(color) {
      if (color instanceof Color) {
        return color;
      }
      return new Color(color);
    };
    generateColor("#1677ff");
    const toHexFormat = (value, alpha) => (value === null || value === void 0 ? void 0 : value.replace(/[^\w/]/g, "").slice(0, alpha ? 8 : 6)) || "";
    const getHex = (value, alpha) => value ? toHexFormat(value, alpha) : "";
    let AggregationColor = /* @__PURE__ */ function() {
      function AggregationColor2(color) {
        _classCallCheck(this, AggregationColor2);
        var _a;
        this.cleared = false;
        if (color instanceof AggregationColor2) {
          this.metaColor = color.metaColor.clone();
          this.colors = (_a = color.colors) === null || _a === void 0 ? void 0 : _a.map((info) => ({
            color: new AggregationColor2(info.color),
            percent: info.percent
          }));
          this.cleared = color.cleared;
          return;
        }
        const isArray2 = Array.isArray(color);
        if (isArray2 && color.length) {
          this.colors = color.map((_ref) => {
            let {
              color: c2,
              percent
            } = _ref;
            return {
              color: new AggregationColor2(c2),
              percent
            };
          });
          this.metaColor = new Color(this.colors[0].color.metaColor);
        } else {
          this.metaColor = new Color(isArray2 ? "" : color);
        }
        if (!color || isArray2 && !this.colors) {
          this.metaColor = this.metaColor.setA(0);
          this.cleared = true;
        }
      }
      return _createClass(AggregationColor2, [{
        key: "toHsb",
        value: function toHsb() {
          return this.metaColor.toHsb();
        }
      }, {
        key: "toHsbString",
        value: function toHsbString() {
          return this.metaColor.toHsbString();
        }
      }, {
        key: "toHex",
        value: function toHex() {
          return getHex(this.toHexString(), this.metaColor.a < 1);
        }
      }, {
        key: "toHexString",
        value: function toHexString() {
          return this.metaColor.toHexString();
        }
      }, {
        key: "toRgb",
        value: function toRgb() {
          return this.metaColor.toRgb();
        }
      }, {
        key: "toRgbString",
        value: function toRgbString() {
          return this.metaColor.toRgbString();
        }
      }, {
        key: "isGradient",
        value: function isGradient() {
          return !!this.colors && !this.cleared;
        }
      }, {
        key: "getColors",
        value: function getColors() {
          return this.colors || [{
            color: this,
            percent: 0
          }];
        }
      }, {
        key: "toCssString",
        value: function toCssString() {
          const {
            colors
          } = this;
          if (colors) {
            const colorsStr = colors.map((c2) => `${c2.color.toRgbString()} ${c2.percent}%`).join(", ");
            return `linear-gradient(90deg, ${colorsStr})`;
          }
          return this.metaColor.toRgbString();
        }
      }, {
        key: "equals",
        value: function equals(color) {
          if (!color || this.isGradient() !== color.isGradient()) {
            return false;
          }
          if (!this.isGradient()) {
            return this.toHexString() === color.toHexString();
          }
          return this.colors.length === color.colors.length && this.colors.every((c2, i2) => {
            const target = color.colors[i2];
            return c2.percent === target.percent && c2.color.equals(target.color);
          });
        }
      }]);
    }();
    var RightOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
    var RightOutlined = function RightOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: RightOutlined$1
      }));
    };
    var RefIcon$w = /* @__PURE__ */ reactExports.forwardRef(RightOutlined);
    const genCollapseMotion = (token2) => ({
      [token2.componentCls]: {
        // For common/openAnimation
        [`${token2.antCls}-motion-collapse-legacy`]: {
          overflow: "hidden",
          "&-active": {
            transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
          }
        },
        [`${token2.antCls}-motion-collapse`]: {
          overflow: "hidden",
          transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
        }
      }
    });
    const initMotionCommon = (duration) => ({
      animationDuration: duration,
      animationFillMode: "both"
    });
    const initMotionCommonLeave = (duration) => ({
      animationDuration: duration,
      animationFillMode: "both"
    });
    const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
      let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      const sameLevelPrefix = sameLevel ? "&" : "";
      return {
        [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), {
          animationPlayState: "paused"
        }),
        [`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), {
          animationPlayState: "paused"
        }),
        [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
          animationName: inKeyframes,
          animationPlayState: "running"
        },
        [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
          animationName: outKeyframes,
          animationPlayState: "running",
          pointerEvents: "none"
        }
      };
    };
    const fadeIn = new Keyframe("antFadeIn", {
      "0%": {
        opacity: 0
      },
      "100%": {
        opacity: 1
      }
    });
    const fadeOut = new Keyframe("antFadeOut", {
      "0%": {
        opacity: 1
      },
      "100%": {
        opacity: 0
      }
    });
    const initFadeMotion = function(token2) {
      let sameLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-fade`;
      const sameLevelPrefix = sameLevel ? "&" : "";
      return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
        [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
          opacity: 0,
          animationTimingFunction: "linear"
        },
        [`${sameLevelPrefix}${motionCls}-leave`]: {
          animationTimingFunction: "linear"
        }
      }];
    };
    const moveDownIn = new Keyframe("antMoveDownIn", {
      "0%": {
        transform: "translate3d(0, 100%, 0)",
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveDownOut = new Keyframe("antMoveDownOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: "translate3d(0, 100%, 0)",
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    const moveLeftIn = new Keyframe("antMoveLeftIn", {
      "0%": {
        transform: "translate3d(-100%, 0, 0)",
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveLeftOut = new Keyframe("antMoveLeftOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: "translate3d(-100%, 0, 0)",
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    const moveRightIn = new Keyframe("antMoveRightIn", {
      "0%": {
        transform: "translate3d(100%, 0, 0)",
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveRightOut = new Keyframe("antMoveRightOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: "translate3d(100%, 0, 0)",
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    const moveUpIn = new Keyframe("antMoveUpIn", {
      "0%": {
        transform: "translate3d(0, -100%, 0)",
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveUpOut = new Keyframe("antMoveUpOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: "translate3d(0, -100%, 0)",
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    const moveMotion = {
      "move-up": {
        inKeyframes: moveUpIn,
        outKeyframes: moveUpOut
      },
      "move-down": {
        inKeyframes: moveDownIn,
        outKeyframes: moveDownOut
      },
      "move-left": {
        inKeyframes: moveLeftIn,
        outKeyframes: moveLeftOut
      },
      "move-right": {
        inKeyframes: moveRightIn,
        outKeyframes: moveRightOut
      }
    };
    const initMoveMotion = (token2, motionName) => {
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-${motionName}`;
      const {
        inKeyframes,
        outKeyframes
      } = moveMotion[motionName];
      return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
        [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
          opacity: 0,
          animationTimingFunction: token2.motionEaseOutCirc
        },
        [`${motionCls}-leave`]: {
          animationTimingFunction: token2.motionEaseInOutCirc
        }
      }];
    };
    const slideUpIn = new Keyframe("antSlideUpIn", {
      "0%": {
        transform: "scaleY(0.8)",
        transformOrigin: "0% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scaleY(1)",
        transformOrigin: "0% 0%",
        opacity: 1
      }
    });
    const slideUpOut = new Keyframe("antSlideUpOut", {
      "0%": {
        transform: "scaleY(1)",
        transformOrigin: "0% 0%",
        opacity: 1
      },
      "100%": {
        transform: "scaleY(0.8)",
        transformOrigin: "0% 0%",
        opacity: 0
      }
    });
    const slideDownIn = new Keyframe("antSlideDownIn", {
      "0%": {
        transform: "scaleY(0.8)",
        transformOrigin: "100% 100%",
        opacity: 0
      },
      "100%": {
        transform: "scaleY(1)",
        transformOrigin: "100% 100%",
        opacity: 1
      }
    });
    const slideDownOut = new Keyframe("antSlideDownOut", {
      "0%": {
        transform: "scaleY(1)",
        transformOrigin: "100% 100%",
        opacity: 1
      },
      "100%": {
        transform: "scaleY(0.8)",
        transformOrigin: "100% 100%",
        opacity: 0
      }
    });
    const slideLeftIn = new Keyframe("antSlideLeftIn", {
      "0%": {
        transform: "scaleX(0.8)",
        transformOrigin: "0% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scaleX(1)",
        transformOrigin: "0% 0%",
        opacity: 1
      }
    });
    const slideLeftOut = new Keyframe("antSlideLeftOut", {
      "0%": {
        transform: "scaleX(1)",
        transformOrigin: "0% 0%",
        opacity: 1
      },
      "100%": {
        transform: "scaleX(0.8)",
        transformOrigin: "0% 0%",
        opacity: 0
      }
    });
    const slideRightIn = new Keyframe("antSlideRightIn", {
      "0%": {
        transform: "scaleX(0.8)",
        transformOrigin: "100% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scaleX(1)",
        transformOrigin: "100% 0%",
        opacity: 1
      }
    });
    const slideRightOut = new Keyframe("antSlideRightOut", {
      "0%": {
        transform: "scaleX(1)",
        transformOrigin: "100% 0%",
        opacity: 1
      },
      "100%": {
        transform: "scaleX(0.8)",
        transformOrigin: "100% 0%",
        opacity: 0
      }
    });
    const slideMotion = {
      "slide-up": {
        inKeyframes: slideUpIn,
        outKeyframes: slideUpOut
      },
      "slide-down": {
        inKeyframes: slideDownIn,
        outKeyframes: slideDownOut
      },
      "slide-left": {
        inKeyframes: slideLeftIn,
        outKeyframes: slideLeftOut
      },
      "slide-right": {
        inKeyframes: slideRightIn,
        outKeyframes: slideRightOut
      }
    };
    const initSlideMotion = (token2, motionName) => {
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-${motionName}`;
      const {
        inKeyframes,
        outKeyframes
      } = slideMotion[motionName];
      return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
        [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
          transform: "scale(0)",
          transformOrigin: "0% 0%",
          opacity: 0,
          animationTimingFunction: token2.motionEaseOutQuint,
          "&-prepare": {
            transform: "scale(1)"
          }
        },
        [`${motionCls}-leave`]: {
          animationTimingFunction: token2.motionEaseInQuint
        }
      }];
    };
    const zoomIn = new Keyframe("antZoomIn", {
      "0%": {
        transform: "scale(0.2)",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        opacity: 1
      }
    });
    const zoomOut = new Keyframe("antZoomOut", {
      "0%": {
        transform: "scale(1)"
      },
      "100%": {
        transform: "scale(0.2)",
        opacity: 0
      }
    });
    const zoomBigIn = new Keyframe("antZoomBigIn", {
      "0%": {
        transform: "scale(0.8)",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        opacity: 1
      }
    });
    const zoomBigOut = new Keyframe("antZoomBigOut", {
      "0%": {
        transform: "scale(1)"
      },
      "100%": {
        transform: "scale(0.8)",
        opacity: 0
      }
    });
    const zoomUpIn = new Keyframe("antZoomUpIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "50% 0%"
      }
    });
    const zoomUpOut = new Keyframe("antZoomUpOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "50% 0%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 0%",
        opacity: 0
      }
    });
    const zoomLeftIn = new Keyframe("antZoomLeftIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "0% 50%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "0% 50%"
      }
    });
    const zoomLeftOut = new Keyframe("antZoomLeftOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "0% 50%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "0% 50%",
        opacity: 0
      }
    });
    const zoomRightIn = new Keyframe("antZoomRightIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "100% 50%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "100% 50%"
      }
    });
    const zoomRightOut = new Keyframe("antZoomRightOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "100% 50%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "100% 50%",
        opacity: 0
      }
    });
    const zoomDownIn = new Keyframe("antZoomDownIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 100%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "50% 100%"
      }
    });
    const zoomDownOut = new Keyframe("antZoomDownOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "50% 100%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 100%",
        opacity: 0
      }
    });
    const zoomMotion = {
      zoom: {
        inKeyframes: zoomIn,
        outKeyframes: zoomOut
      },
      "zoom-big": {
        inKeyframes: zoomBigIn,
        outKeyframes: zoomBigOut
      },
      "zoom-big-fast": {
        inKeyframes: zoomBigIn,
        outKeyframes: zoomBigOut
      },
      "zoom-left": {
        inKeyframes: zoomLeftIn,
        outKeyframes: zoomLeftOut
      },
      "zoom-right": {
        inKeyframes: zoomRightIn,
        outKeyframes: zoomRightOut
      },
      "zoom-up": {
        inKeyframes: zoomUpIn,
        outKeyframes: zoomUpOut
      },
      "zoom-down": {
        inKeyframes: zoomDownIn,
        outKeyframes: zoomDownOut
      }
    };
    const initZoomMotion = (token2, motionName) => {
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-${motionName}`;
      const {
        inKeyframes,
        outKeyframes
      } = zoomMotion[motionName];
      return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
        [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
          transform: "scale(0)",
          opacity: 0,
          animationTimingFunction: token2.motionEaseOutCirc,
          "&-prepare": {
            transform: "none"
          }
        },
        [`${motionCls}-leave`]: {
          animationTimingFunction: token2.motionEaseInOutCirc
        }
      }];
    };
    const isBright = (value, bgColorToken) => {
      const {
        r: r2,
        g: g2,
        b: b2,
        a
      } = value.toRgb();
      const hsv = new Color(value.toRgbString()).onBackground(bgColorToken).toHsv();
      if (a <= 0.5) {
        return hsv.v > 0.5;
      }
      return r2 * 0.299 + g2 * 0.587 + b2 * 0.114 > 192;
    };
    const prepareToken$4 = (token2) => {
      const {
        paddingInline,
        onlyIconSize
      } = token2;
      const buttonToken = merge(token2, {
        buttonPaddingHorizontal: paddingInline,
        buttonPaddingVertical: 0,
        buttonIconOnlyFontSize: onlyIconSize
      });
      return buttonToken;
    };
    const prepareComponentToken$k = (token2) => {
      var _a, _b, _c, _d, _e2, _f;
      const contentFontSize = (_a = token2.contentFontSize) !== null && _a !== void 0 ? _a : token2.fontSize;
      const contentFontSizeSM = (_b = token2.contentFontSizeSM) !== null && _b !== void 0 ? _b : token2.fontSize;
      const contentFontSizeLG = (_c = token2.contentFontSizeLG) !== null && _c !== void 0 ? _c : token2.fontSizeLG;
      const contentLineHeight = (_d = token2.contentLineHeight) !== null && _d !== void 0 ? _d : getLineHeight(contentFontSize);
      const contentLineHeightSM = (_e2 = token2.contentLineHeightSM) !== null && _e2 !== void 0 ? _e2 : getLineHeight(contentFontSizeSM);
      const contentLineHeightLG = (_f = token2.contentLineHeightLG) !== null && _f !== void 0 ? _f : getLineHeight(contentFontSizeLG);
      const solidTextColor = isBright(new AggregationColor(token2.colorBgSolid), "#fff") ? "#000" : "#fff";
      const shadowColorTokens = PresetColors.reduce((prev2, colorKey) => Object.assign(Object.assign({}, prev2), {
        [`${colorKey}ShadowColor`]: `0 ${unit$1(token2.controlOutlineWidth)} 0 ${getAlphaColor(token2[`${colorKey}1`], token2.colorBgContainer)}`
      }), {});
      return Object.assign(Object.assign({}, shadowColorTokens), {
        fontWeight: 400,
        defaultShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`,
        primaryShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`,
        dangerShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`,
        primaryColor: token2.colorTextLightSolid,
        dangerColor: token2.colorTextLightSolid,
        borderColorDisabled: token2.colorBorder,
        defaultGhostColor: token2.colorBgContainer,
        ghostBg: "transparent",
        defaultGhostBorderColor: token2.colorBgContainer,
        paddingInline: token2.paddingContentHorizontal - token2.lineWidth,
        paddingInlineLG: token2.paddingContentHorizontal - token2.lineWidth,
        paddingInlineSM: 8 - token2.lineWidth,
        onlyIconSize: "inherit",
        onlyIconSizeSM: "inherit",
        onlyIconSizeLG: "inherit",
        groupBorderColor: token2.colorPrimaryHover,
        linkHoverBg: "transparent",
        textTextColor: token2.colorText,
        textTextHoverColor: token2.colorText,
        textTextActiveColor: token2.colorText,
        textHoverBg: token2.colorFillTertiary,
        defaultColor: token2.colorText,
        defaultBg: token2.colorBgContainer,
        defaultBorderColor: token2.colorBorder,
        defaultBorderColorDisabled: token2.colorBorder,
        defaultHoverBg: token2.colorBgContainer,
        defaultHoverColor: token2.colorPrimaryHover,
        defaultHoverBorderColor: token2.colorPrimaryHover,
        defaultActiveBg: token2.colorBgContainer,
        defaultActiveColor: token2.colorPrimaryActive,
        defaultActiveBorderColor: token2.colorPrimaryActive,
        solidTextColor,
        contentFontSize,
        contentFontSizeSM,
        contentFontSizeLG,
        contentLineHeight,
        contentLineHeightSM,
        contentLineHeightLG,
        paddingBlock: Math.max((token2.controlHeight - contentFontSize * contentLineHeight) / 2 - token2.lineWidth, 0),
        paddingBlockSM: Math.max((token2.controlHeightSM - contentFontSizeSM * contentLineHeightSM) / 2 - token2.lineWidth, 0),
        paddingBlockLG: Math.max((token2.controlHeightLG - contentFontSizeLG * contentLineHeightLG) / 2 - token2.lineWidth, 0)
      });
    };
    const genSharedButtonStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        fontWeight,
        opacityLoading,
        motionDurationSlow,
        motionEaseInOut,
        marginXS,
        calc
      } = token2;
      return {
        [componentCls]: {
          outline: "none",
          position: "relative",
          display: "inline-flex",
          gap: token2.marginXS,
          alignItems: "center",
          justifyContent: "center",
          fontWeight,
          whiteSpace: "nowrap",
          textAlign: "center",
          backgroundImage: "none",
          background: "transparent",
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
          userSelect: "none",
          touchAction: "manipulation",
          color: token2.colorText,
          "&:disabled > *": {
            pointerEvents: "none"
          },
          // https://github.com/ant-design/ant-design/issues/51380
          [`${componentCls}-icon > svg`]: resetIcon(),
          "> a": {
            color: "currentColor"
          },
          "&:not(:disabled)": genFocusStyle(token2),
          [`&${componentCls}-two-chinese-chars::first-letter`]: {
            letterSpacing: "0.34em"
          },
          [`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
            marginInlineEnd: "-0.34em",
            letterSpacing: "0.34em"
          },
          [`&${componentCls}-icon-only`]: {
            paddingInline: 0,
            // make `btn-icon-only` not too narrow
            [`&${componentCls}-compact-item`]: {
              flex: "none"
            },
            [`&${componentCls}-round`]: {
              width: "auto"
            }
          },
          // Loading
          [`&${componentCls}-loading`]: {
            opacity: opacityLoading,
            cursor: "default"
          },
          [`${componentCls}-loading-icon`]: {
            transition: ["width", "opacity", "margin"].map((transition) => `${transition} ${motionDurationSlow} ${motionEaseInOut}`).join(",")
          },
          // iconPosition
          [`&:not(${componentCls}-icon-end)`]: {
            [`${componentCls}-loading-icon-motion`]: {
              "&-appear-start, &-enter-start": {
                marginInlineEnd: calc(marginXS).mul(-1).equal()
              },
              "&-appear-active, &-enter-active": {
                marginInlineEnd: 0
              },
              "&-leave-start": {
                marginInlineEnd: 0
              },
              "&-leave-active": {
                marginInlineEnd: calc(marginXS).mul(-1).equal()
              }
            }
          },
          "&-icon-end": {
            flexDirection: "row-reverse",
            [`${componentCls}-loading-icon-motion`]: {
              "&-appear-start, &-enter-start": {
                marginInlineStart: calc(marginXS).mul(-1).equal()
              },
              "&-appear-active, &-enter-active": {
                marginInlineStart: 0
              },
              "&-leave-start": {
                marginInlineStart: 0
              },
              "&-leave-active": {
                marginInlineStart: calc(marginXS).mul(-1).equal()
              }
            }
          }
        }
      };
    };
    const genHoverActiveButtonStyle = (btnCls, hoverStyle, activeStyle) => ({
      [`&:not(:disabled):not(${btnCls}-disabled)`]: {
        "&:hover": hoverStyle,
        "&:active": activeStyle
      }
    });
    const genCircleButtonStyle = (token2) => ({
      minWidth: token2.controlHeight,
      paddingInlineStart: 0,
      paddingInlineEnd: 0,
      borderRadius: "50%"
    });
    const genRoundButtonStyle = (token2) => ({
      borderRadius: token2.controlHeight,
      paddingInlineStart: token2.calc(token2.controlHeight).div(2).equal(),
      paddingInlineEnd: token2.calc(token2.controlHeight).div(2).equal()
    });
    const genDisabledStyle$1 = (token2) => ({
      cursor: "not-allowed",
      borderColor: token2.borderColorDisabled,
      color: token2.colorTextDisabled,
      background: token2.colorBgContainerDisabled,
      boxShadow: "none"
    });
    const genGhostButtonStyle = (btnCls, background, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
      [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
        color: textColor || void 0,
        background,
        borderColor: borderColor || void 0,
        boxShadow: "none"
      }, genHoverActiveButtonStyle(btnCls, Object.assign({
        background
      }, hoverStyle), Object.assign({
        background
      }, activeStyle))), {
        "&:disabled": {
          cursor: "not-allowed",
          color: textColorDisabled || void 0,
          borderColor: borderColorDisabled || void 0
        }
      })
    });
    const genSolidDisabledButtonStyle = (token2) => ({
      [`&:disabled, &${token2.componentCls}-disabled`]: Object.assign({}, genDisabledStyle$1(token2))
    });
    const genPureDisabledButtonStyle = (token2) => ({
      [`&:disabled, &${token2.componentCls}-disabled`]: {
        cursor: "not-allowed",
        color: token2.colorTextDisabled
      }
    });
    const genVariantButtonStyle = (token2, hoverStyle, activeStyle, variant) => {
      const isPureDisabled = variant && ["link", "text"].includes(variant);
      const genDisabledButtonStyle = isPureDisabled ? genPureDisabledButtonStyle : genSolidDisabledButtonStyle;
      return Object.assign(Object.assign({}, genDisabledButtonStyle(token2)), genHoverActiveButtonStyle(token2.componentCls, hoverStyle, activeStyle));
    };
    const genSolidButtonStyle = (token2, textColor, background, hoverStyle, activeStyle) => ({
      [`&${token2.componentCls}-variant-solid`]: Object.assign({
        color: textColor,
        background
      }, genVariantButtonStyle(token2, hoverStyle, activeStyle))
    });
    const genOutlinedDashedButtonStyle = (token2, borderColor, background, hoverStyle, activeStyle) => ({
      [`&${token2.componentCls}-variant-outlined, &${token2.componentCls}-variant-dashed`]: Object.assign({
        borderColor,
        background
      }, genVariantButtonStyle(token2, hoverStyle, activeStyle))
    });
    const genDashedButtonStyle = (token2) => ({
      [`&${token2.componentCls}-variant-dashed`]: {
        borderStyle: "dashed"
      }
    });
    const genFilledButtonStyle = (token2, background, hoverStyle, activeStyle) => ({
      [`&${token2.componentCls}-variant-filled`]: Object.assign({
        boxShadow: "none",
        background
      }, genVariantButtonStyle(token2, hoverStyle, activeStyle))
    });
    const genTextLinkButtonStyle = (token2, textColor, variant, hoverStyle, activeStyle) => ({
      [`&${token2.componentCls}-variant-${variant}`]: Object.assign({
        color: textColor,
        boxShadow: "none"
      }, genVariantButtonStyle(token2, hoverStyle, activeStyle, variant))
    });
    const genPresetColorStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return PresetColors.reduce((prev2, colorKey) => {
        const darkColor = token2[`${colorKey}6`];
        const lightColor = token2[`${colorKey}1`];
        const hoverColor = token2[`${colorKey}5`];
        const lightHoverColor = token2[`${colorKey}2`];
        const lightBorderColor = token2[`${colorKey}3`];
        const activeColor = token2[`${colorKey}7`];
        return Object.assign(Object.assign({}, prev2), {
          [`&${componentCls}-color-${colorKey}`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
            color: darkColor,
            boxShadow: token2[`${colorKey}ShadowColor`]
          }, genSolidButtonStyle(token2, token2.colorTextLightSolid, darkColor, {
            background: hoverColor
          }, {
            background: activeColor
          })), genOutlinedDashedButtonStyle(token2, darkColor, token2.colorBgContainer, {
            color: hoverColor,
            borderColor: hoverColor,
            background: token2.colorBgContainer
          }, {
            color: activeColor,
            borderColor: activeColor,
            background: token2.colorBgContainer
          })), genDashedButtonStyle(token2)), genFilledButtonStyle(token2, lightColor, {
            background: lightHoverColor
          }, {
            background: lightBorderColor
          })), genTextLinkButtonStyle(token2, darkColor, "link", {
            color: hoverColor
          }, {
            color: activeColor
          })), genTextLinkButtonStyle(token2, darkColor, "text", {
            color: hoverColor,
            background: lightColor
          }, {
            color: activeColor,
            background: lightBorderColor
          }))
        });
      }, {});
    };
    const genDefaultButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      color: token2.defaultColor,
      boxShadow: token2.defaultShadow
    }, genSolidButtonStyle(token2, token2.solidTextColor, token2.colorBgSolid, {
      color: token2.solidTextColor,
      background: token2.colorBgSolidHover
    }, {
      color: token2.solidTextColor,
      background: token2.colorBgSolidActive
    })), genDashedButtonStyle(token2)), genFilledButtonStyle(token2, token2.colorFillTertiary, {
      background: token2.colorFillSecondary
    }, {
      background: token2.colorFill
    })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.defaultGhostColor, token2.defaultGhostBorderColor, token2.colorTextDisabled, token2.colorBorder)), genTextLinkButtonStyle(token2, token2.textTextColor, "link", {
      color: token2.colorLinkHover,
      background: token2.linkHoverBg
    }, {
      color: token2.colorLinkActive
    }));
    const genPrimaryButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      color: token2.colorPrimary,
      boxShadow: token2.primaryShadow
    }, genOutlinedDashedButtonStyle(token2, token2.colorPrimary, token2.colorBgContainer, {
      color: token2.colorPrimaryTextHover,
      borderColor: token2.colorPrimaryHover,
      background: token2.colorBgContainer
    }, {
      color: token2.colorPrimaryTextActive,
      borderColor: token2.colorPrimaryActive,
      background: token2.colorBgContainer
    })), genDashedButtonStyle(token2)), genFilledButtonStyle(token2, token2.colorPrimaryBg, {
      background: token2.colorPrimaryBgHover
    }, {
      background: token2.colorPrimaryBorder
    })), genTextLinkButtonStyle(token2, token2.colorPrimaryText, "text", {
      color: token2.colorPrimaryTextHover,
      background: token2.colorPrimaryBg
    }, {
      color: token2.colorPrimaryTextActive,
      background: token2.colorPrimaryBorder
    })), genTextLinkButtonStyle(token2, token2.colorPrimaryText, "link", {
      color: token2.colorPrimaryTextHover,
      background: token2.linkHoverBg
    }, {
      color: token2.colorPrimaryTextActive
    })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
      color: token2.colorPrimaryHover,
      borderColor: token2.colorPrimaryHover
    }, {
      color: token2.colorPrimaryActive,
      borderColor: token2.colorPrimaryActive
    }));
    const genDangerousStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      color: token2.colorError,
      boxShadow: token2.dangerShadow
    }, genSolidButtonStyle(token2, token2.dangerColor, token2.colorError, {
      background: token2.colorErrorHover
    }, {
      background: token2.colorErrorActive
    })), genOutlinedDashedButtonStyle(token2, token2.colorError, token2.colorBgContainer, {
      color: token2.colorErrorHover,
      borderColor: token2.colorErrorBorderHover
    }, {
      color: token2.colorErrorActive,
      borderColor: token2.colorErrorActive
    })), genDashedButtonStyle(token2)), genFilledButtonStyle(token2, token2.colorErrorBg, {
      background: token2.colorErrorBgFilledHover
    }, {
      background: token2.colorErrorBgActive
    })), genTextLinkButtonStyle(token2, token2.colorError, "text", {
      color: token2.colorErrorHover,
      background: token2.colorErrorBg
    }, {
      color: token2.colorErrorHover,
      background: token2.colorErrorBgActive
    })), genTextLinkButtonStyle(token2, token2.colorError, "link", {
      color: token2.colorErrorHover
    }, {
      color: token2.colorErrorActive
    })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
      color: token2.colorErrorHover,
      borderColor: token2.colorErrorHover
    }, {
      color: token2.colorErrorActive,
      borderColor: token2.colorErrorActive
    }));
    const genLinkStyle = (token2) => Object.assign(Object.assign({}, genTextLinkButtonStyle(token2, token2.colorLink, "link", {
      color: token2.colorLinkHover
    }, {
      color: token2.colorLinkActive
    })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorInfo, token2.colorInfo, token2.colorTextDisabled, token2.colorBorder, {
      color: token2.colorInfoHover,
      borderColor: token2.colorInfoHover
    }, {
      color: token2.colorInfoActive,
      borderColor: token2.colorInfoActive
    }));
    const genColorButtonStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return Object.assign({
        [`${componentCls}-color-default`]: genDefaultButtonStyle(token2),
        [`${componentCls}-color-primary`]: genPrimaryButtonStyle(token2),
        [`${componentCls}-color-dangerous`]: genDangerousStyle(token2),
        [`${componentCls}-color-link`]: genLinkStyle(token2)
      }, genPresetColorStyle(token2));
    };
    const genCompatibleButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign({}, genOutlinedDashedButtonStyle(token2, token2.defaultBorderColor, token2.defaultBg, {
      color: token2.defaultHoverColor,
      borderColor: token2.defaultHoverBorderColor,
      background: token2.defaultHoverBg
    }, {
      color: token2.defaultActiveColor,
      borderColor: token2.defaultActiveBorderColor,
      background: token2.defaultActiveBg
    })), genTextLinkButtonStyle(token2, token2.textTextColor, "text", {
      color: token2.textTextHoverColor,
      background: token2.textHoverBg
    }, {
      color: token2.textTextActiveColor,
      background: token2.colorBgTextActive
    })), genSolidButtonStyle(token2, token2.primaryColor, token2.colorPrimary, {
      background: token2.colorPrimaryHover,
      color: token2.primaryColor
    }, {
      background: token2.colorPrimaryActive,
      color: token2.primaryColor
    })), genTextLinkButtonStyle(token2, token2.colorLink, "link", {
      color: token2.colorLinkHover,
      background: token2.linkHoverBg
    }, {
      color: token2.colorLinkActive
    }));
    const genButtonStyle = function(token2) {
      let prefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      const {
        componentCls,
        controlHeight,
        fontSize,
        borderRadius,
        buttonPaddingHorizontal,
        iconCls,
        buttonPaddingVertical,
        buttonIconOnlyFontSize
      } = token2;
      return [
        {
          [prefixCls]: {
            fontSize,
            height: controlHeight,
            padding: `${unit$1(buttonPaddingVertical)} ${unit$1(buttonPaddingHorizontal)}`,
            borderRadius,
            [`&${componentCls}-icon-only`]: {
              width: controlHeight,
              [iconCls]: {
                fontSize: buttonIconOnlyFontSize
              }
            }
          }
        },
        // Shape - patch prefixCls again to override solid border radius style
        {
          [`${componentCls}${componentCls}-circle${prefixCls}`]: genCircleButtonStyle(token2)
        },
        {
          [`${componentCls}${componentCls}-round${prefixCls}`]: genRoundButtonStyle(token2)
        }
      ];
    };
    const genSizeBaseButtonStyle = (token2) => {
      const baseToken = merge(token2, {
        fontSize: token2.contentFontSize
      });
      return genButtonStyle(baseToken, token2.componentCls);
    };
    const genSizeSmallButtonStyle = (token2) => {
      const smallToken = merge(token2, {
        controlHeight: token2.controlHeightSM,
        fontSize: token2.contentFontSizeSM,
        padding: token2.paddingXS,
        buttonPaddingHorizontal: token2.paddingInlineSM,
        buttonPaddingVertical: 0,
        borderRadius: token2.borderRadiusSM,
        buttonIconOnlyFontSize: token2.onlyIconSizeSM
      });
      return genButtonStyle(smallToken, `${token2.componentCls}-sm`);
    };
    const genSizeLargeButtonStyle = (token2) => {
      const largeToken = merge(token2, {
        controlHeight: token2.controlHeightLG,
        fontSize: token2.contentFontSizeLG,
        buttonPaddingHorizontal: token2.paddingInlineLG,
        buttonPaddingVertical: 0,
        borderRadius: token2.borderRadiusLG,
        buttonIconOnlyFontSize: token2.onlyIconSizeLG
      });
      return genButtonStyle(largeToken, `${token2.componentCls}-lg`);
    };
    const genBlockButtonStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          [`&${componentCls}-block`]: {
            width: "100%"
          }
        }
      };
    };
    const useStyle$o = genStyleHooks("Button", (token2) => {
      const buttonToken = prepareToken$4(token2);
      return [
        // Shared
        genSharedButtonStyle(buttonToken),
        // Size
        genSizeBaseButtonStyle(buttonToken),
        genSizeSmallButtonStyle(buttonToken),
        genSizeLargeButtonStyle(buttonToken),
        // Block
        genBlockButtonStyle(buttonToken),
        // Color
        genColorButtonStyle(buttonToken),
        // https://github.com/ant-design/ant-design/issues/50969
        genCompatibleButtonStyle(buttonToken),
        // Button Group
        genGroupStyle$1(buttonToken)
      ];
    }, prepareComponentToken$k, {
      unitless: {
        fontWeight: true,
        contentLineHeight: true,
        contentLineHeightSM: true,
        contentLineHeightLG: true
      }
    });
    function compactItemBorder(token2, parentCls, options2) {
      const {
        focusElCls,
        focus,
        borderElCls
      } = options2;
      const childCombinator = borderElCls ? "> *" : "";
      const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
      return {
        [`&-item:not(${parentCls}-last-item)`]: {
          marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal()
        },
        "&-item": Object.assign(Object.assign({
          [hoverEffects]: {
            zIndex: 2
          }
        }, focusElCls ? {
          [`&${focusElCls}`]: {
            zIndex: 2
          }
        } : {}), {
          [`&[disabled] ${childCombinator}`]: {
            zIndex: 0
          }
        })
      };
    }
    function compactItemBorderRadius(prefixCls, parentCls, options2) {
      const {
        borderElCls
      } = options2;
      const childCombinator = borderElCls ? `> ${borderElCls}` : "";
      return {
        [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
          borderRadius: 0
        },
        [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
          [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
          [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        }
      };
    }
    function genCompactItemStyle(token2) {
      let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        focus: true
      };
      const {
        componentCls
      } = token2;
      const compactCls = `${componentCls}-compact`;
      return {
        [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token2, compactCls, options2)), compactItemBorderRadius(componentCls, compactCls, options2))
      };
    }
    function compactItemVerticalBorder(token2, parentCls) {
      return {
        // border collapse
        [`&-item:not(${parentCls}-last-item)`]: {
          marginBottom: token2.calc(token2.lineWidth).mul(-1).equal()
        },
        "&-item": {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        }
      };
    }
    function compactItemBorderVerticalRadius(prefixCls, parentCls) {
      return {
        [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
          borderRadius: 0
        },
        [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
          [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
            borderEndEndRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
          [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
            borderStartStartRadius: 0,
            borderStartEndRadius: 0
          }
        }
      };
    }
    function genCompactItemVerticalStyle(token2) {
      const compactCls = `${token2.componentCls}-compact-vertical`;
      return {
        [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
      };
    }
    const genButtonCompactStyle = (token2) => {
      const {
        componentCls,
        colorPrimaryHover,
        lineWidth,
        calc
      } = token2;
      const insetOffset = calc(lineWidth).mul(-1).equal();
      const getCompactBorderStyle = (vertical) => {
        const selector = `${componentCls}-compact${vertical ? "-vertical" : ""}-item${componentCls}-primary:not([disabled])`;
        return {
          [`${selector} + ${selector}::before`]: {
            position: "absolute",
            top: vertical ? insetOffset : 0,
            insetInlineStart: vertical ? 0 : insetOffset,
            backgroundColor: colorPrimaryHover,
            content: '""',
            width: vertical ? "100%" : lineWidth,
            height: vertical ? lineWidth : "100%"
          }
        };
      };
      return Object.assign(Object.assign({}, getCompactBorderStyle()), getCompactBorderStyle(true));
    };
    const Compact = genSubStyleComponent(["Button", "compact"], (token2) => {
      const buttonToken = prepareToken$4(token2);
      return [
        // Space Compact
        genCompactItemStyle(buttonToken),
        genCompactItemVerticalStyle(buttonToken),
        genButtonCompactStyle(buttonToken)
      ];
    }, prepareComponentToken$k);
    var __rest$O = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function getLoadingConfig(loading) {
      if (typeof loading === "object" && loading) {
        let delay = loading === null || loading === void 0 ? void 0 : loading.delay;
        delay = !Number.isNaN(delay) && typeof delay === "number" ? delay : 0;
        return {
          loading: delay <= 0,
          delay
        };
      }
      return {
        loading: !!loading,
        delay: 0
      };
    }
    const ButtonTypeMap = {
      default: ["default", "outlined"],
      primary: ["primary", "solid"],
      dashed: ["default", "dashed"],
      // `link` is not a real color but we should compatible with it
      link: ["link", "link"],
      text: ["default", "text"]
    };
    const InternalCompoundedButton = /* @__PURE__ */ i.forwardRef((props, ref) => {
      var _a, _b;
      const {
        loading = false,
        prefixCls: customizePrefixCls,
        color,
        variant,
        type: type2,
        danger = false,
        shape = "default",
        size: customizeSize,
        styles,
        disabled: customDisabled,
        className,
        rootClassName,
        children,
        icon,
        iconPosition = "start",
        ghost = false,
        block = false,
        // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
        htmlType = "button",
        classNames: customClassNames,
        style: customStyle = {},
        autoInsertSpace,
        autoFocus
      } = props, rest = __rest$O(props, ["loading", "prefixCls", "color", "variant", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "iconPosition", "ghost", "block", "htmlType", "classNames", "style", "autoInsertSpace", "autoFocus"]);
      const mergedType = type2 || "default";
      const [mergedColor, mergedVariant] = reactExports.useMemo(() => {
        if (color && variant) {
          return [color, variant];
        }
        const colorVariantPair = ButtonTypeMap[mergedType] || [];
        if (danger) {
          return ["danger", colorVariantPair[1]];
        }
        return colorVariantPair;
      }, [type2, color, variant, danger]);
      const isDanger = mergedColor === "danger";
      const mergedColorText = isDanger ? "dangerous" : mergedColor;
      const {
        getPrefixCls,
        direction,
        autoInsertSpace: contextAutoInsertSpace,
        className: contextClassName,
        style: contextStyle,
        classNames: contextClassNames,
        styles: contextStyles
      } = useComponentConfig("button");
      const mergedInsertSpace = (_a = autoInsertSpace !== null && autoInsertSpace !== void 0 ? autoInsertSpace : contextAutoInsertSpace) !== null && _a !== void 0 ? _a : true;
      const prefixCls = getPrefixCls("btn", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$o(prefixCls);
      const disabled = reactExports.useContext(DisabledContext);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const groupSize = reactExports.useContext(GroupSizeContext);
      const loadingOrDelay = reactExports.useMemo(() => getLoadingConfig(loading), [loading]);
      const [innerLoading, setLoading] = reactExports.useState(loadingOrDelay.loading);
      const [hasTwoCNChar, setHasTwoCNChar] = reactExports.useState(false);
      const buttonRef = reactExports.useRef(null);
      const mergedRef = useComposeRef(ref, buttonRef);
      const needInserted = reactExports.Children.count(children) === 1 && !icon && !isUnBorderedButtonVariant(mergedVariant);
      const isMountRef = reactExports.useRef(true);
      i.useEffect(() => {
        isMountRef.current = false;
        return () => {
          isMountRef.current = true;
        };
      }, []);
      reactExports.useEffect(() => {
        let delayTimer = null;
        if (loadingOrDelay.delay > 0) {
          delayTimer = setTimeout(() => {
            delayTimer = null;
            setLoading(true);
          }, loadingOrDelay.delay);
        } else {
          setLoading(loadingOrDelay.loading);
        }
        function cleanupTimer() {
          if (delayTimer) {
            clearTimeout(delayTimer);
            delayTimer = null;
          }
        }
        return cleanupTimer;
      }, [loadingOrDelay]);
      reactExports.useEffect(() => {
        if (!buttonRef.current || !mergedInsertSpace) {
          return;
        }
        const buttonText = buttonRef.current.textContent || "";
        if (needInserted && isTwoCNChar(buttonText)) {
          if (!hasTwoCNChar) {
            setHasTwoCNChar(true);
          }
        } else if (hasTwoCNChar) {
          setHasTwoCNChar(false);
        }
      });
      reactExports.useEffect(() => {
        if (autoFocus && buttonRef.current) {
          buttonRef.current.focus();
        }
      }, []);
      const handleClick = i.useCallback((e2) => {
        var _a2;
        if (innerLoading || mergedDisabled) {
          e2.preventDefault();
          return;
        }
        (_a2 = props.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(props, "href" in props ? e2 : e2);
      }, [props.onClick, innerLoading, mergedDisabled]);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const sizeClassNameMap = {
        large: "lg",
        small: "sm",
        middle: void 0
      };
      const sizeFullName = useSize((ctxSize) => {
        var _a2, _b2;
        return (_b2 = (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : groupSize) !== null && _b2 !== void 0 ? _b2 : ctxSize;
      });
      const sizeCls = sizeFullName ? (_b = sizeClassNameMap[sizeFullName]) !== null && _b !== void 0 ? _b : "" : "";
      const iconType = innerLoading ? "loading" : icon;
      const linkButtonRestProps = omit(rest, ["navigate"]);
      const classes = classNames(prefixCls, hashId, cssVarCls, {
        [`${prefixCls}-${shape}`]: shape !== "default" && shape,
        // line(253 - 254): Compatible with versions earlier than 5.21.0
        [`${prefixCls}-${mergedType}`]: mergedType,
        [`${prefixCls}-dangerous`]: danger,
        [`${prefixCls}-color-${mergedColorText}`]: mergedColorText,
        [`${prefixCls}-variant-${mergedVariant}`]: mergedVariant,
        [`${prefixCls}-${sizeCls}`]: sizeCls,
        [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
        [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonVariant(mergedVariant),
        [`${prefixCls}-loading`]: innerLoading,
        [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && mergedInsertSpace && !innerLoading,
        [`${prefixCls}-block`]: block,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-icon-end`]: iconPosition === "end"
      }, compactItemClassnames, className, rootClassName, contextClassName);
      const fullStyle = Object.assign(Object.assign({}, contextStyle), customStyle);
      const iconClasses = classNames(customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.icon, contextClassNames.icon);
      const iconStyle = Object.assign(Object.assign({}, (styles === null || styles === void 0 ? void 0 : styles.icon) || {}), contextStyles.icon || {});
      const iconNode = icon && !innerLoading ? /* @__PURE__ */ i.createElement(IconWrapper, {
        prefixCls,
        className: iconClasses,
        style: iconStyle
      }, icon) : loading && typeof loading === "object" && loading.icon ? /* @__PURE__ */ i.createElement(IconWrapper, {
        prefixCls,
        className: iconClasses,
        style: iconStyle
      }, loading.icon) : /* @__PURE__ */ i.createElement(DefaultLoadingIcon, {
        existIcon: !!icon,
        prefixCls,
        loading: innerLoading,
        mount: isMountRef.current
      });
      const kids = children || children === 0 ? spaceChildren(children, needInserted && mergedInsertSpace) : null;
      if (linkButtonRestProps.href !== void 0) {
        return wrapCSSVar(/* @__PURE__ */ i.createElement("a", Object.assign({}, linkButtonRestProps, {
          className: classNames(classes, {
            [`${prefixCls}-disabled`]: mergedDisabled
          }),
          href: mergedDisabled ? void 0 : linkButtonRestProps.href,
          style: fullStyle,
          onClick: handleClick,
          ref: mergedRef,
          tabIndex: mergedDisabled ? -1 : 0
        }), iconNode, kids));
      }
      let buttonNode = /* @__PURE__ */ i.createElement("button", Object.assign({}, rest, {
        type: htmlType,
        className: classes,
        style: fullStyle,
        onClick: handleClick,
        disabled: mergedDisabled,
        ref: mergedRef
      }), iconNode, kids, compactItemClassnames && /* @__PURE__ */ i.createElement(Compact, {
        prefixCls
      }));
      if (!isUnBorderedButtonVariant(mergedVariant)) {
        buttonNode = /* @__PURE__ */ i.createElement(Wave, {
          component: "Button",
          disabled: innerLoading
        }, buttonNode);
      }
      return wrapCSSVar(buttonNode);
    });
    const Button$1 = InternalCompoundedButton;
    Button$1.Group = ButtonGroup;
    Button$1.__ANT_BUTTON = true;
    function isThenable(thing) {
      return !!(thing === null || thing === void 0 ? void 0 : thing.then);
    }
    const ActionButton = (props) => {
      const {
        type: type2,
        children,
        prefixCls,
        buttonProps,
        close,
        autoFocus,
        emitEvent,
        isSilent,
        quitOnNullishReturnValue,
        actionFn
      } = props;
      const clickedRef = reactExports.useRef(false);
      const buttonRef = reactExports.useRef(null);
      const [loading, setLoading] = useSafeState(false);
      const onInternalClose = function() {
        close === null || close === void 0 ? void 0 : close.apply(void 0, arguments);
      };
      reactExports.useEffect(() => {
        let timeoutId = null;
        if (autoFocus) {
          timeoutId = setTimeout(() => {
            var _a;
            (_a = buttonRef.current) === null || _a === void 0 ? void 0 : _a.focus({
              preventScroll: true
            });
          });
        }
        return () => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
        };
      }, []);
      const handlePromiseOnOk = (returnValueOfOnOk) => {
        if (!isThenable(returnValueOfOnOk)) {
          return;
        }
        setLoading(true);
        returnValueOfOnOk.then(function() {
          setLoading(false, true);
          onInternalClose.apply(void 0, arguments);
          clickedRef.current = false;
        }, (e2) => {
          setLoading(false, true);
          clickedRef.current = false;
          if (isSilent === null || isSilent === void 0 ? void 0 : isSilent()) {
            return;
          }
          return Promise.reject(e2);
        });
      };
      const onClick = (e2) => {
        if (clickedRef.current) {
          return;
        }
        clickedRef.current = true;
        if (!actionFn) {
          onInternalClose();
          return;
        }
        let returnValueOfOnOk;
        if (emitEvent) {
          returnValueOfOnOk = actionFn(e2);
          if (quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
            clickedRef.current = false;
            onInternalClose(e2);
            return;
          }
        } else if (actionFn.length) {
          returnValueOfOnOk = actionFn(close);
          clickedRef.current = false;
        } else {
          returnValueOfOnOk = actionFn();
          if (!isThenable(returnValueOfOnOk)) {
            onInternalClose();
            return;
          }
        }
        handlePromiseOnOk(returnValueOfOnOk);
      };
      return /* @__PURE__ */ reactExports.createElement(Button$1, Object.assign({}, convertLegacyProps(type2), {
        onClick,
        loading,
        prefixCls
      }, buttonProps, {
        ref: buttonRef
      }), children);
    };
    const ModalContext = /* @__PURE__ */ i.createContext({});
    const {
      Provider: ModalContextProvider
    } = ModalContext;
    const ConfirmCancelBtn = () => {
      const {
        autoFocusButton,
        cancelButtonProps,
        cancelTextLocale,
        isSilent,
        mergedOkCancel,
        rootPrefixCls,
        close,
        onCancel,
        onConfirm
      } = reactExports.useContext(ModalContext);
      return mergedOkCancel ? /* @__PURE__ */ i.createElement(ActionButton, {
        isSilent,
        actionFn: onCancel,
        close: function() {
          close === null || close === void 0 ? void 0 : close.apply(void 0, arguments);
          onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(false);
        },
        autoFocus: autoFocusButton === "cancel",
        buttonProps: cancelButtonProps,
        prefixCls: `${rootPrefixCls}-btn`
      }, cancelTextLocale) : null;
    };
    const ConfirmOkBtn = () => {
      const {
        autoFocusButton,
        close,
        isSilent,
        okButtonProps,
        rootPrefixCls,
        okTextLocale,
        okType,
        onConfirm,
        onOk
      } = reactExports.useContext(ModalContext);
      return /* @__PURE__ */ i.createElement(ActionButton, {
        isSilent,
        type: okType || "primary",
        actionFn: onOk,
        close: function() {
          close === null || close === void 0 ? void 0 : close.apply(void 0, arguments);
          onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(true);
        },
        autoFocus: autoFocusButton === "ok",
        buttonProps: okButtonProps,
        prefixCls: `${rootPrefixCls}-btn`
      }, okTextLocale);
    };
    var OrderContext = /* @__PURE__ */ reactExports.createContext(null);
    var EMPTY_LIST$3 = [];
    function useDom(render2, debug) {
      var _React$useState = reactExports.useState(function() {
        if (!canUseDom$2()) {
          return null;
        }
        var defaultEle = document.createElement("div");
        return defaultEle;
      }), _React$useState2 = _slicedToArray(_React$useState, 1), ele = _React$useState2[0];
      var appendedRef = reactExports.useRef(false);
      var queueCreate = reactExports.useContext(OrderContext);
      var _React$useState3 = reactExports.useState(EMPTY_LIST$3), _React$useState4 = _slicedToArray(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1];
      var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
        setQueue(function(origin) {
          var newQueue = [appendFn].concat(_toConsumableArray(origin));
          return newQueue;
        });
      });
      function append2() {
        if (!ele.parentElement) {
          document.body.appendChild(ele);
        }
        appendedRef.current = true;
      }
      function cleanup2() {
        var _ele$parentElement;
        (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
        appendedRef.current = false;
      }
      useLayoutEffect$1(function() {
        if (render2) {
          if (queueCreate) {
            queueCreate(append2);
          } else {
            append2();
          }
        } else {
          cleanup2();
        }
        return cleanup2;
      }, [render2]);
      useLayoutEffect$1(function() {
        if (queue.length) {
          queue.forEach(function(appendFn) {
            return appendFn();
          });
          setQueue(EMPTY_LIST$3);
        }
      }, [queue]);
      return [ele, mergedQueueCreate];
    }
    function measureScrollbarSize(ele) {
      var randomId = "rc-scrollbar-measure-".concat(Math.random().toString(36).substring(7));
      var measureEle = document.createElement("div");
      measureEle.id = randomId;
      var measureStyle = measureEle.style;
      measureStyle.position = "absolute";
      measureStyle.left = "0";
      measureStyle.top = "0";
      measureStyle.width = "100px";
      measureStyle.height = "100px";
      measureStyle.overflow = "scroll";
      var fallbackWidth;
      var fallbackHeight;
      if (ele) {
        var targetStyle = getComputedStyle(ele);
        measureStyle.scrollbarColor = targetStyle.scrollbarColor;
        measureStyle.scrollbarWidth = targetStyle.scrollbarWidth;
        var webkitScrollbarStyle = getComputedStyle(ele, "::-webkit-scrollbar");
        var width = parseInt(webkitScrollbarStyle.width, 10);
        var height = parseInt(webkitScrollbarStyle.height, 10);
        try {
          var widthStyle = width ? "width: ".concat(webkitScrollbarStyle.width, ";") : "";
          var heightStyle = height ? "height: ".concat(webkitScrollbarStyle.height, ";") : "";
          updateCSS$1("\n#".concat(randomId, "::-webkit-scrollbar {\n").concat(widthStyle, "\n").concat(heightStyle, "\n}"), randomId);
        } catch (e2) {
          console.error(e2);
          fallbackWidth = width;
          fallbackHeight = height;
        }
      }
      document.body.appendChild(measureEle);
      var scrollWidth = ele && fallbackWidth && !isNaN(fallbackWidth) ? fallbackWidth : measureEle.offsetWidth - measureEle.clientWidth;
      var scrollHeight = ele && fallbackHeight && !isNaN(fallbackHeight) ? fallbackHeight : measureEle.offsetHeight - measureEle.clientHeight;
      document.body.removeChild(measureEle);
      removeCSS$1(randomId);
      return {
        width: scrollWidth,
        height: scrollHeight
      };
    }
    function getTargetScrollBarSize(target) {
      if (typeof document === "undefined" || !target || !(target instanceof Element)) {
        return {
          width: 0,
          height: 0
        };
      }
      return measureScrollbarSize(target);
    }
    function isBodyOverflowing() {
      return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
    }
    var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
    var uuid$4 = 0;
    function useScrollLocker(lock) {
      var mergedLock = !!lock;
      var _React$useState = reactExports.useState(function() {
        uuid$4 += 1;
        return "".concat(UNIQUE_ID, "_").concat(uuid$4);
      }), _React$useState2 = _slicedToArray(_React$useState, 1), id = _React$useState2[0];
      useLayoutEffect$1(function() {
        if (mergedLock) {
          var scrollbarSize = getTargetScrollBarSize(document.body).width;
          var isOverflow = isBodyOverflowing();
          updateCSS$1("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id);
        } else {
          removeCSS$1(id);
        }
        return function() {
          removeCSS$1(id);
        };
      }, [mergedLock, id]);
    }
    var inline = false;
    function inlineMock(nextInline) {
      return inline;
    }
    var getPortalContainer = function getPortalContainer2(getContainer2) {
      if (getContainer2 === false) {
        return false;
      }
      if (!canUseDom$2() || !getContainer2) {
        return null;
      }
      if (typeof getContainer2 === "string") {
        return document.querySelector(getContainer2);
      }
      if (typeof getContainer2 === "function") {
        return getContainer2();
      }
      return getContainer2;
    };
    var Portal = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var open2 = props.open, autoLock = props.autoLock, getContainer2 = props.getContainer;
      props.debug;
      var _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
      var _React$useState = reactExports.useState(open2), _React$useState2 = _slicedToArray(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
      var mergedRender = shouldRender || open2;
      reactExports.useEffect(function() {
        if (autoDestroy || open2) {
          setShouldRender(open2);
        }
      }, [open2, autoDestroy]);
      var _React$useState3 = reactExports.useState(function() {
        return getPortalContainer(getContainer2);
      }), _React$useState4 = _slicedToArray(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
      reactExports.useEffect(function() {
        var customizeContainer = getPortalContainer(getContainer2);
        setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
      });
      var _useDom = useDom(mergedRender && !innerContainer), _useDom2 = _slicedToArray(_useDom, 2), defaultContainer = _useDom2[0], queueCreate = _useDom2[1];
      var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer;
      useScrollLocker(autoLock && open2 && canUseDom$2() && (mergedContainer === defaultContainer || mergedContainer === document.body));
      var childRef = null;
      if (children && supportRef(children) && ref) {
        var _ref = children;
        childRef = _ref.ref;
      }
      var mergedRef = useComposeRef(childRef, ref);
      if (!mergedRender || !canUseDom$2() || innerContainer === void 0) {
        return null;
      }
      var renderInline = mergedContainer === false || inlineMock();
      var reffedChildren = children;
      if (ref) {
        reffedChildren = /* @__PURE__ */ reactExports.cloneElement(children, {
          ref: mergedRef
        });
      }
      return /* @__PURE__ */ reactExports.createElement(OrderContext.Provider, {
        value: queueCreate
      }, renderInline ? reffedChildren : /* @__PURE__ */ reactDomExports.createPortal(reffedChildren, mergedContainer));
    });
    var RefContext = /* @__PURE__ */ reactExports.createContext({});
    function getUseId() {
      var fullClone2 = _objectSpread2$3({}, React$5);
      return fullClone2.useId;
    }
    var uuid$3 = 0;
    var useOriginId = getUseId();
    const useId$1 = useOriginId ? (
      // Use React `useId`
      function useId2(id) {
        var reactId = useOriginId();
        if (id) {
          return id;
        }
        return reactId;
      }
    ) : (
      // Use compatible of `useId`
      function useCompatId(id) {
        var _React$useState = reactExports.useState("ssr-id"), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
        reactExports.useEffect(function() {
          var nextId = uuid$3;
          uuid$3 += 1;
          setInnerId("rc_unique_".concat(nextId));
        }, []);
        if (id) {
          return id;
        }
        return innerId;
      }
    );
    function getMotionName(prefixCls, transitionName, animationName) {
      var motionName = transitionName;
      if (!motionName && animationName) {
        motionName = "".concat(prefixCls, "-").concat(animationName);
      }
      return motionName;
    }
    function getScroll$1(w2, top) {
      var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
      var method2 = "scroll".concat(top ? "Top" : "Left");
      if (typeof ret !== "number") {
        var d2 = w2.document;
        ret = d2.documentElement[method2];
        if (typeof ret !== "number") {
          ret = d2.body[method2];
        }
      }
      return ret;
    }
    function offset(el) {
      var rect = el.getBoundingClientRect();
      var pos = {
        left: rect.left,
        top: rect.top
      };
      var doc = el.ownerDocument;
      var w2 = doc.defaultView || doc.parentWindow;
      pos.left += getScroll$1(w2);
      pos.top += getScroll$1(w2, true);
      return pos;
    }
    const MemoChildren = /* @__PURE__ */ reactExports.memo(function(_ref) {
      var children = _ref.children;
      return children;
    }, function(_2, _ref2) {
      var shouldUpdate = _ref2.shouldUpdate;
      return !shouldUpdate;
    });
    var sentinelStyle = {
      width: 0,
      height: 0,
      overflow: "hidden",
      outline: "none"
    };
    var entityStyle = {
      outline: "none"
    };
    var Panel$1 = /* @__PURE__ */ i.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, className = props.className, style2 = props.style, title = props.title, ariaId = props.ariaId, footer = props.footer, closable = props.closable, closeIcon = props.closeIcon, onClose = props.onClose, children = props.children, bodyStyle = props.bodyStyle, bodyProps = props.bodyProps, modalRender = props.modalRender, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, holderRef = props.holderRef, visible = props.visible, forceRender = props.forceRender, width = props.width, height = props.height, modalClassNames = props.classNames, modalStyles = props.styles;
      var _React$useContext = i.useContext(RefContext), panelRef = _React$useContext.panel;
      var mergedRef = useComposeRef(holderRef, panelRef);
      var sentinelStartRef = reactExports.useRef();
      var sentinelEndRef = reactExports.useRef();
      i.useImperativeHandle(ref, function() {
        return {
          focus: function focus() {
            var _sentinelStartRef$cur;
            (_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 || _sentinelStartRef$cur.focus({
              preventScroll: true
            });
          },
          changeActive: function changeActive(next2) {
            var _document = document, activeElement2 = _document.activeElement;
            if (next2 && activeElement2 === sentinelEndRef.current) {
              sentinelStartRef.current.focus({
                preventScroll: true
              });
            } else if (!next2 && activeElement2 === sentinelStartRef.current) {
              sentinelEndRef.current.focus({
                preventScroll: true
              });
            }
          }
        };
      });
      var contentStyle = {};
      if (width !== void 0) {
        contentStyle.width = width;
      }
      if (height !== void 0) {
        contentStyle.height = height;
      }
      var footerNode = footer ? /* @__PURE__ */ i.createElement("div", {
        className: classNames("".concat(prefixCls, "-footer"), modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.footer),
        style: _objectSpread2$3({}, modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.footer)
      }, footer) : null;
      var headerNode = title ? /* @__PURE__ */ i.createElement("div", {
        className: classNames("".concat(prefixCls, "-header"), modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.header),
        style: _objectSpread2$3({}, modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.header)
      }, /* @__PURE__ */ i.createElement("div", {
        className: "".concat(prefixCls, "-title"),
        id: ariaId
      }, title)) : null;
      var closableObj = reactExports.useMemo(function() {
        if (_typeof$1(closable) === "object" && closable !== null) {
          return closable;
        }
        if (closable) {
          return {
            closeIcon: closeIcon !== null && closeIcon !== void 0 ? closeIcon : /* @__PURE__ */ i.createElement("span", {
              className: "".concat(prefixCls, "-close-x")
            })
          };
        }
        return {};
      }, [closable, closeIcon, prefixCls]);
      var ariaProps = pickAttrs(closableObj, true);
      var closeBtnIsDisabled = _typeof$1(closable) === "object" && closable.disabled;
      var closerNode = closable ? /* @__PURE__ */ i.createElement("button", _extends$2({
        type: "button",
        onClick: onClose,
        "aria-label": "Close"
      }, ariaProps, {
        className: "".concat(prefixCls, "-close"),
        disabled: closeBtnIsDisabled
      }), closableObj.closeIcon) : null;
      var content = /* @__PURE__ */ i.createElement("div", {
        className: classNames("".concat(prefixCls, "-content"), modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.content),
        style: modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.content
      }, closerNode, headerNode, /* @__PURE__ */ i.createElement("div", _extends$2({
        className: classNames("".concat(prefixCls, "-body"), modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.body),
        style: _objectSpread2$3(_objectSpread2$3({}, bodyStyle), modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.body)
      }, bodyProps), children), footerNode);
      return /* @__PURE__ */ i.createElement("div", {
        key: "dialog-element",
        role: "dialog",
        "aria-labelledby": title ? ariaId : null,
        "aria-modal": "true",
        ref: mergedRef,
        style: _objectSpread2$3(_objectSpread2$3({}, style2), contentStyle),
        className: classNames(prefixCls, className),
        onMouseDown,
        onMouseUp
      }, /* @__PURE__ */ i.createElement("div", {
        ref: sentinelStartRef,
        tabIndex: 0,
        style: entityStyle
      }, /* @__PURE__ */ i.createElement(MemoChildren, {
        shouldUpdate: visible || forceRender
      }, modalRender ? modalRender(content) : content)), /* @__PURE__ */ i.createElement("div", {
        tabIndex: 0,
        ref: sentinelEndRef,
        style: sentinelStyle
      }));
    });
    var Content$1 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, title = props.title, style2 = props.style, className = props.className, visible = props.visible, forceRender = props.forceRender, destroyOnClose = props.destroyOnClose, motionName = props.motionName, ariaId = props.ariaId, onVisibleChanged = props.onVisibleChanged, mousePosition2 = props.mousePosition;
      var dialogRef = reactExports.useRef();
      var _React$useState = reactExports.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), transformOrigin = _React$useState2[0], setTransformOrigin = _React$useState2[1];
      var contentStyle = {};
      if (transformOrigin) {
        contentStyle.transformOrigin = transformOrigin;
      }
      function onPrepare() {
        var elementOffset = offset(dialogRef.current);
        setTransformOrigin(mousePosition2 && (mousePosition2.x || mousePosition2.y) ? "".concat(mousePosition2.x - elementOffset.left, "px ").concat(mousePosition2.y - elementOffset.top, "px") : "");
      }
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, {
        visible,
        onVisibleChanged,
        onAppearPrepare: onPrepare,
        onEnterPrepare: onPrepare,
        forceRender,
        motionName,
        removeOnLeave: destroyOnClose,
        ref: dialogRef
      }, function(_ref, motionRef) {
        var motionClassName = _ref.className, motionStyle = _ref.style;
        return /* @__PURE__ */ reactExports.createElement(Panel$1, _extends$2({}, props, {
          ref,
          title,
          ariaId,
          prefixCls,
          holderRef: motionRef,
          style: _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({}, motionStyle), style2), contentStyle),
          className: classNames(className, motionClassName)
        }));
      });
    });
    Content$1.displayName = "Content";
    var Mask$1 = function Mask2(props) {
      var prefixCls = props.prefixCls, style2 = props.style, visible = props.visible, maskProps = props.maskProps, motionName = props.motionName, className = props.className;
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, {
        key: "mask",
        visible,
        motionName,
        leavedClassName: "".concat(prefixCls, "-mask-hidden")
      }, function(_ref, ref) {
        var motionClassName = _ref.className, motionStyle = _ref.style;
        return /* @__PURE__ */ reactExports.createElement("div", _extends$2({
          ref,
          style: _objectSpread2$3(_objectSpread2$3({}, motionStyle), style2),
          className: classNames("".concat(prefixCls, "-mask"), motionClassName, className)
        }, maskProps));
      });
    };
    var Dialog = function Dialog2(props) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dialog" : _props$prefixCls, zIndex = props.zIndex, _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$focusTriggerAf = props.focusTriggerAfterClose, focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf, wrapStyle = props.wrapStyle, wrapClassName = props.wrapClassName, wrapProps = props.wrapProps, onClose = props.onClose, afterOpenChange = props.afterOpenChange, afterClose = props.afterClose, transitionName = props.transitionName, animation = props.animation, _props$closable = props.closable, closable = _props$closable === void 0 ? true : _props$closable, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, maskStyle = props.maskStyle, maskProps = props.maskProps, rootClassName = props.rootClassName, modalClassNames = props.classNames, modalStyles = props.styles;
      var lastOutSideActiveElementRef = reactExports.useRef();
      var wrapperRef = reactExports.useRef();
      var contentRef = reactExports.useRef();
      var _React$useState = reactExports.useState(visible), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
      var ariaId = useId$1();
      function saveLastOutSideActiveElementRef() {
        if (!contains$2(wrapperRef.current, document.activeElement)) {
          lastOutSideActiveElementRef.current = document.activeElement;
        }
      }
      function focusDialogContent() {
        if (!contains$2(wrapperRef.current, document.activeElement)) {
          var _contentRef$current;
          (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();
        }
      }
      function onDialogVisibleChanged(newVisible) {
        if (newVisible) {
          focusDialogContent();
        } else {
          setAnimatedVisible(false);
          if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
            try {
              lastOutSideActiveElementRef.current.focus({
                preventScroll: true
              });
            } catch (e2) {
            }
            lastOutSideActiveElementRef.current = null;
          }
          if (animatedVisible) {
            afterClose === null || afterClose === void 0 || afterClose();
          }
        }
        afterOpenChange === null || afterOpenChange === void 0 || afterOpenChange(newVisible);
      }
      function onInternalClose(e2) {
        onClose === null || onClose === void 0 || onClose(e2);
      }
      var contentClickRef = reactExports.useRef(false);
      var contentTimeoutRef = reactExports.useRef();
      var onContentMouseDown = function onContentMouseDown2() {
        clearTimeout(contentTimeoutRef.current);
        contentClickRef.current = true;
      };
      var onContentMouseUp = function onContentMouseUp2() {
        contentTimeoutRef.current = setTimeout(function() {
          contentClickRef.current = false;
        });
      };
      var onWrapperClick = null;
      if (maskClosable) {
        onWrapperClick = function onWrapperClick2(e2) {
          if (contentClickRef.current) {
            contentClickRef.current = false;
          } else if (wrapperRef.current === e2.target) {
            onInternalClose(e2);
          }
        };
      }
      function onWrapperKeyDown(e2) {
        if (keyboard && e2.keyCode === KeyCode.ESC) {
          e2.stopPropagation();
          onInternalClose(e2);
          return;
        }
        if (visible && e2.keyCode === KeyCode.TAB) {
          contentRef.current.changeActive(!e2.shiftKey);
        }
      }
      reactExports.useEffect(function() {
        if (visible) {
          setAnimatedVisible(true);
          saveLastOutSideActiveElementRef();
        }
      }, [visible]);
      reactExports.useEffect(function() {
        return function() {
          clearTimeout(contentTimeoutRef.current);
        };
      }, []);
      var mergedStyle = _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({
        zIndex
      }, wrapStyle), modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.wrapper), {}, {
        display: !animatedVisible ? "none" : null
      });
      return /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        className: classNames("".concat(prefixCls, "-root"), rootClassName)
      }, pickAttrs(props, {
        data: true
      })), /* @__PURE__ */ reactExports.createElement(Mask$1, {
        prefixCls,
        visible: mask && visible,
        motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
        style: _objectSpread2$3(_objectSpread2$3({
          zIndex
        }, maskStyle), modalStyles === null || modalStyles === void 0 ? void 0 : modalStyles.mask),
        maskProps,
        className: modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.mask
      }), /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        tabIndex: -1,
        onKeyDown: onWrapperKeyDown,
        className: classNames("".concat(prefixCls, "-wrap"), wrapClassName, modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.wrapper),
        ref: wrapperRef,
        onClick: onWrapperClick,
        style: mergedStyle
      }, wrapProps), /* @__PURE__ */ reactExports.createElement(Content$1, _extends$2({}, props, {
        onMouseDown: onContentMouseDown,
        onMouseUp: onContentMouseUp,
        ref: contentRef,
        closable,
        ariaId,
        prefixCls,
        visible: visible && animatedVisible,
        onClose: onInternalClose,
        onVisibleChanged: onDialogVisibleChanged,
        motionName: getMotionName(prefixCls, transitionName, animation)
      }))));
    };
    var DialogWrap = function DialogWrap2(props) {
      var visible = props.visible, getContainer2 = props.getContainer, forceRender = props.forceRender, _props$destroyOnClose = props.destroyOnClose, destroyOnClose = _props$destroyOnClose === void 0 ? false : _props$destroyOnClose, _afterClose = props.afterClose, panelRef = props.panelRef;
      var _React$useState = reactExports.useState(visible), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
      var refContext = reactExports.useMemo(function() {
        return {
          panel: panelRef
        };
      }, [panelRef]);
      reactExports.useEffect(function() {
        if (visible) {
          setAnimatedVisible(true);
        }
      }, [visible]);
      if (!forceRender && destroyOnClose && !animatedVisible) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(RefContext.Provider, {
        value: refContext
      }, /* @__PURE__ */ reactExports.createElement(Portal, {
        open: visible || forceRender || animatedVisible,
        autoDestroy: false,
        getContainer: getContainer2,
        autoLock: visible || animatedVisible
      }, /* @__PURE__ */ reactExports.createElement(Dialog, _extends$2({}, props, {
        destroyOnClose,
        afterClose: function afterClose() {
          _afterClose === null || _afterClose === void 0 || _afterClose();
          setAnimatedVisible(false);
        }
      }))));
    };
    DialogWrap.displayName = "Dialog";
    var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
    var warningFunc = function warningFunc2() {
      warningOnce$1(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
    };
    var Context$1 = /* @__PURE__ */ reactExports.createContext({
      getFieldValue: warningFunc,
      getFieldsValue: warningFunc,
      getFieldError: warningFunc,
      getFieldWarning: warningFunc,
      getFieldsError: warningFunc,
      isFieldsTouched: warningFunc,
      isFieldTouched: warningFunc,
      isFieldValidating: warningFunc,
      isFieldsValidating: warningFunc,
      resetFields: warningFunc,
      setFields: warningFunc,
      setFieldValue: warningFunc,
      setFieldsValue: warningFunc,
      validateFields: warningFunc,
      submit: warningFunc,
      getInternalHooks: function getInternalHooks() {
        warningFunc();
        return {
          dispatch: warningFunc,
          initEntityValue: warningFunc,
          registerField: warningFunc,
          useSubscribe: warningFunc,
          setInitialValues: warningFunc,
          destroyForm: warningFunc,
          setCallbacks: warningFunc,
          registerWatch: warningFunc,
          getFields: warningFunc,
          setValidateMessages: warningFunc,
          setPreserve: warningFunc,
          getInitialValue: warningFunc
        };
      }
    });
    var ListContext$1 = /* @__PURE__ */ reactExports.createContext(null);
    function toArray$4(value) {
      if (value === void 0 || value === null) {
        return [];
      }
      return Array.isArray(value) ? value : [value];
    }
    function isFormInstance(form) {
      return form && !!form._init;
    }
    function newMessages() {
      return {
        default: "Validation error on field %s",
        required: "%s is required",
        enum: "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
          format: "%s date %s is invalid for format %s",
          parse: "%s date could not be parsed, %s is invalid ",
          invalid: "%s date %s is invalid"
        },
        types: {
          string: "%s is not a %s",
          method: "%s is not a %s (function)",
          array: "%s is not an %s",
          object: "%s is not an %s",
          number: "%s is not a %s",
          date: "%s is not a %s",
          boolean: "%s is not a %s",
          integer: "%s is not an %s",
          float: "%s is not a %s",
          regexp: "%s is not a valid %s",
          email: "%s is not a valid %s",
          url: "%s is not a valid %s",
          hex: "%s is not a valid %s"
        },
        string: {
          len: "%s must be exactly %s characters",
          min: "%s must be at least %s characters",
          max: "%s cannot be longer than %s characters",
          range: "%s must be between %s and %s characters"
        },
        number: {
          len: "%s must equal %s",
          min: "%s cannot be less than %s",
          max: "%s cannot be greater than %s",
          range: "%s must be between %s and %s"
        },
        array: {
          len: "%s must be exactly %s in length",
          min: "%s cannot be less than %s in length",
          max: "%s cannot be greater than %s in length",
          range: "%s must be between %s and %s in length"
        },
        pattern: {
          mismatch: "%s value %s does not match pattern %s"
        },
        clone: function clone2() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();
    function _isNativeFunction(t2) {
      try {
        return -1 !== Function.toString.call(t2).indexOf("[native code]");
      } catch (n2) {
        return "function" == typeof t2;
      }
    }
    function _construct(t2, e2, r2) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o2 = [null];
      o2.push.apply(o2, e2);
      var p2 = new (t2.bind.apply(t2, o2))();
      return r2 && _setPrototypeOf(p2, r2.prototype), p2;
    }
    function _wrapNativeSuper(t2) {
      var r2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper2(t3) {
        if (null === t3 || !_isNativeFunction(t3)) return t3;
        if ("function" != typeof t3) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r2) {
          if (r2.has(t3)) return r2.get(t3);
          r2.set(t3, Wrapper2);
        }
        function Wrapper2() {
          return _construct(t3, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper2.prototype = Object.create(t3.prototype, {
          constructor: {
            value: Wrapper2,
            enumerable: false,
            writable: true,
            configurable: true
          }
        }), _setPrototypeOf(Wrapper2, t3);
      }, _wrapNativeSuper(t2);
    }
    var formatRegExp = /%[sdj%]/g;
    var warning$3 = function warning2() {
    };
    function convertFieldsError(errors) {
      if (!errors || !errors.length) return null;
      var fields = {};
      errors.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format$1(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i2 = 0;
      var len = args.length;
      if (typeof template === "function") {
        return template.apply(null, args);
      }
      if (typeof template === "string") {
        var str = template.replace(formatRegExp, function(x2) {
          if (x2 === "%%") {
            return "%";
          }
          if (i2 >= len) {
            return x2;
          }
          switch (x2) {
            case "%s":
              return String(args[i2++]);
            case "%d":
              return Number(args[i2++]);
            case "%j":
              try {
                return JSON.stringify(args[i2++]);
              } catch (_2) {
                return "[Circular]";
              }
              break;
            default:
              return x2;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type2) {
      return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
    }
    function isEmptyValue(value, type2) {
      if (value === void 0 || value === null) {
        return true;
      }
      if (type2 === "array" && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type2) && typeof value === "string" && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;
      function count(errors) {
        results.push.apply(results, _toConsumableArray(errors || []));
        total++;
        if (total === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function(a) {
        func(a, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index2 = 0;
      var arrLength = arr.length;
      function next2(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }
        var original = index2;
        index2 = index2 + 1;
        if (original < arrLength) {
          func(arr[original], next2);
        } else {
          callback([]);
        }
      }
      next2([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function(k2) {
        ret.push.apply(ret, _toConsumableArray(objArr[k2] || []));
      });
      return ret;
    }
    var AsyncValidationError = /* @__PURE__ */ function(_Error) {
      _inherits(AsyncValidationError2, _Error);
      var _super = _createSuper(AsyncValidationError2);
      function AsyncValidationError2(errors, fields) {
        var _this;
        _classCallCheck(this, AsyncValidationError2);
        _this = _super.call(this, "Async Validation Error");
        _defineProperty(_assertThisInitialized(_this), "errors", void 0);
        _defineProperty(_assertThisInitialized(_this), "fields", void 0);
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }
      return _createClass(AsyncValidationError2);
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function(resolve, reject) {
          var next2 = function next22(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next2);
        });
        _pending.catch(function(e2) {
          return e2;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function(resolve, reject) {
        var next2 = function next22(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve(source);
        }
        objArrKeys.forEach(function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next2);
          } else {
            asyncParallelArray(arr, func, next2);
          }
        });
      });
      pending.catch(function(e2) {
        return e2;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== void 0);
    }
    function getValue$1(value, path2) {
      var v2 = value;
      for (var i2 = 0; i2 < path2.length; i2++) {
        if (v2 == void 0) {
          return v2;
        }
        v2 = v2[path2[i2]];
      }
      return v2;
    }
    function complementError(rule, source) {
      return function(oe2) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue$1(source, rule.fullFields);
        } else {
          fieldValue = source[oe2.field || rule.fullField];
        }
        if (isErrorObj(oe2)) {
          oe2.field = oe2.field || rule.fullField;
          oe2.fieldValue = fieldValue;
          return oe2;
        }
        return {
          message: typeof oe2 === "function" ? oe2() : oe2,
          fieldValue,
          field: oe2.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s in source) {
          if (source.hasOwnProperty(s)) {
            var value = source[s];
            if (_typeof$1(value) === "object" && _typeof$1(target[s]) === "object") {
              target[s] = _objectSpread2$3(_objectSpread2$3({}, target[s]), value);
            } else {
              target[s] = value;
            }
          }
        }
      }
      return target;
    }
    var ENUM$1 = "enum";
    var enumerable$1 = function enumerable2(rule, value, source, errors, options2) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format$1(options2.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
      }
    };
    var pattern$2 = function pattern2(rule, value, source, errors, options2) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors.push(format$1(options2.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === "string") {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors.push(format$1(options2.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };
    var range = function range2(rule, value, source, errors, options2) {
      var len = typeof rule.len === "number";
      var min = typeof rule.min === "number";
      var max = typeof rule.max === "number";
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === "number";
      var str = typeof value === "string";
      var arr = Array.isArray(value);
      if (num) {
        key = "number";
      } else if (str) {
        key = "string";
      } else if (arr) {
        key = "array";
      }
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        val = value.replace(spRegexp, "_").length;
      }
      if (len) {
        if (val !== rule.len) {
          errors.push(format$1(options2.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min && !max && val < rule.min) {
        errors.push(format$1(options2.messages[key].min, rule.fullField, rule.min));
      } else if (max && !min && val > rule.max) {
        errors.push(format$1(options2.messages[key].max, rule.fullField, rule.max));
      } else if (min && max && (val < rule.min || val > rule.max)) {
        errors.push(format$1(options2.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };
    var required$1 = function required2(rule, value, source, errors, options2, type2) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type2 || rule.type))) {
        errors.push(format$1(options2.messages.required, rule.fullField));
      }
    };
    var urlReg;
    const getUrlRegex = function() {
      if (urlReg) {
        return urlReg;
      }
      var word = "[a-fA-F\\d:]";
      var b2 = function b3(options2) {
        return options2 && options2.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(word, ")|(?<=").concat(word, ")(?=\\s|$))") : "";
      };
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6List = [
        "(?:".concat(v6seg, ":){7}(?:").concat(v6seg, "|:)"),
        // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
        "(?:".concat(v6seg, ":){6}(?:").concat(v4, "|:").concat(v6seg, "|:)"),
        // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::
        "(?:".concat(v6seg, ":){5}(?::").concat(v4, "|(?::").concat(v6seg, "){1,2}|:)"),
        // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::
        "(?:".concat(v6seg, ":){4}(?:(?::").concat(v6seg, "){0,1}:").concat(v4, "|(?::").concat(v6seg, "){1,3}|:)"),
        // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::
        "(?:".concat(v6seg, ":){3}(?:(?::").concat(v6seg, "){0,2}:").concat(v4, "|(?::").concat(v6seg, "){1,4}|:)"),
        // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::
        "(?:".concat(v6seg, ":){2}(?:(?::").concat(v6seg, "){0,3}:").concat(v4, "|(?::").concat(v6seg, "){1,5}|:)"),
        // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::
        "(?:".concat(v6seg, ":){1}(?:(?::").concat(v6seg, "){0,4}:").concat(v4, "|(?::").concat(v6seg, "){1,6}|:)"),
        // 1::              1::3:4:5:6:7:8   1::8            1::
        "(?::(?:(?::".concat(v6seg, "){0,5}:").concat(v4, "|(?::").concat(v6seg, "){1,7}|:))")
        // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::
      ];
      var v6Eth0 = "(?:%[0-9a-zA-Z]{1,})?";
      var v6 = "(?:".concat(v6List.join("|"), ")").concat(v6Eth0);
      var v46Exact = new RegExp("(?:^".concat(v4, "$)|(?:^").concat(v6, "$)"));
      var v4exact = new RegExp("^".concat(v4, "$"));
      var v6exact = new RegExp("^".concat(v6, "$"));
      var ip = function ip2(options2) {
        return options2 && options2.exact ? v46Exact : new RegExp("(?:".concat(b2(options2)).concat(v4).concat(b2(options2), ")|(?:").concat(b2(options2)).concat(v6).concat(b2(options2), ")"), "g");
      };
      ip.v4 = function(options2) {
        return options2 && options2.exact ? v4exact : new RegExp("".concat(b2(options2)).concat(v4).concat(b2(options2)), "g");
      };
      ip.v6 = function(options2) {
        return options2 && options2.exact ? v6exact : new RegExp("".concat(b2(options2)).concat(v6).concat(b2(options2)), "g");
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = "(?:\\S+(?::\\S*)?@)?";
      var ipv4 = ip.v4().source;
      var ipv6 = ip.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = "(?::\\d{2,5})?";
      var path2 = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:".concat(protocol, "|www\\.)").concat(auth, "(?:localhost|").concat(ipv4, "|").concat(ipv6, "|").concat(host).concat(domain).concat(tld, ")").concat(port).concat(path2);
      urlReg = new RegExp("(?:^".concat(regex, "$)"), "i");
      return urlReg;
    };
    var pattern$1 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer2(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      float: function float(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array2(value) {
        return Array.isArray(value);
      },
      regexp: function regexp2(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e2) {
          return false;
        }
      },
      date: function date2(value) {
        return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
      },
      number: function number2(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === "number";
      },
      object: function object2(value) {
        return _typeof$1(value) === "object" && !types.array(value);
      },
      method: function method2(value) {
        return typeof value === "function";
      },
      email: function email(value) {
        return typeof value === "string" && value.length <= 320 && !!value.match(pattern$1.email);
      },
      url: function url(value) {
        return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex(value) {
        return typeof value === "string" && !!value.match(pattern$1.hex);
      }
    };
    var type$1 = function type2(rule, value, source, errors, options2) {
      if (rule.required && value === void 0) {
        required$1(rule, value, source, errors, options2);
        return;
      }
      var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
      var ruleType = rule.type;
      if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors.push(format$1(options2.messages.types[ruleType], rule.fullField, rule.type));
        }
      } else if (ruleType && _typeof$1(value) !== rule.type) {
        errors.push(format$1(options2.messages.types[ruleType], rule.fullField, rule.type));
      }
    };
    var whitespace = function whitespace2(rule, value, source, errors, options2) {
      if (/^\s+$/.test(value) || value === "") {
        errors.push(format$1(options2.messages.whitespace, rule.fullField));
      }
    };
    const rules = {
      required: required$1,
      whitespace,
      type: type$1,
      range,
      enum: enumerable$1,
      pattern: pattern$2
    };
    var any = function any2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2);
      }
      callback(errors);
    };
    var array = function array2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === void 0 || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2, "array");
        if (value !== void 0 && value !== null) {
          rules.type(rule, value, source, errors, options2);
          rules.range(rule, value, source, errors, options2);
        }
      }
      callback(errors);
    };
    var boolean = function boolean2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options2);
        }
      }
      callback(errors);
    };
    var date = function date2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "date") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2);
        if (!isEmptyValue(value, "date")) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors, options2);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options2);
          }
        }
      }
      callback(errors);
    };
    var ENUM = "enum";
    var enumerable = function enumerable2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2);
        if (value !== void 0) {
          rules[ENUM](rule, value, source, errors, options2);
        }
      }
      callback(errors);
    };
    var floatFn = function floatFn2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options2);
          rules.range(rule, value, source, errors, options2);
        }
      }
      callback(errors);
    };
    var integer = function integer2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options2);
          rules.range(rule, value, source, errors, options2);
        }
      }
      callback(errors);
    };
    var method = function method2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options2);
        }
      }
      callback(errors);
    };
    var number = function number2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === "") {
          value = void 0;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options2);
          rules.range(rule, value, source, errors, options2);
        }
      }
      callback(errors);
    };
    var object = function object2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options2);
        }
      }
      callback(errors);
    };
    var pattern = function pattern2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2);
        if (!isEmptyValue(value, "string")) {
          rules.pattern(rule, value, source, errors, options2);
        }
      }
      callback(errors);
    };
    var regexp = function regexp2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options2);
        }
      }
      callback(errors);
    };
    var required = function required2(rule, value, callback, source, options2) {
      var errors = [];
      var type2 = Array.isArray(value) ? "array" : _typeof$1(value);
      rules.required(rule, value, source, errors, options2, type2);
      callback(errors);
    };
    var string = function string2(rule, value, callback, source, options2) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2, "string");
        if (!isEmptyValue(value, "string")) {
          rules.type(rule, value, source, errors, options2);
          rules.range(rule, value, source, errors, options2);
          rules.pattern(rule, value, source, errors, options2);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options2);
          }
        }
      }
      callback(errors);
    };
    var type = function type2(rule, value, callback, source, options2) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options2, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options2);
        }
      }
      callback(errors);
    };
    const validators = {
      string,
      method,
      number,
      boolean,
      regexp,
      integer,
      float: floatFn,
      array,
      object,
      enum: enumerable,
      pattern,
      date,
      url: type,
      hex: type,
      email: type,
      required,
      any
    };
    var Schema$1 = /* @__PURE__ */ function() {
      function Schema2(descriptor) {
        _classCallCheck(this, Schema2);
        _defineProperty(this, "rules", null);
        _defineProperty(this, "_messages", messages);
        this.define(descriptor);
      }
      _createClass(Schema2, [{
        key: "define",
        value: function define(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (_typeof$1(rules2) !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        }
      }, {
        key: "messages",
        value: function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        }
      }, {
        key: "validate",
        value: function validate(source_) {
          var _this2 = this;
          var o2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var oc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
          };
          var source = source_;
          var options2 = o2;
          var callback = oc;
          if (typeof options2 === "function") {
            callback = options2;
            options2 = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add(e2) {
              if (Array.isArray(e2)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, _toConsumableArray(e2));
              } else {
                errors.push(e2);
              }
            }
            for (var i2 = 0; i2 < results.length; i2++) {
              add(results[i2]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options2.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options2.messages);
            options2.messages = messages$1;
          } else {
            options2.messages = this.messages();
          }
          var series = {};
          var keys2 = options2.keys || Object.keys(this.rules);
          keys2.forEach(function(z2) {
            var arr = _this2.rules[z2];
            var value = source[z2];
            arr.forEach(function(r2) {
              var rule = r2;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _objectSpread2$3({}, source);
                }
                value = source[z2] = rule.transform(value);
                if (value !== void 0 && value !== null) {
                  rule.type = rule.type || (Array.isArray(value) ? "array" : _typeof$1(value));
                }
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _objectSpread2$3({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z2;
              rule.fullField = rule.fullField || z2;
              rule.type = _this2.getType(rule);
              series[z2] = series[z2] || [];
              series[z2].push({
                rule,
                value,
                source,
                field: z2
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options2, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (_typeof$1(rule.fields) === "object" || _typeof$1(rule.defaultField) === "object");
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
              return _objectSpread2$3(_objectSpread2$3({}, schema), {}, {
                fullField: "".concat(rule.fullField, ".").concat(key),
                fullFields: rule.fullFields ? [].concat(_toConsumableArray(rule.fullFields), [key]) : [key]
              });
            }
            function cb() {
              var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
              var errorList = Array.isArray(e2) ? e2 : [e2];
              if (!options2.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options2.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options2.error) {
                    filledErrors = [options2.error(rule, format$1(options2.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function(key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _objectSpread2$3(_objectSpread2$3({}, fieldsSchema), data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options2.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options2.messages;
                  data.rule.options.error = options2.error;
                }
                schema.validate(data.value, data.rule.options || options2, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, _toConsumableArray(filledErrors));
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, _toConsumableArray(errs));
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options2);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options2);
              } catch (error) {
                var _console$error, _console;
                (_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error);
                if (!options2.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || "".concat(rule.fullField || rule.field, " fails"));
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e2) {
                return cb(e2);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        }
      }, {
        key: "getType",
        value: function getType(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
            throw new Error(format$1("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        }
      }, {
        key: "getValidationMethod",
        value: function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators.required;
          }
          return validators[this.getType(rule)] || void 0;
        }
      }]);
      return Schema2;
    }();
    _defineProperty(Schema$1, "register", function register(type2, validator) {
      if (typeof validator !== "function") {
        throw new Error("Cannot register a validator by type, validator is not a function");
      }
      validators[type2] = validator;
    });
    _defineProperty(Schema$1, "warning", warning$3);
    _defineProperty(Schema$1, "messages", messages);
    _defineProperty(Schema$1, "validators", validators);
    var typeTemplate = "'${name}' is not a valid ${type}";
    var defaultValidateMessages = {
      default: "Validation error on field '${name}'",
      required: "'${name}' is required",
      enum: "'${name}' must be one of [${enum}]",
      whitespace: "'${name}' cannot be empty",
      date: {
        format: "'${name}' is invalid for format date",
        parse: "'${name}' could not be parsed as date",
        invalid: "'${name}' is invalid date"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        boolean: typeTemplate,
        integer: typeTemplate,
        float: typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "'${name}' must be exactly ${len} characters",
        min: "'${name}' must be at least ${min} characters",
        max: "'${name}' cannot be longer than ${max} characters",
        range: "'${name}' must be between ${min} and ${max} characters"
      },
      number: {
        len: "'${name}' must equal ${len}",
        min: "'${name}' cannot be less than ${min}",
        max: "'${name}' cannot be greater than ${max}",
        range: "'${name}' must be between ${min} and ${max}"
      },
      array: {
        len: "'${name}' must be exactly ${len} in length",
        min: "'${name}' cannot be less than ${min} in length",
        max: "'${name}' cannot be greater than ${max} in length",
        range: "'${name}' must be between ${min} and ${max} in length"
      },
      pattern: {
        mismatch: "'${name}' does not match pattern ${pattern}"
      }
    };
    var AsyncValidator = Schema$1;
    function replaceMessage(template, kv) {
      return template.replace(/\\?\$\{\w+\}/g, function(str) {
        if (str.startsWith("\\")) {
          return str.slice(1);
        }
        var key = str.slice(2, -1);
        return kv[key];
      });
    }
    var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
    function validateRule(_x, _x2, _x3, _x4, _x5) {
      return _validateRule.apply(this, arguments);
    }
    function _validateRule() {
      _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name, value, rule, options2, messageVariables) {
        var cloneRule, originValidator, subRuleField, validator, messages2, result, subResults, kv, fillVariableResult;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              cloneRule = _objectSpread2$3({}, rule);
              delete cloneRule.ruleIndex;
              AsyncValidator.warning = function() {
                return void 0;
              };
              if (cloneRule.validator) {
                originValidator = cloneRule.validator;
                cloneRule.validator = function() {
                  try {
                    return originValidator.apply(void 0, arguments);
                  } catch (error) {
                    console.error(error);
                    return Promise.reject(CODE_LOGIC_ERROR);
                  }
                };
              }
              subRuleField = null;
              if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
                subRuleField = cloneRule.defaultField;
                delete cloneRule.defaultField;
              }
              validator = new AsyncValidator(_defineProperty({}, name, [cloneRule]));
              messages2 = merge$1(defaultValidateMessages, options2.validateMessages);
              validator.messages(messages2);
              result = [];
              _context2.prev = 10;
              _context2.next = 13;
              return Promise.resolve(validator.validate(_defineProperty({}, name, value), _objectSpread2$3({}, options2)));
            case 13:
              _context2.next = 18;
              break;
            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](10);
              if (_context2.t0.errors) {
                result = _context2.t0.errors.map(function(_ref4, index2) {
                  var message2 = _ref4.message;
                  var mergedMessage = message2 === CODE_LOGIC_ERROR ? messages2.default : message2;
                  return /* @__PURE__ */ reactExports.isValidElement(mergedMessage) ? (
                    // Wrap ReactNode with `key`
                    /* @__PURE__ */ reactExports.cloneElement(mergedMessage, {
                      key: "error_".concat(index2)
                    })
                  ) : mergedMessage;
                });
              }
            case 18:
              if (!(!result.length && subRuleField)) {
                _context2.next = 23;
                break;
              }
              _context2.next = 21;
              return Promise.all(value.map(function(subValue, i2) {
                return validateRule("".concat(name, ".").concat(i2), subValue, subRuleField, options2, messageVariables);
              }));
            case 21:
              subResults = _context2.sent;
              return _context2.abrupt("return", subResults.reduce(function(prev2, errors) {
                return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors));
              }, []));
            case 23:
              kv = _objectSpread2$3(_objectSpread2$3({}, rule), {}, {
                name,
                enum: (rule.enum || []).join(", ")
              }, messageVariables);
              fillVariableResult = result.map(function(error) {
                if (typeof error === "string") {
                  return replaceMessage(error, kv);
                }
                return error;
              });
              return _context2.abrupt("return", fillVariableResult);
            case 26:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[10, 15]]);
      }));
      return _validateRule.apply(this, arguments);
    }
    function validateRules(namePath, value, rules2, options2, validateFirst, messageVariables) {
      var name = namePath.join(".");
      var filledRules = rules2.map(function(currentRule, ruleIndex) {
        var originValidatorFunc = currentRule.validator;
        var cloneRule = _objectSpread2$3(_objectSpread2$3({}, currentRule), {}, {
          ruleIndex
        });
        if (originValidatorFunc) {
          cloneRule.validator = function(rule, val, callback) {
            var hasPromise = false;
            var wrappedCallback = function wrappedCallback2() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              Promise.resolve().then(function() {
                warningOnce$1(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
                if (!hasPromise) {
                  callback.apply(void 0, args);
                }
              });
            };
            var promise = originValidatorFunc(rule, val, wrappedCallback);
            hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
            warningOnce$1(hasPromise, "`callback` is deprecated. Please return a promise instead.");
            if (hasPromise) {
              promise.then(function() {
                callback();
              }).catch(function(err) {
                callback(err || " ");
              });
            }
          };
        }
        return cloneRule;
      }).sort(function(_ref, _ref2) {
        var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
        var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
        if (!!w1 === !!w2) {
          return i1 - i2;
        }
        if (w1) {
          return 1;
        }
        return -1;
      });
      var summaryPromise;
      if (validateFirst === true) {
        summaryPromise = new Promise(/* @__PURE__ */ function() {
          var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
            var i2, rule, errors;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  i2 = 0;
                case 1:
                  if (!(i2 < filledRules.length)) {
                    _context.next = 12;
                    break;
                  }
                  rule = filledRules[i2];
                  _context.next = 5;
                  return validateRule(name, value, rule, options2, messageVariables);
                case 5:
                  errors = _context.sent;
                  if (!errors.length) {
                    _context.next = 9;
                    break;
                  }
                  reject([{
                    errors,
                    rule
                  }]);
                  return _context.abrupt("return");
                case 9:
                  i2 += 1;
                  _context.next = 1;
                  break;
                case 12:
                  resolve([]);
                case 13:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function(_x6, _x7) {
            return _ref3.apply(this, arguments);
          };
        }());
      } else {
        var rulePromises = filledRules.map(function(rule) {
          return validateRule(name, value, rule, options2, messageVariables).then(function(errors) {
            return {
              errors,
              rule
            };
          });
        });
        summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
          return Promise.reject(errors);
        });
      }
      summaryPromise.catch(function(e2) {
        return e2;
      });
      return summaryPromise;
    }
    function finishOnAllFailed(_x8) {
      return _finishOnAllFailed.apply(this, arguments);
    }
    function _finishOnAllFailed() {
      _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
                var _ref5;
                var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
                return errors;
              }));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      return _finishOnAllFailed.apply(this, arguments);
    }
    function finishOnFirstFailed(_x9) {
      return _finishOnFirstFailed.apply(this, arguments);
    }
    function _finishOnFirstFailed() {
      _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
        var count;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              count = 0;
              return _context4.abrupt("return", new Promise(function(resolve) {
                rulePromises.forEach(function(promise) {
                  promise.then(function(ruleError) {
                    if (ruleError.errors.length) {
                      resolve([ruleError]);
                    }
                    count += 1;
                    if (count === rulePromises.length) {
                      resolve([]);
                    }
                  });
                });
              }));
            case 2:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      return _finishOnFirstFailed.apply(this, arguments);
    }
    function getNamePath(path2) {
      return toArray$4(path2);
    }
    function cloneByNamePathList(store, namePathList) {
      var newStore = {};
      namePathList.forEach(function(namePath) {
        var value = get(store, namePath);
        newStore = set(newStore, namePath, value);
      });
      return newStore;
    }
    function containsNamePath(namePathList, namePath) {
      var partialMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return namePathList && namePathList.some(function(path2) {
        return matchNamePath(namePath, path2, partialMatch);
      });
    }
    function matchNamePath(namePath, subNamePath) {
      var partialMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (!namePath || !subNamePath) {
        return false;
      }
      if (!partialMatch && namePath.length !== subNamePath.length) {
        return false;
      }
      return subNamePath.every(function(nameUnit, i2) {
        return namePath[i2] === nameUnit;
      });
    }
    function isSimilar(source, target) {
      if (source === target) {
        return true;
      }
      if (!source && target || source && !target) {
        return false;
      }
      if (!source || !target || _typeof$1(source) !== "object" || _typeof$1(target) !== "object") {
        return false;
      }
      var sourceKeys = Object.keys(source);
      var targetKeys = Object.keys(target);
      var keys2 = new Set([].concat(sourceKeys, targetKeys));
      return _toConsumableArray(keys2).every(function(key) {
        var sourceValue = source[key];
        var targetValue = target[key];
        if (typeof sourceValue === "function" && typeof targetValue === "function") {
          return true;
        }
        return sourceValue === targetValue;
      });
    }
    function defaultGetValueFromEvent(valuePropName) {
      var event = arguments.length <= 1 ? void 0 : arguments[1];
      if (event && event.target && _typeof$1(event.target) === "object" && valuePropName in event.target) {
        return event.target[valuePropName];
      }
      return event;
    }
    function move(array2, moveIndex, toIndex) {
      var length2 = array2.length;
      if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
        return array2;
      }
      var item = array2[moveIndex];
      var diff = moveIndex - toIndex;
      if (diff > 0) {
        return [].concat(_toConsumableArray(array2.slice(0, toIndex)), [item], _toConsumableArray(array2.slice(toIndex, moveIndex)), _toConsumableArray(array2.slice(moveIndex + 1, length2)));
      }
      if (diff < 0) {
        return [].concat(_toConsumableArray(array2.slice(0, moveIndex)), _toConsumableArray(array2.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array2.slice(toIndex + 1, length2)));
      }
      return array2;
    }
    var _excluded$D = ["name"];
    var EMPTY_ERRORS = [];
    function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
      if (typeof shouldUpdate === "function") {
        return shouldUpdate(prev2, next2, "source" in info ? {
          source: info.source
        } : {});
      }
      return prevValue !== nextValue;
    }
    var Field = /* @__PURE__ */ function(_React$Component) {
      _inherits(Field2, _React$Component);
      var _super = _createSuper(Field2);
      function Field2(props) {
        var _this;
        _classCallCheck(this, Field2);
        _this = _super.call(this, props);
        _defineProperty(_assertThisInitialized(_this), "state", {
          resetCount: 0
        });
        _defineProperty(_assertThisInitialized(_this), "cancelRegisterFunc", null);
        _defineProperty(_assertThisInitialized(_this), "mounted", false);
        _defineProperty(_assertThisInitialized(_this), "touched", false);
        _defineProperty(_assertThisInitialized(_this), "dirty", false);
        _defineProperty(_assertThisInitialized(_this), "validatePromise", void 0);
        _defineProperty(_assertThisInitialized(_this), "prevValidating", void 0);
        _defineProperty(_assertThisInitialized(_this), "errors", EMPTY_ERRORS);
        _defineProperty(_assertThisInitialized(_this), "warnings", EMPTY_ERRORS);
        _defineProperty(_assertThisInitialized(_this), "cancelRegister", function() {
          var _this$props = _this.props, preserve2 = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
          if (_this.cancelRegisterFunc) {
            _this.cancelRegisterFunc(isListField, preserve2, getNamePath(name));
          }
          _this.cancelRegisterFunc = null;
        });
        _defineProperty(_assertThisInitialized(_this), "getNamePath", function() {
          var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext;
          var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
          return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
        });
        _defineProperty(_assertThisInitialized(_this), "getRules", function() {
          var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
          return rules2.map(function(rule) {
            if (typeof rule === "function") {
              return rule(fieldContext);
            }
            return rule;
          });
        });
        _defineProperty(_assertThisInitialized(_this), "refresh", function() {
          if (!_this.mounted) return;
          _this.setState(function(_ref) {
            var resetCount = _ref.resetCount;
            return {
              resetCount: resetCount + 1
            };
          });
        });
        _defineProperty(_assertThisInitialized(_this), "metaCache", null);
        _defineProperty(_assertThisInitialized(_this), "triggerMetaEvent", function(destroy2) {
          var onMetaChange = _this.props.onMetaChange;
          if (onMetaChange) {
            var _meta = _objectSpread2$3(_objectSpread2$3({}, _this.getMeta()), {}, {
              destroy: destroy2
            });
            if (!isEqual$1(_this.metaCache, _meta)) {
              onMetaChange(_meta);
            }
            _this.metaCache = _meta;
          } else {
            _this.metaCache = null;
          }
        });
        _defineProperty(_assertThisInitialized(_this), "onStoreChange", function(prevStore, namePathList, info) {
          var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
          var store = info.store;
          var namePath = _this.getNamePath();
          var prevValue = _this.getValue(prevStore);
          var curValue = _this.getValue(store);
          var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
          if (info.type === "valueUpdate" && info.source === "external" && !isEqual$1(prevValue, curValue)) {
            _this.touched = true;
            _this.dirty = true;
            _this.validatePromise = null;
            _this.errors = EMPTY_ERRORS;
            _this.warnings = EMPTY_ERRORS;
            _this.triggerMetaEvent();
          }
          switch (info.type) {
            case "reset":
              if (!namePathList || namePathMatch) {
                _this.touched = false;
                _this.dirty = false;
                _this.validatePromise = void 0;
                _this.errors = EMPTY_ERRORS;
                _this.warnings = EMPTY_ERRORS;
                _this.triggerMetaEvent();
                onReset === null || onReset === void 0 || onReset();
                _this.refresh();
                return;
              }
              break;
            case "remove": {
              if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
                _this.reRender();
                return;
              }
              break;
            }
            case "setField": {
              var data = info.data;
              if (namePathMatch) {
                if ("touched" in data) {
                  _this.touched = data.touched;
                }
                if ("validating" in data && !("originRCField" in data)) {
                  _this.validatePromise = data.validating ? Promise.resolve([]) : null;
                }
                if ("errors" in data) {
                  _this.errors = data.errors || EMPTY_ERRORS;
                }
                if ("warnings" in data) {
                  _this.warnings = data.warnings || EMPTY_ERRORS;
                }
                _this.dirty = true;
                _this.triggerMetaEvent();
                _this.reRender();
                return;
              } else if ("value" in data && containsNamePath(namePathList, namePath, true)) {
                _this.reRender();
                return;
              }
              if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
                _this.reRender();
                return;
              }
              break;
            }
            case "dependenciesUpdate": {
              var dependencyList = dependencies.map(getNamePath);
              if (dependencyList.some(function(dependency) {
                return containsNamePath(info.relatedFields, dependency);
              })) {
                _this.reRender();
                return;
              }
              break;
            }
            default:
              if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
                _this.reRender();
                return;
              }
              break;
          }
          if (shouldUpdate === true) {
            _this.reRender();
          }
        });
        _defineProperty(_assertThisInitialized(_this), "validateRules", function(options2) {
          var namePath = _this.getNamePath();
          var currentValue = _this.getValue();
          var _ref2 = options2 || {}, triggerName = _ref2.triggerName, _ref2$validateOnly = _ref2.validateOnly, validateOnly = _ref2$validateOnly === void 0 ? false : _ref2$validateOnly;
          var rootPromise = Promise.resolve().then(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
            var _this$props5, _this$props5$validate, validateFirst, messageVariables, validateDebounce, filteredRules, promise;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  if (_this.mounted) {
                    _context.next = 2;
                    break;
                  }
                  return _context.abrupt("return", []);
                case 2:
                  _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables, validateDebounce = _this$props5.validateDebounce;
                  filteredRules = _this.getRules();
                  if (triggerName) {
                    filteredRules = filteredRules.filter(function(rule) {
                      return rule;
                    }).filter(function(rule) {
                      var validateTrigger = rule.validateTrigger;
                      if (!validateTrigger) {
                        return true;
                      }
                      var triggerList = toArray$4(validateTrigger);
                      return triggerList.includes(triggerName);
                    });
                  }
                  if (!(validateDebounce && triggerName)) {
                    _context.next = 10;
                    break;
                  }
                  _context.next = 8;
                  return new Promise(function(resolve) {
                    setTimeout(resolve, validateDebounce);
                  });
                case 8:
                  if (!(_this.validatePromise !== rootPromise)) {
                    _context.next = 10;
                    break;
                  }
                  return _context.abrupt("return", []);
                case 10:
                  promise = validateRules(namePath, currentValue, filteredRules, options2, validateFirst, messageVariables);
                  promise.catch(function(e2) {
                    return e2;
                  }).then(function() {
                    var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
                    if (_this.validatePromise === rootPromise) {
                      var _ruleErrors$forEach;
                      _this.validatePromise = null;
                      var nextErrors = [];
                      var nextWarnings = [];
                      (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function(_ref4) {
                        var warningOnly = _ref4.rule.warningOnly, _ref4$errors = _ref4.errors, errors = _ref4$errors === void 0 ? EMPTY_ERRORS : _ref4$errors;
                        if (warningOnly) {
                          nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
                        } else {
                          nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
                        }
                      });
                      _this.errors = nextErrors;
                      _this.warnings = nextWarnings;
                      _this.triggerMetaEvent();
                      _this.reRender();
                    }
                  });
                  return _context.abrupt("return", promise);
                case 13:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          })));
          if (validateOnly) {
            return rootPromise;
          }
          _this.validatePromise = rootPromise;
          _this.dirty = true;
          _this.errors = EMPTY_ERRORS;
          _this.warnings = EMPTY_ERRORS;
          _this.triggerMetaEvent();
          _this.reRender();
          return rootPromise;
        });
        _defineProperty(_assertThisInitialized(_this), "isFieldValidating", function() {
          return !!_this.validatePromise;
        });
        _defineProperty(_assertThisInitialized(_this), "isFieldTouched", function() {
          return _this.touched;
        });
        _defineProperty(_assertThisInitialized(_this), "isFieldDirty", function() {
          if (_this.dirty || _this.props.initialValue !== void 0) {
            return true;
          }
          var fieldContext = _this.props.fieldContext;
          var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
          if (getInitialValue(_this.getNamePath()) !== void 0) {
            return true;
          }
          return false;
        });
        _defineProperty(_assertThisInitialized(_this), "getErrors", function() {
          return _this.errors;
        });
        _defineProperty(_assertThisInitialized(_this), "getWarnings", function() {
          return _this.warnings;
        });
        _defineProperty(_assertThisInitialized(_this), "isListField", function() {
          return _this.props.isListField;
        });
        _defineProperty(_assertThisInitialized(_this), "isList", function() {
          return _this.props.isList;
        });
        _defineProperty(_assertThisInitialized(_this), "isPreserve", function() {
          return _this.props.preserve;
        });
        _defineProperty(_assertThisInitialized(_this), "getMeta", function() {
          _this.prevValidating = _this.isFieldValidating();
          var meta = {
            touched: _this.isFieldTouched(),
            validating: _this.prevValidating,
            errors: _this.errors,
            warnings: _this.warnings,
            name: _this.getNamePath(),
            validated: _this.validatePromise === null
          };
          return meta;
        });
        _defineProperty(_assertThisInitialized(_this), "getOnlyChild", function(children) {
          if (typeof children === "function") {
            var _meta2 = _this.getMeta();
            return _objectSpread2$3(_objectSpread2$3({}, _this.getOnlyChild(children(_this.getControlled(), _meta2, _this.props.fieldContext))), {}, {
              isFunction: true
            });
          }
          var childList = toArray$5(children);
          if (childList.length !== 1 || !/* @__PURE__ */ reactExports.isValidElement(childList[0])) {
            return {
              child: childList,
              isFunction: false
            };
          }
          return {
            child: childList[0],
            isFunction: false
          };
        });
        _defineProperty(_assertThisInitialized(_this), "getValue", function(store) {
          var getFieldsValue = _this.props.fieldContext.getFieldsValue;
          var namePath = _this.getNamePath();
          return get(store || getFieldsValue(true), namePath);
        });
        _defineProperty(_assertThisInitialized(_this), "getControlled", function() {
          var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var _this$props6 = _this.props, name = _this$props6.name, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
          var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
          var namePath = _this.getNamePath();
          var getInternalHooks2 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
          var _getInternalHooks = getInternalHooks2(HOOK_MARK), dispatch = _getInternalHooks.dispatch;
          var value = _this.getValue();
          var mergedGetValueProps = getValueProps || function(val) {
            return _defineProperty({}, valuePropName, val);
          };
          var originTriggerFunc = childProps[trigger];
          var valueProps = name !== void 0 ? mergedGetValueProps(value) : {};
          var control = _objectSpread2$3(_objectSpread2$3({}, childProps), valueProps);
          control[trigger] = function() {
            _this.touched = true;
            _this.dirty = true;
            _this.triggerMetaEvent();
            var newValue;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (getValueFromEvent) {
              newValue = getValueFromEvent.apply(void 0, args);
            } else {
              newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
            }
            if (normalize2) {
              newValue = normalize2(newValue, value, getFieldsValue(true));
            }
            if (newValue !== value) {
              dispatch({
                type: "updateValue",
                namePath,
                value: newValue
              });
            }
            if (originTriggerFunc) {
              originTriggerFunc.apply(void 0, args);
            }
          };
          var validateTriggerList = toArray$4(mergedValidateTrigger || []);
          validateTriggerList.forEach(function(triggerName) {
            var originTrigger = control[triggerName];
            control[triggerName] = function() {
              if (originTrigger) {
                originTrigger.apply(void 0, arguments);
              }
              var rules2 = _this.props.rules;
              if (rules2 && rules2.length) {
                dispatch({
                  type: "validateField",
                  namePath,
                  triggerName
                });
              }
            };
          });
          return control;
        });
        if (props.fieldContext) {
          var getInternalHooks = props.fieldContext.getInternalHooks;
          var _getInternalHooks2 = getInternalHooks(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
          initEntityValue(_assertThisInitialized(_this));
        }
        return _this;
      }
      _createClass(Field2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
          this.mounted = true;
          if (fieldContext) {
            var getInternalHooks = fieldContext.getInternalHooks;
            var _getInternalHooks3 = getInternalHooks(HOOK_MARK), registerField = _getInternalHooks3.registerField;
            this.cancelRegisterFunc = registerField(this);
          }
          if (shouldUpdate === true) {
            this.reRender();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.cancelRegister();
          this.triggerMetaEvent(true);
          this.mounted = false;
        }
      }, {
        key: "reRender",
        value: function reRender() {
          if (!this.mounted) return;
          this.forceUpdate();
        }
      }, {
        key: "render",
        value: function render2() {
          var resetCount = this.state.resetCount;
          var children = this.props.children;
          var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction2 = _this$getOnlyChild.isFunction;
          var returnChildNode;
          if (isFunction2) {
            returnChildNode = child;
          } else if (/* @__PURE__ */ reactExports.isValidElement(child)) {
            returnChildNode = /* @__PURE__ */ reactExports.cloneElement(child, this.getControlled(child.props));
          } else {
            warningOnce$1(!child, "`children` of Field is not validate ReactElement.");
            returnChildNode = child;
          }
          return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, {
            key: resetCount
          }, returnChildNode);
        }
      }]);
      return Field2;
    }(reactExports.Component);
    _defineProperty(Field, "contextType", Context$1);
    _defineProperty(Field, "defaultProps", {
      trigger: "onChange",
      valuePropName: "value"
    });
    function WrapperField(_ref6) {
      var _restProps$isListFiel;
      var name = _ref6.name, restProps = _objectWithoutProperties(_ref6, _excluded$D);
      var fieldContext = reactExports.useContext(Context$1);
      var listContext = reactExports.useContext(ListContext$1);
      var namePath = name !== void 0 ? getNamePath(name) : void 0;
      var isMergedListField = (_restProps$isListFiel = restProps.isListField) !== null && _restProps$isListFiel !== void 0 ? _restProps$isListFiel : !!listContext;
      var key = "keep";
      if (!isMergedListField) {
        key = "_".concat((namePath || []).join("_"));
      }
      return /* @__PURE__ */ reactExports.createElement(Field, _extends$2({
        key,
        name: namePath,
        isListField: isMergedListField
      }, restProps, {
        fieldContext
      }));
    }
    function List$2(_ref) {
      var name = _ref.name, initialValue2 = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger, isListField = _ref.isListField;
      var context = reactExports.useContext(Context$1);
      var wrapperListContext = reactExports.useContext(ListContext$1);
      var keyRef = reactExports.useRef({
        keys: [],
        id: 0
      });
      var keyManager = keyRef.current;
      var prefixName = reactExports.useMemo(function() {
        var parentPrefixName = getNamePath(context.prefixName) || [];
        return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
      }, [context.prefixName, name]);
      var fieldContext = reactExports.useMemo(function() {
        return _objectSpread2$3(_objectSpread2$3({}, context), {}, {
          prefixName
        });
      }, [context, prefixName]);
      var listContext = reactExports.useMemo(function() {
        return {
          getKey: function getKey2(namePath) {
            var len = prefixName.length;
            var pathName = namePath[len];
            return [keyManager.keys[pathName], namePath.slice(len + 1)];
          }
        };
      }, [prefixName]);
      if (typeof children !== "function") {
        warningOnce$1(false, "Form.List only accepts function as children.");
        return null;
      }
      var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {
        var source = _ref2.source;
        if (source === "internal") {
          return false;
        }
        return prevValue !== nextValue;
      };
      return /* @__PURE__ */ reactExports.createElement(ListContext$1.Provider, {
        value: listContext
      }, /* @__PURE__ */ reactExports.createElement(Context$1.Provider, {
        value: fieldContext
      }, /* @__PURE__ */ reactExports.createElement(WrapperField, {
        name: [],
        shouldUpdate,
        rules: rules2,
        validateTrigger,
        initialValue: initialValue2,
        isList: true,
        isListField: isListField !== null && isListField !== void 0 ? isListField : !!wrapperListContext
      }, function(_ref3, meta) {
        var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange;
        var getFieldValue = context.getFieldValue;
        var getNewValue = function getNewValue2() {
          var values = getFieldValue(prefixName || []);
          return values || [];
        };
        var operations = {
          add: function add(defaultValue, index2) {
            var newValue = getNewValue();
            if (index2 >= 0 && index2 <= newValue.length) {
              keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));
              onChange([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));
            } else {
              keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
              onChange([].concat(_toConsumableArray(newValue), [defaultValue]));
            }
            keyManager.id += 1;
          },
          remove: function remove(index2) {
            var newValue = getNewValue();
            var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
            if (indexSet.size <= 0) {
              return;
            }
            keyManager.keys = keyManager.keys.filter(function(_2, keysIndex) {
              return !indexSet.has(keysIndex);
            });
            onChange(newValue.filter(function(_2, valueIndex) {
              return !indexSet.has(valueIndex);
            }));
          },
          move: function move$1(from2, to) {
            if (from2 === to) {
              return;
            }
            var newValue = getNewValue();
            if (from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length) {
              return;
            }
            keyManager.keys = move(keyManager.keys, from2, to);
            onChange(move(newValue, from2, to));
          }
        };
        var listValue = value || [];
        if (!Array.isArray(listValue)) {
          listValue = [];
        }
        return children(listValue.map(function(__, index2) {
          var key = keyManager.keys[index2];
          if (key === void 0) {
            keyManager.keys[index2] = keyManager.id;
            key = keyManager.keys[index2];
            keyManager.id += 1;
          }
          return {
            name: index2,
            key,
            isListField: true
          };
        }), operations, meta);
      })));
    }
    function allPromiseFinish(promiseList) {
      var hasError = false;
      var count = promiseList.length;
      var results = [];
      if (!promiseList.length) {
        return Promise.resolve([]);
      }
      return new Promise(function(resolve, reject) {
        promiseList.forEach(function(promise, index2) {
          promise.catch(function(e2) {
            hasError = true;
            return e2;
          }).then(function(result) {
            count -= 1;
            results[index2] = result;
            if (count > 0) {
              return;
            }
            if (hasError) {
              reject(results);
            }
            resolve(results);
          });
        });
      });
    }
    var SPLIT = "__@field_split__";
    function normalize(namePath) {
      return namePath.map(function(cell) {
        return "".concat(_typeof$1(cell), ":").concat(cell);
      }).join(SPLIT);
    }
    var NameMap = /* @__PURE__ */ function() {
      function NameMap2() {
        _classCallCheck(this, NameMap2);
        _defineProperty(this, "kvs", /* @__PURE__ */ new Map());
      }
      _createClass(NameMap2, [{
        key: "set",
        value: function set2(key, value) {
          this.kvs.set(normalize(key), value);
        }
      }, {
        key: "get",
        value: function get2(key) {
          return this.kvs.get(normalize(key));
        }
      }, {
        key: "update",
        value: function update(key, updater) {
          var origin = this.get(key);
          var next2 = updater(origin);
          if (!next2) {
            this.delete(key);
          } else {
            this.set(key, next2);
          }
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          this.kvs.delete(normalize(key));
        }
        // Since we only use this in test, let simply realize this
      }, {
        key: "map",
        value: function map(callback) {
          return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
            var cells = key.split(SPLIT);
            return callback({
              key: cells.map(function(cell) {
                var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray(_cell$match, 3), type2 = _cell$match2[1], unit2 = _cell$match2[2];
                return type2 === "number" ? Number(unit2) : unit2;
              }),
              value
            });
          });
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var json = {};
          this.map(function(_ref3) {
            var key = _ref3.key, value = _ref3.value;
            json[key.join(".")] = value;
            return null;
          });
          return json;
        }
      }]);
      return NameMap2;
    }();
    var _excluded$C = ["name"];
    var FormStore = /* @__PURE__ */ _createClass(function FormStore2(forceRootUpdate) {
      var _this = this;
      _classCallCheck(this, FormStore2);
      _defineProperty(this, "formHooked", false);
      _defineProperty(this, "forceRootUpdate", void 0);
      _defineProperty(this, "subscribable", true);
      _defineProperty(this, "store", {});
      _defineProperty(this, "fieldEntities", []);
      _defineProperty(this, "initialValues", {});
      _defineProperty(this, "callbacks", {});
      _defineProperty(this, "validateMessages", null);
      _defineProperty(this, "preserve", null);
      _defineProperty(this, "lastValidatePromise", null);
      _defineProperty(this, "getForm", function() {
        return {
          getFieldValue: _this.getFieldValue,
          getFieldsValue: _this.getFieldsValue,
          getFieldError: _this.getFieldError,
          getFieldWarning: _this.getFieldWarning,
          getFieldsError: _this.getFieldsError,
          isFieldsTouched: _this.isFieldsTouched,
          isFieldTouched: _this.isFieldTouched,
          isFieldValidating: _this.isFieldValidating,
          isFieldsValidating: _this.isFieldsValidating,
          resetFields: _this.resetFields,
          setFields: _this.setFields,
          setFieldValue: _this.setFieldValue,
          setFieldsValue: _this.setFieldsValue,
          validateFields: _this.validateFields,
          submit: _this.submit,
          _init: true,
          getInternalHooks: _this.getInternalHooks
        };
      });
      _defineProperty(this, "getInternalHooks", function(key) {
        if (key === HOOK_MARK) {
          _this.formHooked = true;
          return {
            dispatch: _this.dispatch,
            initEntityValue: _this.initEntityValue,
            registerField: _this.registerField,
            useSubscribe: _this.useSubscribe,
            setInitialValues: _this.setInitialValues,
            destroyForm: _this.destroyForm,
            setCallbacks: _this.setCallbacks,
            setValidateMessages: _this.setValidateMessages,
            getFields: _this.getFields,
            setPreserve: _this.setPreserve,
            getInitialValue: _this.getInitialValue,
            registerWatch: _this.registerWatch
          };
        }
        warningOnce$1(false, "`getInternalHooks` is internal usage. Should not call directly.");
        return null;
      });
      _defineProperty(this, "useSubscribe", function(subscribable) {
        _this.subscribable = subscribable;
      });
      _defineProperty(this, "prevWithoutPreserves", null);
      _defineProperty(this, "setInitialValues", function(initialValues, init) {
        _this.initialValues = initialValues || {};
        if (init) {
          var _this$prevWithoutPres;
          var nextStore = merge$1(initialValues, _this.store);
          (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 || _this$prevWithoutPres.map(function(_ref) {
            var namePath = _ref.key;
            nextStore = set(nextStore, namePath, get(initialValues, namePath));
          });
          _this.prevWithoutPreserves = null;
          _this.updateStore(nextStore);
        }
      });
      _defineProperty(this, "destroyForm", function(clearOnDestroy) {
        if (clearOnDestroy) {
          _this.updateStore({});
        } else {
          var prevWithoutPreserves = new NameMap();
          _this.getFieldEntities(true).forEach(function(entity) {
            if (!_this.isMergedPreserve(entity.isPreserve())) {
              prevWithoutPreserves.set(entity.getNamePath(), true);
            }
          });
          _this.prevWithoutPreserves = prevWithoutPreserves;
        }
      });
      _defineProperty(this, "getInitialValue", function(namePath) {
        var initValue = get(_this.initialValues, namePath);
        return namePath.length ? merge$1(initValue) : initValue;
      });
      _defineProperty(this, "setCallbacks", function(callbacks) {
        _this.callbacks = callbacks;
      });
      _defineProperty(this, "setValidateMessages", function(validateMessages) {
        _this.validateMessages = validateMessages;
      });
      _defineProperty(this, "setPreserve", function(preserve2) {
        _this.preserve = preserve2;
      });
      _defineProperty(this, "watchList", []);
      _defineProperty(this, "registerWatch", function(callback) {
        _this.watchList.push(callback);
        return function() {
          _this.watchList = _this.watchList.filter(function(fn) {
            return fn !== callback;
          });
        };
      });
      _defineProperty(this, "notifyWatch", function() {
        var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (_this.watchList.length) {
          var values = _this.getFieldsValue();
          var allValues = _this.getFieldsValue(true);
          _this.watchList.forEach(function(callback) {
            callback(values, allValues, namePath);
          });
        }
      });
      _defineProperty(this, "timeoutId", null);
      _defineProperty(this, "warningUnhooked", function() {
      });
      _defineProperty(this, "updateStore", function(nextStore) {
        _this.store = nextStore;
      });
      _defineProperty(this, "getFieldEntities", function() {
        var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (!pure) {
          return _this.fieldEntities;
        }
        return _this.fieldEntities.filter(function(field) {
          return field.getNamePath().length;
        });
      });
      _defineProperty(this, "getFieldsMap", function() {
        var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var cache = new NameMap();
        _this.getFieldEntities(pure).forEach(function(field) {
          var namePath = field.getNamePath();
          cache.set(namePath, field);
        });
        return cache;
      });
      _defineProperty(this, "getFieldEntitiesForNamePathList", function(nameList) {
        if (!nameList) {
          return _this.getFieldEntities(true);
        }
        var cache = _this.getFieldsMap(true);
        return nameList.map(function(name) {
          var namePath = getNamePath(name);
          return cache.get(namePath) || {
            INVALIDATE_NAME_PATH: getNamePath(name)
          };
        });
      });
      _defineProperty(this, "getFieldsValue", function(nameList, filterFunc) {
        _this.warningUnhooked();
        var mergedNameList;
        var mergedFilterFunc;
        var mergedStrict;
        if (nameList === true || Array.isArray(nameList)) {
          mergedNameList = nameList;
          mergedFilterFunc = filterFunc;
        } else if (nameList && _typeof$1(nameList) === "object") {
          mergedStrict = nameList.strict;
          mergedFilterFunc = nameList.filter;
        }
        if (mergedNameList === true && !mergedFilterFunc) {
          return _this.store;
        }
        var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);
        var filteredNameList = [];
        fieldEntities.forEach(function(entity) {
          var _isListField, _ref3;
          var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
          if (mergedStrict) {
            var _isList, _ref2;
            if ((_isList = (_ref2 = entity).isList) !== null && _isList !== void 0 && _isList.call(_ref2)) {
              return;
            }
          } else if (!mergedNameList && (_isListField = (_ref3 = entity).isListField) !== null && _isListField !== void 0 && _isListField.call(_ref3)) {
            return;
          }
          if (!mergedFilterFunc) {
            filteredNameList.push(namePath);
          } else {
            var meta = "getMeta" in entity ? entity.getMeta() : null;
            if (mergedFilterFunc(meta)) {
              filteredNameList.push(namePath);
            }
          }
        });
        return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
      });
      _defineProperty(this, "getFieldValue", function(name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        return get(_this.store, namePath);
      });
      _defineProperty(this, "getFieldsError", function(nameList) {
        _this.warningUnhooked();
        var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
        return fieldEntities.map(function(entity, index2) {
          if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
            return {
              name: entity.getNamePath(),
              errors: entity.getErrors(),
              warnings: entity.getWarnings()
            };
          }
          return {
            name: getNamePath(nameList[index2]),
            errors: [],
            warnings: []
          };
        });
      });
      _defineProperty(this, "getFieldError", function(name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        var fieldError = _this.getFieldsError([namePath])[0];
        return fieldError.errors;
      });
      _defineProperty(this, "getFieldWarning", function(name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        var fieldError = _this.getFieldsError([namePath])[0];
        return fieldError.warnings;
      });
      _defineProperty(this, "isFieldsTouched", function() {
        _this.warningUnhooked();
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var arg0 = args[0], arg1 = args[1];
        var namePathList;
        var isAllFieldsTouched = false;
        if (args.length === 0) {
          namePathList = null;
        } else if (args.length === 1) {
          if (Array.isArray(arg0)) {
            namePathList = arg0.map(getNamePath);
            isAllFieldsTouched = false;
          } else {
            namePathList = null;
            isAllFieldsTouched = arg0;
          }
        } else {
          namePathList = arg0.map(getNamePath);
          isAllFieldsTouched = arg1;
        }
        var fieldEntities = _this.getFieldEntities(true);
        var isFieldTouched = function isFieldTouched2(field) {
          return field.isFieldTouched();
        };
        if (!namePathList) {
          return isAllFieldsTouched ? fieldEntities.every(function(entity) {
            return isFieldTouched(entity) || entity.isList();
          }) : fieldEntities.some(isFieldTouched);
        }
        var map = new NameMap();
        namePathList.forEach(function(shortNamePath) {
          map.set(shortNamePath, []);
        });
        fieldEntities.forEach(function(field) {
          var fieldNamePath = field.getNamePath();
          namePathList.forEach(function(shortNamePath) {
            if (shortNamePath.every(function(nameUnit, i2) {
              return fieldNamePath[i2] === nameUnit;
            })) {
              map.update(shortNamePath, function(list) {
                return [].concat(_toConsumableArray(list), [field]);
              });
            }
          });
        });
        var isNamePathListTouched = function isNamePathListTouched2(entities) {
          return entities.some(isFieldTouched);
        };
        var namePathListEntities = map.map(function(_ref4) {
          var value = _ref4.value;
          return value;
        });
        return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
      });
      _defineProperty(this, "isFieldTouched", function(name) {
        _this.warningUnhooked();
        return _this.isFieldsTouched([name]);
      });
      _defineProperty(this, "isFieldsValidating", function(nameList) {
        _this.warningUnhooked();
        var fieldEntities = _this.getFieldEntities();
        if (!nameList) {
          return fieldEntities.some(function(testField) {
            return testField.isFieldValidating();
          });
        }
        var namePathList = nameList.map(getNamePath);
        return fieldEntities.some(function(testField) {
          var fieldNamePath = testField.getNamePath();
          return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
        });
      });
      _defineProperty(this, "isFieldValidating", function(name) {
        _this.warningUnhooked();
        return _this.isFieldsValidating([name]);
      });
      _defineProperty(this, "resetWithFieldInitialValue", function() {
        var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var cache = new NameMap();
        var fieldEntities = _this.getFieldEntities(true);
        fieldEntities.forEach(function(field) {
          var initialValue2 = field.props.initialValue;
          var namePath = field.getNamePath();
          if (initialValue2 !== void 0) {
            var records = cache.get(namePath) || /* @__PURE__ */ new Set();
            records.add({
              entity: field,
              value: initialValue2
            });
            cache.set(namePath, records);
          }
        });
        var resetWithFields = function resetWithFields2(entities) {
          entities.forEach(function(field) {
            var initialValue2 = field.props.initialValue;
            if (initialValue2 !== void 0) {
              var namePath = field.getNamePath();
              var formInitialValue = _this.getInitialValue(namePath);
              if (formInitialValue !== void 0) {
                warningOnce$1(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
              } else {
                var records = cache.get(namePath);
                if (records && records.size > 1) {
                  warningOnce$1(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
                } else if (records) {
                  var originValue = _this.getFieldValue(namePath);
                  var isListField = field.isListField();
                  if (!isListField && (!info.skipExist || originValue === void 0)) {
                    _this.updateStore(set(_this.store, namePath, _toConsumableArray(records)[0].value));
                  }
                }
              }
            }
          });
        };
        var requiredFieldEntities;
        if (info.entities) {
          requiredFieldEntities = info.entities;
        } else if (info.namePathList) {
          requiredFieldEntities = [];
          info.namePathList.forEach(function(namePath) {
            var records = cache.get(namePath);
            if (records) {
              var _requiredFieldEntitie;
              (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
                return r2.entity;
              })));
            }
          });
        } else {
          requiredFieldEntities = fieldEntities;
        }
        resetWithFields(requiredFieldEntities);
      });
      _defineProperty(this, "resetFields", function(nameList) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        if (!nameList) {
          _this.updateStore(merge$1(_this.initialValues));
          _this.resetWithFieldInitialValue();
          _this.notifyObservers(prevStore, null, {
            type: "reset"
          });
          _this.notifyWatch();
          return;
        }
        var namePathList = nameList.map(getNamePath);
        namePathList.forEach(function(namePath) {
          var initialValue2 = _this.getInitialValue(namePath);
          _this.updateStore(set(_this.store, namePath, initialValue2));
        });
        _this.resetWithFieldInitialValue({
          namePathList
        });
        _this.notifyObservers(prevStore, namePathList, {
          type: "reset"
        });
        _this.notifyWatch(namePathList);
      });
      _defineProperty(this, "setFields", function(fields) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        var namePathList = [];
        fields.forEach(function(fieldData) {
          var name = fieldData.name, data = _objectWithoutProperties(fieldData, _excluded$C);
          var namePath = getNamePath(name);
          namePathList.push(namePath);
          if ("value" in data) {
            _this.updateStore(set(_this.store, namePath, data.value));
          }
          _this.notifyObservers(prevStore, [namePath], {
            type: "setField",
            data: fieldData
          });
        });
        _this.notifyWatch(namePathList);
      });
      _defineProperty(this, "getFields", function() {
        var entities = _this.getFieldEntities(true);
        var fields = entities.map(function(field) {
          var namePath = field.getNamePath();
          var meta = field.getMeta();
          var fieldData = _objectSpread2$3(_objectSpread2$3({}, meta), {}, {
            name: namePath,
            value: _this.getFieldValue(namePath)
          });
          Object.defineProperty(fieldData, "originRCField", {
            value: true
          });
          return fieldData;
        });
        return fields;
      });
      _defineProperty(this, "initEntityValue", function(entity) {
        var initialValue2 = entity.props.initialValue;
        if (initialValue2 !== void 0) {
          var namePath = entity.getNamePath();
          var prevValue = get(_this.store, namePath);
          if (prevValue === void 0) {
            _this.updateStore(set(_this.store, namePath, initialValue2));
          }
        }
      });
      _defineProperty(this, "isMergedPreserve", function(fieldPreserve) {
        var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
        return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
      });
      _defineProperty(this, "registerField", function(entity) {
        _this.fieldEntities.push(entity);
        var namePath = entity.getNamePath();
        _this.notifyWatch([namePath]);
        if (entity.props.initialValue !== void 0) {
          var prevStore = _this.store;
          _this.resetWithFieldInitialValue({
            entities: [entity],
            skipExist: true
          });
          _this.notifyObservers(prevStore, [entity.getNamePath()], {
            type: "valueUpdate",
            source: "internal"
          });
        }
        return function(isListField, preserve2) {
          var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          _this.fieldEntities = _this.fieldEntities.filter(function(item) {
            return item !== entity;
          });
          if (!_this.isMergedPreserve(preserve2) && (!isListField || subNamePath.length > 1)) {
            var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
            if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
              return (
                // Only reset when no namePath exist
                !matchNamePath(field.getNamePath(), namePath)
              );
            })) {
              var _prevStore = _this.store;
              _this.updateStore(set(_prevStore, namePath, defaultValue, true));
              _this.notifyObservers(_prevStore, [namePath], {
                type: "remove"
              });
              _this.triggerDependenciesUpdate(_prevStore, namePath);
            }
          }
          _this.notifyWatch([namePath]);
        };
      });
      _defineProperty(this, "dispatch", function(action) {
        switch (action.type) {
          case "updateValue": {
            var namePath = action.namePath, value = action.value;
            _this.updateValue(namePath, value);
            break;
          }
          case "validateField": {
            var _namePath = action.namePath, triggerName = action.triggerName;
            _this.validateFields([_namePath], {
              triggerName
            });
            break;
          }
        }
      });
      _defineProperty(this, "notifyObservers", function(prevStore, namePathList, info) {
        if (_this.subscribable) {
          var mergedInfo = _objectSpread2$3(_objectSpread2$3({}, info), {}, {
            store: _this.getFieldsValue(true)
          });
          _this.getFieldEntities().forEach(function(_ref5) {
            var onStoreChange = _ref5.onStoreChange;
            onStoreChange(prevStore, namePathList, mergedInfo);
          });
        } else {
          _this.forceRootUpdate();
        }
      });
      _defineProperty(this, "triggerDependenciesUpdate", function(prevStore, namePath) {
        var childrenFields = _this.getDependencyChildrenFields(namePath);
        if (childrenFields.length) {
          _this.validateFields(childrenFields);
        }
        _this.notifyObservers(prevStore, childrenFields, {
          type: "dependenciesUpdate",
          relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
        });
        return childrenFields;
      });
      _defineProperty(this, "updateValue", function(name, value) {
        var namePath = getNamePath(name);
        var prevStore = _this.store;
        _this.updateStore(set(_this.store, namePath, value));
        _this.notifyObservers(prevStore, [namePath], {
          type: "valueUpdate",
          source: "internal"
        });
        _this.notifyWatch([namePath]);
        var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
        var onValuesChange = _this.callbacks.onValuesChange;
        if (onValuesChange) {
          var changedValues = cloneByNamePathList(_this.store, [namePath]);
          onValuesChange(changedValues, _this.getFieldsValue());
        }
        _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
      });
      _defineProperty(this, "setFieldsValue", function(store) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        if (store) {
          var nextStore = merge$1(_this.store, store);
          _this.updateStore(nextStore);
        }
        _this.notifyObservers(prevStore, null, {
          type: "valueUpdate",
          source: "external"
        });
        _this.notifyWatch();
      });
      _defineProperty(this, "setFieldValue", function(name, value) {
        _this.setFields([{
          name,
          value,
          errors: [],
          warnings: []
        }]);
      });
      _defineProperty(this, "getDependencyChildrenFields", function(rootNamePath) {
        var children = /* @__PURE__ */ new Set();
        var childrenFields = [];
        var dependencies2fields = new NameMap();
        _this.getFieldEntities().forEach(function(field) {
          var dependencies = field.props.dependencies;
          (dependencies || []).forEach(function(dependency) {
            var dependencyNamePath = getNamePath(dependency);
            dependencies2fields.update(dependencyNamePath, function() {
              var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
              fields.add(field);
              return fields;
            });
          });
        });
        var fillChildren = function fillChildren2(namePath) {
          var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
          fields.forEach(function(field) {
            if (!children.has(field)) {
              children.add(field);
              var fieldNamePath = field.getNamePath();
              if (field.isFieldDirty() && fieldNamePath.length) {
                childrenFields.push(fieldNamePath);
                fillChildren2(fieldNamePath);
              }
            }
          });
        };
        fillChildren(rootNamePath);
        return childrenFields;
      });
      _defineProperty(this, "triggerOnFieldsChange", function(namePathList, filedErrors) {
        var onFieldsChange = _this.callbacks.onFieldsChange;
        if (onFieldsChange) {
          var fields = _this.getFields();
          if (filedErrors) {
            var cache = new NameMap();
            filedErrors.forEach(function(_ref6) {
              var name = _ref6.name, errors = _ref6.errors;
              cache.set(name, errors);
            });
            fields.forEach(function(field) {
              field.errors = cache.get(field.name) || field.errors;
            });
          }
          var changedFields = fields.filter(function(_ref7) {
            var fieldName = _ref7.name;
            return containsNamePath(namePathList, fieldName);
          });
          if (changedFields.length) {
            onFieldsChange(changedFields, fields);
          }
        }
      });
      _defineProperty(this, "validateFields", function(arg1, arg2) {
        _this.warningUnhooked();
        var nameList;
        var options2;
        if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
          nameList = arg1;
          options2 = arg2;
        } else {
          options2 = arg1;
        }
        var provideNameList = !!nameList;
        var namePathList = provideNameList ? nameList.map(getNamePath) : [];
        var promiseList = [];
        var TMP_SPLIT = String(Date.now());
        var validateNamePathList = /* @__PURE__ */ new Set();
        var _ref8 = options2 || {}, recursive = _ref8.recursive, dirty = _ref8.dirty;
        _this.getFieldEntities(true).forEach(function(field) {
          if (!provideNameList) {
            namePathList.push(field.getNamePath());
          }
          if (!field.props.rules || !field.props.rules.length) {
            return;
          }
          if (dirty && !field.isFieldDirty()) {
            return;
          }
          var fieldNamePath = field.getNamePath();
          validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));
          if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
            var promise = field.validateRules(_objectSpread2$3({
              validateMessages: _objectSpread2$3(_objectSpread2$3({}, defaultValidateMessages), _this.validateMessages)
            }, options2));
            promiseList.push(promise.then(function() {
              return {
                name: fieldNamePath,
                errors: [],
                warnings: []
              };
            }).catch(function(ruleErrors) {
              var _ruleErrors$forEach;
              var mergedErrors = [];
              var mergedWarnings = [];
              (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function(_ref9) {
                var warningOnly = _ref9.rule.warningOnly, errors = _ref9.errors;
                if (warningOnly) {
                  mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
                } else {
                  mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
                }
              });
              if (mergedErrors.length) {
                return Promise.reject({
                  name: fieldNamePath,
                  errors: mergedErrors,
                  warnings: mergedWarnings
                });
              }
              return {
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              };
            }));
          }
        });
        var summaryPromise = allPromiseFinish(promiseList);
        _this.lastValidatePromise = summaryPromise;
        summaryPromise.catch(function(results) {
          return results;
        }).then(function(results) {
          var resultNamePathList = results.map(function(_ref10) {
            var name = _ref10.name;
            return name;
          });
          _this.notifyObservers(_this.store, resultNamePathList, {
            type: "validateFinish"
          });
          _this.triggerOnFieldsChange(resultNamePathList, results);
        });
        var returnPromise = summaryPromise.then(function() {
          if (_this.lastValidatePromise === summaryPromise) {
            return Promise.resolve(_this.getFieldsValue(namePathList));
          }
          return Promise.reject([]);
        }).catch(function(results) {
          var errorList = results.filter(function(result) {
            return result && result.errors.length;
          });
          return Promise.reject({
            values: _this.getFieldsValue(namePathList),
            errorFields: errorList,
            outOfDate: _this.lastValidatePromise !== summaryPromise
          });
        });
        returnPromise.catch(function(e2) {
          return e2;
        });
        var triggerNamePathList = namePathList.filter(function(namePath) {
          return validateNamePathList.has(namePath.join(TMP_SPLIT));
        });
        _this.triggerOnFieldsChange(triggerNamePathList);
        return returnPromise;
      });
      _defineProperty(this, "submit", function() {
        _this.warningUnhooked();
        _this.validateFields().then(function(values) {
          var onFinish = _this.callbacks.onFinish;
          if (onFinish) {
            try {
              onFinish(values);
            } catch (err) {
              console.error(err);
            }
          }
        }).catch(function(e2) {
          var onFinishFailed = _this.callbacks.onFinishFailed;
          if (onFinishFailed) {
            onFinishFailed(e2);
          }
        });
      });
      this.forceRootUpdate = forceRootUpdate;
    });
    function useForm$1(form) {
      var formRef = reactExports.useRef();
      var _React$useState = reactExports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
      if (!formRef.current) {
        if (form) {
          formRef.current = form;
        } else {
          var forceReRender = function forceReRender2() {
            forceUpdate({});
          };
          var formStore = new FormStore(forceReRender);
          formRef.current = formStore.getForm();
        }
      }
      return [formRef.current];
    }
    var FormContext$1 = /* @__PURE__ */ reactExports.createContext({
      triggerFormChange: function triggerFormChange() {
      },
      triggerFormFinish: function triggerFormFinish() {
      },
      registerForm: function registerForm() {
      },
      unregisterForm: function unregisterForm() {
      }
    });
    var FormProvider$1 = function FormProvider2(_ref) {
      var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
      var formContext = reactExports.useContext(FormContext$1);
      var formsRef = reactExports.useRef({});
      return /* @__PURE__ */ reactExports.createElement(FormContext$1.Provider, {
        value: _objectSpread2$3(_objectSpread2$3({}, formContext), {}, {
          validateMessages: _objectSpread2$3(_objectSpread2$3({}, formContext.validateMessages), validateMessages),
          // =========================================================
          // =                  Global Form Control                  =
          // =========================================================
          triggerFormChange: function triggerFormChange(name, changedFields) {
            if (onFormChange) {
              onFormChange(name, {
                changedFields,
                forms: formsRef.current
              });
            }
            formContext.triggerFormChange(name, changedFields);
          },
          triggerFormFinish: function triggerFormFinish(name, values) {
            if (onFormFinish) {
              onFormFinish(name, {
                values,
                forms: formsRef.current
              });
            }
            formContext.triggerFormFinish(name, values);
          },
          registerForm: function registerForm(name, form) {
            if (name) {
              formsRef.current = _objectSpread2$3(_objectSpread2$3({}, formsRef.current), {}, _defineProperty({}, name, form));
            }
            formContext.registerForm(name, form);
          },
          unregisterForm: function unregisterForm(name) {
            var newForms = _objectSpread2$3({}, formsRef.current);
            delete newForms[name];
            formsRef.current = newForms;
            formContext.unregisterForm(name);
          }
        })
      }, children);
    };
    var _excluded$B = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed", "clearOnDestroy"];
    var Form$3 = function Form2(_ref, ref) {
      var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve2 = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component2 = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, clearOnDestroy = _ref.clearOnDestroy, restProps = _objectWithoutProperties(_ref, _excluded$B);
      var nativeElementRef = reactExports.useRef(null);
      var formContext = reactExports.useContext(FormContext$1);
      var _useForm = useForm$1(form), _useForm2 = _slicedToArray(_useForm, 1), formInstance = _useForm2[0];
      var _getInternalHooks = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _getInternalHooks.useSubscribe, setInitialValues = _getInternalHooks.setInitialValues, setCallbacks = _getInternalHooks.setCallbacks, setValidateMessages = _getInternalHooks.setValidateMessages, setPreserve = _getInternalHooks.setPreserve, destroyForm = _getInternalHooks.destroyForm;
      reactExports.useImperativeHandle(ref, function() {
        return _objectSpread2$3(_objectSpread2$3({}, formInstance), {}, {
          nativeElement: nativeElementRef.current
        });
      });
      reactExports.useEffect(function() {
        formContext.registerForm(name, formInstance);
        return function() {
          formContext.unregisterForm(name);
        };
      }, [formContext, formInstance, name]);
      setValidateMessages(_objectSpread2$3(_objectSpread2$3({}, formContext.validateMessages), validateMessages));
      setCallbacks({
        onValuesChange,
        onFieldsChange: function onFieldsChange(changedFields) {
          formContext.triggerFormChange(name, changedFields);
          if (_onFieldsChange) {
            for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              rest[_key - 1] = arguments[_key];
            }
            _onFieldsChange.apply(void 0, [changedFields].concat(rest));
          }
        },
        onFinish: function onFinish(values) {
          formContext.triggerFormFinish(name, values);
          if (_onFinish) {
            _onFinish(values);
          }
        },
        onFinishFailed
      });
      setPreserve(preserve2);
      var mountRef = reactExports.useRef(null);
      setInitialValues(initialValues, !mountRef.current);
      if (!mountRef.current) {
        mountRef.current = true;
      }
      reactExports.useEffect(
        function() {
          return function() {
            return destroyForm(clearOnDestroy);
          };
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        []
      );
      var childrenNode;
      var childrenRenderProps = typeof children === "function";
      if (childrenRenderProps) {
        var _values = formInstance.getFieldsValue(true);
        childrenNode = children(_values, formInstance);
      } else {
        childrenNode = children;
      }
      useSubscribe(!childrenRenderProps);
      var prevFieldsRef = reactExports.useRef();
      reactExports.useEffect(function() {
        if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
          formInstance.setFields(fields || []);
        }
        prevFieldsRef.current = fields;
      }, [fields, formInstance]);
      var formContextValue = reactExports.useMemo(function() {
        return _objectSpread2$3(_objectSpread2$3({}, formInstance), {}, {
          validateTrigger
        });
      }, [formInstance, validateTrigger]);
      var wrapperNode = /* @__PURE__ */ reactExports.createElement(ListContext$1.Provider, {
        value: null
      }, /* @__PURE__ */ reactExports.createElement(Context$1.Provider, {
        value: formContextValue
      }, childrenNode));
      if (Component2 === false) {
        return wrapperNode;
      }
      return /* @__PURE__ */ reactExports.createElement(Component2, _extends$2({}, restProps, {
        ref: nativeElementRef,
        onSubmit: function onSubmit(event) {
          event.preventDefault();
          event.stopPropagation();
          formInstance.submit();
        },
        onReset: function onReset(event) {
          var _restProps$onReset;
          event.preventDefault();
          formInstance.resetFields();
          (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 || _restProps$onReset.call(restProps, event);
        }
      }), wrapperNode);
    };
    function stringify$1(value) {
      try {
        return JSON.stringify(value);
      } catch (err) {
        return Math.random();
      }
    }
    function useWatch$1() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var dependencies = args[0], _args$ = args[1], _form = _args$ === void 0 ? {} : _args$;
      var options2 = isFormInstance(_form) ? {
        form: _form
      } : _form;
      var form = options2.form;
      var _useState = reactExports.useState(), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue = _useState2[1];
      var valueStr = reactExports.useMemo(function() {
        return stringify$1(value);
      }, [value]);
      var valueStrRef = reactExports.useRef(valueStr);
      valueStrRef.current = valueStr;
      var fieldContext = reactExports.useContext(Context$1);
      var formInstance = form || fieldContext;
      var isValidForm = formInstance && formInstance._init;
      var namePath = getNamePath(dependencies);
      var namePathRef = reactExports.useRef(namePath);
      namePathRef.current = namePath;
      reactExports.useEffect(
        function() {
          if (!isValidForm) {
            return;
          }
          var getFieldsValue = formInstance.getFieldsValue, getInternalHooks = formInstance.getInternalHooks;
          var _getInternalHooks = getInternalHooks(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
          var getWatchValue = function getWatchValue2(values, allValues) {
            var watchValue = options2.preserve ? allValues : values;
            return typeof dependencies === "function" ? dependencies(watchValue) : get(watchValue, namePathRef.current);
          };
          var cancelRegister = registerWatch(function(values, allValues) {
            var newValue = getWatchValue(values, allValues);
            var nextValueStr = stringify$1(newValue);
            if (valueStrRef.current !== nextValueStr) {
              valueStrRef.current = nextValueStr;
              setValue(newValue);
            }
          });
          var initialValue2 = getWatchValue(getFieldsValue(), getFieldsValue(true));
          if (value !== initialValue2) {
            setValue(initialValue2);
          }
          return cancelRegister;
        },
        // We do not need re-register since namePath content is the same
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [isValidForm]
      );
      return value;
    }
    var InternalForm$1 = /* @__PURE__ */ reactExports.forwardRef(Form$3);
    var RefForm = InternalForm$1;
    RefForm.FormProvider = FormProvider$1;
    RefForm.Field = WrapperField;
    RefForm.List = List$2;
    RefForm.useForm = useForm$1;
    RefForm.useWatch = useWatch$1;
    const FormContext = /* @__PURE__ */ reactExports.createContext({
      labelAlign: "right",
      vertical: false,
      itemRef: () => {
      }
    });
    const NoStyleItemContext = /* @__PURE__ */ reactExports.createContext(null);
    const FormProvider = (props) => {
      const providerProps = omit(props, ["prefixCls"]);
      return /* @__PURE__ */ reactExports.createElement(FormProvider$1, Object.assign({}, providerProps));
    };
    const FormItemPrefixContext = /* @__PURE__ */ reactExports.createContext({
      prefixCls: ""
    });
    const FormItemInputContext = /* @__PURE__ */ reactExports.createContext({});
    const NoFormStyle = (_ref) => {
      let {
        children,
        status,
        override
      } = _ref;
      const formItemInputContext = reactExports.useContext(FormItemInputContext);
      const newFormItemInputContext = reactExports.useMemo(() => {
        const newContext = Object.assign({}, formItemInputContext);
        if (override) {
          delete newContext.isFormItemInput;
        }
        if (status) {
          delete newContext.status;
          delete newContext.hasFeedback;
          delete newContext.feedbackIcon;
        }
        return newContext;
      }, [status, override, formItemInputContext]);
      return /* @__PURE__ */ reactExports.createElement(FormItemInputContext.Provider, {
        value: newFormItemInputContext
      }, children);
    };
    const VariantContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const ContextIsolator = (props) => {
      const {
        space,
        form,
        children
      } = props;
      if (children === void 0 || children === null) {
        return null;
      }
      let result = children;
      if (form) {
        result = /* @__PURE__ */ i.createElement(NoFormStyle, {
          override: true,
          status: true
        }, result);
      }
      if (space) {
        result = /* @__PURE__ */ i.createElement(NoCompactStyle, null, result);
      }
      return result;
    };
    function pickClosable(context) {
      if (!context) {
        return void 0;
      }
      return {
        closable: context.closable,
        closeIcon: context.closeIcon
      };
    }
    function useClosableConfig(closableCollection) {
      const {
        closable,
        closeIcon
      } = closableCollection || {};
      return i.useMemo(() => {
        if (
          // If `closable`, whatever rest be should be true
          !closable && (closable === false || closeIcon === false || closeIcon === null)
        ) {
          return false;
        }
        if (closable === void 0 && closeIcon === void 0) {
          return null;
        }
        let closableConfig = {
          closeIcon: typeof closeIcon !== "boolean" && closeIcon !== null ? closeIcon : void 0
        };
        if (closable && typeof closable === "object") {
          closableConfig = Object.assign(Object.assign({}, closableConfig), closable);
        }
        return closableConfig;
      }, [closable, closeIcon]);
    }
    function assignWithoutUndefined() {
      const target = {};
      for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
        objList[_key] = arguments[_key];
      }
      objList.forEach((obj) => {
        if (obj) {
          Object.keys(obj).forEach((key) => {
            if (obj[key] !== void 0) {
              target[key] = obj[key];
            }
          });
        }
      });
      return target;
    }
    const EmptyFallbackCloseCollection = {};
    function useClosable(propCloseCollection, contextCloseCollection) {
      let fallbackCloseCollection = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EmptyFallbackCloseCollection;
      const propCloseConfig = useClosableConfig(propCloseCollection);
      const contextCloseConfig = useClosableConfig(contextCloseCollection);
      const closeBtnIsDisabled = typeof propCloseConfig !== "boolean" ? !!(propCloseConfig === null || propCloseConfig === void 0 ? void 0 : propCloseConfig.disabled) : false;
      const mergedFallbackCloseCollection = i.useMemo(() => Object.assign({
        closeIcon: /* @__PURE__ */ i.createElement(RefIcon$A, null)
      }, fallbackCloseCollection), [fallbackCloseCollection]);
      const mergedClosableConfig = i.useMemo(() => {
        if (propCloseConfig === false) {
          return false;
        }
        if (propCloseConfig) {
          return assignWithoutUndefined(mergedFallbackCloseCollection, contextCloseConfig, propCloseConfig);
        }
        if (contextCloseConfig === false) {
          return false;
        }
        if (contextCloseConfig) {
          return assignWithoutUndefined(mergedFallbackCloseCollection, contextCloseConfig);
        }
        return !mergedFallbackCloseCollection.closable ? false : mergedFallbackCloseCollection;
      }, [propCloseConfig, contextCloseConfig, mergedFallbackCloseCollection]);
      return i.useMemo(() => {
        if (mergedClosableConfig === false) {
          return [false, null, closeBtnIsDisabled];
        }
        const {
          closeIconRender
        } = mergedFallbackCloseCollection;
        const {
          closeIcon
        } = mergedClosableConfig;
        let mergedCloseIcon = closeIcon;
        if (mergedCloseIcon !== null && mergedCloseIcon !== void 0) {
          if (closeIconRender) {
            mergedCloseIcon = closeIconRender(closeIcon);
          }
          const ariaProps = pickAttrs(mergedClosableConfig, true);
          if (Object.keys(ariaProps).length) {
            mergedCloseIcon = /* @__PURE__ */ i.isValidElement(mergedCloseIcon) ? /* @__PURE__ */ i.cloneElement(mergedCloseIcon, ariaProps) : /* @__PURE__ */ i.createElement("span", Object.assign({}, ariaProps), mergedCloseIcon);
          }
        }
        return [true, mergedCloseIcon, closeBtnIsDisabled];
      }, [mergedClosableConfig, mergedFallbackCloseCollection]);
    }
    var isStyleNameSupport = function isStyleNameSupport2(styleName) {
      if (canUseDom$2() && window.document.documentElement) {
        var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
        var documentElement = window.document.documentElement;
        return styleNameList.some(function(name) {
          return name in documentElement.style;
        });
      }
      return false;
    };
    function isStyleSupport(styleName, styleValue) {
      return isStyleNameSupport(styleName);
    }
    const canUseDocElement = () => canUseDom$2() && window.document.documentElement;
    const Element$2 = (props) => {
      const {
        prefixCls,
        className,
        style: style2,
        size,
        shape
      } = props;
      const sizeCls = classNames({
        [`${prefixCls}-lg`]: size === "large",
        [`${prefixCls}-sm`]: size === "small"
      });
      const shapeCls = classNames({
        [`${prefixCls}-circle`]: shape === "circle",
        [`${prefixCls}-square`]: shape === "square",
        [`${prefixCls}-round`]: shape === "round"
      });
      const sizeStyle = reactExports.useMemo(() => typeof size === "number" ? {
        width: size,
        height: size,
        lineHeight: `${size}px`
      } : {}, [size]);
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(prefixCls, sizeCls, shapeCls, className),
        style: Object.assign(Object.assign({}, sizeStyle), style2)
      });
    };
    const skeletonClsLoading = new Keyframe(`ant-skeleton-loading`, {
      "0%": {
        backgroundPosition: "100% 50%"
      },
      "100%": {
        backgroundPosition: "0 50%"
      }
    });
    const genSkeletonElementCommonSize = (size) => ({
      height: size,
      lineHeight: unit$1(size)
    });
    const genSkeletonElementAvatarSize = (size) => Object.assign({
      width: size
    }, genSkeletonElementCommonSize(size));
    const genSkeletonColor = (token2) => ({
      background: token2.skeletonLoadingBackground,
      backgroundSize: "400% 100%",
      animationName: skeletonClsLoading,
      animationDuration: token2.skeletonLoadingMotionDuration,
      animationTimingFunction: "ease",
      animationIterationCount: "infinite"
    });
    const genSkeletonElementInputSize = (size, calc) => Object.assign({
      width: calc(size).mul(5).equal(),
      minWidth: calc(size).mul(5).equal()
    }, genSkeletonElementCommonSize(size));
    const genSkeletonElementAvatar = (token2) => {
      const {
        skeletonAvatarCls,
        gradientFromColor,
        controlHeight,
        controlHeightLG,
        controlHeightSM
      } = token2;
      return {
        [skeletonAvatarCls]: Object.assign({
          display: "inline-block",
          verticalAlign: "top",
          background: gradientFromColor
        }, genSkeletonElementAvatarSize(controlHeight)),
        [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
          borderRadius: "50%"
        },
        [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
        [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
      };
    };
    const genSkeletonElementInput = (token2) => {
      const {
        controlHeight,
        borderRadiusSM,
        skeletonInputCls,
        controlHeightLG,
        controlHeightSM,
        gradientFromColor,
        calc
      } = token2;
      return {
        [skeletonInputCls]: Object.assign({
          display: "inline-block",
          verticalAlign: "top",
          background: gradientFromColor,
          borderRadius: borderRadiusSM
        }, genSkeletonElementInputSize(controlHeight, calc)),
        [`${skeletonInputCls}-lg`]: Object.assign({}, genSkeletonElementInputSize(controlHeightLG, calc)),
        [`${skeletonInputCls}-sm`]: Object.assign({}, genSkeletonElementInputSize(controlHeightSM, calc))
      };
    };
    const genSkeletonElementImageSize = (size) => Object.assign({
      width: size
    }, genSkeletonElementCommonSize(size));
    const genSkeletonElementImage = (token2) => {
      const {
        skeletonImageCls,
        imageSizeBase,
        gradientFromColor,
        borderRadiusSM,
        calc
      } = token2;
      return {
        [skeletonImageCls]: Object.assign(Object.assign({
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          verticalAlign: "middle",
          background: gradientFromColor,
          borderRadius: borderRadiusSM
        }, genSkeletonElementImageSize(calc(imageSizeBase).mul(2).equal())), {
          [`${skeletonImageCls}-path`]: {
            fill: "#bfbfbf"
          },
          [`${skeletonImageCls}-svg`]: Object.assign(Object.assign({}, genSkeletonElementImageSize(imageSizeBase)), {
            maxWidth: calc(imageSizeBase).mul(4).equal(),
            maxHeight: calc(imageSizeBase).mul(4).equal()
          }),
          [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
            borderRadius: "50%"
          }
        }),
        [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
          borderRadius: "50%"
        }
      };
    };
    const genSkeletonElementButtonShape = (token2, size, buttonCls) => {
      const {
        skeletonButtonCls
      } = token2;
      return {
        [`${buttonCls}${skeletonButtonCls}-circle`]: {
          width: size,
          minWidth: size,
          borderRadius: "50%"
        },
        [`${buttonCls}${skeletonButtonCls}-round`]: {
          borderRadius: size
        }
      };
    };
    const genSkeletonElementButtonSize = (size, calc) => Object.assign({
      width: calc(size).mul(2).equal(),
      minWidth: calc(size).mul(2).equal()
    }, genSkeletonElementCommonSize(size));
    const genSkeletonElementButton = (token2) => {
      const {
        borderRadiusSM,
        skeletonButtonCls,
        controlHeight,
        controlHeightLG,
        controlHeightSM,
        gradientFromColor,
        calc
      } = token2;
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
        [skeletonButtonCls]: Object.assign({
          display: "inline-block",
          verticalAlign: "top",
          background: gradientFromColor,
          borderRadius: borderRadiusSM,
          width: calc(controlHeight).mul(2).equal(),
          minWidth: calc(controlHeight).mul(2).equal()
        }, genSkeletonElementButtonSize(controlHeight, calc))
      }, genSkeletonElementButtonShape(token2, controlHeight, skeletonButtonCls)), {
        [`${skeletonButtonCls}-lg`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightLG, calc))
      }), genSkeletonElementButtonShape(token2, controlHeightLG, `${skeletonButtonCls}-lg`)), {
        [`${skeletonButtonCls}-sm`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightSM, calc))
      }), genSkeletonElementButtonShape(token2, controlHeightSM, `${skeletonButtonCls}-sm`));
    };
    const genBaseStyle$3 = (token2) => {
      const {
        componentCls,
        skeletonAvatarCls,
        skeletonTitleCls,
        skeletonParagraphCls,
        skeletonButtonCls,
        skeletonInputCls,
        skeletonImageCls,
        controlHeight,
        controlHeightLG,
        controlHeightSM,
        gradientFromColor,
        padding,
        marginSM,
        borderRadius,
        titleHeight,
        blockRadius,
        paragraphLiHeight,
        controlHeightXS,
        paragraphMarginTop
      } = token2;
      return {
        [componentCls]: {
          display: "table",
          width: "100%",
          [`${componentCls}-header`]: {
            display: "table-cell",
            paddingInlineEnd: padding,
            verticalAlign: "top",
            // Avatar
            [skeletonAvatarCls]: Object.assign({
              display: "inline-block",
              verticalAlign: "top",
              background: gradientFromColor
            }, genSkeletonElementAvatarSize(controlHeight)),
            [`${skeletonAvatarCls}-circle`]: {
              borderRadius: "50%"
            },
            [`${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
            [`${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
          },
          [`${componentCls}-content`]: {
            display: "table-cell",
            width: "100%",
            verticalAlign: "top",
            // Title
            [skeletonTitleCls]: {
              width: "100%",
              height: titleHeight,
              background: gradientFromColor,
              borderRadius: blockRadius,
              [`+ ${skeletonParagraphCls}`]: {
                marginBlockStart: controlHeightSM
              }
            },
            // paragraph
            [skeletonParagraphCls]: {
              padding: 0,
              "> li": {
                width: "100%",
                height: paragraphLiHeight,
                listStyle: "none",
                background: gradientFromColor,
                borderRadius: blockRadius,
                "+ li": {
                  marginBlockStart: controlHeightXS
                }
              }
            },
            [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
              width: "61%"
            }
          },
          [`&-round ${componentCls}-content`]: {
            [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
              borderRadius
            }
          }
        },
        [`${componentCls}-with-avatar ${componentCls}-content`]: {
          // Title
          [skeletonTitleCls]: {
            marginBlockStart: marginSM,
            [`+ ${skeletonParagraphCls}`]: {
              marginBlockStart: paragraphMarginTop
            }
          }
        },
        // Skeleton element
        [`${componentCls}${componentCls}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({
          display: "inline-block",
          width: "auto"
        }, genSkeletonElementButton(token2)), genSkeletonElementAvatar(token2)), genSkeletonElementInput(token2)), genSkeletonElementImage(token2)),
        // Skeleton Block Button, Input
        [`${componentCls}${componentCls}-block`]: {
          width: "100%",
          [skeletonButtonCls]: {
            width: "100%"
          },
          [skeletonInputCls]: {
            width: "100%"
          }
        },
        // With active animation
        [`${componentCls}${componentCls}-active`]: {
          [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonImageCls}
      `]: Object.assign({}, genSkeletonColor(token2))
        }
      };
    };
    const prepareComponentToken$j = (token2) => {
      const {
        colorFillContent,
        colorFill
      } = token2;
      const gradientFromColor = colorFillContent;
      const gradientToColor = colorFill;
      return {
        color: gradientFromColor,
        colorGradientEnd: gradientToColor,
        gradientFromColor,
        gradientToColor,
        titleHeight: token2.controlHeight / 2,
        blockRadius: token2.borderRadiusSM,
        paragraphMarginTop: token2.marginLG + token2.marginXXS,
        paragraphLiHeight: token2.controlHeight / 2
      };
    };
    const useStyle$n = genStyleHooks("Skeleton", (token2) => {
      const {
        componentCls,
        calc
      } = token2;
      const skeletonToken = merge(token2, {
        skeletonAvatarCls: `${componentCls}-avatar`,
        skeletonTitleCls: `${componentCls}-title`,
        skeletonParagraphCls: `${componentCls}-paragraph`,
        skeletonButtonCls: `${componentCls}-button`,
        skeletonInputCls: `${componentCls}-input`,
        skeletonImageCls: `${componentCls}-image`,
        imageSizeBase: calc(token2.controlHeight).mul(1.5).equal(),
        borderRadius: 100,
        // Large number to make capsule shape
        skeletonLoadingBackground: `linear-gradient(90deg, ${token2.gradientFromColor} 25%, ${token2.gradientToColor} 37%, ${token2.gradientFromColor} 63%)`,
        skeletonLoadingMotionDuration: "1.4s"
      });
      return [genBaseStyle$3(skeletonToken)];
    }, prepareComponentToken$j, {
      deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]]
    });
    const SkeletonAvatar = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        active,
        shape = "circle",
        size = "default"
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$n(prefixCls);
      const otherProps = omit(props, ["prefixCls", "className"]);
      const cls = classNames(prefixCls, `${prefixCls}-element`, {
        [`${prefixCls}-active`]: active
      }, className, rootClassName, hashId, cssVarCls);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
        className: cls
      }, /* @__PURE__ */ reactExports.createElement(Element$2, Object.assign({
        prefixCls: `${prefixCls}-avatar`,
        shape,
        size
      }, otherProps))));
    };
    const SkeletonButton = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        active,
        block = false,
        size = "default"
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$n(prefixCls);
      const otherProps = omit(props, ["prefixCls"]);
      const cls = classNames(prefixCls, `${prefixCls}-element`, {
        [`${prefixCls}-active`]: active,
        [`${prefixCls}-block`]: block
      }, className, rootClassName, hashId, cssVarCls);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
        className: cls
      }, /* @__PURE__ */ reactExports.createElement(Element$2, Object.assign({
        prefixCls: `${prefixCls}-button`,
        size
      }, otherProps))));
    };
    const path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
    const SkeletonImage = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        style: style2,
        active
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$n(prefixCls);
      const cls = classNames(prefixCls, `${prefixCls}-element`, {
        [`${prefixCls}-active`]: active
      }, className, rootClassName, hashId, cssVarCls);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
        className: cls
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-image`, className),
        style: style2
      }, /* @__PURE__ */ reactExports.createElement("svg", {
        viewBox: "0 0 1098 1024",
        xmlns: "http://www.w3.org/2000/svg",
        className: `${prefixCls}-image-svg`
      }, /* @__PURE__ */ reactExports.createElement("title", null, "Image placeholder"), /* @__PURE__ */ reactExports.createElement("path", {
        d: path,
        className: `${prefixCls}-image-path`
      })))));
    };
    const SkeletonInput = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        active,
        block,
        size = "default"
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$n(prefixCls);
      const otherProps = omit(props, ["prefixCls"]);
      const cls = classNames(prefixCls, `${prefixCls}-element`, {
        [`${prefixCls}-active`]: active,
        [`${prefixCls}-block`]: block
      }, className, rootClassName, hashId, cssVarCls);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
        className: cls
      }, /* @__PURE__ */ reactExports.createElement(Element$2, Object.assign({
        prefixCls: `${prefixCls}-input`,
        size
      }, otherProps))));
    };
    const SkeletonNode = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        style: style2,
        active,
        children
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$n(prefixCls);
      const cls = classNames(prefixCls, `${prefixCls}-element`, {
        [`${prefixCls}-active`]: active
      }, hashId, className, rootClassName, cssVarCls);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
        className: cls
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-image`, className),
        style: style2
      }, children)));
    };
    const getWidth = (index2, props) => {
      const {
        width,
        rows = 2
      } = props;
      if (Array.isArray(width)) {
        return width[index2];
      }
      if (rows - 1 === index2) {
        return width;
      }
      return void 0;
    };
    const Paragraph$2 = (props) => {
      const {
        prefixCls,
        className,
        style: style2,
        rows = 0
      } = props;
      const rowList = Array.from({
        length: rows
      }).map((_2, index2) => (
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ reactExports.createElement("li", {
          key: index2,
          style: {
            width: getWidth(index2, props)
          }
        })
      ));
      return /* @__PURE__ */ reactExports.createElement("ul", {
        className: classNames(prefixCls, className),
        style: style2
      }, rowList);
    };
    const Title$1 = (_ref) => {
      let {
        prefixCls,
        className,
        width,
        style: style2
      } = _ref;
      return (
        // biome-ignore lint/a11y/useHeadingContent: HOC here
        /* @__PURE__ */ reactExports.createElement("h3", {
          className: classNames(prefixCls, className),
          style: Object.assign({
            width
          }, style2)
        })
      );
    };
    function getComponentProps(prop) {
      if (prop && typeof prop === "object") {
        return prop;
      }
      return {};
    }
    function getAvatarBasicProps(hasTitle, hasParagraph) {
      if (hasTitle && !hasParagraph) {
        return {
          size: "large",
          shape: "square"
        };
      }
      return {
        size: "large",
        shape: "circle"
      };
    }
    function getTitleBasicProps(hasAvatar, hasParagraph) {
      if (!hasAvatar && hasParagraph) {
        return {
          width: "38%"
        };
      }
      if (hasAvatar && hasParagraph) {
        return {
          width: "50%"
        };
      }
      return {};
    }
    function getParagraphBasicProps(hasAvatar, hasTitle) {
      const basicProps = {};
      if (!hasAvatar || !hasTitle) {
        basicProps.width = "61%";
      }
      if (!hasAvatar && hasTitle) {
        basicProps.rows = 3;
      } else {
        basicProps.rows = 2;
      }
      return basicProps;
    }
    const Skeleton = (props) => {
      const {
        prefixCls: customizePrefixCls,
        loading,
        className,
        rootClassName,
        style: style2,
        children,
        avatar = false,
        title = true,
        paragraph = true,
        active,
        round: round2
      } = props;
      const {
        getPrefixCls,
        direction,
        className: contextClassName,
        style: contextStyle
      } = useComponentConfig("skeleton");
      const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$n(prefixCls);
      if (loading || !("loading" in props)) {
        const hasAvatar = !!avatar;
        const hasTitle = !!title;
        const hasParagraph = !!paragraph;
        let avatarNode;
        if (hasAvatar) {
          const avatarProps = Object.assign(Object.assign({
            prefixCls: `${prefixCls}-avatar`
          }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
          avatarNode = /* @__PURE__ */ reactExports.createElement("div", {
            className: `${prefixCls}-header`
          }, /* @__PURE__ */ reactExports.createElement(Element$2, Object.assign({}, avatarProps)));
        }
        let contentNode;
        if (hasTitle || hasParagraph) {
          let $title;
          if (hasTitle) {
            const titleProps = Object.assign(Object.assign({
              prefixCls: `${prefixCls}-title`
            }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title));
            $title = /* @__PURE__ */ reactExports.createElement(Title$1, Object.assign({}, titleProps));
          }
          let paragraphNode;
          if (hasParagraph) {
            const paragraphProps = Object.assign(Object.assign({
              prefixCls: `${prefixCls}-paragraph`
            }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph));
            paragraphNode = /* @__PURE__ */ reactExports.createElement(Paragraph$2, Object.assign({}, paragraphProps));
          }
          contentNode = /* @__PURE__ */ reactExports.createElement("div", {
            className: `${prefixCls}-content`
          }, $title, paragraphNode);
        }
        const cls = classNames(prefixCls, {
          [`${prefixCls}-with-avatar`]: hasAvatar,
          [`${prefixCls}-active`]: active,
          [`${prefixCls}-rtl`]: direction === "rtl",
          [`${prefixCls}-round`]: round2
        }, contextClassName, className, rootClassName, hashId, cssVarCls);
        return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
          className: cls,
          style: Object.assign(Object.assign({}, contextStyle), style2)
        }, avatarNode, contentNode));
      }
      return children !== null && children !== void 0 ? children : null;
    };
    Skeleton.Button = SkeletonButton;
    Skeleton.Avatar = SkeletonAvatar;
    Skeleton.Input = SkeletonInput;
    Skeleton.Image = SkeletonImage;
    Skeleton.Node = SkeletonNode;
    function voidFunc() {
    }
    const WatermarkContext = /* @__PURE__ */ reactExports.createContext({
      add: voidFunc,
      remove: voidFunc
    });
    function usePanelRef(panelSelector) {
      const watermark = reactExports.useContext(WatermarkContext);
      const panelEleRef = reactExports.useRef(null);
      const panelRef = useEvent((ele) => {
        if (ele) {
          const innerContentEle = panelSelector ? ele.querySelector(panelSelector) : ele;
          watermark.add(innerContentEle);
          panelEleRef.current = innerContentEle;
        } else {
          watermark.remove(panelEleRef.current);
        }
      });
      return panelRef;
    }
    const NormalCancelBtn = () => {
      const {
        cancelButtonProps,
        cancelTextLocale,
        onCancel
      } = reactExports.useContext(ModalContext);
      return /* @__PURE__ */ i.createElement(Button$1, Object.assign({
        onClick: onCancel
      }, cancelButtonProps), cancelTextLocale);
    };
    const NormalOkBtn = () => {
      const {
        confirmLoading,
        okButtonProps,
        okType,
        okTextLocale,
        onOk
      } = reactExports.useContext(ModalContext);
      return /* @__PURE__ */ i.createElement(Button$1, Object.assign({}, convertLegacyProps(okType), {
        loading: confirmLoading,
        onClick: onOk
      }, okButtonProps), okTextLocale);
    };
    function renderCloseIcon(prefixCls, closeIcon) {
      return /* @__PURE__ */ i.createElement("span", {
        className: `${prefixCls}-close-x`
      }, closeIcon || /* @__PURE__ */ i.createElement(RefIcon$A, {
        className: `${prefixCls}-close-icon`
      }));
    }
    const Footer$1 = (props) => {
      const {
        okText,
        okType = "primary",
        cancelText,
        confirmLoading,
        onOk,
        onCancel,
        okButtonProps,
        cancelButtonProps,
        footer
      } = props;
      const [locale2] = useLocale$1("Modal", getConfirmLocale());
      const okTextLocale = okText || (locale2 === null || locale2 === void 0 ? void 0 : locale2.okText);
      const cancelTextLocale = cancelText || (locale2 === null || locale2 === void 0 ? void 0 : locale2.cancelText);
      const btnCtxValue = {
        confirmLoading,
        okButtonProps,
        cancelButtonProps,
        okTextLocale,
        cancelTextLocale,
        okType,
        onOk,
        onCancel
      };
      const btnCtxValueMemo = i.useMemo(() => btnCtxValue, _toConsumableArray(Object.values(btnCtxValue)));
      let footerNode;
      if (typeof footer === "function" || typeof footer === "undefined") {
        footerNode = /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(NormalCancelBtn, null), /* @__PURE__ */ i.createElement(NormalOkBtn, null));
        if (typeof footer === "function") {
          footerNode = footer(footerNode, {
            OkBtn: NormalOkBtn,
            CancelBtn: NormalCancelBtn
          });
        }
        footerNode = /* @__PURE__ */ i.createElement(ModalContextProvider, {
          value: btnCtxValueMemo
        }, footerNode);
      } else {
        footerNode = footer;
      }
      return /* @__PURE__ */ i.createElement(DisabledContextProvider, {
        disabled: false
      }, footerNode);
    };
    const genGridRowStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        // Grid system
        [componentCls]: {
          display: "flex",
          flexFlow: "row wrap",
          minWidth: 0,
          "&::before, &::after": {
            display: "flex"
          },
          "&-no-wrap": {
            flexWrap: "nowrap"
          },
          // The origin of the X-axis
          "&-start": {
            justifyContent: "flex-start"
          },
          // The center of the X-axis
          "&-center": {
            justifyContent: "center"
          },
          // The opposite of the X-axis
          "&-end": {
            justifyContent: "flex-end"
          },
          "&-space-between": {
            justifyContent: "space-between"
          },
          "&-space-around": {
            justifyContent: "space-around"
          },
          "&-space-evenly": {
            justifyContent: "space-evenly"
          },
          // Align at the top
          "&-top": {
            alignItems: "flex-start"
          },
          // Align at the center
          "&-middle": {
            alignItems: "center"
          },
          "&-bottom": {
            alignItems: "flex-end"
          }
        }
      };
    };
    const genGridColStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        // Grid system
        [componentCls]: {
          position: "relative",
          maxWidth: "100%",
          // Prevent columns from collapsing when empty
          minHeight: 1
        }
      };
    };
    const genLoopGridColumnsStyle = (token2, sizeCls) => {
      const {
        prefixCls,
        componentCls,
        gridColumns
      } = token2;
      const gridColumnsStyle = {};
      for (let i2 = gridColumns; i2 >= 0; i2--) {
        if (i2 === 0) {
          gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
            display: "none"
          };
          gridColumnsStyle[`${componentCls}-push-${i2}`] = {
            insetInlineStart: "auto"
          };
          gridColumnsStyle[`${componentCls}-pull-${i2}`] = {
            insetInlineEnd: "auto"
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
            insetInlineStart: "auto"
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
            insetInlineEnd: "auto"
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
            marginInlineStart: 0
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
            order: 0
          };
        } else {
          gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = [
            // https://github.com/ant-design/ant-design/issues/44456
            // Form set `display: flex` on Col which will override `display: block`.
            // Let's get it from css variable to support override.
            {
              ["--ant-display"]: "block",
              // Fallback to display if variable not support
              display: "block"
            },
            {
              display: "var(--ant-display)",
              flex: `0 0 ${i2 / gridColumns * 100}%`,
              maxWidth: `${i2 / gridColumns * 100}%`
            }
          ];
          gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
            insetInlineStart: `${i2 / gridColumns * 100}%`
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
            insetInlineEnd: `${i2 / gridColumns * 100}%`
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
            marginInlineStart: `${i2 / gridColumns * 100}%`
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
            order: i2
          };
        }
      }
      gridColumnsStyle[`${componentCls}${sizeCls}-flex`] = {
        flex: `var(--${prefixCls}${sizeCls}-flex)`
      };
      return gridColumnsStyle;
    };
    const genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls);
    const genGridMediaStyle = (token2, screenSize, sizeCls) => ({
      [`@media (min-width: ${unit$1(screenSize)})`]: Object.assign({}, genGridStyle(token2, sizeCls))
    });
    const prepareRowComponentToken = () => ({});
    const prepareColComponentToken = () => ({});
    const useRowStyle = genStyleHooks("Grid", genGridRowStyle, prepareRowComponentToken);
    const getMediaSize = (token2) => {
      const mediaSizesMap = {
        xs: token2.screenXSMin,
        sm: token2.screenSMMin,
        md: token2.screenMDMin,
        lg: token2.screenLGMin,
        xl: token2.screenXLMin,
        xxl: token2.screenXXLMin
      };
      return mediaSizesMap;
    };
    const useColStyle = genStyleHooks("Grid", (token2) => {
      const gridToken = merge(token2, {
        gridColumns: 24
        // Row is divided into 24 parts in Grid
      });
      const gridMediaSizesMap = getMediaSize(gridToken);
      delete gridMediaSizesMap.xs;
      return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], `-${key}`)).reduce((pre, cur) => Object.assign(Object.assign({}, pre), cur), {})];
    }, prepareColComponentToken);
    function box(position2) {
      return {
        position: position2,
        inset: 0
      };
    }
    const genModalMaskStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      return [{
        [`${componentCls}-root`]: {
          [`${componentCls}${antCls}-zoom-enter, ${componentCls}${antCls}-zoom-appear`]: {
            // reset scale avoid mousePosition bug
            transform: "none",
            opacity: 0,
            animationDuration: token2.motionDurationSlow,
            // https://github.com/ant-design/ant-design/issues/11777
            userSelect: "none"
          },
          // https://github.com/ant-design/ant-design/issues/37329
          // https://github.com/ant-design/ant-design/issues/40272
          [`${componentCls}${antCls}-zoom-leave ${componentCls}-content`]: {
            pointerEvents: "none"
          },
          [`${componentCls}-mask`]: Object.assign(Object.assign({}, box("fixed")), {
            zIndex: token2.zIndexPopupBase,
            height: "100%",
            backgroundColor: token2.colorBgMask,
            pointerEvents: "none",
            [`${componentCls}-hidden`]: {
              display: "none"
            }
          }),
          [`${componentCls}-wrap`]: Object.assign(Object.assign({}, box("fixed")), {
            zIndex: token2.zIndexPopupBase,
            overflow: "auto",
            outline: 0,
            WebkitOverflowScrolling: "touch"
          })
        }
      }, {
        [`${componentCls}-root`]: initFadeMotion(token2)
      }];
    };
    const genModalStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return [
        // ======================== Root =========================
        {
          [`${componentCls}-root`]: {
            [`${componentCls}-wrap-rtl`]: {
              direction: "rtl"
            },
            [`${componentCls}-centered`]: {
              textAlign: "center",
              "&::before": {
                display: "inline-block",
                width: 0,
                height: "100%",
                verticalAlign: "middle",
                content: '""'
              },
              [componentCls]: {
                top: 0,
                display: "inline-block",
                paddingBottom: 0,
                textAlign: "start",
                verticalAlign: "middle"
              }
            },
            [`@media (max-width: ${token2.screenSMMax}px)`]: {
              [componentCls]: {
                maxWidth: "calc(100vw - 16px)",
                margin: `${unit$1(token2.marginXS)} auto`
              },
              [`${componentCls}-centered`]: {
                [componentCls]: {
                  flex: 1
                }
              }
            }
          }
        },
        // ======================== Modal ========================
        {
          [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
            pointerEvents: "none",
            position: "relative",
            top: 100,
            width: "auto",
            maxWidth: `calc(100vw - ${unit$1(token2.calc(token2.margin).mul(2).equal())})`,
            margin: "0 auto",
            paddingBottom: token2.paddingLG,
            [`${componentCls}-title`]: {
              margin: 0,
              color: token2.titleColor,
              fontWeight: token2.fontWeightStrong,
              fontSize: token2.titleFontSize,
              lineHeight: token2.titleLineHeight,
              wordWrap: "break-word"
            },
            [`${componentCls}-content`]: {
              position: "relative",
              backgroundColor: token2.contentBg,
              backgroundClip: "padding-box",
              border: 0,
              borderRadius: token2.borderRadiusLG,
              boxShadow: token2.boxShadow,
              pointerEvents: "auto",
              padding: token2.contentPadding
            },
            [`${componentCls}-close`]: Object.assign({
              position: "absolute",
              top: token2.calc(token2.modalHeaderHeight).sub(token2.modalCloseBtnSize).div(2).equal(),
              insetInlineEnd: token2.calc(token2.modalHeaderHeight).sub(token2.modalCloseBtnSize).div(2).equal(),
              zIndex: token2.calc(token2.zIndexPopupBase).add(10).equal(),
              padding: 0,
              color: token2.modalCloseIconColor,
              fontWeight: token2.fontWeightStrong,
              lineHeight: 1,
              textDecoration: "none",
              background: "transparent",
              borderRadius: token2.borderRadiusSM,
              width: token2.modalCloseBtnSize,
              height: token2.modalCloseBtnSize,
              border: 0,
              outline: 0,
              cursor: "pointer",
              transition: `color ${token2.motionDurationMid}, background-color ${token2.motionDurationMid}`,
              "&-x": {
                display: "flex",
                fontSize: token2.fontSizeLG,
                fontStyle: "normal",
                lineHeight: unit$1(token2.modalCloseBtnSize),
                justifyContent: "center",
                textTransform: "none",
                textRendering: "auto"
              },
              "&:disabled": {
                pointerEvents: "none"
              },
              "&:hover": {
                color: token2.modalCloseIconHoverColor,
                backgroundColor: token2.colorBgTextHover,
                textDecoration: "none"
              },
              "&:active": {
                backgroundColor: token2.colorBgTextActive
              }
            }, genFocusStyle(token2)),
            [`${componentCls}-header`]: {
              color: token2.colorText,
              background: token2.headerBg,
              borderRadius: `${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0 0`,
              marginBottom: token2.headerMarginBottom,
              padding: token2.headerPadding,
              borderBottom: token2.headerBorderBottom
            },
            [`${componentCls}-body`]: {
              fontSize: token2.fontSize,
              lineHeight: token2.lineHeight,
              wordWrap: "break-word",
              padding: token2.bodyPadding,
              [`${componentCls}-body-skeleton`]: {
                width: "100%",
                height: "100%",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                margin: `${unit$1(token2.margin)} auto`
              }
            },
            [`${componentCls}-footer`]: {
              textAlign: "end",
              background: token2.footerBg,
              marginTop: token2.footerMarginTop,
              padding: token2.footerPadding,
              borderTop: token2.footerBorderTop,
              borderRadius: token2.footerBorderRadius,
              [`> ${token2.antCls}-btn + ${token2.antCls}-btn`]: {
                marginInlineStart: token2.marginXS
              }
            },
            [`${componentCls}-open`]: {
              overflow: "hidden"
            }
          })
        },
        // ======================== Pure =========================
        {
          [`${componentCls}-pure-panel`]: {
            top: "auto",
            padding: 0,
            display: "flex",
            flexDirection: "column",
            [`${componentCls}-content,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
              display: "flex",
              flexDirection: "column",
              flex: "auto"
            },
            [`${componentCls}-confirm-body`]: {
              marginBottom: "auto"
            }
          }
        }
      ];
    };
    const genRTLStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-root`]: {
          [`${componentCls}-wrap-rtl`]: {
            direction: "rtl",
            [`${componentCls}-confirm-body`]: {
              direction: "rtl"
            }
          }
        }
      };
    };
    const genResponsiveWidthStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const gridMediaSizesMap = getMediaSize(token2);
      delete gridMediaSizesMap.xs;
      const responsiveStyles = Object.keys(gridMediaSizesMap).map((key) => ({
        [`@media (min-width: ${unit$1(gridMediaSizesMap[key])})`]: {
          width: `var(--${componentCls.replace(".", "")}-${key}-width)`
        }
      }));
      return {
        [`${componentCls}-root`]: {
          [componentCls]: [{
            width: `var(--${componentCls.replace(".", "")}-xs-width)`
          }].concat(_toConsumableArray(responsiveStyles))
        }
      };
    };
    const prepareToken$3 = (token2) => {
      const headerPaddingVertical = token2.padding;
      const headerFontSize = token2.fontSizeHeading5;
      const headerLineHeight = token2.lineHeightHeading5;
      const modalToken = merge(token2, {
        modalHeaderHeight: token2.calc(token2.calc(headerLineHeight).mul(headerFontSize).equal()).add(token2.calc(headerPaddingVertical).mul(2).equal()).equal(),
        modalFooterBorderColorSplit: token2.colorSplit,
        modalFooterBorderStyle: token2.lineType,
        modalFooterBorderWidth: token2.lineWidth,
        modalCloseIconColor: token2.colorIcon,
        modalCloseIconHoverColor: token2.colorIconHover,
        modalCloseBtnSize: token2.controlHeight,
        modalConfirmIconSize: token2.fontHeight,
        modalTitleHeight: token2.calc(token2.titleFontSize).mul(token2.titleLineHeight).equal()
      });
      return modalToken;
    };
    const prepareComponentToken$i = (token2) => ({
      footerBg: "transparent",
      headerBg: token2.colorBgElevated,
      titleLineHeight: token2.lineHeightHeading5,
      titleFontSize: token2.fontSizeHeading5,
      contentBg: token2.colorBgElevated,
      titleColor: token2.colorTextHeading,
      // internal
      contentPadding: token2.wireframe ? 0 : `${unit$1(token2.paddingMD)} ${unit$1(token2.paddingContentHorizontalLG)}`,
      headerPadding: token2.wireframe ? `${unit$1(token2.padding)} ${unit$1(token2.paddingLG)}` : 0,
      headerBorderBottom: token2.wireframe ? `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}` : "none",
      headerMarginBottom: token2.wireframe ? 0 : token2.marginXS,
      bodyPadding: token2.wireframe ? token2.paddingLG : 0,
      footerPadding: token2.wireframe ? `${unit$1(token2.paddingXS)} ${unit$1(token2.padding)}` : 0,
      footerBorderTop: token2.wireframe ? `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}` : "none",
      footerBorderRadius: token2.wireframe ? `0 0 ${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)}` : 0,
      footerMarginTop: token2.wireframe ? 0 : token2.marginSM,
      confirmBodyPadding: token2.wireframe ? `${unit$1(token2.padding * 2)} ${unit$1(token2.padding * 2)} ${unit$1(token2.paddingLG)}` : 0,
      confirmIconMarginInlineEnd: token2.wireframe ? token2.margin : token2.marginSM,
      confirmBtnsMarginTop: token2.wireframe ? token2.marginLG : token2.marginSM
    });
    const useStyle$m = genStyleHooks("Modal", (token2) => {
      const modalToken = prepareToken$3(token2);
      return [genModalStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), initZoomMotion(modalToken, "zoom"), genResponsiveWidthStyle(modalToken)];
    }, prepareComponentToken$i, {
      unitless: {
        titleLineHeight: true
      }
    });
    var __rest$N = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    let mousePosition;
    const getClickPosition = (e2) => {
      mousePosition = {
        x: e2.pageX,
        y: e2.pageY
      };
      setTimeout(() => {
        mousePosition = null;
      }, 100);
    };
    if (canUseDocElement()) {
      document.documentElement.addEventListener("click", getClickPosition, true);
    }
    const Modal$1 = (props) => {
      var _a;
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        direction,
        modal: modalContext
      } = reactExports.useContext(ConfigContext);
      const handleCancel = (e2) => {
        const {
          onCancel
        } = props;
        onCancel === null || onCancel === void 0 ? void 0 : onCancel(e2);
      };
      const handleOk = (e2) => {
        const {
          onOk
        } = props;
        onOk === null || onOk === void 0 ? void 0 : onOk(e2);
      };
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        open: open2,
        wrapClassName,
        centered,
        getContainer: getContainer2,
        focusTriggerAfterClose = true,
        style: style2,
        // Deprecated
        visible,
        width = 520,
        footer,
        classNames: modalClassNames,
        styles: modalStyles,
        children,
        loading
      } = props, restProps = __rest$N(props, ["prefixCls", "className", "rootClassName", "open", "wrapClassName", "centered", "getContainer", "focusTriggerAfterClose", "style", "visible", "width", "footer", "classNames", "styles", "children", "loading"]);
      const prefixCls = getPrefixCls("modal", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$m(prefixCls, rootCls);
      const wrapClassNameExtended = classNames(wrapClassName, {
        [`${prefixCls}-centered`]: centered !== null && centered !== void 0 ? centered : modalContext === null || modalContext === void 0 ? void 0 : modalContext.centered,
        [`${prefixCls}-wrap-rtl`]: direction === "rtl"
      });
      const dialogFooter = footer !== null && !loading ? /* @__PURE__ */ reactExports.createElement(Footer$1, Object.assign({}, props, {
        onOk: handleOk,
        onCancel: handleCancel
      })) : null;
      const [mergedClosable, mergedCloseIcon, closeBtnIsDisabled] = useClosable(pickClosable(props), pickClosable(modalContext), {
        closable: true,
        closeIcon: /* @__PURE__ */ reactExports.createElement(RefIcon$A, {
          className: `${prefixCls}-close-icon`
        }),
        closeIconRender: (icon) => renderCloseIcon(prefixCls, icon)
      });
      const panelRef = usePanelRef(`.${prefixCls}-content`);
      const [zIndex, contextZIndex] = useZIndex("Modal", restProps.zIndex);
      const [numWidth, responsiveWidth] = reactExports.useMemo(() => {
        if (width && typeof width === "object") {
          return [void 0, width];
        }
        return [width, void 0];
      }, [width]);
      const responsiveWidthVars = reactExports.useMemo(() => {
        const vars = {};
        if (responsiveWidth) {
          Object.keys(responsiveWidth).forEach((breakpoint) => {
            const breakpointWidth = responsiveWidth[breakpoint];
            if (breakpointWidth !== void 0) {
              vars[`--${prefixCls}-${breakpoint}-width`] = typeof breakpointWidth === "number" ? `${breakpointWidth}px` : breakpointWidth;
            }
          });
        }
        return vars;
      }, [responsiveWidth]);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(ContextIsolator, {
        form: true,
        space: true
      }, /* @__PURE__ */ reactExports.createElement(zIndexContext.Provider, {
        value: contextZIndex
      }, /* @__PURE__ */ reactExports.createElement(DialogWrap, Object.assign({
        width: numWidth
      }, restProps, {
        zIndex,
        getContainer: getContainer2 === void 0 ? getContextPopupContainer : getContainer2,
        prefixCls,
        rootClassName: classNames(hashId, rootClassName, cssVarCls, rootCls),
        footer: dialogFooter,
        visible: open2 !== null && open2 !== void 0 ? open2 : visible,
        mousePosition: (_a = restProps.mousePosition) !== null && _a !== void 0 ? _a : mousePosition,
        onClose: handleCancel,
        closable: mergedClosable ? {
          disabled: closeBtnIsDisabled,
          closeIcon: mergedCloseIcon
        } : mergedClosable,
        closeIcon: mergedCloseIcon,
        focusTriggerAfterClose,
        transitionName: getTransitionName(rootPrefixCls, "zoom", props.transitionName),
        maskTransitionName: getTransitionName(rootPrefixCls, "fade", props.maskTransitionName),
        className: classNames(hashId, className, modalContext === null || modalContext === void 0 ? void 0 : modalContext.className),
        style: Object.assign(Object.assign(Object.assign({}, modalContext === null || modalContext === void 0 ? void 0 : modalContext.style), style2), responsiveWidthVars),
        classNames: Object.assign(Object.assign(Object.assign({}, modalContext === null || modalContext === void 0 ? void 0 : modalContext.classNames), modalClassNames), {
          wrapper: classNames(wrapClassNameExtended, modalClassNames === null || modalClassNames === void 0 ? void 0 : modalClassNames.wrapper)
        }),
        styles: Object.assign(Object.assign({}, modalContext === null || modalContext === void 0 ? void 0 : modalContext.styles), modalStyles),
        panelRef
      }), loading ? /* @__PURE__ */ reactExports.createElement(Skeleton, {
        active: true,
        title: false,
        paragraph: {
          rows: 4
        },
        className: `${prefixCls}-body-skeleton`
      }) : children))));
    };
    const genModalConfirmStyle = (token2) => {
      const {
        componentCls,
        titleFontSize,
        titleLineHeight,
        modalConfirmIconSize,
        fontSize,
        lineHeight,
        modalTitleHeight,
        fontHeight,
        confirmBodyPadding
      } = token2;
      const confirmComponentCls = `${componentCls}-confirm`;
      return {
        [confirmComponentCls]: {
          "&-rtl": {
            direction: "rtl"
          },
          [`${token2.antCls}-modal-header`]: {
            display: "none"
          },
          [`${confirmComponentCls}-body-wrapper`]: Object.assign({}, clearFix()),
          [`&${componentCls} ${componentCls}-body`]: {
            padding: confirmBodyPadding
          },
          // ====================== Body ======================
          [`${confirmComponentCls}-body`]: {
            display: "flex",
            flexWrap: "nowrap",
            alignItems: "start",
            [`> ${token2.iconCls}`]: {
              flex: "none",
              fontSize: modalConfirmIconSize,
              marginInlineEnd: token2.confirmIconMarginInlineEnd,
              marginTop: token2.calc(token2.calc(fontHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
            },
            [`&-has-title > ${token2.iconCls}`]: {
              marginTop: token2.calc(token2.calc(modalTitleHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
            }
          },
          [`${confirmComponentCls}-paragraph`]: {
            display: "flex",
            flexDirection: "column",
            flex: "auto",
            rowGap: token2.marginXS,
            // https://github.com/ant-design/ant-design/issues/51912
            maxWidth: `calc(100% - ${unit$1(token2.marginSM)})`
          },
          // https://github.com/ant-design/ant-design/issues/48159
          [`${token2.iconCls} + ${confirmComponentCls}-paragraph`]: {
            maxWidth: `calc(100% - ${unit$1(token2.calc(token2.modalConfirmIconSize).add(token2.marginSM).equal())})`
          },
          [`${confirmComponentCls}-title`]: {
            color: token2.colorTextHeading,
            fontWeight: token2.fontWeightStrong,
            fontSize: titleFontSize,
            lineHeight: titleLineHeight
          },
          [`${confirmComponentCls}-content`]: {
            color: token2.colorText,
            fontSize,
            lineHeight
          },
          // ===================== Footer =====================
          [`${confirmComponentCls}-btns`]: {
            textAlign: "end",
            marginTop: token2.confirmBtnsMarginTop,
            [`${token2.antCls}-btn + ${token2.antCls}-btn`]: {
              marginBottom: 0,
              marginInlineStart: token2.marginXS
            }
          }
        },
        [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token2.iconCls}`]: {
          color: token2.colorError
        },
        [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token2.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token2.iconCls}`]: {
          color: token2.colorWarning
        },
        [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token2.iconCls}`]: {
          color: token2.colorInfo
        },
        [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token2.iconCls}`]: {
          color: token2.colorSuccess
        }
      };
    };
    const Confirm = genSubStyleComponent(["Modal", "confirm"], (token2) => {
      const modalToken = prepareToken$3(token2);
      return [genModalConfirmStyle(modalToken)];
    }, prepareComponentToken$i, {
      // confirm is weak than modal since no conflict here
      order: -1e3
    });
    var __rest$M = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function ConfirmContent(props) {
      const {
        prefixCls,
        icon,
        okText,
        cancelText,
        confirmPrefixCls,
        type: type2,
        okCancel,
        footer,
        // Legacy for static function usage
        locale: staticLocale
      } = props, resetProps = __rest$M(props, ["prefixCls", "icon", "okText", "cancelText", "confirmPrefixCls", "type", "okCancel", "footer", "locale"]);
      let mergedIcon = icon;
      if (!icon && icon !== null) {
        switch (type2) {
          case "info":
            mergedIcon = /* @__PURE__ */ reactExports.createElement(RefIcon$y, null);
            break;
          case "success":
            mergedIcon = /* @__PURE__ */ reactExports.createElement(RefIcon$C, null);
            break;
          case "error":
            mergedIcon = /* @__PURE__ */ reactExports.createElement(RefIcon$B, null);
            break;
          default:
            mergedIcon = /* @__PURE__ */ reactExports.createElement(RefIcon$z, null);
        }
      }
      const mergedOkCancel = okCancel !== null && okCancel !== void 0 ? okCancel : type2 === "confirm";
      const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || "ok";
      const [locale2] = useLocale$1("Modal");
      const mergedLocale = staticLocale || locale2;
      const okTextLocale = okText || (mergedOkCancel ? mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.okText : mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.justOkText);
      const cancelTextLocale = cancelText || (mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.cancelText);
      const btnCtxValue = Object.assign({
        autoFocusButton,
        cancelTextLocale,
        okTextLocale,
        mergedOkCancel
      }, resetProps);
      const btnCtxValueMemo = reactExports.useMemo(() => btnCtxValue, _toConsumableArray(Object.values(btnCtxValue)));
      const footerOriginNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(ConfirmCancelBtn, null), /* @__PURE__ */ reactExports.createElement(ConfirmOkBtn, null));
      const hasTitle = props.title !== void 0 && props.title !== null;
      const bodyCls = `${confirmPrefixCls}-body`;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: `${confirmPrefixCls}-body-wrapper`
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(bodyCls, {
          [`${bodyCls}-has-title`]: hasTitle
        })
      }, mergedIcon, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${confirmPrefixCls}-paragraph`
      }, hasTitle && /* @__PURE__ */ reactExports.createElement("span", {
        className: `${confirmPrefixCls}-title`
      }, props.title), /* @__PURE__ */ reactExports.createElement("div", {
        className: `${confirmPrefixCls}-content`
      }, props.content))), footer === void 0 || typeof footer === "function" ? /* @__PURE__ */ reactExports.createElement(ModalContextProvider, {
        value: btnCtxValueMemo
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${confirmPrefixCls}-btns`
      }, typeof footer === "function" ? footer(footerOriginNode, {
        OkBtn: ConfirmOkBtn,
        CancelBtn: ConfirmCancelBtn
      }) : footerOriginNode)) : footer, /* @__PURE__ */ reactExports.createElement(Confirm, {
        prefixCls
      }));
    }
    const ConfirmDialog = (props) => {
      const {
        close,
        zIndex,
        maskStyle,
        direction,
        prefixCls,
        wrapClassName,
        rootPrefixCls,
        bodyStyle,
        closable = false,
        onConfirm,
        styles
      } = props;
      const confirmPrefixCls = `${prefixCls}-confirm`;
      const width = props.width || 416;
      const style2 = props.style || {};
      const mask = props.mask === void 0 ? true : props.mask;
      const maskClosable = props.maskClosable === void 0 ? false : props.maskClosable;
      const classString = classNames(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, {
        [`${confirmPrefixCls}-rtl`]: direction === "rtl"
      }, props.className);
      const [, token2] = useToken();
      const mergedZIndex = reactExports.useMemo(() => {
        if (zIndex !== void 0) {
          return zIndex;
        }
        return token2.zIndexPopupBase + CONTAINER_MAX_OFFSET;
      }, [zIndex, token2]);
      return /* @__PURE__ */ reactExports.createElement(Modal$1, Object.assign({}, props, {
        className: classString,
        wrapClassName: classNames({
          [`${confirmPrefixCls}-centered`]: !!props.centered
        }, wrapClassName),
        onCancel: () => {
          close === null || close === void 0 ? void 0 : close({
            triggerCancel: true
          });
          onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm(false);
        },
        title: "",
        footer: null,
        transitionName: getTransitionName(rootPrefixCls || "", "zoom", props.transitionName),
        maskTransitionName: getTransitionName(rootPrefixCls || "", "fade", props.maskTransitionName),
        mask,
        maskClosable,
        style: style2,
        styles: Object.assign({
          body: bodyStyle,
          mask: maskStyle
        }, styles),
        width,
        zIndex: mergedZIndex,
        closable
      }), /* @__PURE__ */ reactExports.createElement(ConfirmContent, Object.assign({}, props, {
        confirmPrefixCls
      })));
    };
    const ConfirmDialogWrapper$1 = (props) => {
      const {
        rootPrefixCls,
        iconPrefixCls,
        direction,
        theme
      } = props;
      return /* @__PURE__ */ reactExports.createElement(ConfigProvider, {
        prefixCls: rootPrefixCls,
        iconPrefixCls,
        direction,
        theme
      }, /* @__PURE__ */ reactExports.createElement(ConfirmDialog, Object.assign({}, props)));
    };
    const destroyFns = [];
    let defaultRootPrefixCls = "";
    function getRootPrefixCls() {
      return defaultRootPrefixCls;
    }
    const ConfirmDialogWrapper = (props) => {
      var _a, _b;
      const {
        prefixCls: customizePrefixCls,
        getContainer: getContainer2,
        direction
      } = props;
      const runtimeLocale2 = getConfirmLocale();
      const config = reactExports.useContext(ConfigContext);
      const rootPrefixCls = getRootPrefixCls() || config.getPrefixCls();
      const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;
      let mergedGetContainer = getContainer2;
      if (mergedGetContainer === false) {
        mergedGetContainer = void 0;
      }
      return /* @__PURE__ */ i.createElement(ConfirmDialogWrapper$1, Object.assign({}, props, {
        rootPrefixCls,
        prefixCls,
        iconPrefixCls: config.iconPrefixCls,
        theme: config.theme,
        direction: direction !== null && direction !== void 0 ? direction : config.direction,
        locale: (_b = (_a = config.locale) === null || _a === void 0 ? void 0 : _a.Modal) !== null && _b !== void 0 ? _b : runtimeLocale2,
        getContainer: mergedGetContainer
      }));
    };
    function confirm(config) {
      const global2 = globalConfig();
      const container = document.createDocumentFragment();
      let currentConfig = Object.assign(Object.assign({}, config), {
        close,
        open: true
      });
      let timeoutId;
      let reactUnmount;
      function destroy2() {
        var _a;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const triggerCancel = args.some((param) => param === null || param === void 0 ? void 0 : param.triggerCancel);
        if (triggerCancel) {
          var _a2;
          (_a = config.onCancel) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [config, () => {
          }].concat(_toConsumableArray(args.slice(1))));
        }
        for (let i2 = 0; i2 < destroyFns.length; i2++) {
          const fn = destroyFns[i2];
          if (fn === close) {
            destroyFns.splice(i2, 1);
            break;
          }
        }
        reactUnmount();
      }
      function render2(props) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          const rootPrefixCls = global2.getPrefixCls(void 0, getRootPrefixCls());
          const iconPrefixCls = global2.getIconPrefixCls();
          const theme = global2.getTheme();
          const dom = /* @__PURE__ */ i.createElement(ConfirmDialogWrapper, Object.assign({}, props));
          const reactRender2 = getReactRender();
          reactUnmount = reactRender2(/* @__PURE__ */ i.createElement(ConfigProvider, {
            prefixCls: rootPrefixCls,
            iconPrefixCls,
            theme
          }, global2.holderRender ? global2.holderRender(dom) : dom), container);
        });
      }
      function close() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        currentConfig = Object.assign(Object.assign({}, currentConfig), {
          open: false,
          afterClose: () => {
            if (typeof config.afterClose === "function") {
              config.afterClose();
            }
            destroy2.apply(this, args);
          }
        });
        if (currentConfig.visible) {
          delete currentConfig.visible;
        }
        render2(currentConfig);
      }
      function update(configUpdate) {
        if (typeof configUpdate === "function") {
          currentConfig = configUpdate(currentConfig);
        } else {
          currentConfig = Object.assign(Object.assign({}, currentConfig), configUpdate);
        }
        render2(currentConfig);
      }
      render2(currentConfig);
      destroyFns.push(close);
      return {
        destroy: close,
        update
      };
    }
    function withWarn(props) {
      return Object.assign(Object.assign({}, props), {
        type: "warning"
      });
    }
    function withInfo(props) {
      return Object.assign(Object.assign({}, props), {
        type: "info"
      });
    }
    function withSuccess(props) {
      return Object.assign(Object.assign({}, props), {
        type: "success"
      });
    }
    function withError(props) {
      return Object.assign(Object.assign({}, props), {
        type: "error"
      });
    }
    function withConfirm(props) {
      return Object.assign(Object.assign({}, props), {
        type: "confirm"
      });
    }
    function modalGlobalConfig(_ref) {
      let {
        rootPrefixCls
      } = _ref;
      defaultRootPrefixCls = rootPrefixCls;
    }
    var __rest$L = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const HookModal = (_a, ref) => {
      var _b;
      var {
        afterClose: hookAfterClose,
        config
      } = _a, restProps = __rest$L(_a, ["afterClose", "config"]);
      const [open2, setOpen] = reactExports.useState(true);
      const [innerConfig, setInnerConfig] = reactExports.useState(config);
      const {
        direction,
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("modal");
      const rootPrefixCls = getPrefixCls();
      const afterClose = () => {
        var _a2;
        hookAfterClose();
        (_a2 = innerConfig.afterClose) === null || _a2 === void 0 ? void 0 : _a2.call(innerConfig);
      };
      const close = function() {
        var _a2;
        setOpen(false);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const triggerCancel = args.some((param) => param === null || param === void 0 ? void 0 : param.triggerCancel);
        if (triggerCancel) {
          var _a22;
          (_a2 = innerConfig.onCancel) === null || _a2 === void 0 ? void 0 : (_a22 = _a2).call.apply(_a22, [innerConfig, () => {
          }].concat(_toConsumableArray(args.slice(1))));
        }
      };
      reactExports.useImperativeHandle(ref, () => ({
        destroy: close,
        update: (newConfig) => {
          setInnerConfig((originConfig) => Object.assign(Object.assign({}, originConfig), newConfig));
        }
      }));
      const mergedOkCancel = (_b = innerConfig.okCancel) !== null && _b !== void 0 ? _b : innerConfig.type === "confirm";
      const [contextLocale] = useLocale$1("Modal", localeValues.Modal);
      return /* @__PURE__ */ reactExports.createElement(ConfirmDialogWrapper$1, Object.assign({
        prefixCls,
        rootPrefixCls
      }, innerConfig, {
        close,
        open: open2,
        afterClose,
        okText: innerConfig.okText || (mergedOkCancel ? contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.okText : contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.justOkText),
        direction: innerConfig.direction || direction,
        cancelText: innerConfig.cancelText || (contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.cancelText)
      }, restProps));
    };
    const HookModal$1 = /* @__PURE__ */ reactExports.forwardRef(HookModal);
    let uuid$2 = 0;
    const ElementsHolder = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef((_props, ref) => {
      const [elements, patchElement] = usePatchElement();
      reactExports.useImperativeHandle(ref, () => ({
        patchElement
      }), []);
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, elements);
    }));
    function useModal() {
      const holderRef = reactExports.useRef(null);
      const [actionQueue, setActionQueue] = reactExports.useState([]);
      reactExports.useEffect(() => {
        if (actionQueue.length) {
          const cloneQueue = _toConsumableArray(actionQueue);
          cloneQueue.forEach((action) => {
            action();
          });
          setActionQueue([]);
        }
      }, [actionQueue]);
      const getConfirmFunc = reactExports.useCallback((withFunc) => function hookConfirm(config) {
        var _a;
        uuid$2 += 1;
        const modalRef = /* @__PURE__ */ reactExports.createRef();
        let resolvePromise;
        const promise = new Promise((resolve) => {
          resolvePromise = resolve;
        });
        let silent = false;
        let closeFunc;
        const modal = /* @__PURE__ */ reactExports.createElement(HookModal$1, {
          key: `modal-${uuid$2}`,
          config: withFunc(config),
          ref: modalRef,
          afterClose: () => {
            closeFunc === null || closeFunc === void 0 ? void 0 : closeFunc();
          },
          isSilent: () => silent,
          onConfirm: (confirmed) => {
            resolvePromise(confirmed);
          }
        });
        closeFunc = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.patchElement(modal);
        if (closeFunc) {
          destroyFns.push(closeFunc);
        }
        const instance = {
          destroy: () => {
            function destroyAction() {
              var _a2;
              (_a2 = modalRef.current) === null || _a2 === void 0 ? void 0 : _a2.destroy();
            }
            if (modalRef.current) {
              destroyAction();
            } else {
              setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [destroyAction]));
            }
          },
          update: (newConfig) => {
            function updateAction() {
              var _a2;
              (_a2 = modalRef.current) === null || _a2 === void 0 ? void 0 : _a2.update(newConfig);
            }
            if (modalRef.current) {
              updateAction();
            } else {
              setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [updateAction]));
            }
          },
          then: (resolve) => {
            silent = true;
            return promise.then(resolve);
          }
        };
        return instance;
      }, []);
      const fns = reactExports.useMemo(() => ({
        info: getConfirmFunc(withInfo),
        success: getConfirmFunc(withSuccess),
        error: getConfirmFunc(withError),
        warning: getConfirmFunc(withWarn),
        confirm: getConfirmFunc(withConfirm)
      }), []);
      return [fns, /* @__PURE__ */ reactExports.createElement(ElementsHolder, {
        key: "modal-holder",
        ref: holderRef
      })];
    }
    const AppConfigContext = /* @__PURE__ */ i.createContext({});
    function withPureRenderTheme(Component2) {
      return (props) => /* @__PURE__ */ reactExports.createElement(ConfigProvider, {
        theme: {
          token: {
            motion: false,
            zIndexPopupBase: 0
          }
        }
      }, /* @__PURE__ */ reactExports.createElement(Component2, Object.assign({}, props)));
    }
    const genPurePanel = (Component2, alignPropName, postProps, defaultPrefixCls2, getDropdownCls) => {
      const PurePanel2 = (props) => {
        const {
          prefixCls: customizePrefixCls,
          style: style2
        } = props;
        const holderRef = reactExports.useRef(null);
        const [popupHeight, setPopupHeight] = reactExports.useState(0);
        const [popupWidth, setPopupWidth] = reactExports.useState(0);
        const [open2, setOpen] = useMergedState(false, {
          value: props.open
        });
        const {
          getPrefixCls
        } = reactExports.useContext(ConfigContext);
        const prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
        reactExports.useEffect(() => {
          setOpen(true);
          if (typeof ResizeObserver !== "undefined") {
            const resizeObserver2 = new ResizeObserver((entries) => {
              const element = entries[0].target;
              setPopupHeight(element.offsetHeight + 8);
              setPopupWidth(element.offsetWidth);
            });
            const interval = setInterval(() => {
              var _a;
              const dropdownCls = `.${prefixCls}-dropdown`;
              const popup = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(dropdownCls);
              if (popup) {
                clearInterval(interval);
                resizeObserver2.observe(popup);
              }
            }, 10);
            return () => {
              clearInterval(interval);
              resizeObserver2.disconnect();
            };
          }
        }, []);
        let mergedProps = Object.assign(Object.assign({}, props), {
          style: Object.assign(Object.assign({}, style2), {
            margin: 0
          }),
          open: open2,
          visible: open2,
          getPopupContainer: () => holderRef.current
        });
        if (alignPropName) {
          Object.assign(mergedProps, {
            [alignPropName]: {
              overflow: {
                adjustX: false,
                adjustY: false
              }
            }
          });
        }
        const mergedStyle = {
          paddingBottom: popupHeight,
          position: "relative",
          minWidth: popupWidth
        };
        return /* @__PURE__ */ reactExports.createElement("div", {
          ref: holderRef,
          style: mergedStyle
        }, /* @__PURE__ */ reactExports.createElement(Component2, Object.assign({}, mergedProps)));
      };
      return withPureRenderTheme(PurePanel2);
    };
    const isMobile = function() {
      if (typeof navigator === "undefined" || typeof window === "undefined") {
        return false;
      }
      var agent = navigator.userAgent || navigator.vendor || window.opera;
      return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
    };
    var TransBtn = function TransBtn2(props) {
      var className = props.className, customizeIcon = props.customizeIcon, customizeIconProps = props.customizeIconProps, children = props.children, _onMouseDown = props.onMouseDown, onClick = props.onClick;
      var icon = typeof customizeIcon === "function" ? customizeIcon(customizeIconProps) : customizeIcon;
      return /* @__PURE__ */ reactExports.createElement("span", {
        className,
        onMouseDown: function onMouseDown(event) {
          event.preventDefault();
          _onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(event);
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        },
        unselectable: "on",
        onClick,
        "aria-hidden": true
      }, icon !== void 0 ? icon : /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(className.split(/\s+/).map(function(cls) {
          return "".concat(cls, "-icon");
        }))
      }, children));
    };
    var useAllowClear = function useAllowClear2(prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon) {
      var disabled = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
      var mergedSearchValue = arguments.length > 6 ? arguments[6] : void 0;
      var mode = arguments.length > 7 ? arguments[7] : void 0;
      var mergedClearIcon = i.useMemo(function() {
        if (_typeof$1(allowClear) === "object") {
          return allowClear.clearIcon;
        }
        if (clearIcon) {
          return clearIcon;
        }
      }, [allowClear, clearIcon]);
      var mergedAllowClear = i.useMemo(function() {
        if (!disabled && !!allowClear && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "")) {
          return true;
        }
        return false;
      }, [allowClear, disabled, displayValues.length, mergedSearchValue, mode]);
      return {
        allowClear: mergedAllowClear,
        clearIcon: /* @__PURE__ */ i.createElement(TransBtn, {
          className: "".concat(prefixCls, "-clear"),
          onMouseDown: onClearMouseDown,
          customizeIcon: mergedClearIcon
        }, "")
      };
    };
    var BaseSelectContext = /* @__PURE__ */ reactExports.createContext(null);
    function useBaseProps() {
      return reactExports.useContext(BaseSelectContext);
    }
    function useDelayReset() {
      var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), bool = _React$useState2[0], setBool = _React$useState2[1];
      var delayRef = reactExports.useRef(null);
      var cancelLatest = function cancelLatest2() {
        window.clearTimeout(delayRef.current);
      };
      reactExports.useEffect(function() {
        return cancelLatest;
      }, []);
      var delaySetBool = function delaySetBool2(value, callback) {
        cancelLatest();
        delayRef.current = window.setTimeout(function() {
          setBool(value);
          if (callback) {
            callback();
          }
        }, timeout);
      };
      return [bool, delaySetBool, cancelLatest];
    }
    function useLock() {
      var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
      var lockRef = reactExports.useRef(null);
      var timeoutRef = reactExports.useRef(null);
      reactExports.useEffect(function() {
        return function() {
          window.clearTimeout(timeoutRef.current);
        };
      }, []);
      function doLock(locked) {
        if (locked || lockRef.current === null) {
          lockRef.current = locked;
        }
        window.clearTimeout(timeoutRef.current);
        timeoutRef.current = window.setTimeout(function() {
          lockRef.current = null;
        }, duration);
      }
      return [function() {
        return lockRef.current;
      }, doLock];
    }
    function useSelectTriggerControl(elements, open2, triggerOpen, customizedTrigger) {
      var propsRef = reactExports.useRef(null);
      propsRef.current = {
        open: open2,
        triggerOpen,
        customizedTrigger
      };
      reactExports.useEffect(function() {
        function onGlobalMouseDown(event) {
          var _propsRef$current;
          if ((_propsRef$current = propsRef.current) !== null && _propsRef$current !== void 0 && _propsRef$current.customizedTrigger) {
            return;
          }
          var target = event.target;
          if (target.shadowRoot && event.composed) {
            target = event.composedPath()[0] || target;
          }
          if (propsRef.current.open && elements().filter(function(element) {
            return element;
          }).every(function(element) {
            return !element.contains(target) && element !== target;
          })) {
            propsRef.current.triggerOpen(false);
          }
        }
        window.addEventListener("mousedown", onGlobalMouseDown);
        return function() {
          return window.removeEventListener("mousedown", onGlobalMouseDown);
        };
      }, []);
    }
    function isValidateOpenKey(currentKeyCode) {
      return (
        // Undefined for Edge bug:
        // https://github.com/ant-design/ant-design/issues/51292
        currentKeyCode && // Other keys
        ![
          // System function button
          KeyCode.ESC,
          KeyCode.SHIFT,
          KeyCode.BACKSPACE,
          KeyCode.TAB,
          KeyCode.WIN_KEY,
          KeyCode.ALT,
          KeyCode.META,
          KeyCode.WIN_KEY_RIGHT,
          KeyCode.CTRL,
          KeyCode.SEMICOLON,
          KeyCode.EQUALS,
          KeyCode.CAPS_LOCK,
          KeyCode.CONTEXT_MENU,
          // F1-F12
          KeyCode.F1,
          KeyCode.F2,
          KeyCode.F3,
          KeyCode.F4,
          KeyCode.F5,
          KeyCode.F6,
          KeyCode.F7,
          KeyCode.F8,
          KeyCode.F9,
          KeyCode.F10,
          KeyCode.F11,
          KeyCode.F12
        ].includes(currentKeyCode)
      );
    }
    var _excluded$A = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
    var UNDEFINED = void 0;
    function InternalItem$1(props, ref) {
      var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey2 = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order = props.order, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties(props, _excluded$A);
      var mergedHidden = responsive && !display;
      function internalRegisterSize(width) {
        registerSize(itemKey2, width);
      }
      reactExports.useEffect(function() {
        return function() {
          internalRegisterSize(null);
        };
      }, []);
      var childNode = renderItem && item !== UNDEFINED ? renderItem(item, {
        index: order
      }) : children;
      var overflowStyle;
      if (!invalidate) {
        overflowStyle = {
          opacity: mergedHidden ? 0 : 1,
          height: mergedHidden ? 0 : UNDEFINED,
          overflowY: mergedHidden ? "hidden" : UNDEFINED,
          order: responsive ? order : UNDEFINED,
          pointerEvents: mergedHidden ? "none" : UNDEFINED,
          position: mergedHidden ? "absolute" : UNDEFINED
        };
      }
      var overflowProps = {};
      if (mergedHidden) {
        overflowProps["aria-hidden"] = true;
      }
      var itemNode = /* @__PURE__ */ reactExports.createElement(Component2, _extends$2({
        className: classNames(!invalidate && prefixCls, className),
        style: _objectSpread2$3(_objectSpread2$3({}, overflowStyle), style2)
      }, overflowProps, restProps, {
        ref
      }), childNode);
      if (responsive) {
        itemNode = /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          onResize: function onResize2(_ref) {
            var offsetWidth = _ref.offsetWidth;
            internalRegisterSize(offsetWidth);
          },
          disabled: responsiveDisabled
        }, itemNode);
      }
      return itemNode;
    }
    var Item$3 = /* @__PURE__ */ reactExports.forwardRef(InternalItem$1);
    Item$3.displayName = "Item";
    function channelUpdate(callback) {
      if (typeof MessageChannel === "undefined") {
        wrapperRaf(callback);
      } else {
        var channel = new MessageChannel();
        channel.port1.onmessage = function() {
          return callback();
        };
        channel.port2.postMessage(void 0);
      }
    }
    function useBatcher() {
      var updateFuncRef = reactExports.useRef(null);
      var notifyEffectUpdate = function notifyEffectUpdate2(callback) {
        if (!updateFuncRef.current) {
          updateFuncRef.current = [];
          channelUpdate(function() {
            reactDomExports.unstable_batchedUpdates(function() {
              updateFuncRef.current.forEach(function(fn) {
                fn();
              });
              updateFuncRef.current = null;
            });
          });
        }
        updateFuncRef.current.push(callback);
      };
      return notifyEffectUpdate;
    }
    function useEffectState(notifyEffectUpdate, defaultValue) {
      var _React$useState = reactExports.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), stateValue = _React$useState2[0], setStateValue = _React$useState2[1];
      var setEffectVal = useEvent(function(nextValue) {
        notifyEffectUpdate(function() {
          setStateValue(nextValue);
        });
      });
      return [stateValue, setEffectVal];
    }
    var OverflowContext = /* @__PURE__ */ i.createContext(null);
    var _excluded$z = ["component"], _excluded2$7 = ["className"], _excluded3$1 = ["className"];
    var InternalRawItem = function InternalRawItem2(props, ref) {
      var context = reactExports.useContext(OverflowContext);
      if (!context) {
        var _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties(props, _excluded$z);
        return /* @__PURE__ */ reactExports.createElement(Component2, _extends$2({}, _restProps, {
          ref
        }));
      }
      var contextClassName = context.className, restContext = _objectWithoutProperties(context, _excluded2$7);
      var className = props.className, restProps = _objectWithoutProperties(props, _excluded3$1);
      return /* @__PURE__ */ reactExports.createElement(OverflowContext.Provider, {
        value: null
      }, /* @__PURE__ */ reactExports.createElement(Item$3, _extends$2({
        ref,
        className: classNames(contextClassName, className)
      }, restContext, restProps)));
    };
    var RawItem = /* @__PURE__ */ reactExports.forwardRef(InternalRawItem);
    RawItem.displayName = "RawItem";
    var _excluded$y = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
    var RESPONSIVE = "responsive";
    var INVALIDATE = "invalidate";
    function defaultRenderRest(omittedItems) {
      return "+ ".concat(omittedItems.length, " ...");
    }
    function Overflow(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data = _props$data === void 0 ? [] : _props$data, renderItem = props.renderItem, renderRawItem = props.renderRawItem, itemKey2 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix2 = props.suffix, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties(props, _excluded$y);
      var fullySSR = ssr === "full";
      var notifyEffectUpdate = useBatcher();
      var _useEffectState = useEffectState(notifyEffectUpdate, null), _useEffectState2 = _slicedToArray(_useEffectState, 2), containerWidth = _useEffectState2[0], setContainerWidth = _useEffectState2[1];
      var mergedContainerWidth = containerWidth || 0;
      var _useEffectState3 = useEffectState(notifyEffectUpdate, /* @__PURE__ */ new Map()), _useEffectState4 = _slicedToArray(_useEffectState3, 2), itemWidths = _useEffectState4[0], setItemWidths = _useEffectState4[1];
      var _useEffectState5 = useEffectState(notifyEffectUpdate, 0), _useEffectState6 = _slicedToArray(_useEffectState5, 2), prevRestWidth = _useEffectState6[0], setPrevRestWidth = _useEffectState6[1];
      var _useEffectState7 = useEffectState(notifyEffectUpdate, 0), _useEffectState8 = _slicedToArray(_useEffectState7, 2), restWidth = _useEffectState8[0], setRestWidth = _useEffectState8[1];
      var _useEffectState9 = useEffectState(notifyEffectUpdate, 0), _useEffectState10 = _slicedToArray(_useEffectState9, 2), suffixWidth = _useEffectState10[0], setSuffixWidth = _useEffectState10[1];
      var _useState = reactExports.useState(null), _useState2 = _slicedToArray(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
      var _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
      var mergedDisplayCount = reactExports.useMemo(function() {
        if (displayCount === null && fullySSR) {
          return Number.MAX_SAFE_INTEGER;
        }
        return displayCount || 0;
      }, [displayCount, containerWidth]);
      var _useState5 = reactExports.useState(false), _useState6 = _slicedToArray(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
      var itemPrefixCls = "".concat(prefixCls, "-item");
      var mergedRestWidth = Math.max(prevRestWidth, restWidth);
      var isResponsive = maxCount === RESPONSIVE;
      var shouldResponsive = data.length && isResponsive;
      var invalidate = maxCount === INVALIDATE;
      var showRest = shouldResponsive || typeof maxCount === "number" && data.length > maxCount;
      var mergedData = reactExports.useMemo(function() {
        var items = data;
        if (shouldResponsive) {
          if (containerWidth === null && fullySSR) {
            items = data;
          } else {
            items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
          }
        } else if (typeof maxCount === "number") {
          items = data.slice(0, maxCount);
        }
        return items;
      }, [data, itemWidth, containerWidth, maxCount, shouldResponsive]);
      var omittedItems = reactExports.useMemo(function() {
        if (shouldResponsive) {
          return data.slice(mergedDisplayCount + 1);
        }
        return data.slice(mergedData.length);
      }, [data, mergedData, shouldResponsive, mergedDisplayCount]);
      var getKey2 = reactExports.useCallback(function(item, index2) {
        var _ref;
        if (typeof itemKey2 === "function") {
          return itemKey2(item);
        }
        return (_ref = itemKey2 && (item === null || item === void 0 ? void 0 : item[itemKey2])) !== null && _ref !== void 0 ? _ref : index2;
      }, [itemKey2]);
      var mergedRenderItem = reactExports.useCallback(renderItem || function(item) {
        return item;
      }, [renderItem]);
      function updateDisplayCount(count, suffixFixedStartVal, notReady) {
        if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
          return;
        }
        setDisplayCount(count);
        if (!notReady) {
          setRestReady(count < data.length - 1);
          onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(count);
        }
        if (suffixFixedStartVal !== void 0) {
          setSuffixFixedStart(suffixFixedStartVal);
        }
      }
      function onOverflowResize(_2, element) {
        setContainerWidth(element.clientWidth);
      }
      function registerSize(key, width) {
        setItemWidths(function(origin) {
          var clone2 = new Map(origin);
          if (width === null) {
            clone2.delete(key);
          } else {
            clone2.set(key, width);
          }
          return clone2;
        });
      }
      function registerOverflowSize(_2, width) {
        setRestWidth(width);
        setPrevRestWidth(restWidth);
      }
      function registerSuffixSize(_2, width) {
        setSuffixWidth(width);
      }
      function getItemWidth(index2) {
        return itemWidths.get(getKey2(mergedData[index2], index2));
      }
      useLayoutEffect$1(function() {
        if (mergedContainerWidth && typeof mergedRestWidth === "number" && mergedData) {
          var totalWidth = suffixWidth;
          var len = mergedData.length;
          var lastIndex = len - 1;
          if (!len) {
            updateDisplayCount(0, null);
            return;
          }
          for (var i2 = 0; i2 < len; i2 += 1) {
            var currentItemWidth = getItemWidth(i2);
            if (fullySSR) {
              currentItemWidth = currentItemWidth || 0;
            }
            if (currentItemWidth === void 0) {
              updateDisplayCount(i2 - 1, void 0, true);
              break;
            }
            totalWidth += currentItemWidth;
            if (
              // Only one means `totalWidth` is the final width
              lastIndex === 0 && totalWidth <= mergedContainerWidth || // Last two width will be the final width
              i2 === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth
            ) {
              updateDisplayCount(lastIndex, null);
              break;
            } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
              updateDisplayCount(i2 - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
              break;
            }
          }
          if (suffix2 && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
            setSuffixFixedStart(null);
          }
        }
      }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey2, mergedData]);
      var displayRest = restReady && !!omittedItems.length;
      var suffixStyle = {};
      if (suffixFixedStart !== null && shouldResponsive) {
        suffixStyle = {
          position: "absolute",
          left: suffixFixedStart,
          top: 0
        };
      }
      var itemSharedProps = {
        prefixCls: itemPrefixCls,
        responsive: shouldResponsive,
        component: itemComponent,
        invalidate
      };
      var internalRenderItemNode = renderRawItem ? function(item, index2) {
        var key = getKey2(item, index2);
        return /* @__PURE__ */ reactExports.createElement(OverflowContext.Provider, {
          key,
          value: _objectSpread2$3(_objectSpread2$3({}, itemSharedProps), {}, {
            order: index2,
            item,
            itemKey: key,
            registerSize,
            display: index2 <= mergedDisplayCount
          })
        }, renderRawItem(item, index2));
      } : function(item, index2) {
        var key = getKey2(item, index2);
        return /* @__PURE__ */ reactExports.createElement(Item$3, _extends$2({}, itemSharedProps, {
          order: index2,
          key,
          item,
          renderItem: mergedRenderItem,
          itemKey: key,
          registerSize,
          display: index2 <= mergedDisplayCount
        }));
      };
      var restContextProps = {
        order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
        className: "".concat(itemPrefixCls, "-rest"),
        registerSize: registerOverflowSize,
        display: displayRest
      };
      var mergedRenderRest = renderRest || defaultRenderRest;
      var restNode = renderRawRest ? /* @__PURE__ */ reactExports.createElement(OverflowContext.Provider, {
        value: _objectSpread2$3(_objectSpread2$3({}, itemSharedProps), restContextProps)
      }, renderRawRest(omittedItems)) : /* @__PURE__ */ reactExports.createElement(Item$3, _extends$2({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
      var overflowNode = /* @__PURE__ */ reactExports.createElement(Component2, _extends$2({
        className: classNames(!invalidate && prefixCls, className),
        style: style2,
        ref
      }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix2 && /* @__PURE__ */ reactExports.createElement(Item$3, _extends$2({}, itemSharedProps, {
        responsive: isResponsive,
        responsiveDisabled: !shouldResponsive,
        order: mergedDisplayCount,
        className: "".concat(itemPrefixCls, "-suffix"),
        registerSize: registerSuffixSize,
        display: true,
        style: suffixStyle
      }), suffix2));
      return isResponsive ? /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onOverflowResize,
        disabled: !shouldResponsive
      }, overflowNode) : overflowNode;
    }
    var ForwardOverflow = /* @__PURE__ */ reactExports.forwardRef(Overflow);
    ForwardOverflow.displayName = "Overflow";
    ForwardOverflow.Item = RawItem;
    ForwardOverflow.RESPONSIVE = RESPONSIVE;
    ForwardOverflow.INVALIDATE = INVALIDATE;
    var Input$5 = function Input2(props, ref) {
      var _inputNode2;
      var prefixCls = props.prefixCls, id = props.id, inputElement = props.inputElement, disabled = props.disabled, tabIndex = props.tabIndex, autoFocus = props.autoFocus, autoComplete = props.autoComplete, editable = props.editable, activeDescendantId = props.activeDescendantId, value = props.value, maxLength = props.maxLength, _onKeyDown = props.onKeyDown, _onMouseDown = props.onMouseDown, _onChange = props.onChange, onPaste = props.onPaste, _onCompositionStart = props.onCompositionStart, _onCompositionEnd = props.onCompositionEnd, _onBlur = props.onBlur, open2 = props.open, attrs = props.attrs;
      var inputNode = inputElement || /* @__PURE__ */ reactExports.createElement("input", null);
      var _inputNode = inputNode, originRef = _inputNode.ref, originProps = _inputNode.props;
      var onOriginKeyDown = originProps.onKeyDown, onOriginChange = originProps.onChange, onOriginMouseDown = originProps.onMouseDown, onOriginCompositionStart = originProps.onCompositionStart, onOriginCompositionEnd = originProps.onCompositionEnd, onOriginBlur = originProps.onBlur, style2 = originProps.style;
      warning$5(!("maxLength" in inputNode.props));
      inputNode = /* @__PURE__ */ reactExports.cloneElement(inputNode, _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({
        type: "search"
      }, originProps), {}, {
        // Override over origin props
        id,
        ref: composeRef(ref, originRef),
        disabled,
        tabIndex,
        autoComplete: autoComplete || "off",
        autoFocus,
        className: classNames("".concat(prefixCls, "-selection-search-input"), (_inputNode2 = inputNode) === null || _inputNode2 === void 0 || (_inputNode2 = _inputNode2.props) === null || _inputNode2 === void 0 ? void 0 : _inputNode2.className),
        role: "combobox",
        "aria-expanded": open2 || false,
        "aria-haspopup": "listbox",
        "aria-owns": "".concat(id, "_list"),
        "aria-autocomplete": "list",
        "aria-controls": "".concat(id, "_list"),
        "aria-activedescendant": open2 ? activeDescendantId : void 0
      }, attrs), {}, {
        value: editable ? value : "",
        maxLength,
        readOnly: !editable,
        unselectable: !editable ? "on" : null,
        style: _objectSpread2$3(_objectSpread2$3({}, style2), {}, {
          opacity: editable ? null : 0
        }),
        onKeyDown: function onKeyDown(event) {
          _onKeyDown(event);
          if (onOriginKeyDown) {
            onOriginKeyDown(event);
          }
        },
        onMouseDown: function onMouseDown(event) {
          _onMouseDown(event);
          if (onOriginMouseDown) {
            onOriginMouseDown(event);
          }
        },
        onChange: function onChange(event) {
          _onChange(event);
          if (onOriginChange) {
            onOriginChange(event);
          }
        },
        onCompositionStart: function onCompositionStart(event) {
          _onCompositionStart(event);
          if (onOriginCompositionStart) {
            onOriginCompositionStart(event);
          }
        },
        onCompositionEnd: function onCompositionEnd(event) {
          _onCompositionEnd(event);
          if (onOriginCompositionEnd) {
            onOriginCompositionEnd(event);
          }
        },
        onPaste,
        onBlur: function onBlur(event) {
          _onBlur(event);
          if (onOriginBlur) {
            onOriginBlur(event);
          }
        }
      }));
      return inputNode;
    };
    var RefInput = /* @__PURE__ */ reactExports.forwardRef(Input$5);
    function toArray$3(value) {
      if (Array.isArray(value)) {
        return value;
      }
      return value !== void 0 ? [value] : [];
    }
    var isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
    var isBrowserClient$1 = isClient;
    function hasValue(value) {
      return value !== void 0 && value !== null;
    }
    function isComboNoValue(value) {
      return !value && value !== 0;
    }
    function isTitleType$1(title) {
      return ["string", "number"].includes(_typeof$1(title));
    }
    function getTitle(item) {
      var title = void 0;
      if (item) {
        if (isTitleType$1(item.title)) {
          title = item.title.toString();
        } else if (isTitleType$1(item.label)) {
          title = item.label.toString();
        }
      }
      return title;
    }
    function useLayoutEffect(effect, deps) {
      if (isBrowserClient$1) {
        reactExports.useLayoutEffect(effect, deps);
      } else {
        reactExports.useEffect(effect, deps);
      }
    }
    function itemKey(value) {
      var _value$key;
      return (_value$key = value.key) !== null && _value$key !== void 0 ? _value$key : value.value;
    }
    var onPreventMouseDown = function onPreventMouseDown2(event) {
      event.preventDefault();
      event.stopPropagation();
    };
    var SelectSelector = function SelectSelector2(props) {
      var id = props.id, prefixCls = props.prefixCls, values = props.values, open2 = props.open, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, inputRef = props.inputRef, placeholder = props.placeholder, disabled = props.disabled, mode = props.mode, showSearch = props.showSearch, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, tabIndex = props.tabIndex, removeIcon = props.removeIcon, maxTagCount = props.maxTagCount, maxTagTextLength = props.maxTagTextLength, _props$maxTagPlacehol = props.maxTagPlaceholder, maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function(omittedValues) {
        return "+ ".concat(omittedValues.length, " ...");
      } : _props$maxTagPlacehol, tagRender = props.tagRender, onToggleOpen = props.onToggleOpen, onRemove = props.onRemove, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd, onInputBlur = props.onInputBlur;
      var measureRef = reactExports.useRef(null);
      var _useState = reactExports.useState(0), _useState2 = _slicedToArray(_useState, 2), inputWidth = _useState2[0], setInputWidth = _useState2[1];
      var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1];
      var selectionPrefixCls = "".concat(prefixCls, "-selection");
      var inputValue = open2 || mode === "multiple" && autoClearSearchValue === false || mode === "tags" ? searchValue : "";
      var inputEditable = mode === "tags" || mode === "multiple" && autoClearSearchValue === false || showSearch && (open2 || focused);
      useLayoutEffect(function() {
        setInputWidth(measureRef.current.scrollWidth);
      }, [inputValue]);
      var defaultRenderSelector = function defaultRenderSelector2(item, content, itemDisabled, closable, onClose) {
        return /* @__PURE__ */ reactExports.createElement("span", {
          title: getTitle(item),
          className: classNames("".concat(selectionPrefixCls, "-item"), _defineProperty({}, "".concat(selectionPrefixCls, "-item-disabled"), itemDisabled))
        }, /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(selectionPrefixCls, "-item-content")
        }, content), closable && /* @__PURE__ */ reactExports.createElement(TransBtn, {
          className: "".concat(selectionPrefixCls, "-item-remove"),
          onMouseDown: onPreventMouseDown,
          onClick: onClose,
          customizeIcon: removeIcon
        }, ""));
      };
      var customizeRenderSelector = function customizeRenderSelector2(value, content, itemDisabled, closable, onClose, isMaxTag) {
        var onMouseDown = function onMouseDown2(e2) {
          onPreventMouseDown(e2);
          onToggleOpen(!open2);
        };
        return /* @__PURE__ */ reactExports.createElement("span", {
          onMouseDown
        }, tagRender({
          label: content,
          value,
          disabled: itemDisabled,
          closable,
          onClose,
          isMaxTag: !!isMaxTag
        }));
      };
      var renderItem = function renderItem2(valueItem) {
        var itemDisabled = valueItem.disabled, label = valueItem.label, value = valueItem.value;
        var closable = !disabled && !itemDisabled;
        var displayLabel = label;
        if (typeof maxTagTextLength === "number") {
          if (typeof label === "string" || typeof label === "number") {
            var strLabel = String(displayLabel);
            if (strLabel.length > maxTagTextLength) {
              displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "...");
            }
          }
        }
        var onClose = function onClose2(event) {
          if (event) {
            event.stopPropagation();
          }
          onRemove(valueItem);
        };
        return typeof tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
      };
      var renderRest = function renderRest2(omittedValues) {
        if (!values.length) {
          return null;
        }
        var content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
        return typeof tagRender === "function" ? customizeRenderSelector(void 0, content, false, false, void 0, true) : defaultRenderSelector({
          title: content
        }, content, false);
      };
      var inputNode = /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(selectionPrefixCls, "-search"),
        style: {
          width: inputWidth
        },
        onFocus: function onFocus() {
          setFocused(true);
        },
        onBlur: function onBlur() {
          setFocused(false);
        }
      }, /* @__PURE__ */ reactExports.createElement(RefInput, {
        ref: inputRef,
        open: open2,
        prefixCls,
        id,
        inputElement: null,
        disabled,
        autoFocus,
        autoComplete,
        editable: inputEditable,
        activeDescendantId,
        value: inputValue,
        onKeyDown: onInputKeyDown,
        onMouseDown: onInputMouseDown,
        onChange: onInputChange,
        onPaste: onInputPaste,
        onCompositionStart: onInputCompositionStart,
        onCompositionEnd: onInputCompositionEnd,
        onBlur: onInputBlur,
        tabIndex,
        attrs: pickAttrs(props, true)
      }), /* @__PURE__ */ reactExports.createElement("span", {
        ref: measureRef,
        className: "".concat(selectionPrefixCls, "-search-mirror"),
        "aria-hidden": true
      }, inputValue, ""));
      var selectionNode = /* @__PURE__ */ reactExports.createElement(ForwardOverflow, {
        prefixCls: "".concat(selectionPrefixCls, "-overflow"),
        data: values,
        renderItem,
        renderRest,
        suffix: inputNode,
        itemKey,
        maxCount: maxTagCount
      });
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(selectionPrefixCls, "-wrap")
      }, selectionNode, !values.length && !inputValue && /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(selectionPrefixCls, "-placeholder")
      }, placeholder));
    };
    var SingleSelector$1 = function SingleSelector2(props) {
      var inputElement = props.inputElement, prefixCls = props.prefixCls, id = props.id, inputRef = props.inputRef, disabled = props.disabled, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, mode = props.mode, open2 = props.open, values = props.values, placeholder = props.placeholder, tabIndex = props.tabIndex, showSearch = props.showSearch, searchValue = props.searchValue, activeValue = props.activeValue, maxLength = props.maxLength, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd, onInputBlur = props.onInputBlur, title = props.title;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), inputChanged = _React$useState2[0], setInputChanged = _React$useState2[1];
      var combobox = mode === "combobox";
      var inputEditable = combobox || showSearch;
      var item = values[0];
      var inputValue = searchValue || "";
      if (combobox && activeValue && !inputChanged) {
        inputValue = activeValue;
      }
      reactExports.useEffect(function() {
        if (combobox) {
          setInputChanged(false);
        }
      }, [combobox, activeValue]);
      var hasTextInput = mode !== "combobox" && !open2 && !showSearch ? false : !!inputValue;
      var selectionTitle = title === void 0 ? getTitle(item) : title;
      var placeholderNode = reactExports.useMemo(function() {
        if (item) {
          return null;
        }
        return /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(prefixCls, "-selection-placeholder"),
          style: hasTextInput ? {
            visibility: "hidden"
          } : void 0
        }, placeholder);
      }, [item, hasTextInput, placeholder, prefixCls]);
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-selection-wrap")
      }, /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-selection-search")
      }, /* @__PURE__ */ reactExports.createElement(RefInput, {
        ref: inputRef,
        prefixCls,
        id,
        open: open2,
        inputElement,
        disabled,
        autoFocus,
        autoComplete,
        editable: inputEditable,
        activeDescendantId,
        value: inputValue,
        onKeyDown: onInputKeyDown,
        onMouseDown: onInputMouseDown,
        onChange: function onChange(e2) {
          setInputChanged(true);
          onInputChange(e2);
        },
        onPaste: onInputPaste,
        onCompositionStart: onInputCompositionStart,
        onCompositionEnd: onInputCompositionEnd,
        onBlur: onInputBlur,
        tabIndex,
        attrs: pickAttrs(props, true),
        maxLength: combobox ? maxLength : void 0
      })), !combobox && item ? /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-selection-item"),
        title: selectionTitle,
        style: hasTextInput ? {
          visibility: "hidden"
        } : void 0
      }, item.label) : null, placeholderNode);
    };
    var Selector = function Selector2(props, ref) {
      var inputRef = reactExports.useRef(null);
      var compositionStatusRef = reactExports.useRef(false);
      var prefixCls = props.prefixCls, open2 = props.open, mode = props.mode, showSearch = props.showSearch, tokenWithEnter = props.tokenWithEnter, disabled = props.disabled, prefix2 = props.prefix, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSubmit = props.onSearchSubmit, onToggleOpen = props.onToggleOpen, onInputKeyDown = props.onInputKeyDown, onInputBlur = props.onInputBlur, domRef = props.domRef;
      reactExports.useImperativeHandle(ref, function() {
        return {
          focus: function focus(options2) {
            inputRef.current.focus(options2);
          },
          blur: function blur() {
            inputRef.current.blur();
          }
        };
      });
      var _useLock = useLock(0), _useLock2 = _slicedToArray(_useLock, 2), getInputMouseDown = _useLock2[0], setInputMouseDown = _useLock2[1];
      var onInternalInputKeyDown = function onInternalInputKeyDown2(event) {
        var which = event.which;
        var isTextAreaElement = inputRef.current instanceof HTMLTextAreaElement;
        if (!isTextAreaElement && open2 && (which === KeyCode.UP || which === KeyCode.DOWN)) {
          event.preventDefault();
        }
        if (onInputKeyDown) {
          onInputKeyDown(event);
        }
        if (which === KeyCode.ENTER && mode === "tags" && !compositionStatusRef.current && !open2) {
          onSearchSubmit === null || onSearchSubmit === void 0 || onSearchSubmit(event.target.value);
        }
        if (isTextAreaElement && !open2 && ~[KeyCode.UP, KeyCode.DOWN, KeyCode.LEFT, KeyCode.RIGHT].indexOf(which)) {
          return;
        }
        if (isValidateOpenKey(which)) {
          onToggleOpen(true);
        }
      };
      var onInternalInputMouseDown = function onInternalInputMouseDown2() {
        setInputMouseDown(true);
      };
      var pastedTextRef = reactExports.useRef(null);
      var triggerOnSearch = function triggerOnSearch2(value) {
        if (onSearch(value, true, compositionStatusRef.current) !== false) {
          onToggleOpen(true);
        }
      };
      var onInputCompositionStart = function onInputCompositionStart2() {
        compositionStatusRef.current = true;
      };
      var onInputCompositionEnd = function onInputCompositionEnd2(e2) {
        compositionStatusRef.current = false;
        if (mode !== "combobox") {
          triggerOnSearch(e2.target.value);
        }
      };
      var onInputChange = function onInputChange2(event) {
        var value = event.target.value;
        if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
          var replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
          value = value.replace(replacedText, pastedTextRef.current);
        }
        pastedTextRef.current = null;
        triggerOnSearch(value);
      };
      var onInputPaste = function onInputPaste2(e2) {
        var clipboardData = e2.clipboardData;
        var value = clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData("text");
        pastedTextRef.current = value || "";
      };
      var onClick = function onClick2(_ref) {
        var target = _ref.target;
        if (target !== inputRef.current) {
          var isIE = document.body.style.msTouchAction !== void 0;
          if (isIE) {
            setTimeout(function() {
              inputRef.current.focus();
            });
          } else {
            inputRef.current.focus();
          }
        }
      };
      var onMouseDown = function onMouseDown2(event) {
        var inputMouseDown = getInputMouseDown();
        if (event.target !== inputRef.current && !inputMouseDown && !(mode === "combobox" && disabled)) {
          event.preventDefault();
        }
        if (mode !== "combobox" && (!showSearch || !inputMouseDown) || !open2) {
          if (open2 && autoClearSearchValue !== false) {
            onSearch("", true, false);
          }
          onToggleOpen();
        }
      };
      var sharedProps = {
        inputRef,
        onInputKeyDown: onInternalInputKeyDown,
        onInputMouseDown: onInternalInputMouseDown,
        onInputChange,
        onInputPaste,
        onInputCompositionStart,
        onInputCompositionEnd,
        onInputBlur
      };
      var selectNode = mode === "multiple" || mode === "tags" ? /* @__PURE__ */ reactExports.createElement(SelectSelector, _extends$2({}, props, sharedProps)) : /* @__PURE__ */ reactExports.createElement(SingleSelector$1, _extends$2({}, props, sharedProps));
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: domRef,
        className: "".concat(prefixCls, "-selector"),
        onClick,
        onMouseDown
      }, prefix2 && /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-prefix")
      }, prefix2), selectNode);
    };
    var ForwardSelector = /* @__PURE__ */ reactExports.forwardRef(Selector);
    function Arrow(props) {
      var prefixCls = props.prefixCls, align = props.align, arrow = props.arrow, arrowPos = props.arrowPos;
      var _ref = arrow || {}, className = _ref.className, content = _ref.content;
      var _arrowPos$x = arrowPos.x, x2 = _arrowPos$x === void 0 ? 0 : _arrowPos$x, _arrowPos$y = arrowPos.y, y2 = _arrowPos$y === void 0 ? 0 : _arrowPos$y;
      var arrowRef = reactExports.useRef();
      if (!align || !align.points) {
        return null;
      }
      var alignStyle = {
        position: "absolute"
      };
      if (align.autoArrow !== false) {
        var popupPoints = align.points[0];
        var targetPoints = align.points[1];
        var popupTB = popupPoints[0];
        var popupLR = popupPoints[1];
        var targetTB = targetPoints[0];
        var targetLR = targetPoints[1];
        if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
          alignStyle.top = y2;
        } else if (popupTB === "t") {
          alignStyle.top = 0;
        } else {
          alignStyle.bottom = 0;
        }
        if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
          alignStyle.left = x2;
        } else if (popupLR === "l") {
          alignStyle.left = 0;
        } else {
          alignStyle.right = 0;
        }
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: arrowRef,
        className: classNames("".concat(prefixCls, "-arrow"), className),
        style: alignStyle
      }, content);
    }
    function Mask(props) {
      var prefixCls = props.prefixCls, open2 = props.open, zIndex = props.zIndex, mask = props.mask, motion2 = props.motion;
      if (!mask) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({}, motion2, {
        motionAppear: true,
        visible: open2,
        removeOnLeave: true
      }), function(_ref) {
        var className = _ref.className;
        return /* @__PURE__ */ reactExports.createElement("div", {
          style: {
            zIndex
          },
          className: classNames("".concat(prefixCls, "-mask"), className)
        });
      });
    }
    var PopupContent = /* @__PURE__ */ reactExports.memo(function(_ref) {
      var children = _ref.children;
      return children;
    }, function(_2, next2) {
      return next2.cache;
    });
    var Popup$2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var popup = props.popup, className = props.className, prefixCls = props.prefixCls, style2 = props.style, target = props.target, _onVisibleChanged = props.onVisibleChanged, open2 = props.open, keepDom = props.keepDom, fresh = props.fresh, onClick = props.onClick, mask = props.mask, arrow = props.arrow, arrowPos = props.arrowPos, align = props.align, motion2 = props.motion, maskMotion = props.maskMotion, forceRender = props.forceRender, getPopupContainer = props.getPopupContainer, autoDestroy = props.autoDestroy, Portal2 = props.portal, zIndex = props.zIndex, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onPointerEnter = props.onPointerEnter, onPointerDownCapture = props.onPointerDownCapture, ready = props.ready, offsetX = props.offsetX, offsetY = props.offsetY, offsetR = props.offsetR, offsetB = props.offsetB, onAlign = props.onAlign, onPrepare = props.onPrepare, stretch = props.stretch, targetWidth = props.targetWidth, targetHeight = props.targetHeight;
      var childNode = typeof popup === "function" ? popup() : popup;
      var isNodeVisible = open2 || keepDom;
      var getPopupContainerNeedParams = (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.length) > 0;
      var _React$useState = reactExports.useState(!getPopupContainer || !getPopupContainerNeedParams), _React$useState2 = _slicedToArray(_React$useState, 2), show = _React$useState2[0], setShow = _React$useState2[1];
      useLayoutEffect$1(function() {
        if (!show && getPopupContainerNeedParams && target) {
          setShow(true);
        }
      }, [show, getPopupContainerNeedParams, target]);
      if (!show) {
        return null;
      }
      var AUTO = "auto";
      var offsetStyle = {
        left: "-1000vw",
        top: "-1000vh",
        right: AUTO,
        bottom: AUTO
      };
      if (ready || !open2) {
        var _experimental;
        var points = align.points;
        var dynamicInset = align.dynamicInset || ((_experimental = align._experimental) === null || _experimental === void 0 ? void 0 : _experimental.dynamicInset);
        var alignRight = dynamicInset && points[0][1] === "r";
        var alignBottom = dynamicInset && points[0][0] === "b";
        if (alignRight) {
          offsetStyle.right = offsetR;
          offsetStyle.left = AUTO;
        } else {
          offsetStyle.left = offsetX;
          offsetStyle.right = AUTO;
        }
        if (alignBottom) {
          offsetStyle.bottom = offsetB;
          offsetStyle.top = AUTO;
        } else {
          offsetStyle.top = offsetY;
          offsetStyle.bottom = AUTO;
        }
      }
      var miscStyle = {};
      if (stretch) {
        if (stretch.includes("height") && targetHeight) {
          miscStyle.height = targetHeight;
        } else if (stretch.includes("minHeight") && targetHeight) {
          miscStyle.minHeight = targetHeight;
        }
        if (stretch.includes("width") && targetWidth) {
          miscStyle.width = targetWidth;
        } else if (stretch.includes("minWidth") && targetWidth) {
          miscStyle.minWidth = targetWidth;
        }
      }
      if (!open2) {
        miscStyle.pointerEvents = "none";
      }
      return /* @__PURE__ */ reactExports.createElement(Portal2, {
        open: forceRender || isNodeVisible,
        getContainer: getPopupContainer && function() {
          return getPopupContainer(target);
        },
        autoDestroy
      }, /* @__PURE__ */ reactExports.createElement(Mask, {
        prefixCls,
        open: open2,
        zIndex,
        mask,
        motion: maskMotion
      }), /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onAlign,
        disabled: !open2
      }, function(resizeObserverRef) {
        return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({
          motionAppear: true,
          motionEnter: true,
          motionLeave: true,
          removeOnLeave: false,
          forceRender,
          leavedClassName: "".concat(prefixCls, "-hidden")
        }, motion2, {
          onAppearPrepare: onPrepare,
          onEnterPrepare: onPrepare,
          visible: open2,
          onVisibleChanged: function onVisibleChanged(nextVisible) {
            var _motion$onVisibleChan;
            motion2 === null || motion2 === void 0 || (_motion$onVisibleChan = motion2.onVisibleChanged) === null || _motion$onVisibleChan === void 0 || _motion$onVisibleChan.call(motion2, nextVisible);
            _onVisibleChanged(nextVisible);
          }
        }), function(_ref, motionRef) {
          var motionClassName = _ref.className, motionStyle = _ref.style;
          var cls = classNames(prefixCls, motionClassName, className);
          return /* @__PURE__ */ reactExports.createElement("div", {
            ref: composeRef(resizeObserverRef, ref, motionRef),
            className: cls,
            style: _objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({
              "--arrow-x": "".concat(arrowPos.x || 0, "px"),
              "--arrow-y": "".concat(arrowPos.y || 0, "px")
            }, offsetStyle), miscStyle), motionStyle), {}, {
              boxSizing: "border-box",
              zIndex
            }, style2),
            onMouseEnter,
            onMouseLeave,
            onPointerEnter,
            onClick,
            onPointerDownCapture
          }, arrow && /* @__PURE__ */ reactExports.createElement(Arrow, {
            prefixCls,
            arrow,
            arrowPos,
            align
          }), /* @__PURE__ */ reactExports.createElement(PopupContent, {
            cache: !open2 && !fresh
          }, childNode));
        });
      }));
    });
    var TriggerWrapper = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var children = props.children, getTriggerDOMNode = props.getTriggerDOMNode;
      var canUseRef = supportRef(children);
      var setRef = reactExports.useCallback(function(node2) {
        fillRef(ref, getTriggerDOMNode ? getTriggerDOMNode(node2) : node2);
      }, [getTriggerDOMNode]);
      var mergedRef = useComposeRef(setRef, getNodeRef(children));
      return canUseRef ? /* @__PURE__ */ reactExports.cloneElement(children, {
        ref: mergedRef
      }) : children;
    });
    var TriggerContext = /* @__PURE__ */ reactExports.createContext(null);
    function toArray$2(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    }
    function useAction(mobile, action, showAction, hideAction) {
      return reactExports.useMemo(function() {
        var mergedShowAction = toArray$2(showAction !== null && showAction !== void 0 ? showAction : action);
        var mergedHideAction = toArray$2(hideAction !== null && hideAction !== void 0 ? hideAction : action);
        var showActionSet = new Set(mergedShowAction);
        var hideActionSet = new Set(mergedHideAction);
        if (mobile) {
          if (showActionSet.has("hover")) {
            showActionSet.delete("hover");
            showActionSet.add("click");
          }
          if (hideActionSet.has("hover")) {
            hideActionSet.delete("hover");
            hideActionSet.add("click");
          }
        }
        return [showActionSet, hideActionSet];
      }, [mobile, action, showAction, hideAction]);
    }
    function isPointsEq() {
      var a1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var a2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var isAlignPoint = arguments.length > 2 ? arguments[2] : void 0;
      if (isAlignPoint) {
        return a1[0] === a2[0];
      }
      return a1[0] === a2[0] && a1[1] === a2[1];
    }
    function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
      var points = align.points;
      var placements2 = Object.keys(builtinPlacements);
      for (var i2 = 0; i2 < placements2.length; i2 += 1) {
        var _builtinPlacements$pl;
        var placement = placements2[i2];
        if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {
          return "".concat(prefixCls, "-placement-").concat(placement);
        }
      }
      return "";
    }
    function getMotion$1(prefixCls, motion2, animation, transitionName) {
      if (motion2) {
        return motion2;
      }
      if (animation) {
        return {
          motionName: "".concat(prefixCls, "-").concat(animation)
        };
      }
      if (transitionName) {
        return {
          motionName: transitionName
        };
      }
      return null;
    }
    function getWin(ele) {
      return ele.ownerDocument.defaultView;
    }
    function collectScroller(ele) {
      var scrollerList = [];
      var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;
      var scrollStyle = ["hidden", "scroll", "clip", "auto"];
      while (current) {
        var _getWin$getComputedSt = getWin(current).getComputedStyle(current), overflowX = _getWin$getComputedSt.overflowX, overflowY = _getWin$getComputedSt.overflowY, overflow = _getWin$getComputedSt.overflow;
        if ([overflowX, overflowY, overflow].some(function(o2) {
          return scrollStyle.includes(o2);
        })) {
          scrollerList.push(current);
        }
        current = current.parentElement;
      }
      return scrollerList;
    }
    function toNum(num) {
      var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      return Number.isNaN(num) ? defaultValue : num;
    }
    function getPxValue(val) {
      return toNum(parseFloat(val), 0);
    }
    function getVisibleArea(initArea, scrollerList) {
      var visibleArea = _objectSpread2$3({}, initArea);
      (scrollerList || []).forEach(function(ele) {
        if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {
          return;
        }
        var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele), overflow = _getWin$getComputedSt2.overflow, overflowClipMargin = _getWin$getComputedSt2.overflowClipMargin, borderTopWidth = _getWin$getComputedSt2.borderTopWidth, borderBottomWidth = _getWin$getComputedSt2.borderBottomWidth, borderLeftWidth = _getWin$getComputedSt2.borderLeftWidth, borderRightWidth = _getWin$getComputedSt2.borderRightWidth;
        var eleRect = ele.getBoundingClientRect();
        var eleOutHeight = ele.offsetHeight, eleInnerHeight = ele.clientHeight, eleOutWidth = ele.offsetWidth, eleInnerWidth = ele.clientWidth;
        var borderTopNum = getPxValue(borderTopWidth);
        var borderBottomNum = getPxValue(borderBottomWidth);
        var borderLeftNum = getPxValue(borderLeftWidth);
        var borderRightNum = getPxValue(borderRightWidth);
        var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
        var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
        var eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
        var eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
        var scaledBorderTopWidth = borderTopNum * scaleY;
        var scaledBorderBottomWidth = borderBottomNum * scaleY;
        var scaledBorderLeftWidth = borderLeftNum * scaleX;
        var scaledBorderRightWidth = borderRightNum * scaleX;
        var clipMarginWidth = 0;
        var clipMarginHeight = 0;
        if (overflow === "clip") {
          var clipNum = getPxValue(overflowClipMargin);
          clipMarginWidth = clipNum * scaleX;
          clipMarginHeight = clipNum * scaleY;
        }
        var eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
        var eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
        var eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
        var eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
        visibleArea.left = Math.max(visibleArea.left, eleLeft);
        visibleArea.top = Math.max(visibleArea.top, eleTop);
        visibleArea.right = Math.min(visibleArea.right, eleRight);
        visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
      });
      return visibleArea;
    }
    function getUnitOffset(size) {
      var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var offsetStr = "".concat(offset2);
      var cells = offsetStr.match(/^(.*)\%$/);
      if (cells) {
        return size * (parseFloat(cells[1]) / 100);
      }
      return parseFloat(offsetStr);
    }
    function getNumberOffset(rect, offset2) {
      var _ref = offset2 || [], _ref2 = _slicedToArray(_ref, 2), offsetX = _ref2[0], offsetY = _ref2[1];
      return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
    }
    function splitPoints() {
      var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return [points[0], points[1]];
    }
    function getAlignPoint(rect, points) {
      var topBottom = points[0];
      var leftRight = points[1];
      var x2;
      var y2;
      if (topBottom === "t") {
        y2 = rect.y;
      } else if (topBottom === "b") {
        y2 = rect.y + rect.height;
      } else {
        y2 = rect.y + rect.height / 2;
      }
      if (leftRight === "l") {
        x2 = rect.x;
      } else if (leftRight === "r") {
        x2 = rect.x + rect.width;
      } else {
        x2 = rect.x + rect.width / 2;
      }
      return {
        x: x2,
        y: y2
      };
    }
    function reversePoints(points, index2) {
      var reverseMap = {
        t: "b",
        b: "t",
        l: "r",
        r: "l"
      };
      return points.map(function(point, i2) {
        if (i2 === index2) {
          return reverseMap[point] || "c";
        }
        return point;
      }).join("");
    }
    function useAlign(open2, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
      var _React$useState = reactExports.useState({
        ready: false,
        offsetX: 0,
        offsetY: 0,
        offsetR: 0,
        offsetB: 0,
        arrowX: 0,
        arrowY: 0,
        scaleX: 1,
        scaleY: 1,
        align: builtinPlacements[placement] || {}
      }), _React$useState2 = _slicedToArray(_React$useState, 2), offsetInfo = _React$useState2[0], setOffsetInfo = _React$useState2[1];
      var alignCountRef = reactExports.useRef(0);
      var scrollerList = reactExports.useMemo(function() {
        if (!popupEle) {
          return [];
        }
        return collectScroller(popupEle);
      }, [popupEle]);
      var prevFlipRef = reactExports.useRef({});
      var resetFlipCache = function resetFlipCache2() {
        prevFlipRef.current = {};
      };
      if (!open2) {
        resetFlipCache();
      }
      var onAlign = useEvent(function() {
        if (popupEle && target && open2) {
          let getIntersectionVisibleArea2 = function(offsetX, offsetY) {
            var area = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : visibleArea;
            var l2 = popupRect.x + offsetX;
            var t2 = popupRect.y + offsetY;
            var r2 = l2 + popupWidth;
            var b2 = t2 + popupHeight;
            var visibleL = Math.max(l2, area.left);
            var visibleT = Math.max(t2, area.top);
            var visibleR = Math.min(r2, area.right);
            var visibleB = Math.min(b2, area.bottom);
            return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
          }, syncNextPopupPosition2 = function() {
            nextPopupY = popupRect.y + nextOffsetY;
            nextPopupBottom = nextPopupY + popupHeight;
            nextPopupX = popupRect.x + nextOffsetX;
            nextPopupRight = nextPopupX + popupWidth;
          };
          var getIntersectionVisibleArea = getIntersectionVisibleArea2, syncNextPopupPosition = syncNextPopupPosition2;
          var _popupElement$parentE, _popupRect$x, _popupRect$y, _popupElement$parentE2;
          var popupElement = popupEle;
          var doc = popupElement.ownerDocument;
          var win = getWin(popupElement);
          var _win$getComputedStyle = win.getComputedStyle(popupElement), width = _win$getComputedStyle.width, height = _win$getComputedStyle.height, popupPosition = _win$getComputedStyle.position;
          var originLeft = popupElement.style.left;
          var originTop = popupElement.style.top;
          var originRight = popupElement.style.right;
          var originBottom = popupElement.style.bottom;
          var originOverflow = popupElement.style.overflow;
          var placementInfo = _objectSpread2$3(_objectSpread2$3({}, builtinPlacements[placement]), popupAlign);
          var placeholderElement = doc.createElement("div");
          (_popupElement$parentE = popupElement.parentElement) === null || _popupElement$parentE === void 0 || _popupElement$parentE.appendChild(placeholderElement);
          placeholderElement.style.left = "".concat(popupElement.offsetLeft, "px");
          placeholderElement.style.top = "".concat(popupElement.offsetTop, "px");
          placeholderElement.style.position = popupPosition;
          placeholderElement.style.height = "".concat(popupElement.offsetHeight, "px");
          placeholderElement.style.width = "".concat(popupElement.offsetWidth, "px");
          popupElement.style.left = "0";
          popupElement.style.top = "0";
          popupElement.style.right = "auto";
          popupElement.style.bottom = "auto";
          popupElement.style.overflow = "hidden";
          var targetRect;
          if (Array.isArray(target)) {
            targetRect = {
              x: target[0],
              y: target[1],
              width: 0,
              height: 0
            };
          } else {
            var _rect$x, _rect$y;
            var rect = target.getBoundingClientRect();
            rect.x = (_rect$x = rect.x) !== null && _rect$x !== void 0 ? _rect$x : rect.left;
            rect.y = (_rect$y = rect.y) !== null && _rect$y !== void 0 ? _rect$y : rect.top;
            targetRect = {
              x: rect.x,
              y: rect.y,
              width: rect.width,
              height: rect.height
            };
          }
          var popupRect = popupElement.getBoundingClientRect();
          popupRect.x = (_popupRect$x = popupRect.x) !== null && _popupRect$x !== void 0 ? _popupRect$x : popupRect.left;
          popupRect.y = (_popupRect$y = popupRect.y) !== null && _popupRect$y !== void 0 ? _popupRect$y : popupRect.top;
          var _doc$documentElement = doc.documentElement, clientWidth = _doc$documentElement.clientWidth, clientHeight = _doc$documentElement.clientHeight, scrollWidth = _doc$documentElement.scrollWidth, scrollHeight = _doc$documentElement.scrollHeight, scrollTop = _doc$documentElement.scrollTop, scrollLeft = _doc$documentElement.scrollLeft;
          var popupHeight = popupRect.height;
          var popupWidth = popupRect.width;
          var targetHeight = targetRect.height;
          var targetWidth = targetRect.width;
          var visibleRegion = {
            left: 0,
            top: 0,
            right: clientWidth,
            bottom: clientHeight
          };
          var scrollRegion = {
            left: -scrollLeft,
            top: -scrollTop,
            right: scrollWidth - scrollLeft,
            bottom: scrollHeight - scrollTop
          };
          var htmlRegion = placementInfo.htmlRegion;
          var VISIBLE = "visible";
          var VISIBLE_FIRST = "visibleFirst";
          if (htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST) {
            htmlRegion = VISIBLE;
          }
          var isVisibleFirst = htmlRegion === VISIBLE_FIRST;
          var scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
          var visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
          var visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
          var adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
          popupElement.style.left = "auto";
          popupElement.style.top = "auto";
          popupElement.style.right = "0";
          popupElement.style.bottom = "0";
          var popupMirrorRect = popupElement.getBoundingClientRect();
          popupElement.style.left = originLeft;
          popupElement.style.top = originTop;
          popupElement.style.right = originRight;
          popupElement.style.bottom = originBottom;
          popupElement.style.overflow = originOverflow;
          (_popupElement$parentE2 = popupElement.parentElement) === null || _popupElement$parentE2 === void 0 || _popupElement$parentE2.removeChild(placeholderElement);
          var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
          var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
          if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {
            return;
          }
          var offset2 = placementInfo.offset, targetOffset2 = placementInfo.targetOffset;
          var _getNumberOffset = getNumberOffset(popupRect, offset2), _getNumberOffset2 = _slicedToArray(_getNumberOffset, 2), popupOffsetX = _getNumberOffset2[0], popupOffsetY = _getNumberOffset2[1];
          var _getNumberOffset3 = getNumberOffset(targetRect, targetOffset2), _getNumberOffset4 = _slicedToArray(_getNumberOffset3, 2), targetOffsetX = _getNumberOffset4[0], targetOffsetY = _getNumberOffset4[1];
          targetRect.x -= targetOffsetX;
          targetRect.y -= targetOffsetY;
          var _ref3 = placementInfo.points || [], _ref4 = _slicedToArray(_ref3, 2), popupPoint = _ref4[0], targetPoint = _ref4[1];
          var targetPoints = splitPoints(targetPoint);
          var popupPoints = splitPoints(popupPoint);
          var targetAlignPoint = getAlignPoint(targetRect, targetPoints);
          var popupAlignPoint = getAlignPoint(popupRect, popupPoints);
          var nextAlignInfo = _objectSpread2$3({}, placementInfo);
          var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
          var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
          var originIntersectionVisibleArea = getIntersectionVisibleArea2(nextOffsetX, nextOffsetY);
          var originIntersectionRecommendArea = getIntersectionVisibleArea2(nextOffsetX, nextOffsetY, visibleRegionArea);
          var targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
          var popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
          var targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
          var popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
          var overflow = placementInfo.overflow || {};
          var adjustX = overflow.adjustX, adjustY = overflow.adjustY, shiftX = overflow.shiftX, shiftY = overflow.shiftY;
          var supportAdjust = function supportAdjust2(val) {
            if (typeof val === "boolean") {
              return val;
            }
            return val >= 0;
          };
          var nextPopupY;
          var nextPopupBottom;
          var nextPopupX;
          var nextPopupRight;
          syncNextPopupPosition2();
          var needAdjustY = supportAdjust(adjustY);
          var sameTB = popupPoints[0] === targetPoints[0];
          if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
            var tmpNextOffsetY = nextOffsetY;
            if (sameTB) {
              tmpNextOffsetY -= popupHeight - targetHeight;
            } else {
              tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
            }
            var newVisibleArea = getIntersectionVisibleArea2(nextOffsetX, tmpNextOffsetY);
            var newVisibleRecommendArea = getIntersectionVisibleArea2(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
            if (
              // Of course use larger one
              newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
              newVisibleRecommendArea >= originIntersectionRecommendArea)
            ) {
              prevFlipRef.current.bt = true;
              nextOffsetY = tmpNextOffsetY;
              popupOffsetY = -popupOffsetY;
              nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
            } else {
              prevFlipRef.current.bt = false;
            }
          }
          if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
            var _tmpNextOffsetY = nextOffsetY;
            if (sameTB) {
              _tmpNextOffsetY += popupHeight - targetHeight;
            } else {
              _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
            }
            var _newVisibleArea = getIntersectionVisibleArea2(nextOffsetX, _tmpNextOffsetY);
            var _newVisibleRecommendArea = getIntersectionVisibleArea2(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);
            if (
              // Of course use larger one
              _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
              _newVisibleRecommendArea >= originIntersectionRecommendArea)
            ) {
              prevFlipRef.current.tb = true;
              nextOffsetY = _tmpNextOffsetY;
              popupOffsetY = -popupOffsetY;
              nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
            } else {
              prevFlipRef.current.tb = false;
            }
          }
          var needAdjustX = supportAdjust(adjustX);
          var sameLR = popupPoints[1] === targetPoints[1];
          if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
            var tmpNextOffsetX = nextOffsetX;
            if (sameLR) {
              tmpNextOffsetX -= popupWidth - targetWidth;
            } else {
              tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
            }
            var _newVisibleArea2 = getIntersectionVisibleArea2(tmpNextOffsetX, nextOffsetY);
            var _newVisibleRecommendArea2 = getIntersectionVisibleArea2(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
            if (
              // Of course use larger one
              _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
              _newVisibleRecommendArea2 >= originIntersectionRecommendArea)
            ) {
              prevFlipRef.current.rl = true;
              nextOffsetX = tmpNextOffsetX;
              popupOffsetX = -popupOffsetX;
              nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
            } else {
              prevFlipRef.current.rl = false;
            }
          }
          if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
            var _tmpNextOffsetX = nextOffsetX;
            if (sameLR) {
              _tmpNextOffsetX += popupWidth - targetWidth;
            } else {
              _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
            }
            var _newVisibleArea3 = getIntersectionVisibleArea2(_tmpNextOffsetX, nextOffsetY);
            var _newVisibleRecommendArea3 = getIntersectionVisibleArea2(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);
            if (
              // Of course use larger one
              _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
              _newVisibleRecommendArea3 >= originIntersectionRecommendArea)
            ) {
              prevFlipRef.current.lr = true;
              nextOffsetX = _tmpNextOffsetX;
              popupOffsetX = -popupOffsetX;
              nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
            } else {
              prevFlipRef.current.lr = false;
            }
          }
          syncNextPopupPosition2();
          var numShiftX = shiftX === true ? 0 : shiftX;
          if (typeof numShiftX === "number") {
            if (nextPopupX < visibleRegionArea.left) {
              nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
              if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {
                nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
              }
            }
            if (nextPopupRight > visibleRegionArea.right) {
              nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
              if (targetRect.x > visibleRegionArea.right - numShiftX) {
                nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
              }
            }
          }
          var numShiftY = shiftY === true ? 0 : shiftY;
          if (typeof numShiftY === "number") {
            if (nextPopupY < visibleRegionArea.top) {
              nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;
              if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {
                nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
              }
            }
            if (nextPopupBottom > visibleRegionArea.bottom) {
              nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
              if (targetRect.y > visibleRegionArea.bottom - numShiftY) {
                nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
              }
            }
          }
          var popupLeft = popupRect.x + nextOffsetX;
          var popupRight = popupLeft + popupWidth;
          var popupTop = popupRect.y + nextOffsetY;
          var popupBottom = popupTop + popupHeight;
          var targetLeft = targetRect.x;
          var targetRight = targetLeft + targetWidth;
          var targetTop = targetRect.y;
          var targetBottom = targetTop + targetHeight;
          var maxLeft = Math.max(popupLeft, targetLeft);
          var minRight = Math.min(popupRight, targetRight);
          var xCenter = (maxLeft + minRight) / 2;
          var nextArrowX = xCenter - popupLeft;
          var maxTop = Math.max(popupTop, targetTop);
          var minBottom = Math.min(popupBottom, targetBottom);
          var yCenter = (maxTop + minBottom) / 2;
          var nextArrowY = yCenter - popupTop;
          onPopupAlign === null || onPopupAlign === void 0 || onPopupAlign(popupEle, nextAlignInfo);
          var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
          var offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
          if (_scaleX === 1) {
            nextOffsetX = Math.round(nextOffsetX);
            offsetX4Right = Math.round(offsetX4Right);
          }
          if (_scaleY === 1) {
            nextOffsetY = Math.round(nextOffsetY);
            offsetY4Bottom = Math.round(offsetY4Bottom);
          }
          var nextOffsetInfo = {
            ready: true,
            offsetX: nextOffsetX / _scaleX,
            offsetY: nextOffsetY / _scaleY,
            offsetR: offsetX4Right / _scaleX,
            offsetB: offsetY4Bottom / _scaleY,
            arrowX: nextArrowX / _scaleX,
            arrowY: nextArrowY / _scaleY,
            scaleX: _scaleX,
            scaleY: _scaleY,
            align: nextAlignInfo
          };
          setOffsetInfo(nextOffsetInfo);
        }
      });
      var triggerAlign = function triggerAlign2() {
        alignCountRef.current += 1;
        var id = alignCountRef.current;
        Promise.resolve().then(function() {
          if (alignCountRef.current === id) {
            onAlign();
          }
        });
      };
      var resetReady = function resetReady2() {
        setOffsetInfo(function(ori) {
          return _objectSpread2$3(_objectSpread2$3({}, ori), {}, {
            ready: false
          });
        });
      };
      useLayoutEffect$1(resetReady, [placement]);
      useLayoutEffect$1(function() {
        if (!open2) {
          resetReady();
        }
      }, [open2]);
      return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
    }
    function useWatch(open2, target, popup, onAlign, onScroll) {
      useLayoutEffect$1(function() {
        if (open2 && target && popup) {
          let notifyScroll2 = function() {
            onAlign();
            onScroll();
          };
          var notifyScroll = notifyScroll2;
          var targetElement = target;
          var popupElement = popup;
          var targetScrollList = collectScroller(targetElement);
          var popupScrollList = collectScroller(popupElement);
          var win = getWin(popupElement);
          var mergedList = new Set([win].concat(_toConsumableArray(targetScrollList), _toConsumableArray(popupScrollList)));
          mergedList.forEach(function(scroller) {
            scroller.addEventListener("scroll", notifyScroll2, {
              passive: true
            });
          });
          win.addEventListener("resize", notifyScroll2, {
            passive: true
          });
          onAlign();
          return function() {
            mergedList.forEach(function(scroller) {
              scroller.removeEventListener("scroll", notifyScroll2);
              win.removeEventListener("resize", notifyScroll2);
            });
          };
        }
      }, [open2, target, popup]);
    }
    function useWinClick(open2, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
      var openRef = reactExports.useRef(open2);
      openRef.current = open2;
      var popupPointerDownRef = reactExports.useRef(false);
      reactExports.useEffect(function() {
        if (clickToHide && popupEle && (!mask || maskClosable)) {
          var onPointerDown = function onPointerDown2() {
            popupPointerDownRef.current = false;
          };
          var onTriggerClose = function onTriggerClose2(e2) {
            var _e$composedPath;
            if (openRef.current && !inPopupOrChild(((_e$composedPath = e2.composedPath) === null || _e$composedPath === void 0 || (_e$composedPath = _e$composedPath.call(e2)) === null || _e$composedPath === void 0 ? void 0 : _e$composedPath[0]) || e2.target) && !popupPointerDownRef.current) {
              triggerOpen(false);
            }
          };
          var win = getWin(popupEle);
          win.addEventListener("pointerdown", onPointerDown, true);
          win.addEventListener("mousedown", onTriggerClose, true);
          win.addEventListener("contextmenu", onTriggerClose, true);
          var targetShadowRoot = getShadowRoot$1(targetEle);
          if (targetShadowRoot) {
            targetShadowRoot.addEventListener("mousedown", onTriggerClose, true);
            targetShadowRoot.addEventListener("contextmenu", onTriggerClose, true);
          }
          return function() {
            win.removeEventListener("pointerdown", onPointerDown, true);
            win.removeEventListener("mousedown", onTriggerClose, true);
            win.removeEventListener("contextmenu", onTriggerClose, true);
            if (targetShadowRoot) {
              targetShadowRoot.removeEventListener("mousedown", onTriggerClose, true);
              targetShadowRoot.removeEventListener("contextmenu", onTriggerClose, true);
            }
          };
        }
      }, [clickToHide, targetEle, popupEle, mask, maskClosable]);
      function onPopupPointerDown() {
        popupPointerDownRef.current = true;
      }
      return onPopupPointerDown;
    }
    var _excluded$x = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
    function generateTrigger() {
      var PortalComponent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Portal;
      var Trigger2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
        var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-trigger-popup" : _props$prefixCls, children = props.children, _props$action = props.action, action = _props$action === void 0 ? "hover" : _props$action, showAction = props.showAction, hideAction = props.hideAction, popupVisible = props.popupVisible, defaultPopupVisible = props.defaultPopupVisible, onPopupVisibleChange = props.onPopupVisibleChange, afterPopupVisibleChange = props.afterPopupVisibleChange, mouseEnterDelay = props.mouseEnterDelay, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, focusDelay = props.focusDelay, blurDelay = props.blurDelay, mask = props.mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getPopupContainer = props.getPopupContainer, forceRender = props.forceRender, autoDestroy = props.autoDestroy, destroyPopupOnHide = props.destroyPopupOnHide, popup = props.popup, popupClassName = props.popupClassName, popupStyle = props.popupStyle, popupPlacement = props.popupPlacement, _props$builtinPlaceme = props.builtinPlacements, builtinPlacements = _props$builtinPlaceme === void 0 ? {} : _props$builtinPlaceme, popupAlign = props.popupAlign, zIndex = props.zIndex, stretch = props.stretch, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign, fresh = props.fresh, alignPoint = props.alignPoint, onPopupClick = props.onPopupClick, onPopupAlign = props.onPopupAlign, arrow = props.arrow, popupMotion = props.popupMotion, maskMotion = props.maskMotion, popupTransitionName = props.popupTransitionName, popupAnimation = props.popupAnimation, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, className = props.className, getTriggerDOMNode = props.getTriggerDOMNode, restProps = _objectWithoutProperties(props, _excluded$x);
        var mergedAutoDestroy = autoDestroy || destroyPopupOnHide || false;
        var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
        useLayoutEffect$1(function() {
          setMobile(isMobile());
        }, []);
        var subPopupElements = reactExports.useRef({});
        var parentContext = reactExports.useContext(TriggerContext);
        var context = reactExports.useMemo(function() {
          return {
            registerSubPopup: function registerSubPopup(id2, subPopupEle) {
              subPopupElements.current[id2] = subPopupEle;
              parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id2, subPopupEle);
            }
          };
        }, [parentContext]);
        var id = useId$1();
        var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), popupEle = _React$useState4[0], setPopupEle = _React$useState4[1];
        var externalPopupRef = reactExports.useRef(null);
        var setPopupRef = useEvent(function(node2) {
          externalPopupRef.current = node2;
          if (isDOM(node2) && popupEle !== node2) {
            setPopupEle(node2);
          }
          parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id, node2);
        });
        var _React$useState5 = reactExports.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), targetEle = _React$useState6[0], setTargetEle = _React$useState6[1];
        var externalForwardRef = reactExports.useRef(null);
        var setTargetRef = useEvent(function(node2) {
          if (isDOM(node2) && targetEle !== node2) {
            setTargetEle(node2);
            externalForwardRef.current = node2;
          }
        });
        var child = reactExports.Children.only(children);
        var originChildProps = (child === null || child === void 0 ? void 0 : child.props) || {};
        var cloneProps = {};
        var inPopupOrChild = useEvent(function(ele) {
          var _getShadowRoot, _getShadowRoot2;
          var childDOM = targetEle;
          return (childDOM === null || childDOM === void 0 ? void 0 : childDOM.contains(ele)) || ((_getShadowRoot = getShadowRoot$1(childDOM)) === null || _getShadowRoot === void 0 ? void 0 : _getShadowRoot.host) === ele || ele === childDOM || (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(ele)) || ((_getShadowRoot2 = getShadowRoot$1(popupEle)) === null || _getShadowRoot2 === void 0 ? void 0 : _getShadowRoot2.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some(function(subPopupEle) {
            return (subPopupEle === null || subPopupEle === void 0 ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle;
          });
        });
        var mergePopupMotion = getMotion$1(prefixCls, popupMotion, popupAnimation, popupTransitionName);
        var mergeMaskMotion = getMotion$1(prefixCls, maskMotion, maskAnimation, maskTransitionName);
        var _React$useState7 = reactExports.useState(defaultPopupVisible || false), _React$useState8 = _slicedToArray(_React$useState7, 2), internalOpen = _React$useState8[0], setInternalOpen = _React$useState8[1];
        var mergedOpen = popupVisible !== null && popupVisible !== void 0 ? popupVisible : internalOpen;
        var setMergedOpen = useEvent(function(nextOpen) {
          if (popupVisible === void 0) {
            setInternalOpen(nextOpen);
          }
        });
        useLayoutEffect$1(function() {
          setInternalOpen(popupVisible || false);
        }, [popupVisible]);
        var openRef = reactExports.useRef(mergedOpen);
        openRef.current = mergedOpen;
        var lastTriggerRef = reactExports.useRef([]);
        lastTriggerRef.current = [];
        var internalTriggerOpen = useEvent(function(nextOpen) {
          var _lastTriggerRef$curre;
          setMergedOpen(nextOpen);
          if (((_lastTriggerRef$curre = lastTriggerRef.current[lastTriggerRef.current.length - 1]) !== null && _lastTriggerRef$curre !== void 0 ? _lastTriggerRef$curre : mergedOpen) !== nextOpen) {
            lastTriggerRef.current.push(nextOpen);
            onPopupVisibleChange === null || onPopupVisibleChange === void 0 || onPopupVisibleChange(nextOpen);
          }
        });
        var delayRef = reactExports.useRef();
        var clearDelay = function clearDelay2() {
          clearTimeout(delayRef.current);
        };
        var triggerOpen = function triggerOpen2(nextOpen) {
          var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          clearDelay();
          if (delay === 0) {
            internalTriggerOpen(nextOpen);
          } else {
            delayRef.current = setTimeout(function() {
              internalTriggerOpen(nextOpen);
            }, delay * 1e3);
          }
        };
        reactExports.useEffect(function() {
          return clearDelay;
        }, []);
        var _React$useState9 = reactExports.useState(false), _React$useState10 = _slicedToArray(_React$useState9, 2), inMotion = _React$useState10[0], setInMotion = _React$useState10[1];
        useLayoutEffect$1(function(firstMount) {
          if (!firstMount || mergedOpen) {
            setInMotion(true);
          }
        }, [mergedOpen]);
        var _React$useState11 = reactExports.useState(null), _React$useState12 = _slicedToArray(_React$useState11, 2), motionPrepareResolve = _React$useState12[0], setMotionPrepareResolve = _React$useState12[1];
        var _React$useState13 = reactExports.useState(null), _React$useState14 = _slicedToArray(_React$useState13, 2), mousePos = _React$useState14[0], setMousePos = _React$useState14[1];
        var setMousePosByEvent = function setMousePosByEvent2(event) {
          setMousePos([event.clientX, event.clientY]);
        };
        var _useAlign = useAlign(mergedOpen, popupEle, alignPoint && mousePos !== null ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign), _useAlign2 = _slicedToArray(_useAlign, 11), ready = _useAlign2[0], offsetX = _useAlign2[1], offsetY = _useAlign2[2], offsetR = _useAlign2[3], offsetB = _useAlign2[4], arrowX = _useAlign2[5], arrowY = _useAlign2[6], scaleX = _useAlign2[7], scaleY = _useAlign2[8], alignInfo = _useAlign2[9], onAlign = _useAlign2[10];
        var _useAction = useAction(mobile, action, showAction, hideAction), _useAction2 = _slicedToArray(_useAction, 2), showActions = _useAction2[0], hideActions = _useAction2[1];
        var clickToShow = showActions.has("click");
        var clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
        var triggerAlign = useEvent(function() {
          if (!inMotion) {
            onAlign();
          }
        });
        var onScroll = function onScroll2() {
          if (openRef.current && alignPoint && clickToHide) {
            triggerOpen(false);
          }
        };
        useWatch(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);
        useLayoutEffect$1(function() {
          triggerAlign();
        }, [mousePos, popupPlacement]);
        useLayoutEffect$1(function() {
          if (mergedOpen && !(builtinPlacements !== null && builtinPlacements !== void 0 && builtinPlacements[popupPlacement])) {
            triggerAlign();
          }
        }, [JSON.stringify(popupAlign)]);
        var alignedClassName = reactExports.useMemo(function() {
          var baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
          return classNames(baseClassName, getPopupClassNameFromAlign === null || getPopupClassNameFromAlign === void 0 ? void 0 : getPopupClassNameFromAlign(alignInfo));
        }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);
        reactExports.useImperativeHandle(ref, function() {
          return {
            nativeElement: externalForwardRef.current,
            popupElement: externalPopupRef.current,
            forceAlign: triggerAlign
          };
        });
        var _React$useState15 = reactExports.useState(0), _React$useState16 = _slicedToArray(_React$useState15, 2), targetWidth = _React$useState16[0], setTargetWidth = _React$useState16[1];
        var _React$useState17 = reactExports.useState(0), _React$useState18 = _slicedToArray(_React$useState17, 2), targetHeight = _React$useState18[0], setTargetHeight = _React$useState18[1];
        var syncTargetSize = function syncTargetSize2() {
          if (stretch && targetEle) {
            var rect = targetEle.getBoundingClientRect();
            setTargetWidth(rect.width);
            setTargetHeight(rect.height);
          }
        };
        var onTargetResize = function onTargetResize2() {
          syncTargetSize();
          triggerAlign();
        };
        var onVisibleChanged = function onVisibleChanged2(visible) {
          setInMotion(false);
          onAlign();
          afterPopupVisibleChange === null || afterPopupVisibleChange === void 0 || afterPopupVisibleChange(visible);
        };
        var onPrepare = function onPrepare2() {
          return new Promise(function(resolve) {
            syncTargetSize();
            setMotionPrepareResolve(function() {
              return resolve;
            });
          });
        };
        useLayoutEffect$1(function() {
          if (motionPrepareResolve) {
            onAlign();
            motionPrepareResolve();
            setMotionPrepareResolve(null);
          }
        }, [motionPrepareResolve]);
        function wrapperAction(eventName, nextOpen, delay, preEvent) {
          cloneProps[eventName] = function(event) {
            var _originChildProps$eve;
            preEvent === null || preEvent === void 0 || preEvent(event);
            triggerOpen(nextOpen, delay);
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            (_originChildProps$eve = originChildProps[eventName]) === null || _originChildProps$eve === void 0 || _originChildProps$eve.call.apply(_originChildProps$eve, [originChildProps, event].concat(args));
          };
        }
        if (clickToShow || clickToHide) {
          cloneProps.onClick = function(event) {
            var _originChildProps$onC;
            if (openRef.current && clickToHide) {
              triggerOpen(false);
            } else if (!openRef.current && clickToShow) {
              setMousePosByEvent(event);
              triggerOpen(true);
            }
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            (_originChildProps$onC = originChildProps.onClick) === null || _originChildProps$onC === void 0 || _originChildProps$onC.call.apply(_originChildProps$onC, [originChildProps, event].concat(args));
          };
        }
        var onPopupPointerDown = useWinClick(mergedOpen, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
        var hoverToShow = showActions.has("hover");
        var hoverToHide = hideActions.has("hover");
        var onPopupMouseEnter;
        var onPopupMouseLeave;
        if (hoverToShow) {
          wrapperAction("onMouseEnter", true, mouseEnterDelay, function(event) {
            setMousePosByEvent(event);
          });
          wrapperAction("onPointerEnter", true, mouseEnterDelay, function(event) {
            setMousePosByEvent(event);
          });
          onPopupMouseEnter = function onPopupMouseEnter2(event) {
            if ((mergedOpen || inMotion) && popupEle !== null && popupEle !== void 0 && popupEle.contains(event.target)) {
              triggerOpen(true, mouseEnterDelay);
            }
          };
          if (alignPoint) {
            cloneProps.onMouseMove = function(event) {
              var _originChildProps$onM;
              (_originChildProps$onM = originChildProps.onMouseMove) === null || _originChildProps$onM === void 0 || _originChildProps$onM.call(originChildProps, event);
            };
          }
        }
        if (hoverToHide) {
          wrapperAction("onMouseLeave", false, mouseLeaveDelay);
          wrapperAction("onPointerLeave", false, mouseLeaveDelay);
          onPopupMouseLeave = function onPopupMouseLeave2() {
            triggerOpen(false, mouseLeaveDelay);
          };
        }
        if (showActions.has("focus")) {
          wrapperAction("onFocus", true, focusDelay);
        }
        if (hideActions.has("focus")) {
          wrapperAction("onBlur", false, blurDelay);
        }
        if (showActions.has("contextMenu")) {
          cloneProps.onContextMenu = function(event) {
            var _originChildProps$onC2;
            if (openRef.current && hideActions.has("contextMenu")) {
              triggerOpen(false);
            } else {
              setMousePosByEvent(event);
              triggerOpen(true);
            }
            event.preventDefault();
            for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
              args[_key3 - 1] = arguments[_key3];
            }
            (_originChildProps$onC2 = originChildProps.onContextMenu) === null || _originChildProps$onC2 === void 0 || _originChildProps$onC2.call.apply(_originChildProps$onC2, [originChildProps, event].concat(args));
          };
        }
        if (className) {
          cloneProps.className = classNames(originChildProps.className, className);
        }
        var mergedChildrenProps = _objectSpread2$3(_objectSpread2$3({}, originChildProps), cloneProps);
        var passedProps = {};
        var passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
        passedEventList.forEach(function(eventName) {
          if (restProps[eventName]) {
            passedProps[eventName] = function() {
              var _mergedChildrenProps$;
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }
              (_mergedChildrenProps$ = mergedChildrenProps[eventName]) === null || _mergedChildrenProps$ === void 0 || _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [mergedChildrenProps].concat(args));
              restProps[eventName].apply(restProps, args);
            };
          }
        });
        var triggerNode = /* @__PURE__ */ reactExports.cloneElement(child, _objectSpread2$3(_objectSpread2$3({}, mergedChildrenProps), passedProps));
        var arrowPos = {
          x: arrowX,
          y: arrowY
        };
        var innerArrow = arrow ? _objectSpread2$3({}, arrow !== true ? arrow : {}) : null;
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          disabled: !mergedOpen,
          ref: setTargetRef,
          onResize: onTargetResize
        }, /* @__PURE__ */ reactExports.createElement(TriggerWrapper, {
          getTriggerDOMNode
        }, triggerNode)), /* @__PURE__ */ reactExports.createElement(TriggerContext.Provider, {
          value: context
        }, /* @__PURE__ */ reactExports.createElement(Popup$2, {
          portal: PortalComponent,
          ref: setPopupRef,
          prefixCls,
          popup,
          className: classNames(popupClassName, alignedClassName),
          style: popupStyle,
          target: targetEle,
          onMouseEnter: onPopupMouseEnter,
          onMouseLeave: onPopupMouseLeave,
          onPointerEnter: onPopupMouseEnter,
          zIndex,
          open: mergedOpen,
          keepDom: inMotion,
          fresh,
          onClick: onPopupClick,
          onPointerDownCapture: onPopupPointerDown,
          mask,
          motion: mergePopupMotion,
          maskMotion: mergeMaskMotion,
          onVisibleChanged,
          onPrepare,
          forceRender,
          autoDestroy: mergedAutoDestroy,
          getPopupContainer,
          align: alignInfo,
          arrow: innerArrow,
          arrowPos,
          ready,
          offsetX,
          offsetY,
          offsetR,
          offsetB,
          onAlign: triggerAlign,
          stretch,
          targetWidth: targetWidth / scaleX,
          targetHeight: targetHeight / scaleY
        })));
      });
      return Trigger2;
    }
    const Trigger = generateTrigger(Portal);
    var _excluded$w = ["prefixCls", "disabled", "visible", "children", "popupElement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "builtinPlacements", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"];
    var getBuiltInPlacements$1 = function getBuiltInPlacements2(dropdownMatchSelectWidth) {
      var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
      return {
        bottomLeft: {
          points: ["tl", "bl"],
          offset: [0, 4],
          overflow: {
            adjustX,
            adjustY: 1
          },
          htmlRegion: "scroll"
        },
        bottomRight: {
          points: ["tr", "br"],
          offset: [0, 4],
          overflow: {
            adjustX,
            adjustY: 1
          },
          htmlRegion: "scroll"
        },
        topLeft: {
          points: ["bl", "tl"],
          offset: [0, -4],
          overflow: {
            adjustX,
            adjustY: 1
          },
          htmlRegion: "scroll"
        },
        topRight: {
          points: ["br", "tr"],
          offset: [0, -4],
          overflow: {
            adjustX,
            adjustY: 1
          },
          htmlRegion: "scroll"
        }
      };
    };
    var SelectTrigger = function SelectTrigger2(props, ref) {
      var prefixCls = props.prefixCls;
      props.disabled;
      var visible = props.visible, children = props.children, popupElement = props.popupElement, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, _props$direction = props.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction, placement = props.placement, builtinPlacements = props.builtinPlacements, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, getPopupContainer = props.getPopupContainer, empty = props.empty, getTriggerDOMNode = props.getTriggerDOMNode, onPopupVisibleChange = props.onPopupVisibleChange, onPopupMouseEnter = props.onPopupMouseEnter, restProps = _objectWithoutProperties(props, _excluded$w);
      var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
      var popupNode = popupElement;
      if (dropdownRender) {
        popupNode = dropdownRender(popupElement);
      }
      var mergedBuiltinPlacements2 = reactExports.useMemo(function() {
        return builtinPlacements || getBuiltInPlacements$1(dropdownMatchSelectWidth);
      }, [builtinPlacements, dropdownMatchSelectWidth]);
      var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName;
      var isNumberPopupWidth = typeof dropdownMatchSelectWidth === "number";
      var stretch = reactExports.useMemo(function() {
        if (isNumberPopupWidth) {
          return null;
        }
        return dropdownMatchSelectWidth === false ? "minWidth" : "width";
      }, [dropdownMatchSelectWidth, isNumberPopupWidth]);
      var popupStyle = dropdownStyle;
      if (isNumberPopupWidth) {
        popupStyle = _objectSpread2$3(_objectSpread2$3({}, popupStyle), {}, {
          width: dropdownMatchSelectWidth
        });
      }
      var triggerPopupRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, function() {
        return {
          getPopupElement: function getPopupElement() {
            var _triggerPopupRef$curr;
            return (_triggerPopupRef$curr = triggerPopupRef.current) === null || _triggerPopupRef$curr === void 0 ? void 0 : _triggerPopupRef$curr.popupElement;
          }
        };
      });
      return /* @__PURE__ */ reactExports.createElement(Trigger, _extends$2({}, restProps, {
        showAction: onPopupVisibleChange ? ["click"] : [],
        hideAction: onPopupVisibleChange ? ["click"] : [],
        popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
        builtinPlacements: mergedBuiltinPlacements2,
        prefixCls: dropdownPrefixCls,
        popupTransitionName: mergedTransitionName,
        popup: /* @__PURE__ */ reactExports.createElement("div", {
          onMouseEnter: onPopupMouseEnter
        }, popupNode),
        ref: triggerPopupRef,
        stretch,
        popupAlign: dropdownAlign,
        popupVisible: visible,
        getPopupContainer,
        popupClassName: classNames(dropdownClassName, _defineProperty({}, "".concat(dropdownPrefixCls, "-empty"), empty)),
        popupStyle,
        getTriggerDOMNode,
        onPopupVisibleChange
      }), children);
    };
    var RefSelectTrigger = /* @__PURE__ */ reactExports.forwardRef(SelectTrigger);
    function getKey(data, index2) {
      var key = data.key;
      var value;
      if ("value" in data) {
        value = data.value;
      }
      if (key !== null && key !== void 0) {
        return key;
      }
      if (value !== void 0) {
        return value;
      }
      return "rc-index-key-".concat(index2);
    }
    function isValidCount(value) {
      return typeof value !== "undefined" && !Number.isNaN(value);
    }
    function fillFieldNames(fieldNames, childrenAsData) {
      var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, options2 = _ref.options, groupLabel = _ref.groupLabel;
      var mergedLabel = label || (childrenAsData ? "children" : "label");
      return {
        label: mergedLabel,
        value: value || "value",
        options: options2 || "options",
        groupLabel: groupLabel || mergedLabel
      };
    }
    function flattenOptions(options2) {
      var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fieldNames = _ref2.fieldNames, childrenAsData = _ref2.childrenAsData;
      var flattenList = [];
      var _fillFieldNames = fillFieldNames(fieldNames, false), fieldLabel = _fillFieldNames.label, fieldValue = _fillFieldNames.value, fieldOptions = _fillFieldNames.options, groupLabel = _fillFieldNames.groupLabel;
      function dig(list, isGroupOption) {
        if (!Array.isArray(list)) {
          return;
        }
        list.forEach(function(data) {
          if (isGroupOption || !(fieldOptions in data)) {
            var value = data[fieldValue];
            flattenList.push({
              key: getKey(data, flattenList.length),
              groupOption: isGroupOption,
              data,
              label: data[fieldLabel],
              value
            });
          } else {
            var grpLabel = data[groupLabel];
            if (grpLabel === void 0 && childrenAsData) {
              grpLabel = data.label;
            }
            flattenList.push({
              key: getKey(data, flattenList.length),
              group: true,
              data,
              label: grpLabel
            });
            dig(data[fieldOptions], true);
          }
        });
      }
      dig(options2, false);
      return flattenList;
    }
    function injectPropsWithOption(option) {
      var newOption = _objectSpread2$3({}, option);
      if (!("props" in newOption)) {
        Object.defineProperty(newOption, "props", {
          get: function get2() {
            warningOnce$1(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
            return newOption;
          }
        });
      }
      return newOption;
    }
    var getSeparatedContent = function getSeparatedContent2(text, tokens, end) {
      if (!tokens || !tokens.length) {
        return null;
      }
      var match2 = false;
      var separate = function separate2(str, _ref3) {
        var _ref4 = _toArray(_ref3), token2 = _ref4[0], restTokens = _ref4.slice(1);
        if (!token2) {
          return [str];
        }
        var list2 = str.split(token2);
        match2 = match2 || list2.length > 1;
        return list2.reduce(function(prevList, unitStr) {
          return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate2(unitStr, restTokens)));
        }, []).filter(Boolean);
      };
      var list = separate(text, tokens);
      if (match2) {
        return typeof end !== "undefined" ? list.slice(0, end) : list;
      } else {
        return null;
      }
    };
    var SelectContext = /* @__PURE__ */ reactExports.createContext(null);
    function Polite(props) {
      var visible = props.visible, values = props.values;
      if (!visible) {
        return null;
      }
      var MAX_COUNT = 50;
      return /* @__PURE__ */ reactExports.createElement("span", {
        "aria-live": "polite",
        style: {
          width: 0,
          height: 0,
          position: "absolute",
          overflow: "hidden",
          opacity: 0
        }
      }, "".concat(values.slice(0, MAX_COUNT).map(function(_ref) {
        var label = _ref.label, value = _ref.value;
        return ["number", "string"].includes(_typeof$1(label)) ? label : value;
      }).join(", ")), values.length > MAX_COUNT ? ", ..." : null);
    }
    var _excluded$v = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "autoClearSearchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "prefix", "suffixIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "builtinPlacements", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"];
    var DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autoFocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex"];
    var isMultiple = function isMultiple2(mode) {
      return mode === "tags" || mode === "multiple";
    };
    var BaseSelect = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _customizeRawInputEle;
      var id = props.id, prefixCls = props.prefixCls, className = props.className, showSearch = props.showSearch, tagRender = props.tagRender, direction = props.direction, omitDomProps = props.omitDomProps, displayValues = props.displayValues, onDisplayValuesChange = props.onDisplayValuesChange, emptyOptions = props.emptyOptions, _props$notFoundConten = props.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? "Not Found" : _props$notFoundConten, onClear = props.onClear, mode = props.mode, disabled = props.disabled, loading = props.loading, getInputElement = props.getInputElement, getRawInputElement = props.getRawInputElement, open2 = props.open, defaultOpen = props.defaultOpen, onDropdownVisibleChange = props.onDropdownVisibleChange, activeValue = props.activeValue, onActiveValueChange = props.onActiveValueChange, activeDescendantId = props.activeDescendantId, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSplit = props.onSearchSplit, tokenSeparators = props.tokenSeparators, allowClear = props.allowClear, prefix2 = props.prefix, suffixIcon = props.suffixIcon, clearIcon = props.clearIcon, OptionList2 = props.OptionList, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, placement = props.placement, builtinPlacements = props.builtinPlacements, getPopupContainer = props.getPopupContainer, _props$showAction = props.showAction, showAction = _props$showAction === void 0 ? [] : _props$showAction, onFocus = props.onFocus, onBlur = props.onBlur, onKeyUp = props.onKeyUp, onKeyDown = props.onKeyDown, onMouseDown = props.onMouseDown, restProps = _objectWithoutProperties(props, _excluded$v);
      var multiple = isMultiple(mode);
      var mergedShowSearch = (showSearch !== void 0 ? showSearch : multiple) || mode === "combobox";
      var domProps = _objectSpread2$3({}, restProps);
      DEFAULT_OMIT_PROPS.forEach(function(propName) {
        delete domProps[propName];
      });
      omitDomProps === null || omitDomProps === void 0 || omitDomProps.forEach(function(propName) {
        delete domProps[propName];
      });
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
      reactExports.useEffect(function() {
        setMobile(isMobile());
      }, []);
      var containerRef = reactExports.useRef(null);
      var selectorDomRef = reactExports.useRef(null);
      var triggerRef = reactExports.useRef(null);
      var selectorRef = reactExports.useRef(null);
      var listRef = reactExports.useRef(null);
      var blurRef = reactExports.useRef(false);
      var _useDelayReset = useDelayReset(), _useDelayReset2 = _slicedToArray(_useDelayReset, 3), mockFocused = _useDelayReset2[0], setMockFocused = _useDelayReset2[1], cancelSetMockFocused = _useDelayReset2[2];
      reactExports.useImperativeHandle(ref, function() {
        var _selectorRef$current, _selectorRef$current2;
        return {
          focus: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.focus,
          blur: (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 ? void 0 : _selectorRef$current2.blur,
          scrollTo: function scrollTo(arg) {
            var _listRef$current;
            return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(arg);
          },
          nativeElement: containerRef.current || selectorDomRef.current
        };
      });
      var mergedSearchValue = reactExports.useMemo(function() {
        var _displayValues$;
        if (mode !== "combobox") {
          return searchValue;
        }
        var val = (_displayValues$ = displayValues[0]) === null || _displayValues$ === void 0 ? void 0 : _displayValues$.value;
        return typeof val === "string" || typeof val === "number" ? String(val) : "";
      }, [searchValue, mode, displayValues]);
      var customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
      var customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
      var customizeRawInputRef = useComposeRef(selectorDomRef, customizeRawInputElement === null || customizeRawInputElement === void 0 || (_customizeRawInputEle = customizeRawInputElement.props) === null || _customizeRawInputEle === void 0 ? void 0 : _customizeRawInputEle.ref);
      var _React$useState3 = reactExports.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), rendered = _React$useState4[0], setRendered = _React$useState4[1];
      useLayoutEffect$1(function() {
        setRendered(true);
      }, []);
      var _useMergedState = useMergedState(false, {
        defaultValue: defaultOpen,
        value: open2
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerOpen = _useMergedState2[0], setInnerOpen = _useMergedState2[1];
      var mergedOpen = rendered ? innerOpen : false;
      var emptyListContent = !notFoundContent && emptyOptions;
      if (disabled || emptyListContent && mergedOpen && mode === "combobox") {
        mergedOpen = false;
      }
      var triggerOpen = emptyListContent ? false : mergedOpen;
      var onToggleOpen = reactExports.useCallback(function(newOpen) {
        var nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen;
        if (!disabled) {
          setInnerOpen(nextOpen);
          if (mergedOpen !== nextOpen) {
            onDropdownVisibleChange === null || onDropdownVisibleChange === void 0 || onDropdownVisibleChange(nextOpen);
          }
        }
      }, [disabled, mergedOpen, setInnerOpen, onDropdownVisibleChange]);
      var tokenWithEnter = reactExports.useMemo(function() {
        return (tokenSeparators || []).some(function(tokenSeparator) {
          return ["\n", "\r\n"].includes(tokenSeparator);
        });
      }, [tokenSeparators]);
      var _ref = reactExports.useContext(SelectContext) || {}, maxCount = _ref.maxCount, rawValues = _ref.rawValues;
      var onInternalSearch = function onInternalSearch2(searchText, fromTyping, isCompositing) {
        if (multiple && isValidCount(maxCount) && (rawValues === null || rawValues === void 0 ? void 0 : rawValues.size) >= maxCount) {
          return;
        }
        var ret = true;
        var newSearchText = searchText;
        onActiveValueChange === null || onActiveValueChange === void 0 || onActiveValueChange(null);
        var separatedList = getSeparatedContent(searchText, tokenSeparators, isValidCount(maxCount) ? maxCount - rawValues.size : void 0);
        var patchLabels = isCompositing ? null : separatedList;
        if (mode !== "combobox" && patchLabels) {
          newSearchText = "";
          onSearchSplit === null || onSearchSplit === void 0 || onSearchSplit(patchLabels);
          onToggleOpen(false);
          ret = false;
        }
        if (onSearch && mergedSearchValue !== newSearchText) {
          onSearch(newSearchText, {
            source: fromTyping ? "typing" : "effect"
          });
        }
        return ret;
      };
      var onInternalSearchSubmit = function onInternalSearchSubmit2(searchText) {
        if (!searchText || !searchText.trim()) {
          return;
        }
        onSearch(searchText, {
          source: "submit"
        });
      };
      reactExports.useEffect(function() {
        if (!mergedOpen && !multiple && mode !== "combobox") {
          onInternalSearch("", false, false);
        }
      }, [mergedOpen]);
      reactExports.useEffect(function() {
        if (innerOpen && disabled) {
          setInnerOpen(false);
        }
        if (disabled && !blurRef.current) {
          setMockFocused(false);
        }
      }, [disabled]);
      var _useLock = useLock(), _useLock2 = _slicedToArray(_useLock, 2), getClearLock = _useLock2[0], setClearLock = _useLock2[1];
      var keyLockRef = reactExports.useRef(false);
      var onInternalKeyDown = function onInternalKeyDown2(event) {
        var clearLock = getClearLock();
        var key = event.key;
        var isEnterKey = key === "Enter";
        if (isEnterKey) {
          if (mode !== "combobox") {
            event.preventDefault();
          }
          if (!mergedOpen) {
            onToggleOpen(true);
          }
        }
        setClearLock(!!mergedSearchValue);
        if (key === "Backspace" && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
          var cloneDisplayValues = _toConsumableArray(displayValues);
          var removedDisplayValue = null;
          for (var i2 = cloneDisplayValues.length - 1; i2 >= 0; i2 -= 1) {
            var current = cloneDisplayValues[i2];
            if (!current.disabled) {
              cloneDisplayValues.splice(i2, 1);
              removedDisplayValue = current;
              break;
            }
          }
          if (removedDisplayValue) {
            onDisplayValuesChange(cloneDisplayValues, {
              type: "remove",
              values: [removedDisplayValue]
            });
          }
        }
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        if (mergedOpen && (!isEnterKey || !keyLockRef.current)) {
          var _listRef$current2;
          if (isEnterKey) {
            keyLockRef.current = true;
          }
          (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 || _listRef$current2.onKeyDown.apply(_listRef$current2, [event].concat(rest));
        }
        onKeyDown === null || onKeyDown === void 0 || onKeyDown.apply(void 0, [event].concat(rest));
      };
      var onInternalKeyUp = function onInternalKeyUp2(event) {
        for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          rest[_key2 - 1] = arguments[_key2];
        }
        if (mergedOpen) {
          var _listRef$current3;
          (_listRef$current3 = listRef.current) === null || _listRef$current3 === void 0 || _listRef$current3.onKeyUp.apply(_listRef$current3, [event].concat(rest));
        }
        if (event.key === "Enter") {
          keyLockRef.current = false;
        }
        onKeyUp === null || onKeyUp === void 0 || onKeyUp.apply(void 0, [event].concat(rest));
      };
      var onSelectorRemove = function onSelectorRemove2(val) {
        var newValues = displayValues.filter(function(i2) {
          return i2 !== val;
        });
        onDisplayValuesChange(newValues, {
          type: "remove",
          values: [val]
        });
      };
      var onInputBlur = function onInputBlur2() {
        keyLockRef.current = false;
      };
      var focusRef = reactExports.useRef(false);
      var onContainerFocus = function onContainerFocus2() {
        setMockFocused(true);
        if (!disabled) {
          if (onFocus && !focusRef.current) {
            onFocus.apply(void 0, arguments);
          }
          if (showAction.includes("focus")) {
            onToggleOpen(true);
          }
        }
        focusRef.current = true;
      };
      var onContainerBlur = function onContainerBlur2() {
        blurRef.current = true;
        setMockFocused(false, function() {
          focusRef.current = false;
          blurRef.current = false;
          onToggleOpen(false);
        });
        if (disabled) {
          return;
        }
        if (mergedSearchValue) {
          if (mode === "tags") {
            onSearch(mergedSearchValue, {
              source: "submit"
            });
          } else if (mode === "multiple") {
            onSearch("", {
              source: "blur"
            });
          }
        }
        if (onBlur) {
          onBlur.apply(void 0, arguments);
        }
      };
      var activeTimeoutIds = [];
      reactExports.useEffect(function() {
        return function() {
          activeTimeoutIds.forEach(function(timeoutId) {
            return clearTimeout(timeoutId);
          });
          activeTimeoutIds.splice(0, activeTimeoutIds.length);
        };
      }, []);
      var onInternalMouseDown = function onInternalMouseDown2(event) {
        var _triggerRef$current;
        var target = event.target;
        var popupElement = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getPopupElement();
        if (popupElement && popupElement.contains(target)) {
          var timeoutId = setTimeout(function() {
            var index2 = activeTimeoutIds.indexOf(timeoutId);
            if (index2 !== -1) {
              activeTimeoutIds.splice(index2, 1);
            }
            cancelSetMockFocused();
            if (!mobile && !popupElement.contains(document.activeElement)) {
              var _selectorRef$current3;
              (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 || _selectorRef$current3.focus();
            }
          });
          activeTimeoutIds.push(timeoutId);
        }
        for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          restArgs[_key3 - 1] = arguments[_key3];
        }
        onMouseDown === null || onMouseDown === void 0 || onMouseDown.apply(void 0, [event].concat(restArgs));
      };
      var _React$useState5 = reactExports.useState({}), _React$useState6 = _slicedToArray(_React$useState5, 2), forceUpdate = _React$useState6[1];
      function onPopupMouseEnter() {
        forceUpdate({});
      }
      var onTriggerVisibleChange;
      if (customizeRawInputElement) {
        onTriggerVisibleChange = function onTriggerVisibleChange2(newOpen) {
          onToggleOpen(newOpen);
        };
      }
      useSelectTriggerControl(function() {
        var _triggerRef$current2;
        return [containerRef.current, (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getPopupElement()];
      }, triggerOpen, onToggleOpen, !!customizeRawInputElement);
      var baseSelectContext = reactExports.useMemo(function() {
        return _objectSpread2$3(_objectSpread2$3({}, props), {}, {
          notFoundContent,
          open: mergedOpen,
          triggerOpen,
          id,
          showSearch: mergedShowSearch,
          multiple,
          toggleOpen: onToggleOpen
        });
      }, [props, notFoundContent, triggerOpen, mergedOpen, id, mergedShowSearch, multiple, onToggleOpen]);
      var showSuffixIcon = !!suffixIcon || loading;
      var arrowNode;
      if (showSuffixIcon) {
        arrowNode = /* @__PURE__ */ reactExports.createElement(TransBtn, {
          className: classNames("".concat(prefixCls, "-arrow"), _defineProperty({}, "".concat(prefixCls, "-arrow-loading"), loading)),
          customizeIcon: suffixIcon,
          customizeIconProps: {
            loading,
            searchValue: mergedSearchValue,
            open: mergedOpen,
            focused: mockFocused,
            showSearch: mergedShowSearch
          }
        });
      }
      var onClearMouseDown = function onClearMouseDown2() {
        var _selectorRef$current4;
        onClear === null || onClear === void 0 || onClear();
        (_selectorRef$current4 = selectorRef.current) === null || _selectorRef$current4 === void 0 || _selectorRef$current4.focus();
        onDisplayValuesChange([], {
          type: "clear",
          values: displayValues
        });
        onInternalSearch("", false, false);
      };
      var _useAllowClear = useAllowClear(prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon, disabled, mergedSearchValue, mode), mergedAllowClear = _useAllowClear.allowClear, clearNode = _useAllowClear.clearIcon;
      var optionList = /* @__PURE__ */ reactExports.createElement(OptionList2, {
        ref: listRef
      });
      var mergedClassName = classNames(prefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-focused"), mockFocused), "".concat(prefixCls, "-multiple"), multiple), "".concat(prefixCls, "-single"), !multiple), "".concat(prefixCls, "-allow-clear"), allowClear), "".concat(prefixCls, "-show-arrow"), showSuffixIcon), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-loading"), loading), "".concat(prefixCls, "-open"), mergedOpen), "".concat(prefixCls, "-customize-input"), customizeInputElement), "".concat(prefixCls, "-show-search"), mergedShowSearch));
      var selectorNode = /* @__PURE__ */ reactExports.createElement(RefSelectTrigger, {
        ref: triggerRef,
        disabled,
        prefixCls,
        visible: triggerOpen,
        popupElement: optionList,
        animation,
        transitionName,
        dropdownStyle,
        dropdownClassName,
        direction,
        dropdownMatchSelectWidth,
        dropdownRender,
        dropdownAlign,
        placement,
        builtinPlacements,
        getPopupContainer,
        empty: emptyOptions,
        getTriggerDOMNode: function getTriggerDOMNode(node2) {
          return (
            // TODO: This is workaround and should be removed in `rc-select`
            // And use new standard `nativeElement` for ref.
            // But we should update `rc-resize-observer` first.
            selectorDomRef.current || node2
          );
        },
        onPopupVisibleChange: onTriggerVisibleChange,
        onPopupMouseEnter
      }, customizeRawInputElement ? /* @__PURE__ */ reactExports.cloneElement(customizeRawInputElement, {
        ref: customizeRawInputRef
      }) : /* @__PURE__ */ reactExports.createElement(ForwardSelector, _extends$2({}, props, {
        domRef: selectorDomRef,
        prefixCls,
        inputElement: customizeInputElement,
        ref: selectorRef,
        id,
        prefix: prefix2,
        showSearch: mergedShowSearch,
        autoClearSearchValue,
        mode,
        activeDescendantId,
        tagRender,
        values: displayValues,
        open: mergedOpen,
        onToggleOpen,
        activeValue,
        searchValue: mergedSearchValue,
        onSearch: onInternalSearch,
        onSearchSubmit: onInternalSearchSubmit,
        onRemove: onSelectorRemove,
        tokenWithEnter,
        onInputBlur
      })));
      var renderNode;
      if (customizeRawInputElement) {
        renderNode = selectorNode;
      } else {
        renderNode = /* @__PURE__ */ reactExports.createElement("div", _extends$2({
          className: mergedClassName
        }, domProps, {
          ref: containerRef,
          onMouseDown: onInternalMouseDown,
          onKeyDown: onInternalKeyDown,
          onKeyUp: onInternalKeyUp,
          onFocus: onContainerFocus,
          onBlur: onContainerBlur
        }), /* @__PURE__ */ reactExports.createElement(Polite, {
          visible: mockFocused && !mergedOpen,
          values: displayValues
        }), selectorNode, arrowNode, mergedAllowClear && clearNode);
      }
      return /* @__PURE__ */ reactExports.createElement(BaseSelectContext.Provider, {
        value: baseSelectContext
      }, renderNode);
    });
    var OptGroup = function OptGroup2() {
      return null;
    };
    OptGroup.isSelectOptGroup = true;
    var Option = function Option2() {
      return null;
    };
    Option.isSelectOption = true;
    var Filler = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref) {
      var height = _ref.height, offsetY = _ref.offsetY, offsetX = _ref.offsetX, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize, innerProps = _ref.innerProps, rtl = _ref.rtl, extra = _ref.extra;
      var outerStyle = {};
      var innerStyle = {
        display: "flex",
        flexDirection: "column"
      };
      if (offsetY !== void 0) {
        outerStyle = {
          height,
          position: "relative",
          overflow: "hidden"
        };
        innerStyle = _objectSpread2$3(_objectSpread2$3({}, innerStyle), {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
          transform: "translateY(".concat(offsetY, "px)")
        }, rtl ? "marginRight" : "marginLeft", -offsetX), "position", "absolute"), "left", 0), "right", 0), "top", 0));
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        style: outerStyle
      }, /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: function onResize2(_ref2) {
          var offsetHeight = _ref2.offsetHeight;
          if (offsetHeight && onInnerResize) {
            onInnerResize();
          }
        }
      }, /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        style: innerStyle,
        className: classNames(_defineProperty({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
        ref
      }, innerProps), children, extra)));
    });
    Filler.displayName = "Filler";
    function Item$2(_ref) {
      var children = _ref.children, setRef = _ref.setRef;
      var refFunc = reactExports.useCallback(function(node2) {
        setRef(node2);
      }, []);
      return /* @__PURE__ */ reactExports.cloneElement(children, {
        ref: refFunc
      });
    }
    function useChildren$1(list, startIndex, endIndex, scrollWidth, offsetX, setNodeRef, renderFunc, _ref) {
      var getKey2 = _ref.getKey;
      return list.slice(startIndex, endIndex + 1).map(function(item, index2) {
        var eleIndex = startIndex + index2;
        var node2 = renderFunc(item, eleIndex, {
          style: {
            width: scrollWidth
          },
          offsetX
        });
        var key = getKey2(item);
        return /* @__PURE__ */ reactExports.createElement(Item$2, {
          key,
          setRef: function setRef(ele) {
            return setNodeRef(item, ele);
          }
        }, node2);
      });
    }
    function findListDiffIndex(originList, targetList, getKey2) {
      var originLen = originList.length;
      var targetLen = targetList.length;
      var shortList;
      var longList;
      if (originLen === 0 && targetLen === 0) {
        return null;
      }
      if (originLen < targetLen) {
        shortList = originList;
        longList = targetList;
      } else {
        shortList = targetList;
        longList = originList;
      }
      var notExistKey = {
        __EMPTY_ITEM__: true
      };
      function getItemKey(item) {
        if (item !== void 0) {
          return getKey2(item);
        }
        return notExistKey;
      }
      var diffIndex = null;
      var multiple = Math.abs(originLen - targetLen) !== 1;
      for (var i2 = 0; i2 < longList.length; i2 += 1) {
        var shortKey = getItemKey(shortList[i2]);
        var longKey = getItemKey(longList[i2]);
        if (shortKey !== longKey) {
          diffIndex = i2;
          multiple = multiple || shortKey !== getItemKey(longList[i2 + 1]);
          break;
        }
      }
      return diffIndex === null ? null : {
        index: diffIndex,
        multiple
      };
    }
    function useDiffItem(data, getKey2, onDiff) {
      var _React$useState = reactExports.useState(data), _React$useState2 = _slicedToArray(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
      var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
      reactExports.useEffect(function() {
        var diff = findListDiffIndex(prevData || [], data || [], getKey2);
        if ((diff === null || diff === void 0 ? void 0 : diff.index) !== void 0) {
          setDiffItem(data[diff.index]);
        }
        setPrevData(data);
      }, [data]);
      return [diffItem];
    }
    var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof$1(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
    const useOriginScroll = function(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight) {
      var lockRef = reactExports.useRef(false);
      var lockTimeoutRef = reactExports.useRef(null);
      function lockScroll() {
        clearTimeout(lockTimeoutRef.current);
        lockRef.current = true;
        lockTimeoutRef.current = setTimeout(function() {
          lockRef.current = false;
        }, 50);
      }
      var scrollPingRef = reactExports.useRef({
        top: isScrollAtTop,
        bottom: isScrollAtBottom,
        left: isScrollAtLeft,
        right: isScrollAtRight
      });
      scrollPingRef.current.top = isScrollAtTop;
      scrollPingRef.current.bottom = isScrollAtBottom;
      scrollPingRef.current.left = isScrollAtLeft;
      scrollPingRef.current.right = isScrollAtRight;
      return function(isHorizontal, delta) {
        var smoothOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var originScroll = isHorizontal ? (
          // Pass origin wheel when on the left
          delta < 0 && scrollPingRef.current.left || // Pass origin wheel when on the right
          delta > 0 && scrollPingRef.current.right
        ) : delta < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
        delta > 0 && scrollPingRef.current.bottom;
        if (smoothOffset && originScroll) {
          clearTimeout(lockTimeoutRef.current);
          lockRef.current = false;
        } else if (!originScroll || lockRef.current) {
          lockScroll();
        }
        return !lockRef.current && originScroll;
      };
    };
    function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, horizontalScroll, onWheelDelta) {
      var offsetRef = reactExports.useRef(0);
      var nextFrameRef = reactExports.useRef(null);
      var wheelValueRef = reactExports.useRef(null);
      var isMouseScrollRef = reactExports.useRef(false);
      var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
      function onWheelY(e2, deltaY) {
        wrapperRaf.cancel(nextFrameRef.current);
        if (originScroll(false, deltaY)) return;
        var event = e2;
        if (!event._virtualHandled) {
          event._virtualHandled = true;
        } else {
          return;
        }
        offsetRef.current += deltaY;
        wheelValueRef.current = deltaY;
        if (!isFF) {
          event.preventDefault();
        }
        nextFrameRef.current = wrapperRaf(function() {
          var patchMultiple = isMouseScrollRef.current ? 10 : 1;
          onWheelDelta(offsetRef.current * patchMultiple, false);
          offsetRef.current = 0;
        });
      }
      function onWheelX(event, deltaX) {
        onWheelDelta(deltaX, true);
        if (!isFF) {
          event.preventDefault();
        }
      }
      var wheelDirectionRef = reactExports.useRef(null);
      var wheelDirectionCleanRef = reactExports.useRef(null);
      function onWheel(event) {
        if (!inVirtual) return;
        wrapperRaf.cancel(wheelDirectionCleanRef.current);
        wheelDirectionCleanRef.current = wrapperRaf(function() {
          wheelDirectionRef.current = null;
        }, 2);
        var deltaX = event.deltaX, deltaY = event.deltaY, shiftKey = event.shiftKey;
        var mergedDeltaX = deltaX;
        var mergedDeltaY = deltaY;
        if (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
          mergedDeltaX = deltaY;
          mergedDeltaY = 0;
          wheelDirectionRef.current = "sx";
        }
        var absX = Math.abs(mergedDeltaX);
        var absY = Math.abs(mergedDeltaY);
        if (wheelDirectionRef.current === null) {
          wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y";
        }
        if (wheelDirectionRef.current === "y") {
          onWheelY(event, mergedDeltaY);
        } else {
          onWheelX(event, mergedDeltaX);
        }
      }
      function onFireFoxScroll(event) {
        if (!inVirtual) return;
        isMouseScrollRef.current = event.detail === wheelValueRef.current;
      }
      return [onWheel, onFireFoxScroll];
    }
    function useGetSize(mergedData, getKey2, heights, itemHeight) {
      var _React$useMemo = reactExports.useMemo(function() {
        return [/* @__PURE__ */ new Map(), []];
      }, [mergedData, heights.id, itemHeight]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), key2Index = _React$useMemo2[0], bottomList = _React$useMemo2[1];
      var getSize2 = function getSize3(startKey) {
        var endKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startKey;
        var startIndex = key2Index.get(startKey);
        var endIndex = key2Index.get(endKey);
        if (startIndex === void 0 || endIndex === void 0) {
          var dataLen = mergedData.length;
          for (var i2 = bottomList.length; i2 < dataLen; i2 += 1) {
            var _heights$get;
            var item = mergedData[i2];
            var key = getKey2(item);
            key2Index.set(key, i2);
            var cacheHeight = (_heights$get = heights.get(key)) !== null && _heights$get !== void 0 ? _heights$get : itemHeight;
            bottomList[i2] = (bottomList[i2 - 1] || 0) + cacheHeight;
            if (key === startKey) {
              startIndex = i2;
            }
            if (key === endKey) {
              endIndex = i2;
            }
            if (startIndex !== void 0 && endIndex !== void 0) {
              break;
            }
          }
        }
        return {
          top: bottomList[startIndex - 1] || 0,
          bottom: bottomList[endIndex]
        };
      };
      return getSize2;
    }
    var CacheMap = /* @__PURE__ */ function() {
      function CacheMap2() {
        _classCallCheck(this, CacheMap2);
        _defineProperty(this, "maps", void 0);
        _defineProperty(this, "id", 0);
        _defineProperty(this, "diffKeys", /* @__PURE__ */ new Set());
        this.maps = /* @__PURE__ */ Object.create(null);
      }
      _createClass(CacheMap2, [{
        key: "set",
        value: function set2(key, value) {
          this.maps[key] = value;
          this.id += 1;
          this.diffKeys.add(key);
        }
      }, {
        key: "get",
        value: function get2(key) {
          return this.maps[key];
        }
        /**
         * CacheMap will record the key changed.
         * To help to know what's update in the next render.
         */
      }, {
        key: "resetRecord",
        value: function resetRecord() {
          this.diffKeys.clear();
        }
      }, {
        key: "getRecord",
        value: function getRecord() {
          return this.diffKeys;
        }
      }]);
      return CacheMap2;
    }();
    function parseNumber(value) {
      var num = parseFloat(value);
      return isNaN(num) ? 0 : num;
    }
    function useHeights(getKey2, onItemAdd, onItemRemove) {
      var _React$useState = reactExports.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
      var instanceRef = reactExports.useRef(/* @__PURE__ */ new Map());
      var heightsRef = reactExports.useRef(new CacheMap());
      var promiseIdRef = reactExports.useRef(0);
      function cancelRaf() {
        promiseIdRef.current += 1;
      }
      function collectHeight() {
        var sync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        cancelRaf();
        var doCollect = function doCollect2() {
          var changed = false;
          instanceRef.current.forEach(function(element, key) {
            if (element && element.offsetParent) {
              var offsetHeight = element.offsetHeight;
              var _getComputedStyle = getComputedStyle(element), marginTop = _getComputedStyle.marginTop, marginBottom = _getComputedStyle.marginBottom;
              var marginTopNum = parseNumber(marginTop);
              var marginBottomNum = parseNumber(marginBottom);
              var totalHeight = offsetHeight + marginTopNum + marginBottomNum;
              if (heightsRef.current.get(key) !== totalHeight) {
                heightsRef.current.set(key, totalHeight);
                changed = true;
              }
            }
          });
          if (changed) {
            setUpdatedMark(function(c2) {
              return c2 + 1;
            });
          }
        };
        if (sync) {
          doCollect();
        } else {
          promiseIdRef.current += 1;
          var id = promiseIdRef.current;
          Promise.resolve().then(function() {
            if (id === promiseIdRef.current) {
              doCollect();
            }
          });
        }
      }
      function setInstanceRef(item, instance) {
        var key = getKey2(item);
        instanceRef.current.get(key);
        if (instance) {
          instanceRef.current.set(key, instance);
          collectHeight();
        } else {
          instanceRef.current.delete(key);
        }
      }
      reactExports.useEffect(function() {
        return cancelRaf;
      }, []);
      return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
    }
    var SMOOTH_PTG = 14 / 15;
    function useMobileTouchMove(inVirtual, listRef, callback) {
      var touchedRef = reactExports.useRef(false);
      var touchXRef = reactExports.useRef(0);
      var touchYRef = reactExports.useRef(0);
      var elementRef = reactExports.useRef(null);
      var intervalRef = reactExports.useRef(null);
      var cleanUpEvents;
      var onTouchMove = function onTouchMove2(e2) {
        if (touchedRef.current) {
          var currentX = Math.ceil(e2.touches[0].pageX);
          var currentY = Math.ceil(e2.touches[0].pageY);
          var offsetX = touchXRef.current - currentX;
          var offsetY = touchYRef.current - currentY;
          var _isHorizontal = Math.abs(offsetX) > Math.abs(offsetY);
          if (_isHorizontal) {
            touchXRef.current = currentX;
          } else {
            touchYRef.current = currentY;
          }
          var scrollHandled = callback(_isHorizontal, _isHorizontal ? offsetX : offsetY, false, e2);
          if (scrollHandled) {
            e2.preventDefault();
          }
          clearInterval(intervalRef.current);
          if (scrollHandled) {
            intervalRef.current = setInterval(function() {
              if (_isHorizontal) {
                offsetX *= SMOOTH_PTG;
              } else {
                offsetY *= SMOOTH_PTG;
              }
              var offset2 = Math.floor(_isHorizontal ? offsetX : offsetY);
              if (!callback(_isHorizontal, offset2, true) || Math.abs(offset2) <= 0.1) {
                clearInterval(intervalRef.current);
              }
            }, 16);
          }
        }
      };
      var onTouchEnd = function onTouchEnd2() {
        touchedRef.current = false;
        cleanUpEvents();
      };
      var onTouchStart = function onTouchStart2(e2) {
        cleanUpEvents();
        if (e2.touches.length === 1 && !touchedRef.current) {
          touchedRef.current = true;
          touchXRef.current = Math.ceil(e2.touches[0].pageX);
          touchYRef.current = Math.ceil(e2.touches[0].pageY);
          elementRef.current = e2.target;
          elementRef.current.addEventListener("touchmove", onTouchMove, {
            passive: false
          });
          elementRef.current.addEventListener("touchend", onTouchEnd, {
            passive: true
          });
        }
      };
      cleanUpEvents = function cleanUpEvents2() {
        if (elementRef.current) {
          elementRef.current.removeEventListener("touchmove", onTouchMove);
          elementRef.current.removeEventListener("touchend", onTouchEnd);
        }
      };
      useLayoutEffect$1(function() {
        if (inVirtual) {
          listRef.current.addEventListener("touchstart", onTouchStart, {
            passive: true
          });
        }
        return function() {
          var _listRef$current;
          (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.removeEventListener("touchstart", onTouchStart);
          cleanUpEvents();
          clearInterval(intervalRef.current);
        };
      }, [inVirtual]);
    }
    function smoothScrollOffset(offset2) {
      return Math.floor(Math.pow(offset2, 0.5));
    }
    function getPageXY(e2, horizontal) {
      var obj = "touches" in e2 ? e2.touches[0] : e2;
      return obj[horizontal ? "pageX" : "pageY"] - window[horizontal ? "scrollX" : "scrollY"];
    }
    function useScrollDrag(inVirtual, componentRef, onScrollOffset) {
      reactExports.useEffect(function() {
        var ele = componentRef.current;
        if (inVirtual && ele) {
          var mouseDownLock = false;
          var rafId;
          var _offset;
          var stopScroll = function stopScroll2() {
            wrapperRaf.cancel(rafId);
          };
          var continueScroll = function continueScroll2() {
            stopScroll();
            rafId = wrapperRaf(function() {
              onScrollOffset(_offset);
              continueScroll2();
            });
          };
          var onMouseDown = function onMouseDown2(e2) {
            if (e2.target.draggable || e2.button !== 0) {
              return;
            }
            var event = e2;
            if (!event._virtualHandled) {
              event._virtualHandled = true;
              mouseDownLock = true;
            }
          };
          var onMouseUp = function onMouseUp2() {
            mouseDownLock = false;
            stopScroll();
          };
          var onMouseMove = function onMouseMove2(e2) {
            if (mouseDownLock) {
              var mouseY = getPageXY(e2, false);
              var _ele$getBoundingClien = ele.getBoundingClientRect(), top = _ele$getBoundingClien.top, bottom = _ele$getBoundingClien.bottom;
              if (mouseY <= top) {
                var diff = top - mouseY;
                _offset = -smoothScrollOffset(diff);
                continueScroll();
              } else if (mouseY >= bottom) {
                var _diff = mouseY - bottom;
                _offset = smoothScrollOffset(_diff);
                continueScroll();
              } else {
                stopScroll();
              }
            }
          };
          ele.addEventListener("mousedown", onMouseDown);
          ele.ownerDocument.addEventListener("mouseup", onMouseUp);
          ele.ownerDocument.addEventListener("mousemove", onMouseMove);
          return function() {
            ele.removeEventListener("mousedown", onMouseDown);
            ele.ownerDocument.removeEventListener("mouseup", onMouseUp);
            ele.ownerDocument.removeEventListener("mousemove", onMouseMove);
            stopScroll();
          };
        }
      }, [inVirtual]);
    }
    var MAX_TIMES = 10;
    function useScrollTo$1(containerRef, data, heights, itemHeight, getKey2, collectHeight, syncScrollTop, triggerFlash) {
      var scrollRef = reactExports.useRef();
      var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), syncState = _React$useState2[0], setSyncState = _React$useState2[1];
      useLayoutEffect$1(function() {
        if (syncState && syncState.times < MAX_TIMES) {
          if (!containerRef.current) {
            setSyncState(function(ori) {
              return _objectSpread2$3({}, ori);
            });
            return;
          }
          collectHeight();
          var targetAlign = syncState.targetAlign, originAlign = syncState.originAlign, index2 = syncState.index, offset2 = syncState.offset;
          var height = containerRef.current.clientHeight;
          var needCollectHeight = false;
          var newTargetAlign = targetAlign;
          var targetTop = null;
          if (height) {
            var mergedAlign = targetAlign || originAlign;
            var stackTop = 0;
            var itemTop = 0;
            var itemBottom = 0;
            var maxLen = Math.min(data.length - 1, index2);
            for (var i2 = 0; i2 <= maxLen; i2 += 1) {
              var key = getKey2(data[i2]);
              itemTop = stackTop;
              var cacheHeight = heights.get(key);
              itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
              stackTop = itemBottom;
            }
            var leftHeight = mergedAlign === "top" ? offset2 : height - offset2;
            for (var _i = maxLen; _i >= 0; _i -= 1) {
              var _key = getKey2(data[_i]);
              var _cacheHeight = heights.get(_key);
              if (_cacheHeight === void 0) {
                needCollectHeight = true;
                break;
              }
              leftHeight -= _cacheHeight;
              if (leftHeight <= 0) {
                break;
              }
            }
            switch (mergedAlign) {
              case "top":
                targetTop = itemTop - offset2;
                break;
              case "bottom":
                targetTop = itemBottom - height + offset2;
                break;
              default: {
                var scrollTop = containerRef.current.scrollTop;
                var scrollBottom = scrollTop + height;
                if (itemTop < scrollTop) {
                  newTargetAlign = "top";
                } else if (itemBottom > scrollBottom) {
                  newTargetAlign = "bottom";
                }
              }
            }
            if (targetTop !== null) {
              syncScrollTop(targetTop);
            }
            if (targetTop !== syncState.lastTop) {
              needCollectHeight = true;
            }
          }
          if (needCollectHeight) {
            setSyncState(_objectSpread2$3(_objectSpread2$3({}, syncState), {}, {
              times: syncState.times + 1,
              targetAlign: newTargetAlign,
              lastTop: targetTop
            }));
          }
        }
      }, [syncState, containerRef.current]);
      return function(arg) {
        if (arg === null || arg === void 0) {
          triggerFlash();
          return;
        }
        wrapperRaf.cancel(scrollRef.current);
        if (typeof arg === "number") {
          syncScrollTop(arg);
        } else if (arg && _typeof$1(arg) === "object") {
          var index2;
          var align = arg.align;
          if ("index" in arg) {
            index2 = arg.index;
          } else {
            index2 = data.findIndex(function(item) {
              return getKey2(item) === arg.key;
            });
          }
          var _arg$offset = arg.offset, offset2 = _arg$offset === void 0 ? 0 : _arg$offset;
          setSyncState({
            times: 0,
            index: index2,
            offset: offset2,
            originAlign: align
          });
        }
      };
    }
    var ScrollBar = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, rtl = props.rtl, scrollOffset = props.scrollOffset, scrollRange = props.scrollRange, onStartMove = props.onStartMove, onStopMove = props.onStopMove, onScroll = props.onScroll, horizontal = props.horizontal, spinSize = props.spinSize, containerSize = props.containerSize, style2 = props.style, propsThumbStyle = props.thumbStyle, showScrollBar = props.showScrollBar;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), dragging = _React$useState2[0], setDragging = _React$useState2[1];
      var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), pageXY = _React$useState4[0], setPageXY = _React$useState4[1];
      var _React$useState5 = reactExports.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), startTop = _React$useState6[0], setStartTop = _React$useState6[1];
      var isLTR = !rtl;
      var scrollbarRef = reactExports.useRef();
      var thumbRef = reactExports.useRef();
      var _React$useState7 = reactExports.useState(showScrollBar), _React$useState8 = _slicedToArray(_React$useState7, 2), visible = _React$useState8[0], setVisible = _React$useState8[1];
      var visibleTimeoutRef = reactExports.useRef();
      var delayHidden = function delayHidden2() {
        if (showScrollBar === true || showScrollBar === false) return;
        clearTimeout(visibleTimeoutRef.current);
        setVisible(true);
        visibleTimeoutRef.current = setTimeout(function() {
          setVisible(false);
        }, 3e3);
      };
      var enableScrollRange = scrollRange - containerSize || 0;
      var enableOffsetRange = containerSize - spinSize || 0;
      var top = reactExports.useMemo(function() {
        if (scrollOffset === 0 || enableScrollRange === 0) {
          return 0;
        }
        var ptg = scrollOffset / enableScrollRange;
        return ptg * enableOffsetRange;
      }, [scrollOffset, enableScrollRange, enableOffsetRange]);
      var onContainerMouseDown = function onContainerMouseDown2(e2) {
        e2.stopPropagation();
        e2.preventDefault();
      };
      var stateRef = reactExports.useRef({
        top,
        dragging,
        pageY: pageXY,
        startTop
      });
      stateRef.current = {
        top,
        dragging,
        pageY: pageXY,
        startTop
      };
      var onThumbMouseDown = function onThumbMouseDown2(e2) {
        setDragging(true);
        setPageXY(getPageXY(e2, horizontal));
        setStartTop(stateRef.current.top);
        onStartMove();
        e2.stopPropagation();
        e2.preventDefault();
      };
      reactExports.useEffect(function() {
        var onScrollbarTouchStart = function onScrollbarTouchStart2(e2) {
          e2.preventDefault();
        };
        var scrollbarEle = scrollbarRef.current;
        var thumbEle = thumbRef.current;
        scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart, {
          passive: false
        });
        thumbEle.addEventListener("touchstart", onThumbMouseDown, {
          passive: false
        });
        return function() {
          scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart);
          thumbEle.removeEventListener("touchstart", onThumbMouseDown);
        };
      }, []);
      var enableScrollRangeRef = reactExports.useRef();
      enableScrollRangeRef.current = enableScrollRange;
      var enableOffsetRangeRef = reactExports.useRef();
      enableOffsetRangeRef.current = enableOffsetRange;
      reactExports.useEffect(function() {
        if (dragging) {
          var moveRafId;
          var onMouseMove = function onMouseMove2(e2) {
            var _stateRef$current = stateRef.current, stateDragging = _stateRef$current.dragging, statePageY = _stateRef$current.pageY, stateStartTop = _stateRef$current.startTop;
            wrapperRaf.cancel(moveRafId);
            var rect = scrollbarRef.current.getBoundingClientRect();
            var scale = containerSize / (horizontal ? rect.width : rect.height);
            if (stateDragging) {
              var offset2 = (getPageXY(e2, horizontal) - statePageY) * scale;
              var newTop = stateStartTop;
              if (!isLTR && horizontal) {
                newTop -= offset2;
              } else {
                newTop += offset2;
              }
              var tmpEnableScrollRange = enableScrollRangeRef.current;
              var tmpEnableOffsetRange = enableOffsetRangeRef.current;
              var ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
              var newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
              newScrollTop = Math.max(newScrollTop, 0);
              newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
              moveRafId = wrapperRaf(function() {
                onScroll(newScrollTop, horizontal);
              });
            }
          };
          var onMouseUp = function onMouseUp2() {
            setDragging(false);
            onStopMove();
          };
          window.addEventListener("mousemove", onMouseMove, {
            passive: true
          });
          window.addEventListener("touchmove", onMouseMove, {
            passive: true
          });
          window.addEventListener("mouseup", onMouseUp, {
            passive: true
          });
          window.addEventListener("touchend", onMouseUp, {
            passive: true
          });
          return function() {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("touchmove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);
            window.removeEventListener("touchend", onMouseUp);
            wrapperRaf.cancel(moveRafId);
          };
        }
      }, [dragging]);
      reactExports.useEffect(function() {
        delayHidden();
        return function() {
          clearTimeout(visibleTimeoutRef.current);
        };
      }, [scrollOffset]);
      reactExports.useImperativeHandle(ref, function() {
        return {
          delayHidden
        };
      });
      var scrollbarPrefixCls = "".concat(prefixCls, "-scrollbar");
      var containerStyle = {
        position: "absolute",
        visibility: visible ? null : "hidden"
      };
      var thumbStyle = {
        position: "absolute",
        background: "rgba(0, 0, 0, 0.5)",
        borderRadius: 99,
        cursor: "pointer",
        userSelect: "none"
      };
      if (horizontal) {
        containerStyle.height = 8;
        containerStyle.left = 0;
        containerStyle.right = 0;
        containerStyle.bottom = 0;
        thumbStyle.height = "100%";
        thumbStyle.width = spinSize;
        if (isLTR) {
          thumbStyle.left = top;
        } else {
          thumbStyle.right = top;
        }
      } else {
        containerStyle.width = 8;
        containerStyle.top = 0;
        containerStyle.bottom = 0;
        if (isLTR) {
          containerStyle.right = 0;
        } else {
          containerStyle.left = 0;
        }
        thumbStyle.width = "100%";
        thumbStyle.height = spinSize;
        thumbStyle.top = top;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: scrollbarRef,
        className: classNames(scrollbarPrefixCls, _defineProperty(_defineProperty(_defineProperty({}, "".concat(scrollbarPrefixCls, "-horizontal"), horizontal), "".concat(scrollbarPrefixCls, "-vertical"), !horizontal), "".concat(scrollbarPrefixCls, "-visible"), visible)),
        style: _objectSpread2$3(_objectSpread2$3({}, containerStyle), style2),
        onMouseDown: onContainerMouseDown,
        onMouseMove: delayHidden
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: thumbRef,
        className: classNames("".concat(scrollbarPrefixCls, "-thumb"), _defineProperty({}, "".concat(scrollbarPrefixCls, "-thumb-moving"), dragging)),
        style: _objectSpread2$3(_objectSpread2$3({}, thumbStyle), propsThumbStyle),
        onMouseDown: onThumbMouseDown
      }));
    });
    var MIN_SIZE = 20;
    function getSpinSize() {
      var containerSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var scrollRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var baseSize = containerSize / scrollRange * containerSize;
      if (isNaN(baseSize)) {
        baseSize = 0;
      }
      baseSize = Math.max(baseSize, MIN_SIZE);
      return Math.floor(baseSize);
    }
    var _excluded$u = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "direction", "scrollWidth", "component", "onScroll", "onVirtualScroll", "onVisibleChange", "innerProps", "extraRender", "styles", "showScrollBar"];
    var EMPTY_DATA = [];
    var ScrollStyle = {
      overflowY: "auto",
      overflowAnchor: "none"
    };
    function RawList(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style2 = props.style, data = props.data, children = props.children, itemKey2 = props.itemKey, virtual = props.virtual, direction = props.direction, scrollWidth = props.scrollWidth, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVirtualScroll = props.onVirtualScroll, onVisibleChange = props.onVisibleChange, innerProps = props.innerProps, extraRender = props.extraRender, styles = props.styles, _props$showScrollBar = props.showScrollBar, showScrollBar = _props$showScrollBar === void 0 ? "optional" : _props$showScrollBar, restProps = _objectWithoutProperties(props, _excluded$u);
      var getKey2 = reactExports.useCallback(function(item) {
        if (typeof itemKey2 === "function") {
          return itemKey2(item);
        }
        return item === null || item === void 0 ? void 0 : item[itemKey2];
      }, [itemKey2]);
      var _useHeights = useHeights(getKey2), _useHeights2 = _slicedToArray(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
      var useVirtual = !!(virtual !== false && height && itemHeight);
      var containerHeight = reactExports.useMemo(function() {
        return Object.values(heights.maps).reduce(function(total, curr) {
          return total + curr;
        }, 0);
      }, [heights.id, heights.maps]);
      var inVirtual = useVirtual && data && (Math.max(itemHeight * data.length, containerHeight) > height || !!scrollWidth);
      var isRTL = direction === "rtl";
      var mergedClassName = classNames(prefixCls, _defineProperty({}, "".concat(prefixCls, "-rtl"), isRTL), className);
      var mergedData = data || EMPTY_DATA;
      var componentRef = reactExports.useRef();
      var fillerInnerRef = reactExports.useRef();
      var containerRef = reactExports.useRef();
      var _useState = reactExports.useState(0), _useState2 = _slicedToArray(_useState, 2), offsetTop = _useState2[0], setOffsetTop = _useState2[1];
      var _useState3 = reactExports.useState(0), _useState4 = _slicedToArray(_useState3, 2), offsetLeft = _useState4[0], setOffsetLeft = _useState4[1];
      var _useState5 = reactExports.useState(false), _useState6 = _slicedToArray(_useState5, 2), scrollMoving = _useState6[0], setScrollMoving = _useState6[1];
      var onScrollbarStartMove = function onScrollbarStartMove2() {
        setScrollMoving(true);
      };
      var onScrollbarStopMove = function onScrollbarStopMove2() {
        setScrollMoving(false);
      };
      var sharedConfig = {
        getKey: getKey2
      };
      function syncScrollTop(newTop) {
        setOffsetTop(function(origin) {
          var value;
          if (typeof newTop === "function") {
            value = newTop(origin);
          } else {
            value = newTop;
          }
          var alignedTop = keepInRange(value);
          componentRef.current.scrollTop = alignedTop;
          return alignedTop;
        });
      }
      var rangeRef = reactExports.useRef({
        start: 0,
        end: mergedData.length
      });
      var diffItemRef = reactExports.useRef();
      var _useDiffItem = useDiffItem(mergedData, getKey2), _useDiffItem2 = _slicedToArray(_useDiffItem, 1), diffItem = _useDiffItem2[0];
      diffItemRef.current = diffItem;
      var _React$useMemo = reactExports.useMemo(function() {
        if (!useVirtual) {
          return {
            scrollHeight: void 0,
            start: 0,
            end: mergedData.length - 1,
            offset: void 0
          };
        }
        if (!inVirtual) {
          var _fillerInnerRef$curre;
          return {
            scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
            start: 0,
            end: mergedData.length - 1,
            offset: void 0
          };
        }
        var itemTop = 0;
        var startIndex;
        var startOffset;
        var endIndex;
        var dataLen = mergedData.length;
        for (var i2 = 0; i2 < dataLen; i2 += 1) {
          var _item = mergedData[i2];
          var key = getKey2(_item);
          var cacheHeight = heights.get(key);
          var currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
          if (currentItemBottom >= offsetTop && startIndex === void 0) {
            startIndex = i2;
            startOffset = itemTop;
          }
          if (currentItemBottom > offsetTop + height && endIndex === void 0) {
            endIndex = i2;
          }
          itemTop = currentItemBottom;
        }
        if (startIndex === void 0) {
          startIndex = 0;
          startOffset = 0;
          endIndex = Math.ceil(height / itemHeight);
        }
        if (endIndex === void 0) {
          endIndex = mergedData.length - 1;
        }
        endIndex = Math.min(endIndex + 1, mergedData.length - 1);
        return {
          scrollHeight: itemTop,
          start: startIndex,
          end: endIndex,
          offset: startOffset
        };
      }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, fillerOffset = _React$useMemo.offset;
      rangeRef.current.start = start;
      rangeRef.current.end = end;
      reactExports.useLayoutEffect(function() {
        var changedRecord = heights.getRecord();
        if (changedRecord.size === 1) {
          var recordKey = Array.from(changedRecord)[0];
          var startItem = mergedData[start];
          if (startItem) {
            var startIndexKey = getKey2(startItem);
            if (startIndexKey === recordKey) {
              var realStartHeight = heights.get(recordKey);
              var diffHeight = realStartHeight - itemHeight;
              syncScrollTop(function(ori) {
                return ori + diffHeight;
              });
            }
          }
        }
        heights.resetRecord();
      }, [scrollHeight]);
      var _React$useState = reactExports.useState({
        width: 0,
        height
      }), _React$useState2 = _slicedToArray(_React$useState, 2), size = _React$useState2[0], setSize = _React$useState2[1];
      var onHolderResize = function onHolderResize2(sizeInfo) {
        setSize({
          width: sizeInfo.offsetWidth,
          height: sizeInfo.offsetHeight
        });
      };
      var verticalScrollBarRef = reactExports.useRef();
      var horizontalScrollBarRef = reactExports.useRef();
      var horizontalScrollBarSpinSize = reactExports.useMemo(function() {
        return getSpinSize(size.width, scrollWidth);
      }, [size.width, scrollWidth]);
      var verticalScrollBarSpinSize = reactExports.useMemo(function() {
        return getSpinSize(size.height, scrollHeight);
      }, [size.height, scrollHeight]);
      var maxScrollHeight = scrollHeight - height;
      var maxScrollHeightRef = reactExports.useRef(maxScrollHeight);
      maxScrollHeightRef.current = maxScrollHeight;
      function keepInRange(newScrollTop) {
        var newTop = newScrollTop;
        if (!Number.isNaN(maxScrollHeightRef.current)) {
          newTop = Math.min(newTop, maxScrollHeightRef.current);
        }
        newTop = Math.max(newTop, 0);
        return newTop;
      }
      var isScrollAtTop = offsetTop <= 0;
      var isScrollAtBottom = offsetTop >= maxScrollHeight;
      var isScrollAtLeft = offsetLeft <= 0;
      var isScrollAtRight = offsetLeft >= scrollWidth;
      var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
      var getVirtualScrollInfo = function getVirtualScrollInfo2() {
        return {
          x: isRTL ? -offsetLeft : offsetLeft,
          y: offsetTop
        };
      };
      var lastVirtualScrollInfoRef = reactExports.useRef(getVirtualScrollInfo());
      var triggerScroll = useEvent(function(params) {
        if (onVirtualScroll) {
          var nextInfo = _objectSpread2$3(_objectSpread2$3({}, getVirtualScrollInfo()), params);
          if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
            onVirtualScroll(nextInfo);
            lastVirtualScrollInfoRef.current = nextInfo;
          }
        }
      });
      function onScrollBar(newScrollOffset, horizontal) {
        var newOffset = newScrollOffset;
        if (horizontal) {
          reactDomExports.flushSync(function() {
            setOffsetLeft(newOffset);
          });
          triggerScroll();
        } else {
          syncScrollTop(newOffset);
        }
      }
      function onFallbackScroll(e2) {
        var newScrollTop = e2.currentTarget.scrollTop;
        if (newScrollTop !== offsetTop) {
          syncScrollTop(newScrollTop);
        }
        onScroll === null || onScroll === void 0 || onScroll(e2);
        triggerScroll();
      }
      var keepInHorizontalRange = function keepInHorizontalRange2(nextOffsetLeft) {
        var tmpOffsetLeft = nextOffsetLeft;
        var max = !!scrollWidth ? scrollWidth - size.width : 0;
        tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
        tmpOffsetLeft = Math.min(tmpOffsetLeft, max);
        return tmpOffsetLeft;
      };
      var onWheelDelta = useEvent(function(offsetXY, fromHorizontal) {
        if (fromHorizontal) {
          reactDomExports.flushSync(function() {
            setOffsetLeft(function(left) {
              var nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
              return keepInHorizontalRange(nextOffsetLeft);
            });
          });
          triggerScroll();
        } else {
          syncScrollTop(function(top) {
            var newTop = top + offsetXY;
            return newTop;
          });
        }
      });
      var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, !!scrollWidth, onWheelDelta), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
      useMobileTouchMove(useVirtual, componentRef, function(isHorizontal, delta, smoothOffset, e2) {
        var event = e2;
        if (originScroll(isHorizontal, delta, smoothOffset)) {
          return false;
        }
        if (!event || !event._virtualHandled) {
          if (event) {
            event._virtualHandled = true;
          }
          onRawWheel({
            preventDefault: function preventDefault() {
            },
            deltaX: isHorizontal ? delta : 0,
            deltaY: isHorizontal ? 0 : delta
          });
          return true;
        }
        return false;
      });
      useScrollDrag(inVirtual, componentRef, function(offset2) {
        syncScrollTop(function(top) {
          return top + offset2;
        });
      });
      useLayoutEffect$1(function() {
        function onMozMousePixelScroll(e2) {
          var scrollingUpAtTop = isScrollAtTop && e2.detail < 0;
          var scrollingDownAtBottom = isScrollAtBottom && e2.detail > 0;
          if (useVirtual && !scrollingUpAtTop && !scrollingDownAtBottom) {
            e2.preventDefault();
          }
        }
        var componentEle = componentRef.current;
        componentEle.addEventListener("wheel", onRawWheel, {
          passive: false
        });
        componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll, {
          passive: true
        });
        componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll, {
          passive: false
        });
        return function() {
          componentEle.removeEventListener("wheel", onRawWheel);
          componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll);
          componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
        };
      }, [useVirtual, isScrollAtTop, isScrollAtBottom]);
      useLayoutEffect$1(function() {
        if (scrollWidth) {
          var newOffsetLeft = keepInHorizontalRange(offsetLeft);
          setOffsetLeft(newOffsetLeft);
          triggerScroll({
            x: newOffsetLeft
          });
        }
      }, [size.width, scrollWidth]);
      var delayHideScrollBar = function delayHideScrollBar2() {
        var _verticalScrollBarRef, _horizontalScrollBarR;
        (_verticalScrollBarRef = verticalScrollBarRef.current) === null || _verticalScrollBarRef === void 0 || _verticalScrollBarRef.delayHidden();
        (_horizontalScrollBarR = horizontalScrollBarRef.current) === null || _horizontalScrollBarR === void 0 || _horizontalScrollBarR.delayHidden();
      };
      var _scrollTo = useScrollTo$1(componentRef, mergedData, heights, itemHeight, getKey2, function() {
        return collectHeight(true);
      }, syncScrollTop, delayHideScrollBar);
      reactExports.useImperativeHandle(ref, function() {
        return {
          nativeElement: containerRef.current,
          getScrollInfo: getVirtualScrollInfo,
          scrollTo: function scrollTo(config) {
            function isPosScroll(arg) {
              return arg && _typeof$1(arg) === "object" && ("left" in arg || "top" in arg);
            }
            if (isPosScroll(config)) {
              if (config.left !== void 0) {
                setOffsetLeft(keepInHorizontalRange(config.left));
              }
              _scrollTo(config.top);
            } else {
              _scrollTo(config);
            }
          }
        };
      });
      useLayoutEffect$1(function() {
        if (onVisibleChange) {
          var renderList = mergedData.slice(start, end + 1);
          onVisibleChange(renderList, mergedData);
        }
      }, [start, end, mergedData]);
      var getSize2 = useGetSize(mergedData, getKey2, heights, itemHeight);
      var extraContent = extraRender === null || extraRender === void 0 ? void 0 : extraRender({
        start,
        end,
        virtual: inVirtual,
        offsetX: offsetLeft,
        offsetY: fillerOffset,
        rtl: isRTL,
        getSize: getSize2
      });
      var listChildren = useChildren$1(mergedData, start, end, scrollWidth, offsetLeft, setInstanceRef, children, sharedConfig);
      var componentStyle = null;
      if (height) {
        componentStyle = _objectSpread2$3(_defineProperty({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle);
        if (useVirtual) {
          componentStyle.overflowY = "hidden";
          if (scrollWidth) {
            componentStyle.overflowX = "hidden";
          }
          if (scrollMoving) {
            componentStyle.pointerEvents = "none";
          }
        }
      }
      var containerProps = {};
      if (isRTL) {
        containerProps.dir = "rtl";
      }
      return /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        ref: containerRef,
        style: _objectSpread2$3(_objectSpread2$3({}, style2), {}, {
          position: "relative"
        }),
        className: mergedClassName
      }, containerProps, restProps), /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onHolderResize
      }, /* @__PURE__ */ reactExports.createElement(Component2, {
        className: "".concat(prefixCls, "-holder"),
        style: componentStyle,
        ref: componentRef,
        onScroll: onFallbackScroll,
        onMouseEnter: delayHideScrollBar
      }, /* @__PURE__ */ reactExports.createElement(Filler, {
        prefixCls,
        height: scrollHeight,
        offsetX: offsetLeft,
        offsetY: fillerOffset,
        scrollWidth,
        onInnerResize: collectHeight,
        ref: fillerInnerRef,
        innerProps,
        rtl: isRTL,
        extra: extraContent
      }, listChildren))), inVirtual && scrollHeight > height && /* @__PURE__ */ reactExports.createElement(ScrollBar, {
        ref: verticalScrollBarRef,
        prefixCls,
        scrollOffset: offsetTop,
        scrollRange: scrollHeight,
        rtl: isRTL,
        onScroll: onScrollBar,
        onStartMove: onScrollbarStartMove,
        onStopMove: onScrollbarStopMove,
        spinSize: verticalScrollBarSpinSize,
        containerSize: size.height,
        style: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBar,
        thumbStyle: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBarThumb,
        showScrollBar
      }), inVirtual && scrollWidth > size.width && /* @__PURE__ */ reactExports.createElement(ScrollBar, {
        ref: horizontalScrollBarRef,
        prefixCls,
        scrollOffset: offsetLeft,
        scrollRange: scrollWidth,
        rtl: isRTL,
        onScroll: onScrollBar,
        onStartMove: onScrollbarStartMove,
        onStopMove: onScrollbarStopMove,
        spinSize: horizontalScrollBarSpinSize,
        containerSize: size.width,
        horizontal: true,
        style: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBar,
        thumbStyle: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBarThumb,
        showScrollBar
      }));
    }
    var List$1 = /* @__PURE__ */ reactExports.forwardRef(RawList);
    List$1.displayName = "List";
    function isPlatformMac() {
      return /(mac\sos|macintosh)/i.test(navigator.appVersion);
    }
    var _excluded$t = ["disabled", "title", "children", "style", "className"];
    function isTitleType(content) {
      return typeof content === "string" || typeof content === "number";
    }
    var OptionList = function OptionList2(_2, ref) {
      var _useBaseProps = useBaseProps(), prefixCls = _useBaseProps.prefixCls, id = _useBaseProps.id, open2 = _useBaseProps.open, multiple = _useBaseProps.multiple, mode = _useBaseProps.mode, searchValue = _useBaseProps.searchValue, toggleOpen = _useBaseProps.toggleOpen, notFoundContent = _useBaseProps.notFoundContent, onPopupScroll = _useBaseProps.onPopupScroll;
      var _React$useContext = reactExports.useContext(SelectContext), maxCount = _React$useContext.maxCount, flattenOptions2 = _React$useContext.flattenOptions, onActiveValue = _React$useContext.onActiveValue, defaultActiveFirstOption = _React$useContext.defaultActiveFirstOption, onSelect = _React$useContext.onSelect, menuItemSelectedIcon = _React$useContext.menuItemSelectedIcon, rawValues = _React$useContext.rawValues, fieldNames = _React$useContext.fieldNames, virtual = _React$useContext.virtual, direction = _React$useContext.direction, listHeight = _React$useContext.listHeight, listItemHeight = _React$useContext.listItemHeight, optionRender = _React$useContext.optionRender;
      var itemPrefixCls = "".concat(prefixCls, "-item");
      var memoFlattenOptions = useMemo(function() {
        return flattenOptions2;
      }, [open2, flattenOptions2], function(prev2, next2) {
        return next2[0] && prev2[1] !== next2[1];
      });
      var listRef = reactExports.useRef(null);
      var overMaxCount = reactExports.useMemo(function() {
        return multiple && isValidCount(maxCount) && (rawValues === null || rawValues === void 0 ? void 0 : rawValues.size) >= maxCount;
      }, [multiple, maxCount, rawValues === null || rawValues === void 0 ? void 0 : rawValues.size]);
      var onListMouseDown = function onListMouseDown2(event) {
        event.preventDefault();
      };
      var scrollIntoView = function scrollIntoView2(args) {
        var _listRef$current;
        (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scrollTo(typeof args === "number" ? {
          index: args
        } : args);
      };
      var isSelected = reactExports.useCallback(function(value) {
        if (mode === "combobox") {
          return false;
        }
        return rawValues.has(value);
      }, [mode, _toConsumableArray(rawValues).toString(), rawValues.size]);
      var getEnabledActiveIndex = function getEnabledActiveIndex2(index2) {
        var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        var len = memoFlattenOptions.length;
        for (var i2 = 0; i2 < len; i2 += 1) {
          var current = (index2 + i2 * offset2 + len) % len;
          var _ref = memoFlattenOptions[current] || {}, group = _ref.group, data = _ref.data;
          if (!group && !(data !== null && data !== void 0 && data.disabled) && (isSelected(data.value) || !overMaxCount)) {
            return current;
          }
        }
        return -1;
      };
      var _React$useState = reactExports.useState(function() {
        return getEnabledActiveIndex(0);
      }), _React$useState2 = _slicedToArray(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
      var setActive = function setActive2(index2) {
        var fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        setActiveIndex(index2);
        var info = {
          source: fromKeyboard ? "keyboard" : "mouse"
        };
        var flattenItem = memoFlattenOptions[index2];
        if (!flattenItem) {
          onActiveValue(null, -1, info);
          return;
        }
        onActiveValue(flattenItem.value, index2, info);
      };
      reactExports.useEffect(function() {
        setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
      }, [memoFlattenOptions.length, searchValue]);
      var isAriaSelected = reactExports.useCallback(function(value) {
        if (mode === "combobox") {
          return String(value).toLowerCase() === searchValue.toLowerCase();
        }
        return rawValues.has(value);
      }, [mode, searchValue, _toConsumableArray(rawValues).toString(), rawValues.size]);
      reactExports.useEffect(function() {
        var timeoutId = setTimeout(function() {
          if (!multiple && open2 && rawValues.size === 1) {
            var value = Array.from(rawValues)[0];
            var index2 = memoFlattenOptions.findIndex(function(_ref2) {
              var data = _ref2.data;
              return data.value === value;
            });
            if (index2 !== -1) {
              setActive(index2);
              scrollIntoView(index2);
            }
          }
        });
        if (open2) {
          var _listRef$current2;
          (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 || _listRef$current2.scrollTo(void 0);
        }
        return function() {
          return clearTimeout(timeoutId);
        };
      }, [open2, searchValue]);
      var onSelectValue = function onSelectValue2(value) {
        if (value !== void 0) {
          onSelect(value, {
            selected: !rawValues.has(value)
          });
        }
        if (!multiple) {
          toggleOpen(false);
        }
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          onKeyDown: function onKeyDown(event) {
            var which = event.which, ctrlKey = event.ctrlKey;
            switch (which) {
              case KeyCode.N:
              case KeyCode.P:
              case KeyCode.UP:
              case KeyCode.DOWN: {
                var offset2 = 0;
                if (which === KeyCode.UP) {
                  offset2 = -1;
                } else if (which === KeyCode.DOWN) {
                  offset2 = 1;
                } else if (isPlatformMac() && ctrlKey) {
                  if (which === KeyCode.N) {
                    offset2 = 1;
                  } else if (which === KeyCode.P) {
                    offset2 = -1;
                  }
                }
                if (offset2 !== 0) {
                  var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset2, offset2);
                  scrollIntoView(nextActiveIndex);
                  setActive(nextActiveIndex, true);
                }
                break;
              }
              case KeyCode.TAB:
              case KeyCode.ENTER: {
                var _item$data;
                var item = memoFlattenOptions[activeIndex];
                if (item && !(item !== null && item !== void 0 && (_item$data = item.data) !== null && _item$data !== void 0 && _item$data.disabled) && !overMaxCount) {
                  onSelectValue(item.value);
                } else {
                  onSelectValue(void 0);
                }
                if (open2) {
                  event.preventDefault();
                }
                break;
              }
              case KeyCode.ESC: {
                toggleOpen(false);
                if (open2) {
                  event.stopPropagation();
                }
              }
            }
          },
          onKeyUp: function onKeyUp() {
          },
          scrollTo: function scrollTo(index2) {
            scrollIntoView(index2);
          }
        };
      });
      if (memoFlattenOptions.length === 0) {
        return /* @__PURE__ */ reactExports.createElement("div", {
          role: "listbox",
          id: "".concat(id, "_list"),
          className: "".concat(itemPrefixCls, "-empty"),
          onMouseDown: onListMouseDown
        }, notFoundContent);
      }
      var omitFieldNameList = Object.keys(fieldNames).map(function(key) {
        return fieldNames[key];
      });
      var getLabel = function getLabel2(item) {
        return item.label;
      };
      function getItemAriaProps(item, index2) {
        var group = item.group;
        return {
          role: group ? "presentation" : "option",
          id: "".concat(id, "_list_").concat(index2)
        };
      }
      var renderItem = function renderItem2(index2) {
        var item = memoFlattenOptions[index2];
        if (!item) {
          return null;
        }
        var itemData = item.data || {};
        var value = itemData.value;
        var group = item.group;
        var attrs = pickAttrs(itemData, true);
        var mergedLabel = getLabel(item);
        return item ? /* @__PURE__ */ reactExports.createElement("div", _extends$2({
          "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null
        }, attrs, {
          key: index2
        }, getItemAriaProps(item, index2), {
          "aria-selected": isAriaSelected(value)
        }), value) : null;
      };
      var a11yProps = {
        role: "listbox",
        id: "".concat(id, "_list")
      };
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, virtual && /* @__PURE__ */ reactExports.createElement("div", _extends$2({}, a11yProps, {
        style: {
          height: 0,
          width: 0,
          overflow: "hidden"
        }
      }), renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), /* @__PURE__ */ reactExports.createElement(List$1, {
        itemKey: "key",
        ref: listRef,
        data: memoFlattenOptions,
        height: listHeight,
        itemHeight: listItemHeight,
        fullHeight: false,
        onMouseDown: onListMouseDown,
        onScroll: onPopupScroll,
        virtual,
        direction,
        innerProps: virtual ? null : a11yProps
      }, function(item, itemIndex) {
        var group = item.group, groupOption = item.groupOption, data = item.data, label = item.label, value = item.value;
        var key = data.key;
        if (group) {
          var _data$title;
          var groupTitle = (_data$title = data.title) !== null && _data$title !== void 0 ? _data$title : isTitleType(label) ? label.toString() : void 0;
          return /* @__PURE__ */ reactExports.createElement("div", {
            className: classNames(itemPrefixCls, "".concat(itemPrefixCls, "-group"), data.className),
            title: groupTitle
          }, label !== void 0 ? label : key);
        }
        var disabled = data.disabled, title = data.title;
        data.children;
        var style2 = data.style, className = data.className, otherProps = _objectWithoutProperties(data, _excluded$t);
        var passedProps = omit(otherProps, omitFieldNameList);
        var selected = isSelected(value);
        var mergedDisabled = disabled || !selected && overMaxCount;
        var optionPrefixCls = "".concat(itemPrefixCls, "-option");
        var optionClassName = classNames(itemPrefixCls, optionPrefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(optionPrefixCls, "-grouped"), groupOption), "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !mergedDisabled), "".concat(optionPrefixCls, "-disabled"), mergedDisabled), "".concat(optionPrefixCls, "-selected"), selected));
        var mergedLabel = getLabel(item);
        var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
        var content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
        var optionTitle = isTitleType(content) ? content.toString() : void 0;
        if (title !== void 0) {
          optionTitle = title;
        }
        return /* @__PURE__ */ reactExports.createElement("div", _extends$2({}, pickAttrs(passedProps), !virtual ? getItemAriaProps(item, itemIndex) : {}, {
          "aria-selected": isAriaSelected(value),
          className: optionClassName,
          title: optionTitle,
          onMouseMove: function onMouseMove() {
            if (activeIndex === itemIndex || mergedDisabled) {
              return;
            }
            setActive(itemIndex);
          },
          onClick: function onClick() {
            if (!mergedDisabled) {
              onSelectValue(value);
            }
          },
          style: style2
        }), /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(optionPrefixCls, "-content")
        }, typeof optionRender === "function" ? optionRender(item, {
          index: itemIndex
        }) : content), /* @__PURE__ */ reactExports.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /* @__PURE__ */ reactExports.createElement(TransBtn, {
          className: "".concat(itemPrefixCls, "-option-state"),
          customizeIcon: menuItemSelectedIcon,
          customizeIconProps: {
            value,
            disabled: mergedDisabled,
            isSelected: selected
          }
        }, selected ? "" : null));
      }));
    };
    var RefOptionList = /* @__PURE__ */ reactExports.forwardRef(OptionList);
    const useCache = function(labeledValues, valueOptions) {
      var cacheRef = reactExports.useRef({
        values: /* @__PURE__ */ new Map(),
        options: /* @__PURE__ */ new Map()
      });
      var filledLabeledValues = reactExports.useMemo(function() {
        var _cacheRef$current = cacheRef.current, prevValueCache = _cacheRef$current.values, prevOptionCache = _cacheRef$current.options;
        var patchedValues = labeledValues.map(function(item) {
          if (item.label === void 0) {
            var _prevValueCache$get;
            return _objectSpread2$3(_objectSpread2$3({}, item), {}, {
              label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label
            });
          }
          return item;
        });
        var valueCache = /* @__PURE__ */ new Map();
        var optionCache = /* @__PURE__ */ new Map();
        patchedValues.forEach(function(item) {
          valueCache.set(item.value, item);
          optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
        });
        cacheRef.current.values = valueCache;
        cacheRef.current.options = optionCache;
        return patchedValues;
      }, [labeledValues, valueOptions]);
      var getOption = reactExports.useCallback(function(val) {
        return valueOptions.get(val) || cacheRef.current.options.get(val);
      }, [valueOptions]);
      return [filledLabeledValues, getOption];
    };
    function includes(test, search) {
      return toArray$3(test).join("").toUpperCase().includes(search);
    }
    const useFilterOptions = function(options2, fieldNames, searchValue, filterOption, optionFilterProp) {
      return reactExports.useMemo(function() {
        if (!searchValue || filterOption === false) {
          return options2;
        }
        var fieldOptions = fieldNames.options, fieldLabel = fieldNames.label, fieldValue = fieldNames.value;
        var filteredOptions = [];
        var customizeFilter = typeof filterOption === "function";
        var upperSearch = searchValue.toUpperCase();
        var filterFunc = customizeFilter ? filterOption : function(_2, option) {
          if (optionFilterProp) {
            return includes(option[optionFilterProp], upperSearch);
          }
          if (option[fieldOptions]) {
            return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
          }
          return includes(option[fieldValue], upperSearch);
        };
        var wrapOption = customizeFilter ? function(opt) {
          return injectPropsWithOption(opt);
        } : function(opt) {
          return opt;
        };
        options2.forEach(function(item) {
          if (item[fieldOptions]) {
            var matchGroup = filterFunc(searchValue, wrapOption(item));
            if (matchGroup) {
              filteredOptions.push(item);
            } else {
              var subOptions = item[fieldOptions].filter(function(subItem) {
                return filterFunc(searchValue, wrapOption(subItem));
              });
              if (subOptions.length) {
                filteredOptions.push(_objectSpread2$3(_objectSpread2$3({}, item), {}, _defineProperty({}, fieldOptions, subOptions)));
              }
            }
            return;
          }
          if (filterFunc(searchValue, wrapOption(item))) {
            filteredOptions.push(item);
          }
        });
        return filteredOptions;
      }, [options2, filterOption, optionFilterProp, searchValue, fieldNames]);
    };
    var uuid$1 = 0;
    var isBrowserClient = canUseDom$2();
    function getUUID() {
      var retId;
      if (isBrowserClient) {
        retId = uuid$1;
        uuid$1 += 1;
      } else {
        retId = "TEST_OR_SSR";
      }
      return retId;
    }
    function useId(id) {
      var _React$useState = reactExports.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
      reactExports.useEffect(function() {
        setInnerId("rc_select_".concat(getUUID()));
      }, []);
      return id || innerId;
    }
    var _excluded$s = ["children", "value"], _excluded2$6 = ["children"];
    function convertNodeToOption(node2) {
      var _ref = node2, key = _ref.key, _ref$props = _ref.props, children = _ref$props.children, value = _ref$props.value, restProps = _objectWithoutProperties(_ref$props, _excluded$s);
      return _objectSpread2$3({
        key,
        value: value !== void 0 ? value : key,
        children
      }, restProps);
    }
    function convertChildrenToData(nodes) {
      var optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return toArray$5(nodes).map(function(node2, index2) {
        if (!/* @__PURE__ */ reactExports.isValidElement(node2) || !node2.type) {
          return null;
        }
        var _ref2 = node2, isSelectOptGroup = _ref2.type.isSelectOptGroup, key = _ref2.key, _ref2$props = _ref2.props, children = _ref2$props.children, restProps = _objectWithoutProperties(_ref2$props, _excluded2$6);
        if (optionOnly || !isSelectOptGroup) {
          return convertNodeToOption(node2);
        }
        return _objectSpread2$3(_objectSpread2$3({
          key: "__RC_SELECT_GRP__".concat(key === null ? index2 : key, "__"),
          label: key
        }, restProps), {}, {
          options: convertChildrenToData(children)
        });
      }).filter(function(data) {
        return data;
      });
    }
    var useOptions = function useOptions2(options2, children, fieldNames, optionFilterProp, optionLabelProp) {
      return reactExports.useMemo(function() {
        var mergedOptions = options2;
        var childrenAsData = !options2;
        if (childrenAsData) {
          mergedOptions = convertChildrenToData(children);
        }
        var valueOptions = /* @__PURE__ */ new Map();
        var labelOptions = /* @__PURE__ */ new Map();
        var setLabelOptions = function setLabelOptions2(labelOptionsMap, option, key) {
          if (key && typeof key === "string") {
            labelOptionsMap.set(option[key], option);
          }
        };
        var dig = function dig2(optionList) {
          var isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          for (var i2 = 0; i2 < optionList.length; i2 += 1) {
            var option = optionList[i2];
            if (!option[fieldNames.options] || isChildren) {
              valueOptions.set(option[fieldNames.value], option);
              setLabelOptions(labelOptions, option, fieldNames.label);
              setLabelOptions(labelOptions, option, optionFilterProp);
              setLabelOptions(labelOptions, option, optionLabelProp);
            } else {
              dig2(option[fieldNames.options], true);
            }
          }
        };
        dig(mergedOptions);
        return {
          options: mergedOptions,
          valueOptions,
          labelOptions
        };
      }, [options2, children, fieldNames, optionFilterProp, optionLabelProp]);
    };
    function useRefFunc(callback) {
      var funcRef = reactExports.useRef();
      funcRef.current = callback;
      var cacheFn = reactExports.useCallback(function() {
        return funcRef.current.apply(funcRef, arguments);
      }, []);
      return cacheFn;
    }
    var _excluded$r = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "optionRender", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "direction", "listHeight", "listItemHeight", "labelRender", "value", "defaultValue", "labelInValue", "onChange", "maxCount"];
    var OMIT_DOM_PROPS = ["inputValue"];
    function isRawValue(value) {
      return !value || _typeof$1(value) !== "object";
    }
    var Select$2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var id = props.id, mode = props.mode, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-select" : _props$prefixCls, backfill = props.backfill, fieldNames = props.fieldNames, inputValue = props.inputValue, searchValue = props.searchValue, onSearch = props.onSearch, _props$autoClearSearc = props.autoClearSearchValue, autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc, onSelect = props.onSelect, onDeselect = props.onDeselect, _props$dropdownMatchS = props.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS, filterOption = props.filterOption, filterSort = props.filterSort, optionFilterProp = props.optionFilterProp, optionLabelProp = props.optionLabelProp, options2 = props.options, optionRender = props.optionRender, children = props.children, defaultActiveFirstOption = props.defaultActiveFirstOption, menuItemSelectedIcon = props.menuItemSelectedIcon, virtual = props.virtual, direction = props.direction, _props$listHeight = props.listHeight, listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight, _props$listItemHeight = props.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight, labelRender = props.labelRender, value = props.value, defaultValue = props.defaultValue, labelInValue = props.labelInValue, onChange = props.onChange, maxCount = props.maxCount, restProps = _objectWithoutProperties(props, _excluded$r);
      var mergedId = useId(id);
      var multiple = isMultiple(mode);
      var childrenAsData = !!(!options2 && children);
      var mergedFilterOption = reactExports.useMemo(function() {
        if (filterOption === void 0 && mode === "combobox") {
          return false;
        }
        return filterOption;
      }, [filterOption, mode]);
      var mergedFieldNames = reactExports.useMemo(
        function() {
          return fillFieldNames(fieldNames, childrenAsData);
        },
        /* eslint-disable react-hooks/exhaustive-deps */
        [
          // We stringify fieldNames to avoid unnecessary re-renders.
          JSON.stringify(fieldNames),
          childrenAsData
        ]
        /* eslint-enable react-hooks/exhaustive-deps */
      );
      var _useMergedState = useMergedState("", {
        value: searchValue !== void 0 ? searchValue : inputValue,
        postState: function postState(search) {
          return search || "";
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1];
      var parsedOptions = useOptions(options2, children, mergedFieldNames, optionFilterProp, optionLabelProp);
      var valueOptions = parsedOptions.valueOptions, labelOptions = parsedOptions.labelOptions, mergedOptions = parsedOptions.options;
      var convert2LabelValues = reactExports.useCallback(function(draftValues) {
        var valueList = toArray$3(draftValues);
        return valueList.map(function(val) {
          var rawValue;
          var rawLabel;
          var rawKey;
          var rawDisabled;
          var rawTitle;
          if (isRawValue(val)) {
            rawValue = val;
          } else {
            var _val$value;
            rawKey = val.key;
            rawLabel = val.label;
            rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
          }
          var option = valueOptions.get(rawValue);
          if (option) {
            var _option$key;
            if (rawLabel === void 0) rawLabel = option === null || option === void 0 ? void 0 : option[optionLabelProp || mergedFieldNames.label];
            if (rawKey === void 0) rawKey = (_option$key = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue;
            rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
            rawTitle = option === null || option === void 0 ? void 0 : option.title;
          }
          return {
            label: rawLabel,
            value: rawValue,
            key: rawKey,
            disabled: rawDisabled,
            title: rawTitle
          };
        });
      }, [mergedFieldNames, optionLabelProp, valueOptions]);
      var _useMergedState3 = useMergedState(defaultValue, {
        value
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1];
      var rawLabeledValues = reactExports.useMemo(function() {
        var _values$;
        var newInternalValue = multiple && internalValue === null ? [] : internalValue;
        var values = convert2LabelValues(newInternalValue);
        if (mode === "combobox" && isComboNoValue((_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.value)) {
          return [];
        }
        return values;
      }, [internalValue, convert2LabelValues, mode, multiple]);
      var _useCache = useCache(rawLabeledValues, valueOptions), _useCache2 = _slicedToArray(_useCache, 2), mergedValues = _useCache2[0], getMixedOption = _useCache2[1];
      var displayValues = reactExports.useMemo(function() {
        if (!mode && mergedValues.length === 1) {
          var firstValue = mergedValues[0];
          if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
            return [];
          }
        }
        return mergedValues.map(function(item) {
          var _ref;
          return _objectSpread2$3(_objectSpread2$3({}, item), {}, {
            label: (_ref = typeof labelRender === "function" ? labelRender(item) : item.label) !== null && _ref !== void 0 ? _ref : item.value
          });
        });
      }, [mode, mergedValues, labelRender]);
      var rawValues = reactExports.useMemo(function() {
        return new Set(mergedValues.map(function(val) {
          return val.value;
        }));
      }, [mergedValues]);
      reactExports.useEffect(function() {
        if (mode === "combobox") {
          var _mergedValues$;
          var strValue = (_mergedValues$ = mergedValues[0]) === null || _mergedValues$ === void 0 ? void 0 : _mergedValues$.value;
          setSearchValue(hasValue(strValue) ? String(strValue) : "");
        }
      }, [mergedValues]);
      var createTagOption = useRefFunc(function(val, label) {
        var mergedLabel = label !== null && label !== void 0 ? label : val;
        return _defineProperty(_defineProperty({}, mergedFieldNames.value, val), mergedFieldNames.label, mergedLabel);
      });
      var filledTagOptions = reactExports.useMemo(function() {
        if (mode !== "tags") {
          return mergedOptions;
        }
        var cloneOptions = _toConsumableArray(mergedOptions);
        var existOptions = function existOptions2(val) {
          return valueOptions.has(val);
        };
        _toConsumableArray(mergedValues).sort(function(a, b2) {
          return a.value < b2.value ? -1 : 1;
        }).forEach(function(item) {
          var val = item.value;
          if (!existOptions(val)) {
            cloneOptions.push(createTagOption(val, item.label));
          }
        });
        return cloneOptions;
      }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
      var filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp);
      var filledSearchOptions = reactExports.useMemo(function() {
        if (mode !== "tags" || !mergedSearchValue || filteredOptions.some(function(item) {
          return item[optionFilterProp || "value"] === mergedSearchValue;
        })) {
          return filteredOptions;
        }
        if (filteredOptions.some(function(item) {
          return item[mergedFieldNames.value] === mergedSearchValue;
        })) {
          return filteredOptions;
        }
        return [createTagOption(mergedSearchValue)].concat(_toConsumableArray(filteredOptions));
      }, [createTagOption, optionFilterProp, mode, filteredOptions, mergedSearchValue, mergedFieldNames]);
      var sorter = function sorter2(inputOptions) {
        var sortedOptions = _toConsumableArray(inputOptions).sort(function(a, b2) {
          return filterSort(a, b2, {
            searchValue: mergedSearchValue
          });
        });
        return sortedOptions.map(function(item) {
          if (Array.isArray(item.options)) {
            return _objectSpread2$3(_objectSpread2$3({}, item), {}, {
              options: item.options.length > 0 ? sorter2(item.options) : item.options
            });
          }
          return item;
        });
      };
      var orderedFilteredOptions = reactExports.useMemo(function() {
        if (!filterSort) {
          return filledSearchOptions;
        }
        return sorter(filledSearchOptions);
      }, [filledSearchOptions, filterSort, mergedSearchValue]);
      var displayOptions = reactExports.useMemo(function() {
        return flattenOptions(orderedFilteredOptions, {
          fieldNames: mergedFieldNames,
          childrenAsData
        });
      }, [orderedFilteredOptions, mergedFieldNames, childrenAsData]);
      var triggerChange = function triggerChange2(values) {
        var labeledValues = convert2LabelValues(values);
        setInternalValue(labeledValues);
        if (onChange && // Trigger event only when value changed
        (labeledValues.length !== mergedValues.length || labeledValues.some(function(newVal, index2) {
          var _mergedValues$index;
          return ((_mergedValues$index = mergedValues[index2]) === null || _mergedValues$index === void 0 ? void 0 : _mergedValues$index.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
        }))) {
          var returnValues = labelInValue ? labeledValues : labeledValues.map(function(v2) {
            return v2.value;
          });
          var returnOptions = labeledValues.map(function(v2) {
            return injectPropsWithOption(getMixedOption(v2.value));
          });
          onChange(
            // Value
            multiple ? returnValues : returnValues[0],
            // Option
            multiple ? returnOptions : returnOptions[0]
          );
        }
      };
      var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), activeValue = _React$useState2[0], setActiveValue = _React$useState2[1];
      var _React$useState3 = reactExports.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), accessibilityIndex = _React$useState4[0], setAccessibilityIndex = _React$useState4[1];
      var mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
      var onActiveValue = reactExports.useCallback(function(active, index2) {
        var _ref3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref3$source = _ref3.source, source = _ref3$source === void 0 ? "keyboard" : _ref3$source;
        setAccessibilityIndex(index2);
        if (backfill && mode === "combobox" && active !== null && source === "keyboard") {
          setActiveValue(String(active));
        }
      }, [backfill, mode]);
      var triggerSelect = function triggerSelect2(val, selected, type2) {
        var getSelectEnt = function getSelectEnt2() {
          var _option$key2;
          var option = getMixedOption(val);
          return [labelInValue ? {
            label: option === null || option === void 0 ? void 0 : option[mergedFieldNames.label],
            value: val,
            key: (_option$key2 = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
          } : val, injectPropsWithOption(option)];
        };
        if (selected && onSelect) {
          var _getSelectEnt = getSelectEnt(), _getSelectEnt2 = _slicedToArray(_getSelectEnt, 2), wrappedValue = _getSelectEnt2[0], _option = _getSelectEnt2[1];
          onSelect(wrappedValue, _option);
        } else if (!selected && onDeselect && type2 !== "clear") {
          var _getSelectEnt3 = getSelectEnt(), _getSelectEnt4 = _slicedToArray(_getSelectEnt3, 2), _wrappedValue = _getSelectEnt4[0], _option2 = _getSelectEnt4[1];
          onDeselect(_wrappedValue, _option2);
        }
      };
      var onInternalSelect = useRefFunc(function(val, info) {
        var cloneValues;
        var mergedSelect = multiple ? info.selected : true;
        if (mergedSelect) {
          cloneValues = multiple ? [].concat(_toConsumableArray(mergedValues), [val]) : [val];
        } else {
          cloneValues = mergedValues.filter(function(v2) {
            return v2.value !== val;
          });
        }
        triggerChange(cloneValues);
        triggerSelect(val, mergedSelect);
        if (mode === "combobox") {
          setActiveValue("");
        } else if (!isMultiple || autoClearSearchValue) {
          setSearchValue("");
          setActiveValue("");
        }
      });
      var onDisplayValuesChange = function onDisplayValuesChange2(nextValues, info) {
        triggerChange(nextValues);
        var type2 = info.type, values = info.values;
        if (type2 === "remove" || type2 === "clear") {
          values.forEach(function(item) {
            triggerSelect(item.value, false, type2);
          });
        }
      };
      var onInternalSearch = function onInternalSearch2(searchText, info) {
        setSearchValue(searchText);
        setActiveValue(null);
        if (info.source === "submit") {
          var formatted = (searchText || "").trim();
          if (formatted) {
            var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), [formatted])));
            triggerChange(newRawValues);
            triggerSelect(formatted, true);
            setSearchValue("");
          }
          return;
        }
        if (info.source !== "blur") {
          if (mode === "combobox") {
            triggerChange(searchText);
          }
          onSearch === null || onSearch === void 0 || onSearch(searchText);
        }
      };
      var onInternalSearchSplit = function onInternalSearchSplit2(words2) {
        var patchValues = words2;
        if (mode !== "tags") {
          patchValues = words2.map(function(word) {
            var opt = labelOptions.get(word);
            return opt === null || opt === void 0 ? void 0 : opt.value;
          }).filter(function(val) {
            return val !== void 0;
          });
        }
        var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), _toConsumableArray(patchValues))));
        triggerChange(newRawValues);
        newRawValues.forEach(function(newRawValue) {
          triggerSelect(newRawValue, true);
        });
      };
      var selectContext = reactExports.useMemo(function() {
        var realVirtual = virtual !== false && dropdownMatchSelectWidth !== false;
        return _objectSpread2$3(_objectSpread2$3({}, parsedOptions), {}, {
          flattenOptions: displayOptions,
          onActiveValue,
          defaultActiveFirstOption: mergedDefaultActiveFirstOption,
          onSelect: onInternalSelect,
          menuItemSelectedIcon,
          rawValues,
          fieldNames: mergedFieldNames,
          virtual: realVirtual,
          direction,
          listHeight,
          listItemHeight,
          childrenAsData,
          maxCount,
          optionRender
        });
      }, [maxCount, parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, dropdownMatchSelectWidth, direction, listHeight, listItemHeight, childrenAsData, optionRender]);
      return /* @__PURE__ */ reactExports.createElement(SelectContext.Provider, {
        value: selectContext
      }, /* @__PURE__ */ reactExports.createElement(BaseSelect, _extends$2({}, restProps, {
        // >>> MISC
        id: mergedId,
        prefixCls,
        ref,
        omitDomProps: OMIT_DOM_PROPS,
        mode,
        displayValues,
        onDisplayValuesChange,
        direction,
        searchValue: mergedSearchValue,
        onSearch: onInternalSearch,
        autoClearSearchValue,
        onSearchSplit: onInternalSearchSplit,
        dropdownMatchSelectWidth,
        OptionList: RefOptionList,
        emptyOptions: !displayOptions.length,
        activeValue,
        activeDescendantId: "".concat(mergedId, "_list_").concat(accessibilityIndex)
      })));
    });
    var TypedSelect = Select$2;
    TypedSelect.Option = Option;
    TypedSelect.OptGroup = OptGroup;
    function getStatusClassNames(prefixCls, status, hasFeedback) {
      return classNames({
        [`${prefixCls}-status-success`]: status === "success",
        [`${prefixCls}-status-warning`]: status === "warning",
        [`${prefixCls}-status-error`]: status === "error",
        [`${prefixCls}-status-validating`]: status === "validating",
        [`${prefixCls}-has-feedback`]: hasFeedback
      });
    }
    const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
    const Empty$1 = () => {
      const [, token2] = useToken();
      const [locale2] = useLocale$1("Empty");
      const bgColor = new FastColor(token2.colorBgBase);
      const themeStyle = bgColor.toHsl().l < 0.5 ? {
        opacity: 0.65
      } : {};
      return /* @__PURE__ */ reactExports.createElement("svg", {
        style: themeStyle,
        width: "184",
        height: "152",
        viewBox: "0 0 184 152",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ reactExports.createElement("title", null, (locale2 === null || locale2 === void 0 ? void 0 : locale2.description) || "Empty"), /* @__PURE__ */ reactExports.createElement("g", {
        fill: "none",
        fillRule: "evenodd"
      }, /* @__PURE__ */ reactExports.createElement("g", {
        transform: "translate(24 31.67)"
      }, /* @__PURE__ */ reactExports.createElement("ellipse", {
        fillOpacity: ".8",
        fill: "#F5F5F7",
        cx: "67.797",
        cy: "106.89",
        rx: "67.797",
        ry: "12.668"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
        fill: "#AEB8C2"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
        fill: "url(#linearGradient-1)",
        transform: "translate(13.56)"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
        fill: "#F5F5F7"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
        fill: "#DCE0E6"
      })), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
        fill: "#DCE0E6"
      }), /* @__PURE__ */ reactExports.createElement("g", {
        transform: "translate(149.65 15.383)",
        fill: "#FFF"
      }, /* @__PURE__ */ reactExports.createElement("ellipse", {
        cx: "20.654",
        cy: "3.167",
        rx: "2.849",
        ry: "2.815"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
      }))));
    };
    const Simple = () => {
      const [, token2] = useToken();
      const [locale2] = useLocale$1("Empty");
      const {
        colorFill,
        colorFillTertiary,
        colorFillQuaternary,
        colorBgContainer
      } = token2;
      const {
        borderColor,
        shadowColor,
        contentColor
      } = reactExports.useMemo(() => ({
        borderColor: new FastColor(colorFill).onBackground(colorBgContainer).toHexString(),
        shadowColor: new FastColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
        contentColor: new FastColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
      }), [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]);
      return /* @__PURE__ */ reactExports.createElement("svg", {
        width: "64",
        height: "41",
        viewBox: "0 0 64 41",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ reactExports.createElement("title", null, (locale2 === null || locale2 === void 0 ? void 0 : locale2.description) || "Empty"), /* @__PURE__ */ reactExports.createElement("g", {
        transform: "translate(0 1)",
        fill: "none",
        fillRule: "evenodd"
      }, /* @__PURE__ */ reactExports.createElement("ellipse", {
        fill: shadowColor,
        cx: "32",
        cy: "33",
        rx: "32",
        ry: "7"
      }), /* @__PURE__ */ reactExports.createElement("g", {
        fillRule: "nonzero",
        stroke: borderColor
      }, /* @__PURE__ */ reactExports.createElement("path", {
        d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
        fill: contentColor
      }))));
    };
    const genSharedEmptyStyle = (token2) => {
      const {
        componentCls,
        margin,
        marginXS,
        marginXL,
        fontSize,
        lineHeight
      } = token2;
      return {
        [componentCls]: {
          marginInline: marginXS,
          fontSize,
          lineHeight,
          textAlign: "center",
          //  &-image  hashId
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeight,
            marginBottom: marginXS,
            opacity: token2.opacityImage,
            img: {
              height: "100%"
            },
            svg: {
              maxWidth: "100%",
              height: "100%",
              margin: "auto"
            }
          },
          [`${componentCls}-description`]: {
            color: token2.colorTextDescription
          },
          //  &-footer  hashId
          [`${componentCls}-footer`]: {
            marginTop: margin
          },
          "&-normal": {
            marginBlock: marginXL,
            color: token2.colorTextDescription,
            [`${componentCls}-description`]: {
              color: token2.colorTextDescription
            },
            [`${componentCls}-image`]: {
              height: token2.emptyImgHeightMD
            }
          },
          "&-small": {
            marginBlock: marginXS,
            color: token2.colorTextDescription,
            [`${componentCls}-image`]: {
              height: token2.emptyImgHeightSM
            }
          }
        }
      };
    };
    const useStyle$l = genStyleHooks("Empty", (token2) => {
      const {
        componentCls,
        controlHeightLG,
        calc
      } = token2;
      const emptyToken = merge(token2, {
        emptyImgCls: `${componentCls}-img`,
        emptyImgHeight: calc(controlHeightLG).mul(2.5).equal(),
        emptyImgHeightMD: controlHeightLG,
        emptyImgHeightSM: calc(controlHeightLG).mul(0.875).equal()
      });
      return [genSharedEmptyStyle(emptyToken)];
    });
    var __rest$K = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const defaultEmptyImg = /* @__PURE__ */ reactExports.createElement(Empty$1, null);
    const simpleEmptyImg = /* @__PURE__ */ reactExports.createElement(Simple, null);
    const Empty = (props) => {
      const {
        className,
        rootClassName,
        prefixCls: customizePrefixCls,
        image = defaultEmptyImg,
        description,
        children,
        imageStyle,
        style: style2,
        classNames: emptyClassNames,
        styles
      } = props, restProps = __rest$K(props, ["className", "rootClassName", "prefixCls", "image", "description", "children", "imageStyle", "style", "classNames", "styles"]);
      const {
        getPrefixCls,
        direction,
        className: contextClassName,
        style: contextStyle,
        classNames: contextClassNames,
        styles: contextStyles
      } = useComponentConfig("empty");
      const prefixCls = getPrefixCls("empty", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$l(prefixCls);
      const [locale2] = useLocale$1("Empty");
      const des = typeof description !== "undefined" ? description : locale2 === null || locale2 === void 0 ? void 0 : locale2.description;
      const alt = typeof des === "string" ? des : "empty";
      let imageNode = null;
      if (typeof image === "string") {
        imageNode = /* @__PURE__ */ reactExports.createElement("img", {
          alt,
          src: image
        });
      } else {
        imageNode = image;
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: classNames(hashId, cssVarCls, prefixCls, contextClassName, {
          [`${prefixCls}-normal`]: image === simpleEmptyImg,
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, className, rootClassName, contextClassNames.root, emptyClassNames === null || emptyClassNames === void 0 ? void 0 : emptyClassNames.root),
        style: Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyles.root), contextStyle), styles === null || styles === void 0 ? void 0 : styles.root), style2)
      }, restProps), /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-image`, contextClassNames.image, emptyClassNames === null || emptyClassNames === void 0 ? void 0 : emptyClassNames.image),
        style: Object.assign(Object.assign(Object.assign({}, imageStyle), contextStyles.image), styles === null || styles === void 0 ? void 0 : styles.image)
      }, imageNode), des && /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-description`, contextClassNames.description, emptyClassNames === null || emptyClassNames === void 0 ? void 0 : emptyClassNames.description),
        style: Object.assign(Object.assign({}, contextStyles.description), styles === null || styles === void 0 ? void 0 : styles.description)
      }, des), children && /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-footer`, contextClassNames.footer, emptyClassNames === null || emptyClassNames === void 0 ? void 0 : emptyClassNames.footer),
        style: Object.assign(Object.assign({}, contextStyles.footer), styles === null || styles === void 0 ? void 0 : styles.footer)
      }, children)));
    };
    Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
    Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
    const DefaultRenderEmpty = (props) => {
      const {
        componentName
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefix2 = getPrefixCls("empty");
      switch (componentName) {
        case "Table":
        case "List":
          return /* @__PURE__ */ i.createElement(Empty, {
            image: Empty.PRESENTED_IMAGE_SIMPLE
          });
        case "Select":
        case "TreeSelect":
        case "Cascader":
        case "Transfer":
        case "Mentions":
          return /* @__PURE__ */ i.createElement(Empty, {
            image: Empty.PRESENTED_IMAGE_SIMPLE,
            className: `${prefix2}-small`
          });
        case "Table.filter":
          return null;
        default:
          return /* @__PURE__ */ i.createElement(Empty, null);
      }
    };
    const useVariant = function(component, variant) {
      let legacyBordered = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
      var _a, _b;
      const {
        variant: configVariant,
        [component]: componentConfig
      } = reactExports.useContext(ConfigContext);
      const ctxVariant = reactExports.useContext(VariantContext);
      const configComponentVariant = componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.variant;
      let mergedVariant;
      if (typeof variant !== "undefined") {
        mergedVariant = variant;
      } else if (legacyBordered === false) {
        mergedVariant = "borderless";
      } else {
        mergedVariant = (_b = (_a = ctxVariant !== null && ctxVariant !== void 0 ? ctxVariant : configComponentVariant) !== null && _a !== void 0 ? _a : configVariant) !== null && _b !== void 0 ? _b : "outlined";
      }
      const enableVariantCls = Variants.includes(mergedVariant);
      return [mergedVariant, enableVariantCls];
    };
    const getBuiltInPlacements = (popupOverflow) => {
      const htmlRegion = popupOverflow === "scroll" ? "scroll" : "visible";
      const sharedConfig = {
        overflow: {
          adjustX: true,
          adjustY: true,
          shiftY: true
        },
        htmlRegion,
        dynamicInset: true
      };
      return {
        bottomLeft: Object.assign(Object.assign({}, sharedConfig), {
          points: ["tl", "bl"],
          offset: [0, 4]
        }),
        bottomRight: Object.assign(Object.assign({}, sharedConfig), {
          points: ["tr", "br"],
          offset: [0, 4]
        }),
        topLeft: Object.assign(Object.assign({}, sharedConfig), {
          points: ["bl", "tl"],
          offset: [0, -4]
        }),
        topRight: Object.assign(Object.assign({}, sharedConfig), {
          points: ["br", "tr"],
          offset: [0, -4]
        })
      };
    };
    function mergedBuiltinPlacements(buildInPlacements, popupOverflow) {
      return buildInPlacements || getBuiltInPlacements(popupOverflow);
    }
    const genItemStyle = (token2) => {
      const {
        optionHeight,
        optionFontSize,
        optionLineHeight,
        optionPadding
      } = token2;
      return {
        position: "relative",
        display: "block",
        minHeight: optionHeight,
        padding: optionPadding,
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: optionFontSize,
        lineHeight: optionLineHeight,
        boxSizing: "border-box"
      };
    };
    const genSingleStyle$1 = (token2) => {
      const {
        antCls,
        componentCls
      } = token2;
      const selectItemCls = `${componentCls}-item`;
      const slideUpEnterActive = `&${antCls}-slide-up-enter${antCls}-slide-up-enter-active`;
      const slideUpAppearActive = `&${antCls}-slide-up-appear${antCls}-slide-up-appear-active`;
      const slideUpLeaveActive = `&${antCls}-slide-up-leave${antCls}-slide-up-leave-active`;
      const dropdownPlacementCls = `${componentCls}-dropdown-placement-`;
      const selectedItemCls = `${selectItemCls}-option-selected`;
      return [
        {
          [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token2)), {
            position: "absolute",
            top: -9999,
            zIndex: token2.zIndexPopup,
            boxSizing: "border-box",
            padding: token2.paddingXXS,
            overflow: "hidden",
            fontSize: token2.fontSize,
            // Fix select render lag of long text in chrome
            // https://github.com/ant-design/ant-design/issues/11456
            // https://github.com/ant-design/ant-design/issues/11843
            fontVariant: "initial",
            backgroundColor: token2.colorBgElevated,
            borderRadius: token2.borderRadiusLG,
            outline: "none",
            boxShadow: token2.boxShadowSecondary,
            [`
          ${slideUpEnterActive}${dropdownPlacementCls}bottomLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}bottomLeft
        `]: {
              animationName: slideUpIn
            },
            [`
          ${slideUpEnterActive}${dropdownPlacementCls}topLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}topLeft,
          ${slideUpEnterActive}${dropdownPlacementCls}topRight,
          ${slideUpAppearActive}${dropdownPlacementCls}topRight
        `]: {
              animationName: slideDownIn
            },
            [`${slideUpLeaveActive}${dropdownPlacementCls}bottomLeft`]: {
              animationName: slideUpOut
            },
            [`
          ${slideUpLeaveActive}${dropdownPlacementCls}topLeft,
          ${slideUpLeaveActive}${dropdownPlacementCls}topRight
        `]: {
              animationName: slideDownOut
            },
            "&-hidden": {
              display: "none"
            },
            [selectItemCls]: Object.assign(Object.assign({}, genItemStyle(token2)), {
              cursor: "pointer",
              transition: `background ${token2.motionDurationSlow} ease`,
              borderRadius: token2.borderRadiusSM,
              // =========== Group ============
              "&-group": {
                color: token2.colorTextDescription,
                fontSize: token2.fontSizeSM,
                cursor: "default"
              },
              // =========== Option ===========
              "&-option": {
                display: "flex",
                "&-content": Object.assign({
                  flex: "auto"
                }, textEllipsis),
                "&-state": {
                  flex: "none",
                  display: "flex",
                  alignItems: "center"
                },
                [`&-active:not(${selectItemCls}-option-disabled)`]: {
                  backgroundColor: token2.optionActiveBg
                },
                [`&-selected:not(${selectItemCls}-option-disabled)`]: {
                  color: token2.optionSelectedColor,
                  fontWeight: token2.optionSelectedFontWeight,
                  backgroundColor: token2.optionSelectedBg,
                  [`${selectItemCls}-option-state`]: {
                    color: token2.colorPrimary
                  }
                },
                "&-disabled": {
                  [`&${selectItemCls}-option-selected`]: {
                    backgroundColor: token2.colorBgContainerDisabled
                  },
                  color: token2.colorTextDisabled,
                  cursor: "not-allowed"
                },
                "&-grouped": {
                  paddingInlineStart: token2.calc(token2.controlPaddingHorizontal).mul(2).equal()
                }
              },
              "&-empty": Object.assign(Object.assign({}, genItemStyle(token2)), {
                color: token2.colorTextDisabled
              })
            }),
            // https://github.com/ant-design/ant-design/pull/46646
            [`${selectedItemCls}:has(+ ${selectedItemCls})`]: {
              borderEndStartRadius: 0,
              borderEndEndRadius: 0,
              [`& + ${selectedItemCls}`]: {
                borderStartStartRadius: 0,
                borderStartEndRadius: 0
              }
            },
            // =========================== RTL ===========================
            "&-rtl": {
              direction: "rtl"
            }
          })
        },
        // Follow code may reuse in other components
        initSlideMotion(token2, "slide-up"),
        initSlideMotion(token2, "slide-down"),
        initMoveMotion(token2, "move-up"),
        initMoveMotion(token2, "move-down")
      ];
    };
    const getMultipleSelectorUnit = (token2) => {
      const {
        multipleSelectItemHeight,
        paddingXXS,
        lineWidth,
        INTERNAL_FIXED_ITEM_MARGIN
      } = token2;
      const basePadding = token2.max(token2.calc(paddingXXS).sub(lineWidth).equal(), 0);
      const containerPadding = token2.max(token2.calc(basePadding).sub(INTERNAL_FIXED_ITEM_MARGIN).equal(), 0);
      return {
        basePadding,
        containerPadding,
        itemHeight: unit$1(multipleSelectItemHeight),
        itemLineHeight: unit$1(token2.calc(multipleSelectItemHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal())
      };
    };
    const getSelectItemStyle = (token2) => {
      const {
        multipleSelectItemHeight,
        selectHeight,
        lineWidth
      } = token2;
      const selectItemDist = token2.calc(selectHeight).sub(multipleSelectItemHeight).div(2).sub(lineWidth).equal();
      return selectItemDist;
    };
    const genOverflowStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        borderRadiusSM,
        motionDurationSlow,
        paddingXS,
        multipleItemColorDisabled,
        multipleItemBorderColorDisabled,
        colorIcon,
        colorIconHover,
        INTERNAL_FIXED_ITEM_MARGIN
      } = token2;
      const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
      return {
        /**
         * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
         * may update to redesign with its align logic.
         */
        // =========================== Overflow ===========================
        [selectOverflowPrefixCls]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          flexWrap: "wrap",
          maxWidth: "100%",
          "&-item": {
            flex: "none",
            alignSelf: "center",
            maxWidth: "100%",
            display: "inline-flex"
          },
          // ======================== Selections ==========================
          [`${componentCls}-selection-item`]: {
            display: "flex",
            alignSelf: "center",
            flex: "none",
            boxSizing: "border-box",
            maxWidth: "100%",
            marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
            borderRadius: borderRadiusSM,
            cursor: "default",
            transition: `font-size ${motionDurationSlow}, line-height ${motionDurationSlow}, height ${motionDurationSlow}`,
            marginInlineEnd: token2.calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
            paddingInlineStart: paddingXS,
            paddingInlineEnd: token2.calc(paddingXS).div(2).equal(),
            [`${componentCls}-disabled&`]: {
              color: multipleItemColorDisabled,
              borderColor: multipleItemBorderColorDisabled,
              cursor: "not-allowed"
            },
            // It's ok not to do this, but 24px makes bottom narrow in view should adjust
            "&-content": {
              display: "inline-block",
              marginInlineEnd: token2.calc(paddingXS).div(2).equal(),
              overflow: "hidden",
              whiteSpace: "pre",
              // fix whitespace wrapping. custom tags display all whitespace within.
              textOverflow: "ellipsis"
            },
            "&-remove": Object.assign(Object.assign({}, resetIcon()), {
              display: "inline-flex",
              alignItems: "center",
              color: colorIcon,
              fontWeight: "bold",
              fontSize: 10,
              lineHeight: "inherit",
              cursor: "pointer",
              [`> ${iconCls}`]: {
                verticalAlign: "-0.2em"
              },
              "&:hover": {
                color: colorIconHover
              }
            })
          }
        }
      };
    };
    const genSelectionStyle = (token2, suffix2) => {
      const {
        componentCls,
        INTERNAL_FIXED_ITEM_MARGIN
      } = token2;
      const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
      const selectItemHeight = token2.multipleSelectItemHeight;
      const selectItemDist = getSelectItemStyle(token2);
      const suffixCls = suffix2 ? `${componentCls}-${suffix2}` : "";
      const multipleSelectorUnit = getMultipleSelectorUnit(token2);
      return {
        [`${componentCls}-multiple${suffixCls}`]: Object.assign(Object.assign({}, genOverflowStyle(token2)), {
          // ========================= Selector =========================
          [`${componentCls}-selector`]: {
            display: "flex",
            alignItems: "center",
            width: "100%",
            height: "100%",
            // Multiple is little different that horizontal is follow the vertical
            paddingInline: multipleSelectorUnit.basePadding,
            paddingBlock: multipleSelectorUnit.containerPadding,
            borderRadius: token2.borderRadius,
            [`${componentCls}-disabled&`]: {
              background: token2.multipleSelectorBgDisabled,
              cursor: "not-allowed"
            },
            "&:after": {
              display: "inline-block",
              width: 0,
              margin: `${unit$1(INTERNAL_FIXED_ITEM_MARGIN)} 0`,
              lineHeight: unit$1(selectItemHeight),
              visibility: "hidden",
              content: '"\\a0"'
            }
          },
          // ======================== Selections ========================
          [`${componentCls}-selection-item`]: {
            height: multipleSelectorUnit.itemHeight,
            lineHeight: unit$1(multipleSelectorUnit.itemLineHeight)
          },
          // ========================== Wrap ===========================
          [`${componentCls}-selection-wrap`]: {
            alignSelf: "flex-start",
            "&:after": {
              lineHeight: unit$1(selectItemHeight),
              marginBlock: INTERNAL_FIXED_ITEM_MARGIN
            }
          },
          // ========================== Input ==========================
          [`${componentCls}-prefix`]: {
            marginInlineStart: token2.calc(token2.inputPaddingHorizontalBase).sub(multipleSelectorUnit.basePadding).equal()
          },
          [`${selectOverflowPrefixCls}-item + ${selectOverflowPrefixCls}-item,
        ${componentCls}-prefix + ${componentCls}-selection-wrap
      `]: {
            [`${componentCls}-selection-search`]: {
              marginInlineStart: 0
            },
            [`${componentCls}-selection-placeholder`]: {
              insetInlineStart: 0
            }
          },
          // https://github.com/ant-design/ant-design/issues/44754
          // Same as `wrap:after`
          [`${selectOverflowPrefixCls}-item-suffix`]: {
            minHeight: multipleSelectorUnit.itemHeight,
            marginBlock: INTERNAL_FIXED_ITEM_MARGIN
          },
          [`${componentCls}-selection-search`]: {
            display: "inline-flex",
            position: "relative",
            maxWidth: "100%",
            marginInlineStart: token2.calc(token2.inputPaddingHorizontalBase).sub(selectItemDist).equal(),
            [`
          &-input,
          &-mirror
        `]: {
              height: selectItemHeight,
              fontFamily: token2.fontFamily,
              lineHeight: unit$1(selectItemHeight),
              transition: `all ${token2.motionDurationSlow}`
            },
            "&-input": {
              width: "100%",
              minWidth: 4.1
              // fix search cursor missing
            },
            "&-mirror": {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              insetInlineEnd: "auto",
              zIndex: 999,
              whiteSpace: "pre",
              // fix whitespace wrapping caused width calculation bug
              visibility: "hidden"
            }
          },
          // ======================= Placeholder =======================
          [`${componentCls}-selection-placeholder`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: token2.calc(token2.inputPaddingHorizontalBase).sub(multipleSelectorUnit.basePadding).equal(),
            insetInlineEnd: token2.inputPaddingHorizontalBase,
            transform: "translateY(-50%)",
            transition: `all ${token2.motionDurationSlow}`
          }
        })
      };
    };
    function genSizeStyle$2(token2, suffix2) {
      const {
        componentCls
      } = token2;
      const suffixCls = suffix2 ? `${componentCls}-${suffix2}` : "";
      const rawStyle = {
        [`${componentCls}-multiple${suffixCls}`]: {
          fontSize: token2.fontSize,
          // ========================= Selector =========================
          [`${componentCls}-selector`]: {
            [`${componentCls}-show-search&`]: {
              cursor: "text"
            }
          },
          [`
        &${componentCls}-show-arrow ${componentCls}-selector,
        &${componentCls}-allow-clear ${componentCls}-selector
      `]: {
            paddingInlineEnd: token2.calc(token2.fontSizeIcon).add(token2.controlPaddingHorizontal).equal()
          }
        }
      };
      return [genSelectionStyle(token2, suffix2), rawStyle];
    }
    const genMultipleStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const smallToken = merge(token2, {
        selectHeight: token2.controlHeightSM,
        multipleSelectItemHeight: token2.multipleItemHeightSM,
        borderRadius: token2.borderRadiusSM,
        borderRadiusSM: token2.borderRadiusXS
      });
      const largeToken = merge(token2, {
        fontSize: token2.fontSizeLG,
        selectHeight: token2.controlHeightLG,
        multipleSelectItemHeight: token2.multipleItemHeightLG,
        borderRadius: token2.borderRadiusLG,
        borderRadiusSM: token2.borderRadius
      });
      return [
        genSizeStyle$2(token2),
        // ======================== Small ========================
        genSizeStyle$2(smallToken, "sm"),
        // Padding
        {
          [`${componentCls}-multiple${componentCls}-sm`]: {
            [`${componentCls}-selection-placeholder`]: {
              insetInline: token2.calc(token2.controlPaddingHorizontalSM).sub(token2.lineWidth).equal()
            },
            // https://github.com/ant-design/ant-design/issues/29559
            [`${componentCls}-selection-search`]: {
              marginInlineStart: 2
              // Magic Number
            }
          }
        },
        // ======================== Large ========================
        genSizeStyle$2(largeToken, "lg")
      ];
    };
    function genSizeStyle$1(token2, suffix2) {
      const {
        componentCls,
        inputPaddingHorizontalBase,
        borderRadius
      } = token2;
      const selectHeightWithoutBorder = token2.calc(token2.controlHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal();
      const suffixCls = suffix2 ? `${componentCls}-${suffix2}` : "";
      return {
        [`${componentCls}-single${suffixCls}`]: {
          fontSize: token2.fontSize,
          height: token2.controlHeight,
          // ========================= Selector =========================
          [`${componentCls}-selector`]: Object.assign(Object.assign({}, resetComponent(token2, true)), {
            display: "flex",
            borderRadius,
            flex: "1 1 auto",
            [`${componentCls}-selection-wrap:after`]: {
              lineHeight: unit$1(selectHeightWithoutBorder)
            },
            [`${componentCls}-selection-search`]: {
              position: "absolute",
              inset: 0,
              width: "100%",
              "&-input": {
                width: "100%",
                WebkitAppearance: "textfield"
              }
            },
            [`
          ${componentCls}-selection-item,
          ${componentCls}-selection-placeholder
        `]: {
              display: "block",
              padding: 0,
              lineHeight: unit$1(selectHeightWithoutBorder),
              transition: `all ${token2.motionDurationSlow}, visibility 0s`,
              alignSelf: "center"
            },
            [`${componentCls}-selection-placeholder`]: {
              transition: "none",
              pointerEvents: "none"
            },
            // For common baseline align
            [[
              "&:after",
              /* For '' value baseline align */
              `${componentCls}-selection-item:empty:after`,
              /* For undefined value baseline align */
              `${componentCls}-selection-placeholder:empty:after`
            ].join(",")]: {
              display: "inline-block",
              width: 0,
              visibility: "hidden",
              content: '"\\a0"'
            }
          }),
          [`
        &${componentCls}-show-arrow ${componentCls}-selection-item,
        &${componentCls}-show-arrow ${componentCls}-selection-search,
        &${componentCls}-show-arrow ${componentCls}-selection-placeholder
      `]: {
            paddingInlineEnd: token2.showArrowPaddingInlineEnd
          },
          // Opacity selection if open
          [`&${componentCls}-open ${componentCls}-selection-item`]: {
            color: token2.colorTextPlaceholder
          },
          // ========================== Input ==========================
          // We only change the style of non-customize input which is only support by `combobox` mode.
          // Not customize
          [`&:not(${componentCls}-customize-input)`]: {
            [`${componentCls}-selector`]: {
              width: "100%",
              height: "100%",
              alignItems: "center",
              padding: `0 ${unit$1(inputPaddingHorizontalBase)}`,
              [`${componentCls}-selection-search-input`]: {
                height: selectHeightWithoutBorder,
                fontSize: token2.fontSize
              },
              "&:after": {
                lineHeight: unit$1(selectHeightWithoutBorder)
              }
            }
          },
          [`&${componentCls}-customize-input`]: {
            [`${componentCls}-selector`]: {
              "&:after": {
                display: "none"
              },
              [`${componentCls}-selection-search`]: {
                position: "static",
                width: "100%"
              },
              [`${componentCls}-selection-placeholder`]: {
                position: "absolute",
                insetInlineStart: 0,
                insetInlineEnd: 0,
                padding: `0 ${unit$1(inputPaddingHorizontalBase)}`,
                "&:after": {
                  display: "none"
                }
              }
            }
          }
        }
      };
    }
    function genSingleStyle(token2) {
      const {
        componentCls
      } = token2;
      const inputPaddingHorizontalSM = token2.calc(token2.controlPaddingHorizontalSM).sub(token2.lineWidth).equal();
      return [
        genSizeStyle$1(token2),
        // ======================== Small ========================
        // Shared
        genSizeStyle$1(merge(token2, {
          controlHeight: token2.controlHeightSM,
          borderRadius: token2.borderRadiusSM
        }), "sm"),
        // padding
        {
          [`${componentCls}-single${componentCls}-sm`]: {
            [`&:not(${componentCls}-customize-input)`]: {
              [`${componentCls}-selector`]: {
                padding: `0 ${unit$1(inputPaddingHorizontalSM)}`
              },
              // With arrow should provides `padding-right` to show the arrow
              [`&${componentCls}-show-arrow ${componentCls}-selection-search`]: {
                insetInlineEnd: token2.calc(inputPaddingHorizontalSM).add(token2.calc(token2.fontSize).mul(1.5)).equal()
              },
              [`
            &${componentCls}-show-arrow ${componentCls}-selection-item,
            &${componentCls}-show-arrow ${componentCls}-selection-placeholder
          `]: {
                paddingInlineEnd: token2.calc(token2.fontSize).mul(1.5).equal()
              }
            }
          }
        },
        // ======================== Large ========================
        // Shared
        genSizeStyle$1(merge(token2, {
          controlHeight: token2.singleItemHeightLG,
          fontSize: token2.fontSizeLG,
          borderRadius: token2.borderRadiusLG
        }), "lg")
      ];
    }
    const prepareComponentToken$h = (token2) => {
      const {
        fontSize,
        lineHeight,
        lineWidth,
        controlHeight,
        controlHeightSM,
        controlHeightLG,
        paddingXXS,
        controlPaddingHorizontal,
        zIndexPopupBase,
        colorText,
        fontWeightStrong,
        controlItemBgActive,
        controlItemBgHover,
        colorBgContainer,
        colorFillSecondary,
        colorBgContainerDisabled,
        colorTextDisabled,
        colorPrimaryHover,
        colorPrimary,
        controlOutline
      } = token2;
      const dblPaddingXXS = paddingXXS * 2;
      const dblLineWidth = lineWidth * 2;
      const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
      const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
      const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
      const INTERNAL_FIXED_ITEM_MARGIN = Math.floor(paddingXXS / 2);
      return {
        INTERNAL_FIXED_ITEM_MARGIN,
        zIndexPopup: zIndexPopupBase + 50,
        optionSelectedColor: colorText,
        optionSelectedFontWeight: fontWeightStrong,
        optionSelectedBg: controlItemBgActive,
        optionActiveBg: controlItemBgHover,
        optionPadding: `${(controlHeight - fontSize * lineHeight) / 2}px ${controlPaddingHorizontal}px`,
        optionFontSize: fontSize,
        optionLineHeight: lineHeight,
        optionHeight: controlHeight,
        selectorBg: colorBgContainer,
        clearBg: colorBgContainer,
        singleItemHeightLG: controlHeightLG,
        multipleItemBg: colorFillSecondary,
        multipleItemBorderColor: "transparent",
        multipleItemHeight,
        multipleItemHeightSM,
        multipleItemHeightLG,
        multipleSelectorBgDisabled: colorBgContainerDisabled,
        multipleItemColorDisabled: colorTextDisabled,
        multipleItemBorderColorDisabled: "transparent",
        showArrowPaddingInlineEnd: Math.ceil(token2.fontSize * 1.25),
        hoverBorderColor: colorPrimaryHover,
        activeBorderColor: colorPrimary,
        activeOutlineColor: controlOutline,
        selectAffixPadding: paddingXXS
      };
    };
    const genBaseOutlinedStyle$1 = (token2, options2) => {
      const {
        componentCls,
        antCls,
        controlOutlineWidth
      } = token2;
      return {
        [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${options2.borderColor}`,
          background: token2.selectorBg
        },
        [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
          [`&:hover ${componentCls}-selector`]: {
            borderColor: options2.hoverBorderHover
          },
          [`${componentCls}-focused& ${componentCls}-selector`]: {
            borderColor: options2.activeBorderColor,
            boxShadow: `0 0 0 ${unit$1(controlOutlineWidth)} ${options2.activeOutlineColor}`,
            outline: 0
          },
          [`${componentCls}-prefix`]: {
            color: options2.color
          }
        }
      };
    };
    const genOutlinedStatusStyle$1 = (token2, options2) => ({
      [`&${token2.componentCls}-status-${options2.status}`]: Object.assign({}, genBaseOutlinedStyle$1(token2, options2))
    });
    const genOutlinedStyle$1 = (token2) => ({
      "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseOutlinedStyle$1(token2, {
        borderColor: token2.colorBorder,
        hoverBorderHover: token2.hoverBorderColor,
        activeBorderColor: token2.activeBorderColor,
        activeOutlineColor: token2.activeOutlineColor,
        color: token2.colorText
      })), genOutlinedStatusStyle$1(token2, {
        status: "error",
        borderColor: token2.colorError,
        hoverBorderHover: token2.colorErrorHover,
        activeBorderColor: token2.colorError,
        activeOutlineColor: token2.colorErrorOutline,
        color: token2.colorError
      })), genOutlinedStatusStyle$1(token2, {
        status: "warning",
        borderColor: token2.colorWarning,
        hoverBorderHover: token2.colorWarningHover,
        activeBorderColor: token2.colorWarning,
        activeOutlineColor: token2.colorWarningOutline,
        color: token2.colorWarning
      })), {
        [`&${token2.componentCls}-disabled`]: {
          [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
            background: token2.colorBgContainerDisabled,
            color: token2.colorTextDisabled
          }
        },
        [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
          background: token2.multipleItemBg,
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
        }
      })
    });
    const genBaseFilledStyle$1 = (token2, options2) => {
      const {
        componentCls,
        antCls
      } = token2;
      return {
        [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
          background: options2.bg,
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
          color: options2.color
        },
        [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
          [`&:hover ${componentCls}-selector`]: {
            background: options2.hoverBg
          },
          [`${componentCls}-focused& ${componentCls}-selector`]: {
            background: token2.selectorBg,
            borderColor: options2.activeBorderColor,
            outline: 0
          }
        }
      };
    };
    const genFilledStatusStyle$1 = (token2, options2) => ({
      [`&${token2.componentCls}-status-${options2.status}`]: Object.assign({}, genBaseFilledStyle$1(token2, options2))
    });
    const genFilledStyle$1 = (token2) => ({
      "&-filled": Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseFilledStyle$1(token2, {
        bg: token2.colorFillTertiary,
        hoverBg: token2.colorFillSecondary,
        activeBorderColor: token2.activeBorderColor,
        color: token2.colorText
      })), genFilledStatusStyle$1(token2, {
        status: "error",
        bg: token2.colorErrorBg,
        hoverBg: token2.colorErrorBgHover,
        activeBorderColor: token2.colorError,
        color: token2.colorError
      })), genFilledStatusStyle$1(token2, {
        status: "warning",
        bg: token2.colorWarningBg,
        hoverBg: token2.colorWarningBgHover,
        activeBorderColor: token2.colorWarning,
        color: token2.colorWarning
      })), {
        [`&${token2.componentCls}-disabled`]: {
          [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
            borderColor: token2.colorBorder,
            background: token2.colorBgContainerDisabled,
            color: token2.colorTextDisabled
          }
        },
        [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
          background: token2.colorBgContainer,
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
        }
      })
    });
    const genBorderlessStyle$1 = (token2) => ({
      "&-borderless": {
        [`${token2.componentCls}-selector`]: {
          background: "transparent",
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`
        },
        [`&${token2.componentCls}-disabled`]: {
          [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
            color: token2.colorTextDisabled
          }
        },
        [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
          background: token2.multipleItemBg,
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
        },
        // Status
        [`&${token2.componentCls}-status-error`]: {
          [`${token2.componentCls}-prefix, ${token2.componentCls}-selection-item`]: {
            color: token2.colorError
          }
        },
        [`&${token2.componentCls}-status-warning`]: {
          [`${token2.componentCls}-prefix, ${token2.componentCls}-selection-item`]: {
            color: token2.colorWarning
          }
        }
      }
    });
    const genBaseUnderlinedStyle$1 = (token2, options2) => {
      const {
        componentCls,
        antCls
      } = token2;
      return {
        [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: {
          borderWidth: `0 0 ${unit$1(token2.lineWidth)} 0`,
          borderStyle: `none none ${token2.lineType} none`,
          borderColor: options2.borderColor,
          background: token2.selectorBg,
          borderRadius: 0
        },
        [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: {
          [`&:hover ${componentCls}-selector`]: {
            borderColor: options2.hoverBorderHover
          },
          [`${componentCls}-focused& ${componentCls}-selector`]: {
            borderColor: options2.activeBorderColor,
            outline: 0
          },
          [`${componentCls}-prefix`]: {
            color: options2.color
          }
        }
      };
    };
    const genUnderlinedStatusStyle$1 = (token2, options2) => ({
      [`&${token2.componentCls}-status-${options2.status}`]: Object.assign({}, genBaseUnderlinedStyle$1(token2, options2))
    });
    const genUnderlinedStyle$1 = (token2) => ({
      "&-underlined": Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseUnderlinedStyle$1(token2, {
        borderColor: token2.colorBorder,
        hoverBorderHover: token2.hoverBorderColor,
        activeBorderColor: token2.activeBorderColor,
        activeOutlineColor: token2.activeOutlineColor,
        color: token2.colorText
      })), genUnderlinedStatusStyle$1(token2, {
        status: "error",
        borderColor: token2.colorError,
        hoverBorderHover: token2.colorErrorHover,
        activeBorderColor: token2.colorError,
        activeOutlineColor: token2.colorErrorOutline,
        color: token2.colorError
      })), genUnderlinedStatusStyle$1(token2, {
        status: "warning",
        borderColor: token2.colorWarning,
        hoverBorderHover: token2.colorWarningHover,
        activeBorderColor: token2.colorWarning,
        activeOutlineColor: token2.colorWarningOutline,
        color: token2.colorWarning
      })), {
        [`&${token2.componentCls}-disabled`]: {
          [`&:not(${token2.componentCls}-customize-input) ${token2.componentCls}-selector`]: {
            color: token2.colorTextDisabled
          }
        },
        [`&${token2.componentCls}-multiple ${token2.componentCls}-selection-item`]: {
          background: token2.multipleItemBg,
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
        }
      })
    });
    const genVariantsStyle$1 = (token2) => ({
      [token2.componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, genOutlinedStyle$1(token2)), genFilledStyle$1(token2)), genBorderlessStyle$1(token2)), genUnderlinedStyle$1(token2))
    });
    const genSelectorStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        position: "relative",
        transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
        input: {
          cursor: "pointer"
        },
        [`${componentCls}-show-search&`]: {
          cursor: "text",
          input: {
            cursor: "auto",
            color: "inherit",
            height: "100%"
          }
        },
        [`${componentCls}-disabled&`]: {
          cursor: "not-allowed",
          input: {
            cursor: "not-allowed"
          }
        }
      };
    };
    const getSearchInputWithoutBorderStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-selection-search-input`]: {
          margin: 0,
          padding: 0,
          background: "transparent",
          border: "none",
          outline: "none",
          appearance: "none",
          fontFamily: "inherit",
          "&::-webkit-search-cancel-button": {
            display: "none",
            appearance: "none"
          }
        }
      };
    };
    const genBaseStyle$2 = (token2) => {
      const {
        antCls,
        componentCls,
        inputPaddingHorizontalBase,
        iconCls
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "relative",
          display: "inline-flex",
          cursor: "pointer",
          [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: Object.assign(Object.assign({}, genSelectorStyle(token2)), getSearchInputWithoutBorderStyle(token2)),
          // ======================== Selection ========================
          [`${componentCls}-selection-item`]: Object.assign(Object.assign({
            flex: 1,
            fontWeight: "normal",
            position: "relative",
            userSelect: "none"
          }, textEllipsis), {
            // https://github.com/ant-design/ant-design/issues/40421
            [`> ${antCls}-typography`]: {
              display: "inline"
            }
          }),
          // ======================= Placeholder =======================
          [`${componentCls}-selection-placeholder`]: Object.assign(Object.assign({}, textEllipsis), {
            flex: 1,
            color: token2.colorTextPlaceholder,
            pointerEvents: "none"
          }),
          // ========================== Arrow ==========================
          [`${componentCls}-arrow`]: Object.assign(Object.assign({}, resetIcon()), {
            position: "absolute",
            top: "50%",
            insetInlineStart: "auto",
            insetInlineEnd: inputPaddingHorizontalBase,
            height: token2.fontSizeIcon,
            marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
            color: token2.colorTextQuaternary,
            fontSize: token2.fontSizeIcon,
            lineHeight: 1,
            textAlign: "center",
            pointerEvents: "none",
            display: "flex",
            alignItems: "center",
            transition: `opacity ${token2.motionDurationSlow} ease`,
            [iconCls]: {
              verticalAlign: "top",
              transition: `transform ${token2.motionDurationSlow}`,
              "> svg": {
                verticalAlign: "top"
              },
              [`&:not(${componentCls}-suffix)`]: {
                pointerEvents: "auto"
              }
            },
            [`${componentCls}-disabled &`]: {
              cursor: "not-allowed"
            },
            "> *:not(:last-child)": {
              marginInlineEnd: 8
              // FIXME: magic
            }
          }),
          // ========================== Wrap ===========================
          [`${componentCls}-selection-wrap`]: {
            display: "flex",
            width: "100%",
            position: "relative",
            minWidth: 0,
            // https://github.com/ant-design/ant-design/issues/51669
            "&:after": {
              content: '"\\a0"',
              width: 0,
              overflow: "hidden"
            }
          },
          // ========================= Prefix ==========================
          [`${componentCls}-prefix`]: {
            flex: "none",
            marginInlineEnd: token2.selectAffixPadding
          },
          // ========================== Clear ==========================
          [`${componentCls}-clear`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: "auto",
            insetInlineEnd: inputPaddingHorizontalBase,
            zIndex: 1,
            display: "inline-block",
            width: token2.fontSizeIcon,
            height: token2.fontSizeIcon,
            marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
            color: token2.colorTextQuaternary,
            fontSize: token2.fontSizeIcon,
            fontStyle: "normal",
            lineHeight: 1,
            textAlign: "center",
            textTransform: "none",
            cursor: "pointer",
            opacity: 0,
            transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
            textRendering: "auto",
            "&:before": {
              display: "block"
            },
            "&:hover": {
              color: token2.colorTextTertiary
            }
          },
          [`&:hover ${componentCls}-clear`]: {
            opacity: 1,
            background: token2.colorBgBase,
            borderRadius: "50%"
          }
        }),
        // ========================= Feedback ==========================
        [`${componentCls}-status`]: {
          "&-error, &-warning, &-success, &-validating": {
            [`&${componentCls}-has-feedback`]: {
              [`${componentCls}-clear`]: {
                insetInlineEnd: token2.calc(inputPaddingHorizontalBase).add(token2.fontSize).add(token2.paddingXS).equal()
              }
            }
          }
        }
      };
    };
    const genSelectStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return [
        {
          [componentCls]: {
            // ==================== In Form ====================
            [`&${componentCls}-in-form-item`]: {
              width: "100%"
            }
          }
        },
        // =====================================================
        // ==                       LTR                       ==
        // =====================================================
        // Base
        genBaseStyle$2(token2),
        // Single
        genSingleStyle(token2),
        // Multiple
        genMultipleStyle(token2),
        // Dropdown
        genSingleStyle$1(token2),
        // =====================================================
        // ==                       RTL                       ==
        // =====================================================
        {
          [`${componentCls}-rtl`]: {
            direction: "rtl"
          }
        },
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        genCompactItemStyle(token2, {
          borderElCls: `${componentCls}-selector`,
          focusElCls: `${componentCls}-focused`
        })
      ];
    };
    const useSelectStyle = genStyleHooks("Select", (token2, _ref) => {
      let {
        rootPrefixCls
      } = _ref;
      const selectToken = merge(token2, {
        rootPrefixCls,
        inputPaddingHorizontalBase: token2.calc(token2.paddingSM).sub(1).equal(),
        multipleSelectItemHeight: token2.multipleItemHeight,
        selectHeight: token2.controlHeight
      });
      return [genSelectStyle(selectToken), genVariantsStyle$1(selectToken)];
    }, prepareComponentToken$h, {
      unitless: {
        optionLineHeight: true,
        optionSelectedFontWeight: true
      }
    });
    var CheckOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
    var CheckOutlined = function CheckOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: CheckOutlined$1
      }));
    };
    var RefIcon$v = /* @__PURE__ */ reactExports.forwardRef(CheckOutlined);
    var DownOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
    var DownOutlined = function DownOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: DownOutlined$1
      }));
    };
    var RefIcon$u = /* @__PURE__ */ reactExports.forwardRef(DownOutlined);
    var SearchOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
    var SearchOutlined = function SearchOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: SearchOutlined$1
      }));
    };
    var RefIcon$t = /* @__PURE__ */ reactExports.forwardRef(SearchOutlined);
    function useIcons$1(_ref) {
      let {
        suffixIcon,
        clearIcon,
        menuItemSelectedIcon,
        removeIcon,
        loading,
        multiple,
        hasFeedback,
        prefixCls,
        showSuffixIcon,
        feedbackIcon,
        showArrow,
        componentName
      } = _ref;
      const mergedClearIcon = clearIcon !== null && clearIcon !== void 0 ? clearIcon : /* @__PURE__ */ reactExports.createElement(RefIcon$B, null);
      const getSuffixIconNode = (arrowIcon) => {
        if (suffixIcon === null && !hasFeedback && !showArrow) {
          return null;
        }
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, showSuffixIcon !== false && arrowIcon, hasFeedback && feedbackIcon);
      };
      let mergedSuffixIcon = null;
      if (suffixIcon !== void 0) {
        mergedSuffixIcon = getSuffixIconNode(suffixIcon);
      } else if (loading) {
        mergedSuffixIcon = getSuffixIconNode(/* @__PURE__ */ reactExports.createElement(RefIcon$x, {
          spin: true
        }));
      } else {
        const iconCls = `${prefixCls}-suffix`;
        mergedSuffixIcon = (_ref2) => {
          let {
            open: open2,
            showSearch
          } = _ref2;
          if (open2 && showSearch) {
            return getSuffixIconNode(/* @__PURE__ */ reactExports.createElement(RefIcon$t, {
              className: iconCls
            }));
          }
          return getSuffixIconNode(/* @__PURE__ */ reactExports.createElement(RefIcon$u, {
            className: iconCls
          }));
        };
      }
      let mergedItemIcon = null;
      if (menuItemSelectedIcon !== void 0) {
        mergedItemIcon = menuItemSelectedIcon;
      } else if (multiple) {
        mergedItemIcon = /* @__PURE__ */ reactExports.createElement(RefIcon$v, null);
      } else {
        mergedItemIcon = null;
      }
      let mergedRemoveIcon = null;
      if (removeIcon !== void 0) {
        mergedRemoveIcon = removeIcon;
      } else {
        mergedRemoveIcon = /* @__PURE__ */ reactExports.createElement(RefIcon$A, null);
      }
      return {
        clearIcon: mergedClearIcon,
        suffixIcon: mergedSuffixIcon,
        itemIcon: mergedItemIcon,
        removeIcon: mergedRemoveIcon
      };
    }
    function useShowArrow(suffixIcon, showArrow) {
      return showArrow !== void 0 ? showArrow : suffixIcon !== null;
    }
    var __rest$J = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
    const InternalSelect = (props, ref) => {
      var _a;
      const {
        prefixCls: customizePrefixCls,
        bordered,
        className,
        rootClassName,
        getPopupContainer,
        popupClassName,
        dropdownClassName,
        listHeight = 256,
        placement,
        listItemHeight: customListItemHeight,
        size: customizeSize,
        disabled: customDisabled,
        notFoundContent,
        status: customStatus,
        builtinPlacements,
        dropdownMatchSelectWidth,
        popupMatchSelectWidth,
        direction: propDirection,
        style: style2,
        allowClear,
        variant: customizeVariant,
        dropdownStyle,
        transitionName,
        tagRender,
        maxCount,
        prefix: prefix2
      } = props, rest = __rest$J(props, ["prefixCls", "bordered", "className", "rootClassName", "getPopupContainer", "popupClassName", "dropdownClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "builtinPlacements", "dropdownMatchSelectWidth", "popupMatchSelectWidth", "direction", "style", "allowClear", "variant", "dropdownStyle", "transitionName", "tagRender", "maxCount", "prefix"]);
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        renderEmpty,
        direction: contextDirection,
        virtual,
        popupMatchSelectWidth: contextPopupMatchSelectWidth,
        popupOverflow
      } = reactExports.useContext(ConfigContext);
      const contextSelect = useComponentConfig("select");
      const [, token2] = useToken();
      const listItemHeight = customListItemHeight !== null && customListItemHeight !== void 0 ? customListItemHeight : token2 === null || token2 === void 0 ? void 0 : token2.controlHeight;
      const prefixCls = getPrefixCls("select", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const direction = propDirection !== null && propDirection !== void 0 ? propDirection : contextDirection;
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const [variant, enableVariantCls] = useVariant("select", customizeVariant, bordered);
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useSelectStyle(prefixCls, rootCls);
      const mode = reactExports.useMemo(() => {
        const {
          mode: m2
        } = props;
        if (m2 === "combobox") {
          return void 0;
        }
        if (m2 === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
          return "combobox";
        }
        return m2;
      }, [props.mode]);
      const isMultiple2 = mode === "multiple" || mode === "tags";
      const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
      const mergedPopupMatchSelectWidth = (_a = popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth) !== null && _a !== void 0 ? _a : contextPopupMatchSelectWidth;
      const {
        status: contextStatus,
        hasFeedback,
        isFormItemInput,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      let mergedNotFound;
      if (notFoundContent !== void 0) {
        mergedNotFound = notFoundContent;
      } else if (mode === "combobox") {
        mergedNotFound = null;
      } else {
        mergedNotFound = (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Select")) || /* @__PURE__ */ reactExports.createElement(DefaultRenderEmpty, {
          componentName: "Select"
        });
      }
      const {
        suffixIcon,
        itemIcon,
        removeIcon,
        clearIcon
      } = useIcons$1(Object.assign(Object.assign({}, rest), {
        multiple: isMultiple2,
        hasFeedback,
        feedbackIcon,
        showSuffixIcon,
        prefixCls,
        componentName: "Select"
      }));
      const mergedAllowClear = allowClear === true ? {
        clearIcon
      } : allowClear;
      const selectProps = omit(rest, ["suffixIcon", "itemIcon"]);
      const mergedPopupClassName = classNames(popupClassName || dropdownClassName, {
        [`${prefixCls}-dropdown-${direction}`]: direction === "rtl"
      }, rootClassName, cssVarCls, rootCls, hashId);
      const mergedSize = useSize((ctx) => {
        var _a2;
        return (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
      });
      const disabled = reactExports.useContext(DisabledContext);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const mergedClassName = classNames({
        [`${prefixCls}-lg`]: mergedSize === "large",
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-${variant}`]: enableVariantCls,
        [`${prefixCls}-in-form-item`]: isFormItemInput
      }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, contextSelect.className, className, rootClassName, cssVarCls, rootCls, hashId);
      const memoPlacement = reactExports.useMemo(() => {
        if (placement !== void 0) {
          return placement;
        }
        return direction === "rtl" ? "bottomRight" : "bottomLeft";
      }, [placement, direction]);
      const [zIndex] = useZIndex("SelectLike", dropdownStyle === null || dropdownStyle === void 0 ? void 0 : dropdownStyle.zIndex);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(TypedSelect, Object.assign({
        ref,
        virtual,
        showSearch: contextSelect.showSearch
      }, selectProps, {
        style: Object.assign(Object.assign({}, contextSelect.style), style2),
        dropdownMatchSelectWidth: mergedPopupMatchSelectWidth,
        transitionName: getTransitionName(rootPrefixCls, "slide-up", transitionName),
        builtinPlacements: mergedBuiltinPlacements(builtinPlacements, popupOverflow),
        listHeight,
        listItemHeight,
        mode,
        prefixCls,
        placement: memoPlacement,
        direction,
        prefix: prefix2,
        suffixIcon,
        menuItemSelectedIcon: itemIcon,
        removeIcon,
        allowClear: mergedAllowClear,
        notFoundContent: mergedNotFound,
        className: mergedClassName,
        getPopupContainer: getPopupContainer || getContextPopupContainer,
        dropdownClassName: mergedPopupClassName,
        disabled: mergedDisabled,
        dropdownStyle: Object.assign(Object.assign({}, dropdownStyle), {
          zIndex
        }),
        maxCount: isMultiple2 ? maxCount : void 0,
        tagRender: isMultiple2 ? tagRender : void 0
      })));
    };
    const Select$1 = /* @__PURE__ */ reactExports.forwardRef(InternalSelect);
    const PurePanel$5 = genPurePanel(Select$1, "dropdownAlign");
    Select$1.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
    Select$1.Option = Option;
    Select$1.OptGroup = OptGroup;
    Select$1._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$5;
    const responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
    const getResponsiveMap = (token2) => ({
      xs: `(max-width: ${token2.screenXSMax}px)`,
      sm: `(min-width: ${token2.screenSM}px)`,
      md: `(min-width: ${token2.screenMD}px)`,
      lg: `(min-width: ${token2.screenLG}px)`,
      xl: `(min-width: ${token2.screenXL}px)`,
      xxl: `(min-width: ${token2.screenXXL}px)`
    });
    const validateBreakpoints = (token2) => {
      const indexableToken = token2;
      const revBreakpoints = [].concat(responsiveArray).reverse();
      revBreakpoints.forEach((breakpoint, i2) => {
        const breakpointUpper = breakpoint.toUpperCase();
        const screenMin = `screen${breakpointUpper}Min`;
        const screen = `screen${breakpointUpper}`;
        if (!(indexableToken[screenMin] <= indexableToken[screen])) {
          throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
        }
        if (i2 < revBreakpoints.length - 1) {
          const screenMax = `screen${breakpointUpper}Max`;
          if (!(indexableToken[screen] <= indexableToken[screenMax])) {
            throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
          }
          const nextBreakpointUpperMin = revBreakpoints[i2 + 1].toUpperCase();
          const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;
          if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {
            throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
          }
        }
      });
      return token2;
    };
    function useResponsiveObserver() {
      const [, token2] = useToken();
      const responsiveMap = getResponsiveMap(validateBreakpoints(token2));
      return i.useMemo(() => {
        const subscribers = /* @__PURE__ */ new Map();
        let subUid = -1;
        let screens = {};
        return {
          responsiveMap,
          matchHandlers: {},
          dispatch(pointMap) {
            screens = pointMap;
            subscribers.forEach((func) => func(screens));
            return subscribers.size >= 1;
          },
          subscribe(func) {
            if (!subscribers.size) {
              this.register();
            }
            subUid += 1;
            subscribers.set(subUid, func);
            func(screens);
            return subUid;
          },
          unsubscribe(paramToken) {
            subscribers.delete(paramToken);
            if (!subscribers.size) {
              this.unregister();
            }
          },
          register() {
            Object.keys(responsiveMap).forEach((screen) => {
              const matchMediaQuery = responsiveMap[screen];
              const listener = (_ref) => {
                let {
                  matches
                } = _ref;
                this.dispatch(Object.assign(Object.assign({}, screens), {
                  [screen]: matches
                }));
              };
              const mql = window.matchMedia(matchMediaQuery);
              mql.addListener(listener);
              this.matchHandlers[matchMediaQuery] = {
                mql,
                listener
              };
              listener(mql);
            });
          },
          unregister() {
            Object.keys(responsiveMap).forEach((screen) => {
              const matchMediaQuery = responsiveMap[screen];
              const handler = this.matchHandlers[matchMediaQuery];
              handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);
            });
            subscribers.clear();
          }
        };
      }, [token2]);
    }
    function useForceUpdate() {
      const [, forceUpdate] = reactExports.useReducer((x2) => x2 + 1, 0);
      return forceUpdate;
    }
    function useBreakpoint() {
      let refreshOnChange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      let defaultScreens = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const screensRef = reactExports.useRef(defaultScreens);
      const forceUpdate = useForceUpdate();
      const responsiveObserver = useResponsiveObserver();
      useLayoutEffect$1(() => {
        const token2 = responsiveObserver.subscribe((supportScreens) => {
          screensRef.current = supportScreens;
          if (refreshOnChange) {
            forceUpdate();
          }
        });
        return () => responsiveObserver.unsubscribe(token2);
      }, []);
      return screensRef.current;
    }
    function Popup$1(props) {
      var children = props.children, prefixCls = props.prefixCls, id = props.id, innerStyle = props.overlayInnerStyle, bodyClassName = props.bodyClassName, className = props.className, style2 = props.style;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-content"), className),
        style: style2
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-inner"), bodyClassName),
        id,
        role: "tooltip",
        style: innerStyle
      }, typeof children === "function" ? children() : children));
    }
    var autoAdjustOverflowTopBottom = {
      shiftX: 64,
      adjustY: 1
    };
    var autoAdjustOverflowLeftRight = {
      adjustX: 1,
      shiftY: true
    };
    var targetOffset$1 = [0, 0];
    var placements$2 = {
      left: {
        points: ["cr", "cl"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [-4, 0],
        targetOffset: targetOffset$1
      },
      right: {
        points: ["cl", "cr"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [4, 0],
        targetOffset: targetOffset$1
      },
      top: {
        points: ["bc", "tc"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, -4],
        targetOffset: targetOffset$1
      },
      bottom: {
        points: ["tc", "bc"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, 4],
        targetOffset: targetOffset$1
      },
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, -4],
        targetOffset: targetOffset$1
      },
      leftTop: {
        points: ["tr", "tl"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [-4, 0],
        targetOffset: targetOffset$1
      },
      topRight: {
        points: ["br", "tr"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, -4],
        targetOffset: targetOffset$1
      },
      rightTop: {
        points: ["tl", "tr"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [4, 0],
        targetOffset: targetOffset$1
      },
      bottomRight: {
        points: ["tr", "br"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, 4],
        targetOffset: targetOffset$1
      },
      rightBottom: {
        points: ["bl", "br"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [4, 0],
        targetOffset: targetOffset$1
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, 4],
        targetOffset: targetOffset$1
      },
      leftBottom: {
        points: ["br", "bl"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [-4, 0],
        targetOffset: targetOffset$1
      }
    };
    var _excluded$q = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow", "classNames", "styles"];
    var Tooltip$1 = function Tooltip2(props, ref) {
      var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion2 = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle;
      props.arrowContent;
      var overlay = props.overlay, id = props.id, _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? true : _props$showArrow, tooltipClassNames = props.classNames, tooltipStyles = props.styles, restProps = _objectWithoutProperties(props, _excluded$q);
      var mergedId = useId$1(id);
      var triggerRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, function() {
        return triggerRef.current;
      });
      var extraProps = _objectSpread2$3({}, restProps);
      if ("visible" in props) {
        extraProps.popupVisible = props.visible;
      }
      var getPopupElement = function getPopupElement2() {
        return /* @__PURE__ */ reactExports.createElement(Popup$1, {
          key: "content",
          prefixCls,
          id: mergedId,
          bodyClassName: tooltipClassNames === null || tooltipClassNames === void 0 ? void 0 : tooltipClassNames.body,
          overlayInnerStyle: _objectSpread2$3(_objectSpread2$3({}, overlayInnerStyle), tooltipStyles === null || tooltipStyles === void 0 ? void 0 : tooltipStyles.body)
        }, overlay);
      };
      var getChildren = function getChildren2() {
        var child = reactExports.Children.only(children);
        var originalProps = (child === null || child === void 0 ? void 0 : child.props) || {};
        var childProps = _objectSpread2$3(_objectSpread2$3({}, originalProps), {}, {
          "aria-describedby": overlay ? mergedId : null
        });
        return /* @__PURE__ */ reactExports.cloneElement(children, childProps);
      };
      return /* @__PURE__ */ reactExports.createElement(Trigger, _extends$2({
        popupClassName: classNames(overlayClassName, tooltipClassNames === null || tooltipClassNames === void 0 ? void 0 : tooltipClassNames.root),
        prefixCls,
        popup: getPopupElement,
        action: trigger,
        builtinPlacements: placements$2,
        popupPlacement: placement,
        ref: triggerRef,
        popupAlign: align,
        getPopupContainer: getTooltipContainer,
        onPopupVisibleChange: onVisibleChange,
        afterPopupVisibleChange: afterVisibleChange,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        popupMotion: motion2,
        defaultPopupVisible: defaultVisible,
        autoDestroy: destroyTooltipOnHide,
        mouseLeaveDelay,
        popupStyle: _objectSpread2$3(_objectSpread2$3({}, overlayStyle), tooltipStyles === null || tooltipStyles === void 0 ? void 0 : tooltipStyles.root),
        mouseEnterDelay,
        arrow: showArrow
      }, extraProps), getChildren());
    };
    const Tooltip$2 = /* @__PURE__ */ reactExports.forwardRef(Tooltip$1);
    function getArrowToken(token2) {
      const {
        sizePopupArrow,
        borderRadiusXS,
        borderRadiusOuter
      } = token2;
      const unitWidth = sizePopupArrow / 2;
      const ax = 0;
      const ay = unitWidth;
      const bx = borderRadiusOuter * 1 / Math.sqrt(2);
      const by = unitWidth - borderRadiusOuter * (1 - 1 / Math.sqrt(2));
      const cx = unitWidth - borderRadiusXS * (1 / Math.sqrt(2));
      const cy = borderRadiusOuter * (Math.sqrt(2) - 1) + borderRadiusXS * (1 / Math.sqrt(2));
      const dx = 2 * unitWidth - cx;
      const dy = cy;
      const ex = 2 * unitWidth - bx;
      const ey = by;
      const fx = 2 * unitWidth - ax;
      const fy = ay;
      const shadowWidth = unitWidth * Math.sqrt(2) + borderRadiusOuter * (Math.sqrt(2) - 2);
      const polygonOffset = borderRadiusOuter * (Math.sqrt(2) - 1);
      const arrowPolygon = `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`;
      const arrowPath = `path('M ${ax} ${ay} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${borderRadiusXS} ${borderRadiusXS} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${fx} ${fy} Z')`;
      return {
        arrowShadowWidth: shadowWidth,
        arrowPath,
        arrowPolygon
      };
    }
    const genRoundedArrow = (token2, bgColor, boxShadow) => {
      const {
        sizePopupArrow,
        arrowPolygon,
        arrowPath,
        arrowShadowWidth,
        borderRadiusXS,
        calc
      } = token2;
      return {
        pointerEvents: "none",
        width: sizePopupArrow,
        height: sizePopupArrow,
        overflow: "hidden",
        "&::before": {
          position: "absolute",
          bottom: 0,
          insetInlineStart: 0,
          width: sizePopupArrow,
          height: calc(sizePopupArrow).div(2).equal(),
          background: bgColor,
          clipPath: {
            _multi_value_: true,
            value: [arrowPolygon, arrowPath]
          },
          content: '""'
        },
        "&::after": {
          content: '""',
          position: "absolute",
          width: arrowShadowWidth,
          height: arrowShadowWidth,
          bottom: 0,
          insetInline: 0,
          margin: "auto",
          borderRadius: {
            _skip_check_: true,
            value: `0 0 ${unit$1(borderRadiusXS)} 0`
          },
          transform: "translateY(50%) rotate(-135deg)",
          boxShadow,
          zIndex: 0,
          background: "transparent"
        }
      };
    };
    const MAX_VERTICAL_CONTENT_RADIUS = 8;
    function getArrowOffsetToken(options2) {
      const {
        contentRadius,
        limitVerticalRadius
      } = options2;
      const arrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
      const arrowOffsetVertical = limitVerticalRadius ? MAX_VERTICAL_CONTENT_RADIUS : arrowOffset;
      return {
        arrowOffsetHorizontal: arrowOffset,
        arrowOffsetVertical
      };
    }
    function isInject(valid, code) {
      if (!valid) {
        return {};
      }
      return code;
    }
    function getArrowStyle(token2, colorBg, options2) {
      const {
        componentCls,
        boxShadowPopoverArrow,
        arrowOffsetVertical,
        arrowOffsetHorizontal
      } = token2;
      const {
        arrowDistance = 0,
        arrowPlacement = {
          left: true,
          right: true,
          top: true,
          bottom: true
        }
      } = {};
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
          // ============================ Basic ============================
          [`${componentCls}-arrow`]: [Object.assign(Object.assign({
            position: "absolute",
            zIndex: 1,
            display: "block"
          }, genRoundedArrow(token2, colorBg, boxShadowPopoverArrow)), {
            "&:before": {
              background: colorBg
            }
          })]
        }, isInject(!!arrowPlacement.top, {
          [[`&-placement-top > ${componentCls}-arrow`, `&-placement-topLeft > ${componentCls}-arrow`, `&-placement-topRight > ${componentCls}-arrow`].join(",")]: {
            bottom: arrowDistance,
            transform: "translateY(100%) rotate(180deg)"
          },
          [`&-placement-top > ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateX(-50%) translateY(100%) rotate(180deg)"
          },
          "&-placement-topLeft": {
            "--arrow-offset-horizontal": arrowOffsetHorizontal,
            [`> ${componentCls}-arrow`]: {
              left: {
                _skip_check_: true,
                value: arrowOffsetHorizontal
              }
            }
          },
          "&-placement-topRight": {
            "--arrow-offset-horizontal": `calc(100% - ${unit$1(arrowOffsetHorizontal)})`,
            [`> ${componentCls}-arrow`]: {
              right: {
                _skip_check_: true,
                value: arrowOffsetHorizontal
              }
            }
          }
        })), isInject(!!arrowPlacement.bottom, {
          [[`&-placement-bottom > ${componentCls}-arrow`, `&-placement-bottomLeft > ${componentCls}-arrow`, `&-placement-bottomRight > ${componentCls}-arrow`].join(",")]: {
            top: arrowDistance,
            transform: `translateY(-100%)`
          },
          [`&-placement-bottom > ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: `translateX(-50%) translateY(-100%)`
          },
          "&-placement-bottomLeft": {
            "--arrow-offset-horizontal": arrowOffsetHorizontal,
            [`> ${componentCls}-arrow`]: {
              left: {
                _skip_check_: true,
                value: arrowOffsetHorizontal
              }
            }
          },
          "&-placement-bottomRight": {
            "--arrow-offset-horizontal": `calc(100% - ${unit$1(arrowOffsetHorizontal)})`,
            [`> ${componentCls}-arrow`]: {
              right: {
                _skip_check_: true,
                value: arrowOffsetHorizontal
              }
            }
          }
        })), isInject(!!arrowPlacement.left, {
          [[`&-placement-left > ${componentCls}-arrow`, `&-placement-leftTop > ${componentCls}-arrow`, `&-placement-leftBottom > ${componentCls}-arrow`].join(",")]: {
            right: {
              _skip_check_: true,
              value: arrowDistance
            },
            transform: "translateX(100%) rotate(90deg)"
          },
          [`&-placement-left > ${componentCls}-arrow`]: {
            top: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateY(-50%) translateX(100%) rotate(90deg)"
          },
          [`&-placement-leftTop > ${componentCls}-arrow`]: {
            top: arrowOffsetVertical
          },
          [`&-placement-leftBottom > ${componentCls}-arrow`]: {
            bottom: arrowOffsetVertical
          }
        })), isInject(!!arrowPlacement.right, {
          [[`&-placement-right > ${componentCls}-arrow`, `&-placement-rightTop > ${componentCls}-arrow`, `&-placement-rightBottom > ${componentCls}-arrow`].join(",")]: {
            left: {
              _skip_check_: true,
              value: arrowDistance
            },
            transform: "translateX(-100%) rotate(-90deg)"
          },
          [`&-placement-right > ${componentCls}-arrow`]: {
            top: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
          },
          [`&-placement-rightTop > ${componentCls}-arrow`]: {
            top: arrowOffsetVertical
          },
          [`&-placement-rightBottom > ${componentCls}-arrow`]: {
            bottom: arrowOffsetVertical
          }
        }))
      };
    }
    function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow2) {
      if (autoAdjustOverflow2 === false) {
        return {
          adjustX: false,
          adjustY: false
        };
      }
      const overflow = autoAdjustOverflow2 && typeof autoAdjustOverflow2 === "object" ? autoAdjustOverflow2 : {};
      const baseOverflow = {};
      switch (placement) {
        case "top":
        case "bottom":
          baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth;
          baseOverflow.shiftY = true;
          baseOverflow.adjustY = true;
          break;
        case "left":
        case "right":
          baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth;
          baseOverflow.shiftX = true;
          baseOverflow.adjustX = true;
          break;
      }
      const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
      if (!mergedOverflow.shiftX) {
        mergedOverflow.adjustX = true;
      }
      if (!mergedOverflow.shiftY) {
        mergedOverflow.adjustY = true;
      }
      return mergedOverflow;
    }
    const PlacementAlignMap = {
      left: {
        points: ["cr", "cl"]
      },
      right: {
        points: ["cl", "cr"]
      },
      top: {
        points: ["bc", "tc"]
      },
      bottom: {
        points: ["tc", "bc"]
      },
      topLeft: {
        points: ["bl", "tl"]
      },
      leftTop: {
        points: ["tr", "tl"]
      },
      topRight: {
        points: ["br", "tr"]
      },
      rightTop: {
        points: ["tl", "tr"]
      },
      bottomRight: {
        points: ["tr", "br"]
      },
      rightBottom: {
        points: ["bl", "br"]
      },
      bottomLeft: {
        points: ["tl", "bl"]
      },
      leftBottom: {
        points: ["br", "bl"]
      }
    };
    const ArrowCenterPlacementAlignMap = {
      topLeft: {
        points: ["bl", "tc"]
      },
      leftTop: {
        points: ["tr", "cl"]
      },
      topRight: {
        points: ["br", "tc"]
      },
      rightTop: {
        points: ["tl", "cr"]
      },
      bottomRight: {
        points: ["tr", "bc"]
      },
      rightBottom: {
        points: ["bl", "cr"]
      },
      bottomLeft: {
        points: ["tl", "bc"]
      },
      leftBottom: {
        points: ["br", "cl"]
      }
    };
    const DisableAutoArrowList = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
    function getPlacements(config) {
      const {
        arrowWidth,
        autoAdjustOverflow: autoAdjustOverflow2,
        arrowPointAtCenter,
        offset: offset2,
        borderRadius
      } = config;
      const halfArrowWidth = arrowWidth / 2;
      const placementMap = {};
      Object.keys(PlacementAlignMap).forEach((key) => {
        const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
        const placementInfo = Object.assign(Object.assign({}, template), {
          offset: [0, 0],
          dynamicInset: true
        });
        placementMap[key] = placementInfo;
        if (DisableAutoArrowList.has(key)) {
          placementInfo.autoArrow = false;
        }
        switch (key) {
          case "top":
          case "topLeft":
          case "topRight":
            placementInfo.offset[1] = -halfArrowWidth - offset2;
            break;
          case "bottom":
          case "bottomLeft":
          case "bottomRight":
            placementInfo.offset[1] = halfArrowWidth + offset2;
            break;
          case "left":
          case "leftTop":
          case "leftBottom":
            placementInfo.offset[0] = -halfArrowWidth - offset2;
            break;
          case "right":
          case "rightTop":
          case "rightBottom":
            placementInfo.offset[0] = halfArrowWidth + offset2;
            break;
        }
        const arrowOffset = getArrowOffsetToken({
          contentRadius: borderRadius,
          limitVerticalRadius: true
        });
        if (arrowPointAtCenter) {
          switch (key) {
            case "topLeft":
            case "bottomLeft":
              placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
              break;
            case "topRight":
            case "bottomRight":
              placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
              break;
            case "leftTop":
            case "rightTop":
              placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal * 2 + halfArrowWidth;
              break;
            case "leftBottom":
            case "rightBottom":
              placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal * 2 - halfArrowWidth;
              break;
          }
        }
        placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow2);
        {
          placementInfo.htmlRegion = "visibleFirst";
        }
      });
      return placementMap;
    }
    const genTooltipStyle = (token2) => {
      const {
        calc,
        componentCls,
        // ant-tooltip
        tooltipMaxWidth,
        tooltipColor,
        tooltipBg,
        tooltipBorderRadius,
        zIndexPopup,
        controlHeight,
        boxShadowSecondary,
        paddingSM,
        paddingXS,
        arrowOffsetHorizontal,
        sizePopupArrow
      } = token2;
      const edgeAlignMinWidth = calc(tooltipBorderRadius).add(sizePopupArrow).add(arrowOffsetHorizontal).equal();
      const centerAlignMinWidth = calc(tooltipBorderRadius).mul(2).add(sizePopupArrow).equal();
      return [
        {
          [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
            position: "absolute",
            zIndex: zIndexPopup,
            display: "block",
            width: "max-content",
            maxWidth: tooltipMaxWidth,
            visibility: "visible",
            // When use `autoArrow`, origin will follow the arrow position
            "--valid-offset-x": "var(--arrow-offset-horizontal, var(--arrow-x))",
            transformOrigin: [`var(--valid-offset-x, 50%)`, `var(--arrow-y, 50%)`].join(" "),
            "&-hidden": {
              display: "none"
            },
            "--antd-arrow-background-color": tooltipBg,
            // Wrapper for the tooltip content
            [`${componentCls}-inner`]: {
              minWidth: centerAlignMinWidth,
              minHeight: controlHeight,
              padding: `${unit$1(token2.calc(paddingSM).div(2).equal())} ${unit$1(paddingXS)}`,
              color: tooltipColor,
              textAlign: "start",
              textDecoration: "none",
              wordWrap: "break-word",
              backgroundColor: tooltipBg,
              borderRadius: tooltipBorderRadius,
              boxShadow: boxShadowSecondary,
              boxSizing: "border-box"
            },
            // Align placement should have another min width
            [[`&-placement-topLeft`, `&-placement-topRight`, `&-placement-bottomLeft`, `&-placement-bottomRight`].join(",")]: {
              minWidth: edgeAlignMinWidth
            },
            // Limit left and right placement radius
            [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
              [`${componentCls}-inner`]: {
                borderRadius: token2.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
              }
            },
            [`${componentCls}-content`]: {
              position: "relative"
            }
          }), genPresetColor(token2, (colorKey, _ref) => {
            let {
              darkColor
            } = _ref;
            return {
              [`&${componentCls}-${colorKey}`]: {
                [`${componentCls}-inner`]: {
                  backgroundColor: darkColor
                },
                [`${componentCls}-arrow`]: {
                  "--antd-arrow-background-color": darkColor
                }
              }
            };
          })), {
            // RTL
            "&-rtl": {
              direction: "rtl"
            }
          })
        },
        // Arrow Style
        getArrowStyle(token2, "var(--antd-arrow-background-color)"),
        // Pure Render
        {
          [`${componentCls}-pure`]: {
            position: "relative",
            maxWidth: "none",
            margin: token2.sizePopupArrow
          }
        }
      ];
    };
    const prepareComponentToken$g = (token2) => Object.assign(Object.assign({
      zIndexPopup: token2.zIndexPopupBase + 70
    }, getArrowOffsetToken({
      contentRadius: token2.borderRadius,
      limitVerticalRadius: true
    })), getArrowToken(merge(token2, {
      borderRadiusOuter: Math.min(token2.borderRadiusOuter, 4)
    })));
    const useStyle$k = function(prefixCls) {
      let injectStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      const useStyle2 = genStyleHooks("Tooltip", (token2) => {
        const {
          borderRadius,
          colorTextLightSolid,
          colorBgSpotlight
        } = token2;
        const TooltipToken = merge(token2, {
          // default variables
          tooltipMaxWidth: 250,
          tooltipColor: colorTextLightSolid,
          tooltipBorderRadius: borderRadius,
          tooltipBg: colorBgSpotlight
        });
        return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
      }, prepareComponentToken$g, {
        resetStyle: false,
        // Popover use Tooltip as internal component. We do not need to handle this.
        injectStyle
      });
      return useStyle2(prefixCls);
    };
    const inverseColors = PresetColors.map((color) => `${color}-inverse`);
    const PresetStatusColorTypes = ["success", "processing", "error", "default", "warning"];
    function isPresetColor(color) {
      let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (includeInverse) {
        return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
      }
      return PresetColors.includes(color);
    }
    function isPresetStatusColor(color) {
      return PresetStatusColorTypes.includes(color);
    }
    function parseColor(prefixCls, color) {
      const isInternalColor = isPresetColor(color);
      const className = classNames({
        [`${prefixCls}-${color}`]: color && isInternalColor
      });
      const overlayStyle = {};
      const arrowStyle = {};
      if (color && !isInternalColor) {
        overlayStyle.background = color;
        arrowStyle["--antd-arrow-background-color"] = color;
      }
      return {
        className,
        overlayStyle,
        arrowStyle
      };
    }
    const PurePanel$4 = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        placement = "top",
        title,
        color,
        overlayInnerStyle
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$k(prefixCls);
      const colorInfo = parseColor(prefixCls, color);
      const arrowContentStyle = colorInfo.arrowStyle;
      const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
      const cls = classNames(hashId, cssVarCls, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
        className: cls,
        style: arrowContentStyle
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-arrow`
      }), /* @__PURE__ */ reactExports.createElement(Popup$1, Object.assign({}, props, {
        className: hashId,
        prefixCls,
        overlayInnerStyle: formattedOverlayInnerStyle
      }), title)));
    };
    var __rest$I = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const InternalTooltip = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a, _b;
      const {
        prefixCls: customizePrefixCls,
        openClassName,
        getTooltipContainer,
        color,
        overlayInnerStyle,
        children,
        afterOpenChange,
        afterVisibleChange,
        destroyTooltipOnHide,
        arrow = true,
        title,
        overlay,
        builtinPlacements,
        arrowPointAtCenter = false,
        autoAdjustOverflow: autoAdjustOverflow2 = true,
        motion: motion2,
        getPopupContainer,
        placement = "top",
        mouseEnterDelay = 0.1,
        mouseLeaveDelay = 0.1,
        overlayStyle,
        rootClassName,
        overlayClassName,
        styles,
        classNames: tooltipClassNames
      } = props, restProps = __rest$I(props, ["prefixCls", "openClassName", "getTooltipContainer", "color", "overlayInnerStyle", "children", "afterOpenChange", "afterVisibleChange", "destroyTooltipOnHide", "arrow", "title", "overlay", "builtinPlacements", "arrowPointAtCenter", "autoAdjustOverflow", "motion", "getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName", "overlayClassName", "styles", "classNames"]);
      const mergedShowArrow = !!arrow;
      const [, token2] = useToken();
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        direction,
        className: contextClassName,
        style: contextStyle,
        classNames: contextClassNames,
        styles: contextStyles
      } = useComponentConfig("tooltip");
      const warning2 = devUseWarning();
      const tooltipRef = reactExports.useRef(null);
      const forceAlign = () => {
        var _a2;
        (_a2 = tooltipRef.current) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
      };
      reactExports.useImperativeHandle(ref, () => {
        var _a2, _b2;
        return {
          forceAlign,
          forcePopupAlign: () => {
            warning2.deprecated(false, "forcePopupAlign", "forceAlign");
            forceAlign();
          },
          nativeElement: (_a2 = tooltipRef.current) === null || _a2 === void 0 ? void 0 : _a2.nativeElement,
          popupElement: (_b2 = tooltipRef.current) === null || _b2 === void 0 ? void 0 : _b2.popupElement
        };
      });
      const [open2, setOpen] = useMergedState(false, {
        value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
        defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
      });
      const noTitle = !title && !overlay && title !== 0;
      const onOpenChange = (vis) => {
        var _a2, _b2;
        setOpen(noTitle ? false : vis);
        if (!noTitle) {
          (_a2 = props.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, vis);
          (_b2 = props.onVisibleChange) === null || _b2 === void 0 ? void 0 : _b2.call(props, vis);
        }
      };
      const tooltipPlacements = reactExports.useMemo(() => {
        var _a2, _b2;
        let mergedArrowPointAtCenter = arrowPointAtCenter;
        if (typeof arrow === "object") {
          mergedArrowPointAtCenter = (_b2 = (_a2 = arrow.pointAtCenter) !== null && _a2 !== void 0 ? _a2 : arrow.arrowPointAtCenter) !== null && _b2 !== void 0 ? _b2 : arrowPointAtCenter;
        }
        return builtinPlacements || getPlacements({
          arrowPointAtCenter: mergedArrowPointAtCenter,
          autoAdjustOverflow: autoAdjustOverflow2,
          arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
          borderRadius: token2.borderRadius,
          offset: token2.marginXXS
        });
      }, [arrowPointAtCenter, arrow, builtinPlacements, token2]);
      const memoOverlay = reactExports.useMemo(() => {
        if (title === 0) {
          return title;
        }
        return overlay || title || "";
      }, [overlay, title]);
      const memoOverlayWrapper = /* @__PURE__ */ reactExports.createElement(ContextIsolator, {
        space: true
      }, typeof memoOverlay === "function" ? memoOverlay() : memoOverlay);
      const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const injectFromPopover = props["data-popover-inject"];
      let tempOpen = open2;
      if (!("open" in props) && !("visible" in props) && noTitle) {
        tempOpen = false;
      }
      const child = /* @__PURE__ */ reactExports.isValidElement(children) && !isFragment(children) ? children : /* @__PURE__ */ reactExports.createElement("span", null, children);
      const childProps = child.props;
      const childCls = !childProps.className || typeof childProps.className === "string" ? classNames(childProps.className, openClassName || `${prefixCls}-open`) : childProps.className;
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$k(prefixCls, !injectFromPopover);
      const colorInfo = parseColor(prefixCls, color);
      const arrowContentStyle = colorInfo.arrowStyle;
      const rootClassNames = classNames(overlayClassName, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, colorInfo.className, rootClassName, hashId, cssVarCls, contextClassName, contextClassNames.root, tooltipClassNames === null || tooltipClassNames === void 0 ? void 0 : tooltipClassNames.root);
      const bodyClassNames = classNames(contextClassNames.body, tooltipClassNames === null || tooltipClassNames === void 0 ? void 0 : tooltipClassNames.body);
      const [zIndex, contextZIndex] = useZIndex("Tooltip", restProps.zIndex);
      const content = /* @__PURE__ */ reactExports.createElement(Tooltip$2, Object.assign({}, restProps, {
        zIndex,
        showArrow: mergedShowArrow,
        placement,
        mouseEnterDelay,
        mouseLeaveDelay,
        prefixCls,
        classNames: {
          root: rootClassNames,
          body: bodyClassNames
        },
        styles: {
          root: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, arrowContentStyle), contextStyles.root), contextStyle), overlayStyle), styles === null || styles === void 0 ? void 0 : styles.root),
          body: Object.assign(Object.assign(Object.assign(Object.assign({}, contextStyles.body), overlayInnerStyle), styles === null || styles === void 0 ? void 0 : styles.body), colorInfo.overlayStyle)
        },
        getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
        ref: tooltipRef,
        builtinPlacements: tooltipPlacements,
        overlay: memoOverlayWrapper,
        visible: tempOpen,
        onVisibleChange: onOpenChange,
        afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
        arrowContent: /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-arrow-content`
        }),
        motion: {
          motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", props.transitionName),
          motionDeadline: 1e3
        },
        destroyTooltipOnHide: !!destroyTooltipOnHide
      }), tempOpen ? cloneElement(child, {
        className: childCls
      }) : child);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(zIndexContext.Provider, {
        value: contextZIndex
      }, content));
    });
    const Tooltip = InternalTooltip;
    Tooltip._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$4;
    var LeftOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
    var LeftOutlined = function LeftOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: LeftOutlined$1
      }));
    };
    var RefIcon$s = /* @__PURE__ */ reactExports.forwardRef(LeftOutlined);
    var ESC$1 = KeyCode.ESC, TAB = KeyCode.TAB;
    function useAccessibility$1(_ref) {
      var visible = _ref.visible, triggerRef = _ref.triggerRef, onVisibleChange = _ref.onVisibleChange, autoFocus = _ref.autoFocus, overlayRef = _ref.overlayRef;
      var focusMenuRef = reactExports.useRef(false);
      var handleCloseMenuAndReturnFocus = function handleCloseMenuAndReturnFocus2() {
        if (visible) {
          var _triggerRef$current, _triggerRef$current$f;
          (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 || (_triggerRef$current$f = _triggerRef$current.focus) === null || _triggerRef$current$f === void 0 || _triggerRef$current$f.call(_triggerRef$current);
          onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(false);
        }
      };
      var focusMenu = function focusMenu2() {
        var _overlayRef$current;
        if ((_overlayRef$current = overlayRef.current) !== null && _overlayRef$current !== void 0 && _overlayRef$current.focus) {
          overlayRef.current.focus();
          focusMenuRef.current = true;
          return true;
        }
        return false;
      };
      var handleKeyDown = function handleKeyDown2(event) {
        switch (event.keyCode) {
          case ESC$1:
            handleCloseMenuAndReturnFocus();
            break;
          case TAB: {
            var focusResult = false;
            if (!focusMenuRef.current) {
              focusResult = focusMenu();
            }
            if (focusResult) {
              event.preventDefault();
            } else {
              handleCloseMenuAndReturnFocus();
            }
            break;
          }
        }
      };
      reactExports.useEffect(function() {
        if (visible) {
          window.addEventListener("keydown", handleKeyDown);
          if (autoFocus) {
            wrapperRaf(focusMenu, 3);
          }
          return function() {
            window.removeEventListener("keydown", handleKeyDown);
            focusMenuRef.current = false;
          };
        }
        return function() {
          focusMenuRef.current = false;
        };
      }, [visible]);
    }
    var Overlay = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var overlay = props.overlay, arrow = props.arrow, prefixCls = props.prefixCls;
      var overlayNode = reactExports.useMemo(function() {
        var overlayElement;
        if (typeof overlay === "function") {
          overlayElement = overlay();
        } else {
          overlayElement = overlay;
        }
        return overlayElement;
      }, [overlay]);
      var composedRef = composeRef(ref, getNodeRef(overlayNode));
      return /* @__PURE__ */ i.createElement(i.Fragment, null, arrow && /* @__PURE__ */ i.createElement("div", {
        className: "".concat(prefixCls, "-arrow")
      }), /* @__PURE__ */ i.cloneElement(overlayNode, {
        ref: supportRef(overlayNode) ? composedRef : void 0
      }));
    });
    var autoAdjustOverflow$1 = {
      adjustX: 1,
      adjustY: 1
    };
    var targetOffset = [0, 0];
    var placements$1 = {
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflow$1,
        offset: [0, -4],
        targetOffset
      },
      top: {
        points: ["bc", "tc"],
        overflow: autoAdjustOverflow$1,
        offset: [0, -4],
        targetOffset
      },
      topRight: {
        points: ["br", "tr"],
        overflow: autoAdjustOverflow$1,
        offset: [0, -4],
        targetOffset
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflow$1,
        offset: [0, 4],
        targetOffset
      },
      bottom: {
        points: ["tc", "bc"],
        overflow: autoAdjustOverflow$1,
        offset: [0, 4],
        targetOffset
      },
      bottomRight: {
        points: ["tr", "br"],
        overflow: autoAdjustOverflow$1,
        offset: [0, 4],
        targetOffset
      }
    };
    var _excluded$p = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus", "overlay", "children", "onVisibleChange"];
    function Dropdown(props, ref) {
      var _children$props;
      var _props$arrow = props.arrow, arrow = _props$arrow === void 0 ? false : _props$arrow, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dropdown" : _props$prefixCls, transitionName = props.transitionName, animation = props.animation, align = props.align, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomLeft" : _props$placement, _props$placements = props.placements, placements2 = _props$placements === void 0 ? placements$1 : _props$placements, getPopupContainer = props.getPopupContainer, showAction = props.showAction, hideAction = props.hideAction, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, visible = props.visible, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, autoFocus = props.autoFocus, overlay = props.overlay, children = props.children, onVisibleChange = props.onVisibleChange, otherProps = _objectWithoutProperties(props, _excluded$p);
      var _React$useState = i.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), triggerVisible = _React$useState2[0], setTriggerVisible = _React$useState2[1];
      var mergedVisible = "visible" in props ? visible : triggerVisible;
      var triggerRef = i.useRef(null);
      var overlayRef = i.useRef(null);
      var childRef = i.useRef(null);
      i.useImperativeHandle(ref, function() {
        return triggerRef.current;
      });
      var handleVisibleChange = function handleVisibleChange2(newVisible) {
        setTriggerVisible(newVisible);
        onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(newVisible);
      };
      useAccessibility$1({
        visible: mergedVisible,
        triggerRef: childRef,
        onVisibleChange: handleVisibleChange,
        autoFocus,
        overlayRef
      });
      var onClick = function onClick2(e2) {
        var onOverlayClick = props.onOverlayClick;
        setTriggerVisible(false);
        if (onOverlayClick) {
          onOverlayClick(e2);
        }
      };
      var getMenuElement = function getMenuElement2() {
        return /* @__PURE__ */ i.createElement(Overlay, {
          ref: overlayRef,
          overlay,
          prefixCls,
          arrow
        });
      };
      var getMenuElementOrLambda = function getMenuElementOrLambda2() {
        if (typeof overlay === "function") {
          return getMenuElement;
        }
        return getMenuElement();
      };
      var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger2() {
        var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger, alignPoint = props.alignPoint;
        if ("minOverlayWidthMatchTrigger" in props) {
          return minOverlayWidthMatchTrigger;
        }
        return !alignPoint;
      };
      var getOpenClassName = function getOpenClassName2() {
        var openClassName = props.openClassName;
        if (openClassName !== void 0) {
          return openClassName;
        }
        return "".concat(prefixCls, "-open");
      };
      var childrenNode = /* @__PURE__ */ i.cloneElement(children, {
        className: classNames((_children$props = children.props) === null || _children$props === void 0 ? void 0 : _children$props.className, mergedVisible && getOpenClassName()),
        ref: supportRef(children) ? composeRef(childRef, getNodeRef(children)) : void 0
      });
      var triggerHideAction = hideAction;
      if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) {
        triggerHideAction = ["click"];
      }
      return /* @__PURE__ */ i.createElement(Trigger, _extends$2({
        builtinPlacements: placements2
      }, otherProps, {
        prefixCls,
        ref: triggerRef,
        popupClassName: classNames(overlayClassName, _defineProperty({}, "".concat(prefixCls, "-show-arrow"), arrow)),
        popupStyle: overlayStyle,
        action: trigger,
        showAction,
        hideAction: triggerHideAction,
        popupPlacement: placement,
        popupAlign: align,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        popupVisible: mergedVisible,
        stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
        popup: getMenuElementOrLambda(),
        onPopupVisibleChange: handleVisibleChange,
        onPopupClick: onClick,
        getPopupContainer
      }), childrenNode);
    }
    const Dropdown$1 = /* @__PURE__ */ i.forwardRef(Dropdown);
    var IdContext = /* @__PURE__ */ reactExports.createContext(null);
    function getMenuId(uuid2, eventKey) {
      if (uuid2 === void 0) {
        return null;
      }
      return "".concat(uuid2, "-").concat(eventKey);
    }
    function useMenuId(eventKey) {
      var id = reactExports.useContext(IdContext);
      return getMenuId(id, eventKey);
    }
    var _excluded$o = ["children", "locked"];
    var MenuContext$1 = /* @__PURE__ */ reactExports.createContext(null);
    function mergeProps(origin, target) {
      var clone2 = _objectSpread2$3({}, origin);
      Object.keys(target).forEach(function(key) {
        var value = target[key];
        if (value !== void 0) {
          clone2[key] = value;
        }
      });
      return clone2;
    }
    function InheritableContextProvider(_ref) {
      var children = _ref.children, locked = _ref.locked, restProps = _objectWithoutProperties(_ref, _excluded$o);
      var context = reactExports.useContext(MenuContext$1);
      var inheritableContext = useMemo(function() {
        return mergeProps(context, restProps);
      }, [context, restProps], function(prev2, next2) {
        return !locked && (prev2[0] !== next2[0] || !isEqual$1(prev2[1], next2[1], true));
      });
      return /* @__PURE__ */ reactExports.createElement(MenuContext$1.Provider, {
        value: inheritableContext
      }, children);
    }
    var EmptyList = [];
    var PathRegisterContext = /* @__PURE__ */ reactExports.createContext(null);
    function useMeasure() {
      return reactExports.useContext(PathRegisterContext);
    }
    var PathTrackerContext = /* @__PURE__ */ reactExports.createContext(EmptyList);
    function useFullPath(eventKey) {
      var parentKeyPath = reactExports.useContext(PathTrackerContext);
      return reactExports.useMemo(function() {
        return eventKey !== void 0 ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
      }, [parentKeyPath, eventKey]);
    }
    var PathUserContext = /* @__PURE__ */ reactExports.createContext(null);
    var PrivateContext = /* @__PURE__ */ reactExports.createContext({});
    function focusable(node2) {
      var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (isVisible(node2)) {
        var nodeName = node2.nodeName.toLowerCase();
        var isFocusableElement = (
          // Focusable element
          ["input", "select", "textarea", "button"].includes(nodeName) || // Editable element
          node2.isContentEditable || // Anchor with href element
          nodeName === "a" && !!node2.getAttribute("href")
        );
        var tabIndexAttr = node2.getAttribute("tabindex");
        var tabIndexNum = Number(tabIndexAttr);
        var tabIndex = null;
        if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
          tabIndex = tabIndexNum;
        } else if (isFocusableElement && tabIndex === null) {
          tabIndex = 0;
        }
        if (isFocusableElement && node2.disabled) {
          tabIndex = null;
        }
        return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
      }
      return false;
    }
    function getFocusNodeList(node2) {
      var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var res = _toConsumableArray(node2.querySelectorAll("*")).filter(function(child) {
        return focusable(child, includePositive);
      });
      if (focusable(node2, includePositive)) {
        res.unshift(node2);
      }
      return res;
    }
    var LEFT = KeyCode.LEFT, RIGHT = KeyCode.RIGHT, UP = KeyCode.UP, DOWN = KeyCode.DOWN, ENTER = KeyCode.ENTER, ESC = KeyCode.ESC, HOME = KeyCode.HOME, END = KeyCode.END;
    var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
    function getOffset(mode, isRootLevel, isRtl, which) {
      var _offsets;
      var prev2 = "prev";
      var next2 = "next";
      var children = "children";
      var parent = "parent";
      if (mode === "inline" && which === ENTER) {
        return {
          inlineTrigger: true
        };
      }
      var inline2 = _defineProperty(_defineProperty({}, UP, prev2), DOWN, next2);
      var horizontal = _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, LEFT, isRtl ? next2 : prev2), RIGHT, isRtl ? prev2 : next2), DOWN, children), ENTER, children);
      var vertical = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, UP, prev2), DOWN, next2), ENTER, children), ESC, parent), LEFT, isRtl ? children : parent), RIGHT, isRtl ? parent : children);
      var offsets = {
        inline: inline2,
        horizontal,
        vertical,
        inlineSub: inline2,
        horizontalSub: vertical,
        verticalSub: vertical
      };
      var type2 = (_offsets = offsets["".concat(mode).concat(isRootLevel ? "" : "Sub")]) === null || _offsets === void 0 ? void 0 : _offsets[which];
      switch (type2) {
        case prev2:
          return {
            offset: -1,
            sibling: true
          };
        case next2:
          return {
            offset: 1,
            sibling: true
          };
        case parent:
          return {
            offset: -1,
            sibling: false
          };
        case children:
          return {
            offset: 1,
            sibling: false
          };
        default:
          return null;
      }
    }
    function findContainerUL(element) {
      var current = element;
      while (current) {
        if (current.getAttribute("data-menu-list")) {
          return current;
        }
        current = current.parentElement;
      }
      return null;
    }
    function getFocusElement(activeElement2, elements) {
      var current = activeElement2 || document.activeElement;
      while (current) {
        if (elements.has(current)) {
          return current;
        }
        current = current.parentElement;
      }
      return null;
    }
    function getFocusableElements(container, elements) {
      var list = getFocusNodeList(container, true);
      return list.filter(function(ele) {
        return elements.has(ele);
      });
    }
    function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
      var offset2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
      if (!parentQueryContainer) {
        return null;
      }
      var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
      var count = sameLevelFocusableMenuElementList.length;
      var focusIndex = sameLevelFocusableMenuElementList.findIndex(function(ele) {
        return focusMenuElement === ele;
      });
      if (offset2 < 0) {
        if (focusIndex === -1) {
          focusIndex = count - 1;
        } else {
          focusIndex -= 1;
        }
      } else if (offset2 > 0) {
        focusIndex += 1;
      }
      focusIndex = (focusIndex + count) % count;
      return sameLevelFocusableMenuElementList[focusIndex];
    }
    var refreshElements = function refreshElements2(keys2, id) {
      var elements = /* @__PURE__ */ new Set();
      var key2element = /* @__PURE__ */ new Map();
      var element2key = /* @__PURE__ */ new Map();
      keys2.forEach(function(key) {
        var element = document.querySelector("[data-menu-id='".concat(getMenuId(id, key), "']"));
        if (element) {
          elements.add(element);
          element2key.set(element, key);
          key2element.set(key, element);
        }
      });
      return {
        elements,
        key2element,
        element2key
      };
    };
    function useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
      var rafRef = reactExports.useRef();
      var activeRef = reactExports.useRef();
      activeRef.current = activeKey;
      var cleanRaf = function cleanRaf2() {
        wrapperRaf.cancel(rafRef.current);
      };
      reactExports.useEffect(function() {
        return function() {
          cleanRaf();
        };
      }, []);
      return function(e2) {
        var which = e2.which;
        if ([].concat(ArrowKeys, [ENTER, ESC, HOME, END]).includes(which)) {
          var keys2 = getKeys();
          var refreshedElements = refreshElements(keys2, id);
          var _refreshedElements = refreshedElements, elements = _refreshedElements.elements, key2element = _refreshedElements.key2element, element2key = _refreshedElements.element2key;
          var activeElement2 = key2element.get(activeKey);
          var focusMenuElement = getFocusElement(activeElement2, elements);
          var focusMenuKey = element2key.get(focusMenuElement);
          var offsetObj = getOffset(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
          if (!offsetObj && which !== HOME && which !== END) {
            return;
          }
          if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
            e2.preventDefault();
          }
          var tryFocus = function tryFocus2(menuElement) {
            if (menuElement) {
              var focusTargetElement = menuElement;
              var link = menuElement.querySelector("a");
              if (link !== null && link !== void 0 && link.getAttribute("href")) {
                focusTargetElement = link;
              }
              var targetKey = element2key.get(menuElement);
              triggerActiveKey(targetKey);
              cleanRaf();
              rafRef.current = wrapperRaf(function() {
                if (activeRef.current === targetKey) {
                  focusTargetElement.focus();
                }
              });
            }
          };
          if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
            var parentQueryContainer;
            if (!focusMenuElement || mode === "inline") {
              parentQueryContainer = containerRef.current;
            } else {
              parentQueryContainer = findContainerUL(focusMenuElement);
            }
            var targetElement;
            var focusableElements = getFocusableElements(parentQueryContainer, elements);
            if (which === HOME) {
              targetElement = focusableElements[0];
            } else if (which === END) {
              targetElement = focusableElements[focusableElements.length - 1];
            } else {
              targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
            }
            tryFocus(targetElement);
          } else if (offsetObj.inlineTrigger) {
            triggerAccessibilityOpen(focusMenuKey);
          } else if (offsetObj.offset > 0) {
            triggerAccessibilityOpen(focusMenuKey, true);
            cleanRaf();
            rafRef.current = wrapperRaf(function() {
              refreshedElements = refreshElements(keys2, id);
              var controlId = focusMenuElement.getAttribute("aria-controls");
              var subQueryContainer = document.getElementById(controlId);
              var targetElement2 = getNextFocusElement(subQueryContainer, refreshedElements.elements);
              tryFocus(targetElement2);
            }, 5);
          } else if (offsetObj.offset < 0) {
            var keyPath = getKeyPath(focusMenuKey, true);
            var parentKey = keyPath[keyPath.length - 2];
            var parentMenuElement = key2element.get(parentKey);
            triggerAccessibilityOpen(parentKey, false);
            tryFocus(parentMenuElement);
          }
        }
        originOnKeyDown === null || originOnKeyDown === void 0 || originOnKeyDown(e2);
      };
    }
    function nextSlice(callback) {
      Promise.resolve().then(callback);
    }
    var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
    var getPathStr = function getPathStr2(keyPath) {
      return keyPath.join(PATH_SPLIT);
    };
    var getPathKeys = function getPathKeys2(keyPathStr) {
      return keyPathStr.split(PATH_SPLIT);
    };
    var OVERFLOW_KEY = "rc-menu-more";
    function useKeyRecords() {
      var _React$useState = reactExports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), internalForceUpdate = _React$useState2[1];
      var key2pathRef = reactExports.useRef(/* @__PURE__ */ new Map());
      var path2keyRef = reactExports.useRef(/* @__PURE__ */ new Map());
      var _React$useState3 = reactExports.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), overflowKeys = _React$useState4[0], setOverflowKeys = _React$useState4[1];
      var updateRef2 = reactExports.useRef(0);
      var destroyRef = reactExports.useRef(false);
      var forceUpdate = function forceUpdate2() {
        if (!destroyRef.current) {
          internalForceUpdate({});
        }
      };
      var registerPath = reactExports.useCallback(function(key, keyPath) {
        var connectedPath = getPathStr(keyPath);
        path2keyRef.current.set(connectedPath, key);
        key2pathRef.current.set(key, connectedPath);
        updateRef2.current += 1;
        var id = updateRef2.current;
        nextSlice(function() {
          if (id === updateRef2.current) {
            forceUpdate();
          }
        });
      }, []);
      var unregisterPath = reactExports.useCallback(function(key, keyPath) {
        var connectedPath = getPathStr(keyPath);
        path2keyRef.current.delete(connectedPath);
        key2pathRef.current.delete(key);
      }, []);
      var refreshOverflowKeys = reactExports.useCallback(function(keys2) {
        setOverflowKeys(keys2);
      }, []);
      var getKeyPath = reactExports.useCallback(function(eventKey, includeOverflow) {
        var fullPath = key2pathRef.current.get(eventKey) || "";
        var keys2 = getPathKeys(fullPath);
        if (includeOverflow && overflowKeys.includes(keys2[0])) {
          keys2.unshift(OVERFLOW_KEY);
        }
        return keys2;
      }, [overflowKeys]);
      var isSubPathKey = reactExports.useCallback(function(pathKeys, eventKey) {
        return pathKeys.filter(function(item) {
          return item !== void 0;
        }).some(function(pathKey2) {
          var pathKeyList = getKeyPath(pathKey2, true);
          return pathKeyList.includes(eventKey);
        });
      }, [getKeyPath]);
      var getKeys = function getKeys2() {
        var keys2 = _toConsumableArray(key2pathRef.current.keys());
        if (overflowKeys.length) {
          keys2.push(OVERFLOW_KEY);
        }
        return keys2;
      };
      var getSubPathKeys = reactExports.useCallback(function(key) {
        var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT);
        var pathKeys = /* @__PURE__ */ new Set();
        _toConsumableArray(path2keyRef.current.keys()).forEach(function(pathKey2) {
          if (pathKey2.startsWith(connectedPath)) {
            pathKeys.add(path2keyRef.current.get(pathKey2));
          }
        });
        return pathKeys;
      }, []);
      reactExports.useEffect(function() {
        return function() {
          destroyRef.current = true;
        };
      }, []);
      return {
        // Register
        registerPath,
        unregisterPath,
        refreshOverflowKeys,
        // Util
        isSubPathKey,
        getKeyPath,
        getKeys,
        getSubPathKeys
      };
    }
    function useMemoCallback(func) {
      var funRef = reactExports.useRef(func);
      funRef.current = func;
      var callback = reactExports.useCallback(function() {
        var _funRef$current;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
      }, []);
      return func ? callback : void 0;
    }
    var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
    var internalId = 0;
    function useUUID(id) {
      var _useMergedState = useMergedState(id, {
        value: id
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), uuid2 = _useMergedState2[0], setUUID = _useMergedState2[1];
      reactExports.useEffect(function() {
        internalId += 1;
        var newId = "".concat(uniquePrefix, "-").concat(internalId);
        setUUID("rc-menu-uuid-".concat(newId));
      }, []);
      return uuid2;
    }
    function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
      var _React$useContext = reactExports.useContext(MenuContext$1), activeKey = _React$useContext.activeKey, onActive = _React$useContext.onActive, onInactive = _React$useContext.onInactive;
      var ret = {
        active: activeKey === eventKey
      };
      if (!disabled) {
        ret.onMouseEnter = function(domEvent) {
          onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
            key: eventKey,
            domEvent
          });
          onActive(eventKey);
        };
        ret.onMouseLeave = function(domEvent) {
          onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
            key: eventKey,
            domEvent
          });
          onInactive(eventKey);
        };
      }
      return ret;
    }
    function useDirectionStyle(level) {
      var _React$useContext = reactExports.useContext(MenuContext$1), mode = _React$useContext.mode, rtl = _React$useContext.rtl, inlineIndent = _React$useContext.inlineIndent;
      if (mode !== "inline") {
        return null;
      }
      var len = level;
      return rtl ? {
        paddingRight: len * inlineIndent
      } : {
        paddingLeft: len * inlineIndent
      };
    }
    function Icon$2(_ref) {
      var icon = _ref.icon, props = _ref.props, children = _ref.children;
      var iconNode;
      if (icon === null || icon === false) {
        return null;
      }
      if (typeof icon === "function") {
        iconNode = /* @__PURE__ */ reactExports.createElement(icon, _objectSpread2$3({}, props));
      } else if (typeof icon !== "boolean") {
        iconNode = icon;
      }
      return iconNode || children || null;
    }
    var _excluded$n = ["item"];
    function warnItemProp(_ref) {
      var item = _ref.item, restInfo = _objectWithoutProperties(_ref, _excluded$n);
      Object.defineProperty(restInfo, "item", {
        get: function get2() {
          warningOnce$1(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
          return item;
        }
      });
      return restInfo;
    }
    var _excluded$m = ["title", "attribute", "elementRef"], _excluded2$5 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], _excluded3 = ["active"];
    var LegacyMenuItem = /* @__PURE__ */ function(_React$Component) {
      _inherits(LegacyMenuItem2, _React$Component);
      var _super = _createSuper(LegacyMenuItem2);
      function LegacyMenuItem2() {
        _classCallCheck(this, LegacyMenuItem2);
        return _super.apply(this, arguments);
      }
      _createClass(LegacyMenuItem2, [{
        key: "render",
        value: function render2() {
          var _this$props = this.props, title = _this$props.title, attribute = _this$props.attribute, elementRef = _this$props.elementRef, restProps = _objectWithoutProperties(_this$props, _excluded$m);
          var passedProps = omit(restProps, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
          warningOnce$1(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
          return /* @__PURE__ */ reactExports.createElement(ForwardOverflow.Item, _extends$2({}, attribute, {
            title: typeof title === "string" ? title : void 0
          }, passedProps, {
            ref: elementRef
          }));
        }
      }]);
      return LegacyMenuItem2;
    }(reactExports.Component);
    var InternalMenuItem = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var style2 = props.style, className = props.className, eventKey = props.eventKey;
      props.warnKey;
      var disabled = props.disabled, itemIcon = props.itemIcon, children = props.children, role = props.role, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown = props.onKeyDown, onFocus = props.onFocus, restProps = _objectWithoutProperties(props, _excluded2$5);
      var domDataId = useMenuId(eventKey);
      var _React$useContext = reactExports.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, onItemClick = _React$useContext.onItemClick, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, contextItemIcon = _React$useContext.itemIcon, selectedKeys = _React$useContext.selectedKeys, onActive = _React$useContext.onActive;
      var _React$useContext2 = reactExports.useContext(PrivateContext), _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
      var itemCls = "".concat(prefixCls, "-item");
      var legacyMenuItemRef = reactExports.useRef();
      var elementRef = reactExports.useRef();
      var mergedDisabled = contextDisabled || disabled;
      var mergedEleRef = useComposeRef(ref, elementRef);
      var connectedKeys = useFullPath(eventKey);
      var getEventInfo = function getEventInfo2(e2) {
        return {
          key: eventKey,
          // Note: For legacy code is reversed which not like other antd component
          keyPath: _toConsumableArray(connectedKeys).reverse(),
          item: legacyMenuItemRef.current,
          domEvent: e2
        };
      };
      var mergedItemIcon = itemIcon || contextItemIcon;
      var _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties(_useActive, _excluded3);
      var selected = selectedKeys.includes(eventKey);
      var directionStyle = useDirectionStyle(connectedKeys.length);
      var onInternalClick = function onInternalClick2(e2) {
        if (mergedDisabled) {
          return;
        }
        var info = getEventInfo(e2);
        onClick === null || onClick === void 0 || onClick(warnItemProp(info));
        onItemClick(info);
      };
      var onInternalKeyDown = function onInternalKeyDown2(e2) {
        onKeyDown === null || onKeyDown === void 0 || onKeyDown(e2);
        if (e2.which === KeyCode.ENTER) {
          var info = getEventInfo(e2);
          onClick === null || onClick === void 0 || onClick(warnItemProp(info));
          onItemClick(info);
        }
      };
      var onInternalFocus = function onInternalFocus2(e2) {
        onActive(eventKey);
        onFocus === null || onFocus === void 0 || onFocus(e2);
      };
      var optionRoleProps = {};
      if (props.role === "option") {
        optionRoleProps["aria-selected"] = selected;
      }
      var renderNode = /* @__PURE__ */ reactExports.createElement(LegacyMenuItem, _extends$2({
        ref: legacyMenuItemRef,
        elementRef: mergedEleRef,
        role: role === null ? "none" : role || "menuitem",
        tabIndex: disabled ? null : -1,
        "data-menu-id": overflowDisabled && domDataId ? null : domDataId
      }, omit(restProps, ["extra"]), activeProps, optionRoleProps, {
        component: "li",
        "aria-disabled": disabled,
        style: _objectSpread2$3(_objectSpread2$3({}, directionStyle), style2),
        className: classNames(itemCls, _defineProperty(_defineProperty(_defineProperty({}, "".concat(itemCls, "-active"), active), "".concat(itemCls, "-selected"), selected), "".concat(itemCls, "-disabled"), mergedDisabled), className),
        onClick: onInternalClick,
        onKeyDown: onInternalKeyDown,
        onFocus: onInternalFocus
      }), children, /* @__PURE__ */ reactExports.createElement(Icon$2, {
        props: _objectSpread2$3(_objectSpread2$3({}, props), {}, {
          isSelected: selected
        }),
        icon: mergedItemIcon
      }));
      if (_internalRenderMenuItem) {
        renderNode = _internalRenderMenuItem(renderNode, props, {
          selected
        });
      }
      return renderNode;
    });
    function MenuItem$1(props, ref) {
      var eventKey = props.eventKey;
      var measure = useMeasure();
      var connectedKeyPath = useFullPath(eventKey);
      reactExports.useEffect(function() {
        if (measure) {
          measure.registerPath(eventKey, connectedKeyPath);
          return function() {
            measure.unregisterPath(eventKey, connectedKeyPath);
          };
        }
      }, [connectedKeyPath]);
      if (measure) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(InternalMenuItem, _extends$2({}, props, {
        ref
      }));
    }
    const MenuItem$2 = /* @__PURE__ */ reactExports.forwardRef(MenuItem$1);
    var _excluded$l = ["className", "children"];
    var InternalSubMenuList = function InternalSubMenuList2(_ref, ref) {
      var className = _ref.className, children = _ref.children, restProps = _objectWithoutProperties(_ref, _excluded$l);
      var _React$useContext = reactExports.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, rtl = _React$useContext.rtl;
      return /* @__PURE__ */ reactExports.createElement("ul", _extends$2({
        className: classNames(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === "inline" ? "inline" : "vertical"), className),
        role: "menu"
      }, restProps, {
        "data-menu-list": true,
        ref
      }), children);
    };
    var SubMenuList = /* @__PURE__ */ reactExports.forwardRef(InternalSubMenuList);
    SubMenuList.displayName = "SubMenuList";
    function parseChildren(children, keyPath) {
      return toArray$5(children).map(function(child, index2) {
        if (/* @__PURE__ */ reactExports.isValidElement(child)) {
          var _eventKey, _child$props;
          var key = child.key;
          var eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key;
          var emptyKey = eventKey === null || eventKey === void 0;
          if (emptyKey) {
            eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index2]).join("-"));
          }
          var cloneProps = {
            key: eventKey,
            eventKey
          };
          return /* @__PURE__ */ reactExports.cloneElement(child, cloneProps);
        }
        return child;
      });
    }
    var autoAdjustOverflow = {
      adjustX: 1,
      adjustY: 1
    };
    var placements = {
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflow
      },
      topRight: {
        points: ["br", "tr"],
        overflow: autoAdjustOverflow
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflow
      },
      bottomRight: {
        points: ["tr", "br"],
        overflow: autoAdjustOverflow
      },
      leftTop: {
        points: ["tr", "tl"],
        overflow: autoAdjustOverflow
      },
      leftBottom: {
        points: ["br", "bl"],
        overflow: autoAdjustOverflow
      },
      rightTop: {
        points: ["tl", "tr"],
        overflow: autoAdjustOverflow
      },
      rightBottom: {
        points: ["bl", "br"],
        overflow: autoAdjustOverflow
      }
    };
    var placementsRtl = {
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflow
      },
      topRight: {
        points: ["br", "tr"],
        overflow: autoAdjustOverflow
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflow
      },
      bottomRight: {
        points: ["tr", "br"],
        overflow: autoAdjustOverflow
      },
      rightTop: {
        points: ["tr", "tl"],
        overflow: autoAdjustOverflow
      },
      rightBottom: {
        points: ["br", "bl"],
        overflow: autoAdjustOverflow
      },
      leftTop: {
        points: ["tl", "tr"],
        overflow: autoAdjustOverflow
      },
      leftBottom: {
        points: ["bl", "br"],
        overflow: autoAdjustOverflow
      }
    };
    function getMotion(mode, motion2, defaultMotions) {
      if (motion2) {
        return motion2;
      }
      if (defaultMotions) {
        return defaultMotions[mode] || defaultMotions.other;
      }
      return void 0;
    }
    var popupPlacementMap = {
      horizontal: "bottomLeft",
      vertical: "rightTop",
      "vertical-left": "rightTop",
      "vertical-right": "leftTop"
    };
    function PopupTrigger(_ref) {
      var prefixCls = _ref.prefixCls, visible = _ref.visible, children = _ref.children, popup = _ref.popup, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupOffset = _ref.popupOffset, disabled = _ref.disabled, mode = _ref.mode, onVisibleChange = _ref.onVisibleChange;
      var _React$useContext = reactExports.useContext(MenuContext$1), getPopupContainer = _React$useContext.getPopupContainer, rtl = _React$useContext.rtl, subMenuOpenDelay = _React$useContext.subMenuOpenDelay, subMenuCloseDelay = _React$useContext.subMenuCloseDelay, builtinPlacements = _React$useContext.builtinPlacements, triggerSubMenuAction = _React$useContext.triggerSubMenuAction, forceSubMenuRender = _React$useContext.forceSubMenuRender, rootClassName = _React$useContext.rootClassName, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), innerVisible = _React$useState2[0], setInnerVisible = _React$useState2[1];
      var placement = rtl ? _objectSpread2$3(_objectSpread2$3({}, placementsRtl), builtinPlacements) : _objectSpread2$3(_objectSpread2$3({}, placements), builtinPlacements);
      var popupPlacement = popupPlacementMap[mode];
      var targetMotion = getMotion(mode, motion2, defaultMotions);
      var targetMotionRef = reactExports.useRef(targetMotion);
      if (mode !== "inline") {
        targetMotionRef.current = targetMotion;
      }
      var mergedMotion = _objectSpread2$3(_objectSpread2$3({}, targetMotionRef.current), {}, {
        leavedClassName: "".concat(prefixCls, "-hidden"),
        removeOnLeave: false,
        motionAppear: true
      });
      var visibleRef = reactExports.useRef();
      reactExports.useEffect(function() {
        visibleRef.current = wrapperRaf(function() {
          setInnerVisible(visible);
        });
        return function() {
          wrapperRaf.cancel(visibleRef.current);
        };
      }, [visible]);
      return /* @__PURE__ */ reactExports.createElement(Trigger, {
        prefixCls,
        popupClassName: classNames("".concat(prefixCls, "-popup"), _defineProperty({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
        stretch: mode === "horizontal" ? "minWidth" : null,
        getPopupContainer,
        builtinPlacements: placement,
        popupPlacement,
        popupVisible: innerVisible,
        popup,
        popupStyle,
        popupAlign: popupOffset && {
          offset: popupOffset
        },
        action: disabled ? [] : [triggerSubMenuAction],
        mouseEnterDelay: subMenuOpenDelay,
        mouseLeaveDelay: subMenuCloseDelay,
        onPopupVisibleChange: onVisibleChange,
        forceRender: forceSubMenuRender,
        popupMotion: mergedMotion,
        fresh: true
      }, children);
    }
    function InlineSubMenuList(_ref) {
      var id = _ref.id, open2 = _ref.open, keyPath = _ref.keyPath, children = _ref.children;
      var fixedMode = "inline";
      var _React$useContext = reactExports.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, forceSubMenuRender = _React$useContext.forceSubMenuRender, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, mode = _React$useContext.mode;
      var sameModeRef = reactExports.useRef(false);
      sameModeRef.current = mode === fixedMode;
      var _React$useState = reactExports.useState(!sameModeRef.current), _React$useState2 = _slicedToArray(_React$useState, 2), destroy2 = _React$useState2[0], setDestroy = _React$useState2[1];
      var mergedOpen = sameModeRef.current ? open2 : false;
      reactExports.useEffect(function() {
        if (sameModeRef.current) {
          setDestroy(false);
        }
      }, [mode]);
      var mergedMotion = _objectSpread2$3({}, getMotion(fixedMode, motion2, defaultMotions));
      if (keyPath.length > 1) {
        mergedMotion.motionAppear = false;
      }
      var originOnVisibleChanged = mergedMotion.onVisibleChanged;
      mergedMotion.onVisibleChanged = function(newVisible) {
        if (!sameModeRef.current && !newVisible) {
          setDestroy(true);
        }
        return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
      };
      if (destroy2) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(InheritableContextProvider, {
        mode: fixedMode,
        locked: !sameModeRef.current
      }, /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({
        visible: mergedOpen
      }, mergedMotion, {
        forceRender: forceSubMenuRender,
        removeOnLeave: false,
        leavedClassName: "".concat(prefixCls, "-hidden")
      }), function(_ref2) {
        var motionClassName = _ref2.className, motionStyle = _ref2.style;
        return /* @__PURE__ */ reactExports.createElement(SubMenuList, {
          id,
          className: motionClassName,
          style: motionStyle
        }, children);
      }));
    }
    var _excluded$k = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "popupStyle", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], _excluded2$4 = ["active"];
    var InternalSubMenu = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var style2 = props.style, className = props.className, title = props.title, eventKey = props.eventKey;
      props.warnKey;
      var disabled = props.disabled, internalPopupClose = props.internalPopupClose, children = props.children, itemIcon = props.itemIcon, expandIcon = props.expandIcon, popupClassName = props.popupClassName, popupOffset = props.popupOffset, popupStyle = props.popupStyle, onClick = props.onClick, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onTitleClick = props.onTitleClick, onTitleMouseEnter = props.onTitleMouseEnter, onTitleMouseLeave = props.onTitleMouseLeave, restProps = _objectWithoutProperties(props, _excluded$k);
      var domDataId = useMenuId(eventKey);
      var _React$useContext = reactExports.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, openKeys = _React$useContext.openKeys, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, activeKey = _React$useContext.activeKey, selectedKeys = _React$useContext.selectedKeys, contextItemIcon = _React$useContext.itemIcon, contextExpandIcon = _React$useContext.expandIcon, onItemClick = _React$useContext.onItemClick, onOpenChange = _React$useContext.onOpenChange, onActive = _React$useContext.onActive;
      var _React$useContext2 = reactExports.useContext(PrivateContext), _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
      var _React$useContext3 = reactExports.useContext(PathUserContext), isSubPathKey = _React$useContext3.isSubPathKey;
      var connectedPath = useFullPath();
      var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
      var mergedDisabled = contextDisabled || disabled;
      var elementRef = reactExports.useRef();
      var popupRef = reactExports.useRef();
      var mergedItemIcon = itemIcon !== null && itemIcon !== void 0 ? itemIcon : contextItemIcon;
      var mergedExpandIcon = expandIcon !== null && expandIcon !== void 0 ? expandIcon : contextExpandIcon;
      var originOpen = openKeys.includes(eventKey);
      var open2 = !overflowDisabled && originOpen;
      var childrenSelected = isSubPathKey(selectedKeys, eventKey);
      var _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties(_useActive, _excluded2$4);
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), childrenActive = _React$useState2[0], setChildrenActive = _React$useState2[1];
      var triggerChildrenActive = function triggerChildrenActive2(newActive) {
        if (!mergedDisabled) {
          setChildrenActive(newActive);
        }
      };
      var onInternalMouseEnter = function onInternalMouseEnter2(domEvent) {
        triggerChildrenActive(true);
        onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
          key: eventKey,
          domEvent
        });
      };
      var onInternalMouseLeave = function onInternalMouseLeave2(domEvent) {
        triggerChildrenActive(false);
        onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
          key: eventKey,
          domEvent
        });
      };
      var mergedActive = reactExports.useMemo(function() {
        if (active) {
          return active;
        }
        if (mode !== "inline") {
          return childrenActive || isSubPathKey([activeKey], eventKey);
        }
        return false;
      }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
      var directionStyle = useDirectionStyle(connectedPath.length);
      var onInternalTitleClick = function onInternalTitleClick2(e2) {
        if (mergedDisabled) {
          return;
        }
        onTitleClick === null || onTitleClick === void 0 || onTitleClick({
          key: eventKey,
          domEvent: e2
        });
        if (mode === "inline") {
          onOpenChange(eventKey, !originOpen);
        }
      };
      var onMergedItemClick = useMemoCallback(function(info) {
        onClick === null || onClick === void 0 || onClick(warnItemProp(info));
        onItemClick(info);
      });
      var onPopupVisibleChange = function onPopupVisibleChange2(newVisible) {
        if (mode !== "inline") {
          onOpenChange(eventKey, newVisible);
        }
      };
      var onInternalFocus = function onInternalFocus2() {
        onActive(eventKey);
      };
      var popupId = domDataId && "".concat(domDataId, "-popup");
      var expandIconNode = reactExports.useMemo(function() {
        return /* @__PURE__ */ reactExports.createElement(Icon$2, {
          icon: mode !== "horizontal" ? mergedExpandIcon : void 0,
          props: _objectSpread2$3(_objectSpread2$3({}, props), {}, {
            isOpen: open2,
            // [Legacy] Not sure why need this mark
            isSubMenu: true
          })
        }, /* @__PURE__ */ reactExports.createElement("i", {
          className: "".concat(subMenuPrefixCls, "-arrow")
        }));
      }, [mode, mergedExpandIcon, props, open2, subMenuPrefixCls]);
      var titleNode = /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        role: "menuitem",
        style: directionStyle,
        className: "".concat(subMenuPrefixCls, "-title"),
        tabIndex: mergedDisabled ? null : -1,
        ref: elementRef,
        title: typeof title === "string" ? title : null,
        "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
        "aria-expanded": open2,
        "aria-haspopup": true,
        "aria-controls": popupId,
        "aria-disabled": mergedDisabled,
        onClick: onInternalTitleClick,
        onFocus: onInternalFocus
      }, activeProps), title, expandIconNode);
      var triggerModeRef = reactExports.useRef(mode);
      if (mode !== "inline" && connectedPath.length > 1) {
        triggerModeRef.current = "vertical";
      } else {
        triggerModeRef.current = mode;
      }
      if (!overflowDisabled) {
        var triggerMode = triggerModeRef.current;
        titleNode = /* @__PURE__ */ reactExports.createElement(PopupTrigger, {
          mode: triggerMode,
          prefixCls: subMenuPrefixCls,
          visible: !internalPopupClose && open2 && mode !== "inline",
          popupClassName,
          popupOffset,
          popupStyle,
          popup: /* @__PURE__ */ reactExports.createElement(
            InheritableContextProvider,
            {
              mode: triggerMode === "horizontal" ? "vertical" : triggerMode
            },
            /* @__PURE__ */ reactExports.createElement(SubMenuList, {
              id: popupId,
              ref: popupRef
            }, children)
          ),
          disabled: mergedDisabled,
          onVisibleChange: onPopupVisibleChange
        }, titleNode);
      }
      var listNode = /* @__PURE__ */ reactExports.createElement(ForwardOverflow.Item, _extends$2({
        ref,
        role: "none"
      }, restProps, {
        component: "li",
        style: style2,
        className: classNames(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(subMenuPrefixCls, "-open"), open2), "".concat(subMenuPrefixCls, "-active"), mergedActive), "".concat(subMenuPrefixCls, "-selected"), childrenSelected), "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled)),
        onMouseEnter: onInternalMouseEnter,
        onMouseLeave: onInternalMouseLeave
      }), titleNode, !overflowDisabled && /* @__PURE__ */ reactExports.createElement(InlineSubMenuList, {
        id: popupId,
        open: open2,
        keyPath: connectedPath
      }, children));
      if (_internalRenderSubMenuItem) {
        listNode = _internalRenderSubMenuItem(listNode, props, {
          selected: childrenSelected,
          active: mergedActive,
          open: open2,
          disabled: mergedDisabled
        });
      }
      return /* @__PURE__ */ reactExports.createElement(InheritableContextProvider, {
        onItemClick: onMergedItemClick,
        mode: mode === "horizontal" ? "vertical" : mode,
        itemIcon: mergedItemIcon,
        expandIcon: mergedExpandIcon
      }, listNode);
    });
    var SubMenu$1 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var eventKey = props.eventKey, children = props.children;
      var connectedKeyPath = useFullPath(eventKey);
      var childList = parseChildren(children, connectedKeyPath);
      var measure = useMeasure();
      reactExports.useEffect(function() {
        if (measure) {
          measure.registerPath(eventKey, connectedKeyPath);
          return function() {
            measure.unregisterPath(eventKey, connectedKeyPath);
          };
        }
      }, [connectedKeyPath]);
      var renderNode;
      if (measure) {
        renderNode = childList;
      } else {
        renderNode = /* @__PURE__ */ reactExports.createElement(InternalSubMenu, _extends$2({
          ref
        }, props), childList);
      }
      return /* @__PURE__ */ reactExports.createElement(PathTrackerContext.Provider, {
        value: connectedKeyPath
      }, renderNode);
    });
    function Divider$2(_ref) {
      var className = _ref.className, style2 = _ref.style;
      var _React$useContext = reactExports.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls;
      var measure = useMeasure();
      if (measure) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("li", {
        role: "separator",
        className: classNames("".concat(prefixCls, "-item-divider"), className),
        style: style2
      });
    }
    var _excluded$j = ["className", "title", "eventKey", "children"];
    var InternalMenuItemGroup = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var className = props.className, title = props.title;
      props.eventKey;
      var children = props.children, restProps = _objectWithoutProperties(props, _excluded$j);
      var _React$useContext = reactExports.useContext(MenuContext$1), prefixCls = _React$useContext.prefixCls;
      var groupPrefixCls = "".concat(prefixCls, "-item-group");
      return /* @__PURE__ */ reactExports.createElement("li", _extends$2({
        ref,
        role: "presentation"
      }, restProps, {
        onClick: function onClick(e2) {
          return e2.stopPropagation();
        },
        className: classNames(groupPrefixCls, className)
      }), /* @__PURE__ */ reactExports.createElement("div", {
        role: "presentation",
        className: "".concat(groupPrefixCls, "-title"),
        title: typeof title === "string" ? title : void 0
      }, title), /* @__PURE__ */ reactExports.createElement("ul", {
        role: "group",
        className: "".concat(groupPrefixCls, "-list")
      }, children));
    });
    var MenuItemGroup = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var eventKey = props.eventKey, children = props.children;
      var connectedKeyPath = useFullPath(eventKey);
      var childList = parseChildren(children, connectedKeyPath);
      var measure = useMeasure();
      if (measure) {
        return childList;
      }
      return /* @__PURE__ */ reactExports.createElement(InternalMenuItemGroup, _extends$2({
        ref
      }, omit(props, ["warnKey"])), childList);
    });
    var _excluded$i = ["label", "children", "key", "type", "extra"];
    function convertItemsToNodes(list, components, prefixCls) {
      var MergedMenuItem = components.item, MergedMenuItemGroup = components.group, MergedSubMenu = components.submenu, MergedDivider = components.divider;
      return (list || []).map(function(opt, index2) {
        if (opt && _typeof$1(opt) === "object") {
          var _ref = opt, label = _ref.label, children = _ref.children, key = _ref.key, type2 = _ref.type, extra = _ref.extra, restProps = _objectWithoutProperties(_ref, _excluded$i);
          var mergedKey = key !== null && key !== void 0 ? key : "tmp-".concat(index2);
          if (children || type2 === "group") {
            if (type2 === "group") {
              return /* @__PURE__ */ reactExports.createElement(MergedMenuItemGroup, _extends$2({
                key: mergedKey
              }, restProps, {
                title: label
              }), convertItemsToNodes(children, components, prefixCls));
            }
            return /* @__PURE__ */ reactExports.createElement(MergedSubMenu, _extends$2({
              key: mergedKey
            }, restProps, {
              title: label
            }), convertItemsToNodes(children, components, prefixCls));
          }
          if (type2 === "divider") {
            return /* @__PURE__ */ reactExports.createElement(MergedDivider, _extends$2({
              key: mergedKey
            }, restProps));
          }
          return /* @__PURE__ */ reactExports.createElement(MergedMenuItem, _extends$2({
            key: mergedKey
          }, restProps, {
            extra
          }), label, (!!extra || extra === 0) && /* @__PURE__ */ reactExports.createElement("span", {
            className: "".concat(prefixCls, "-item-extra")
          }, extra));
        }
        return null;
      }).filter(function(opt) {
        return opt;
      });
    }
    function parseItems(children, items, keyPath, components, prefixCls) {
      var childNodes = children;
      var mergedComponents = _objectSpread2$3({
        divider: Divider$2,
        item: MenuItem$2,
        group: MenuItemGroup,
        submenu: SubMenu$1
      }, components);
      if (items) {
        childNodes = convertItemsToNodes(items, mergedComponents, prefixCls);
      }
      return parseChildren(childNodes, keyPath);
    }
    var _excluded$h = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem", "_internalComponents"];
    var EMPTY_LIST$2 = [];
    var Menu$1 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _childList$;
      var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-menu" : _ref$prefixCls, rootClassName = _ref.rootClassName, style2 = _ref.style, className = _ref.className, _ref$tabIndex = _ref.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, items = _ref.items, children = _ref.children, direction = _ref.direction, id = _ref.id, _ref$mode = _ref.mode, mode = _ref$mode === void 0 ? "vertical" : _ref$mode, inlineCollapsed = _ref.inlineCollapsed, disabled = _ref.disabled, disabledOverflow = _ref.disabledOverflow, _ref$subMenuOpenDelay = _ref.subMenuOpenDelay, subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? 0.1 : _ref$subMenuOpenDelay, _ref$subMenuCloseDela = _ref.subMenuCloseDelay, subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? 0.1 : _ref$subMenuCloseDela, forceSubMenuRender = _ref.forceSubMenuRender, defaultOpenKeys = _ref.defaultOpenKeys, openKeys = _ref.openKeys, activeKey = _ref.activeKey, defaultActiveFirst = _ref.defaultActiveFirst, _ref$selectable = _ref.selectable, selectable = _ref$selectable === void 0 ? true : _ref$selectable, _ref$multiple = _ref.multiple, multiple = _ref$multiple === void 0 ? false : _ref$multiple, defaultSelectedKeys = _ref.defaultSelectedKeys, selectedKeys = _ref.selectedKeys, onSelect = _ref.onSelect, onDeselect = _ref.onDeselect, _ref$inlineIndent = _ref.inlineIndent, inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent, motion2 = _ref.motion, defaultMotions = _ref.defaultMotions, _ref$triggerSubMenuAc = _ref.triggerSubMenuAction, triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? "hover" : _ref$triggerSubMenuAc, builtinPlacements = _ref.builtinPlacements, itemIcon = _ref.itemIcon, expandIcon = _ref.expandIcon, _ref$overflowedIndica = _ref.overflowedIndicator, overflowedIndicator = _ref$overflowedIndica === void 0 ? "..." : _ref$overflowedIndica, overflowedIndicatorPopupClassName = _ref.overflowedIndicatorPopupClassName, getPopupContainer = _ref.getPopupContainer, onClick = _ref.onClick, onOpenChange = _ref.onOpenChange, onKeyDown = _ref.onKeyDown;
      _ref.openAnimation;
      _ref.openTransitionName;
      var _internalRenderMenuItem = _ref._internalRenderMenuItem, _internalRenderSubMenuItem = _ref._internalRenderSubMenuItem, _internalComponents = _ref._internalComponents, restProps = _objectWithoutProperties(_ref, _excluded$h);
      var _React$useMemo = reactExports.useMemo(function() {
        return [parseItems(children, items, EMPTY_LIST$2, _internalComponents, prefixCls), parseItems(children, items, EMPTY_LIST$2, {}, prefixCls)];
      }, [children, items, _internalComponents]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), childList = _React$useMemo2[0], measureChildList = _React$useMemo2[1];
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mounted = _React$useState2[0], setMounted = _React$useState2[1];
      var containerRef = reactExports.useRef();
      var uuid2 = useUUID(id);
      var isRtl = direction === "rtl";
      var _useMergedState = useMergedState(defaultOpenKeys, {
        value: openKeys,
        postState: function postState(keys2) {
          return keys2 || EMPTY_LIST$2;
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedOpenKeys = _useMergedState2[0], setMergedOpenKeys = _useMergedState2[1];
      var triggerOpenKeys = function triggerOpenKeys2(keys2) {
        var forceFlush = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        function doUpdate() {
          setMergedOpenKeys(keys2);
          onOpenChange === null || onOpenChange === void 0 || onOpenChange(keys2);
        }
        if (forceFlush) {
          reactDomExports.flushSync(doUpdate);
        } else {
          doUpdate();
        }
      };
      var _React$useState3 = reactExports.useState(mergedOpenKeys), _React$useState4 = _slicedToArray(_React$useState3, 2), inlineCacheOpenKeys = _React$useState4[0], setInlineCacheOpenKeys = _React$useState4[1];
      var mountRef = reactExports.useRef(false);
      var _React$useMemo3 = reactExports.useMemo(function() {
        if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
          return ["vertical", inlineCollapsed];
        }
        return [mode, false];
      }, [mode, inlineCollapsed]), _React$useMemo4 = _slicedToArray(_React$useMemo3, 2), mergedMode = _React$useMemo4[0], mergedInlineCollapsed = _React$useMemo4[1];
      var isInlineMode = mergedMode === "inline";
      var _React$useState5 = reactExports.useState(mergedMode), _React$useState6 = _slicedToArray(_React$useState5, 2), internalMode = _React$useState6[0], setInternalMode = _React$useState6[1];
      var _React$useState7 = reactExports.useState(mergedInlineCollapsed), _React$useState8 = _slicedToArray(_React$useState7, 2), internalInlineCollapsed = _React$useState8[0], setInternalInlineCollapsed = _React$useState8[1];
      reactExports.useEffect(function() {
        setInternalMode(mergedMode);
        setInternalInlineCollapsed(mergedInlineCollapsed);
        if (!mountRef.current) {
          return;
        }
        if (isInlineMode) {
          setMergedOpenKeys(inlineCacheOpenKeys);
        } else {
          triggerOpenKeys(EMPTY_LIST$2);
        }
      }, [mergedMode, mergedInlineCollapsed]);
      var _React$useState9 = reactExports.useState(0), _React$useState10 = _slicedToArray(_React$useState9, 2), lastVisibleIndex = _React$useState10[0], setLastVisibleIndex = _React$useState10[1];
      var allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
      reactExports.useEffect(function() {
        if (isInlineMode) {
          setInlineCacheOpenKeys(mergedOpenKeys);
        }
      }, [mergedOpenKeys]);
      reactExports.useEffect(function() {
        mountRef.current = true;
        return function() {
          mountRef.current = false;
        };
      }, []);
      var _useKeyRecords = useKeyRecords(), registerPath = _useKeyRecords.registerPath, unregisterPath = _useKeyRecords.unregisterPath, refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys, isSubPathKey = _useKeyRecords.isSubPathKey, getKeyPath = _useKeyRecords.getKeyPath, getKeys = _useKeyRecords.getKeys, getSubPathKeys = _useKeyRecords.getSubPathKeys;
      var registerPathContext = reactExports.useMemo(function() {
        return {
          registerPath,
          unregisterPath
        };
      }, [registerPath, unregisterPath]);
      var pathUserContext = reactExports.useMemo(function() {
        return {
          isSubPathKey
        };
      }, [isSubPathKey]);
      reactExports.useEffect(function() {
        refreshOverflowKeys(allVisible ? EMPTY_LIST$2 : childList.slice(lastVisibleIndex + 1).map(function(child) {
          return child.key;
        }));
      }, [lastVisibleIndex, allVisible]);
      var _useMergedState3 = useMergedState(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
        value: activeKey
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedActiveKey = _useMergedState4[0], setMergedActiveKey = _useMergedState4[1];
      var onActive = useMemoCallback(function(key) {
        setMergedActiveKey(key);
      });
      var onInactive = useMemoCallback(function() {
        setMergedActiveKey(void 0);
      });
      reactExports.useImperativeHandle(ref, function() {
        return {
          list: containerRef.current,
          focus: function focus(options2) {
            var _childList$find;
            var keys2 = getKeys();
            var _refreshElements = refreshElements(keys2, uuid2), elements = _refreshElements.elements, key2element = _refreshElements.key2element, element2key = _refreshElements.element2key;
            var focusableElements = getFocusableElements(containerRef.current, elements);
            var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : focusableElements[0] ? element2key.get(focusableElements[0]) : (_childList$find = childList.find(function(node2) {
              return !node2.props.disabled;
            })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
            var elementToFocus = key2element.get(shouldFocusKey);
            if (shouldFocusKey && elementToFocus) {
              var _elementToFocus$focus;
              elementToFocus === null || elementToFocus === void 0 || (_elementToFocus$focus = elementToFocus.focus) === null || _elementToFocus$focus === void 0 || _elementToFocus$focus.call(elementToFocus, options2);
            }
          }
        };
      });
      var _useMergedState5 = useMergedState(defaultSelectedKeys || [], {
        value: selectedKeys,
        // Legacy convert key to array
        postState: function postState(keys2) {
          if (Array.isArray(keys2)) {
            return keys2;
          }
          if (keys2 === null || keys2 === void 0) {
            return EMPTY_LIST$2;
          }
          return [keys2];
        }
      }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedSelectKeys = _useMergedState6[0], setMergedSelectKeys = _useMergedState6[1];
      var triggerSelection = function triggerSelection2(info) {
        if (selectable) {
          var targetKey = info.key;
          var exist = mergedSelectKeys.includes(targetKey);
          var newSelectKeys;
          if (multiple) {
            if (exist) {
              newSelectKeys = mergedSelectKeys.filter(function(key) {
                return key !== targetKey;
              });
            } else {
              newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]);
            }
          } else {
            newSelectKeys = [targetKey];
          }
          setMergedSelectKeys(newSelectKeys);
          var selectInfo = _objectSpread2$3(_objectSpread2$3({}, info), {}, {
            selectedKeys: newSelectKeys
          });
          if (exist) {
            onDeselect === null || onDeselect === void 0 || onDeselect(selectInfo);
          } else {
            onSelect === null || onSelect === void 0 || onSelect(selectInfo);
          }
        }
        if (!multiple && mergedOpenKeys.length && internalMode !== "inline") {
          triggerOpenKeys(EMPTY_LIST$2);
        }
      };
      var onInternalClick = useMemoCallback(function(info) {
        onClick === null || onClick === void 0 || onClick(warnItemProp(info));
        triggerSelection(info);
      });
      var onInternalOpenChange = useMemoCallback(function(key, open2) {
        var newOpenKeys = mergedOpenKeys.filter(function(k2) {
          return k2 !== key;
        });
        if (open2) {
          newOpenKeys.push(key);
        } else if (internalMode !== "inline") {
          var subPathKeys = getSubPathKeys(key);
          newOpenKeys = newOpenKeys.filter(function(k2) {
            return !subPathKeys.has(k2);
          });
        }
        if (!isEqual$1(mergedOpenKeys, newOpenKeys, true)) {
          triggerOpenKeys(newOpenKeys, true);
        }
      });
      var triggerAccessibilityOpen = function triggerAccessibilityOpen2(key, open2) {
        var nextOpen = open2 !== null && open2 !== void 0 ? open2 : !mergedOpenKeys.includes(key);
        onInternalOpenChange(key, nextOpen);
      };
      var onInternalKeyDown = useAccessibility(internalMode, mergedActiveKey, isRtl, uuid2, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown);
      reactExports.useEffect(function() {
        setMounted(true);
      }, []);
      var privateContext = reactExports.useMemo(function() {
        return {
          _internalRenderMenuItem,
          _internalRenderSubMenuItem
        };
      }, [_internalRenderMenuItem, _internalRenderSubMenuItem]);
      var wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : (
        // Need wrap for overflow dropdown that do not response for open
        childList.map(function(child, index2) {
          return (
            // Always wrap provider to avoid sub node re-mount
            /* @__PURE__ */ reactExports.createElement(InheritableContextProvider, {
              key: child.key,
              overflowDisabled: index2 > lastVisibleIndex
            }, child)
          );
        })
      );
      var container = /* @__PURE__ */ reactExports.createElement(ForwardOverflow, _extends$2({
        id,
        ref: containerRef,
        prefixCls: "".concat(prefixCls, "-overflow"),
        component: "ul",
        itemComponent: MenuItem$2,
        className: classNames(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), "".concat(prefixCls, "-rtl"), isRtl), rootClassName),
        dir: direction,
        style: style2,
        role: "menu",
        tabIndex,
        data: wrappedChildList,
        renderRawItem: function renderRawItem(node2) {
          return node2;
        },
        renderRawRest: function renderRawRest(omitItems) {
          var len = omitItems.length;
          var originOmitItems = len ? childList.slice(-len) : null;
          return /* @__PURE__ */ reactExports.createElement(SubMenu$1, {
            eventKey: OVERFLOW_KEY,
            title: overflowedIndicator,
            disabled: allVisible,
            internalPopupClose: len === 0,
            popupClassName: overflowedIndicatorPopupClassName
          }, originOmitItems);
        },
        maxCount: internalMode !== "horizontal" || disabledOverflow ? ForwardOverflow.INVALIDATE : ForwardOverflow.RESPONSIVE,
        ssr: "full",
        "data-menu-list": true,
        onVisibleChange: function onVisibleChange(newLastIndex) {
          setLastVisibleIndex(newLastIndex);
        },
        onKeyDown: onInternalKeyDown
      }, restProps));
      return /* @__PURE__ */ reactExports.createElement(PrivateContext.Provider, {
        value: privateContext
      }, /* @__PURE__ */ reactExports.createElement(IdContext.Provider, {
        value: uuid2
      }, /* @__PURE__ */ reactExports.createElement(InheritableContextProvider, {
        prefixCls,
        rootClassName,
        mode: internalMode,
        openKeys: mergedOpenKeys,
        rtl: isRtl,
        disabled,
        motion: mounted ? motion2 : null,
        defaultMotions: mounted ? defaultMotions : null,
        activeKey: mergedActiveKey,
        onActive,
        onInactive,
        selectedKeys: mergedSelectKeys,
        inlineIndent,
        subMenuOpenDelay,
        subMenuCloseDelay,
        forceSubMenuRender,
        builtinPlacements,
        triggerSubMenuAction,
        getPopupContainer,
        itemIcon,
        expandIcon,
        onItemClick: onInternalClick,
        onOpenChange: onInternalOpenChange
      }, /* @__PURE__ */ reactExports.createElement(PathUserContext.Provider, {
        value: pathUserContext
      }, container), /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          display: "none"
        },
        "aria-hidden": true
      }, /* @__PURE__ */ reactExports.createElement(PathRegisterContext.Provider, {
        value: registerPathContext
      }, measureChildList)))));
    });
    var ExportMenu = Menu$1;
    ExportMenu.Item = MenuItem$2;
    ExportMenu.SubMenu = SubMenu$1;
    ExportMenu.ItemGroup = MenuItemGroup;
    ExportMenu.Divider = Divider$2;
    var BarsOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "bars", "theme": "outlined" };
    var BarsOutlined = function BarsOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: BarsOutlined$1
      }));
    };
    var RefIcon$r = /* @__PURE__ */ reactExports.forwardRef(BarsOutlined);
    const SiderContext = /* @__PURE__ */ reactExports.createContext({});
    var EllipsisOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
    var EllipsisOutlined = function EllipsisOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: EllipsisOutlined$1
      }));
    };
    var RefIcon$q = /* @__PURE__ */ reactExports.forwardRef(EllipsisOutlined);
    const MenuContext = /* @__PURE__ */ reactExports.createContext({
      prefixCls: "",
      firstLevel: true,
      inlineCollapsed: false
    });
    var __rest$H = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const MenuDivider = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        dashed
      } = props, restProps = __rest$H(props, ["prefixCls", "className", "dashed"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("menu", customizePrefixCls);
      const classString = classNames({
        [`${prefixCls}-item-divider-dashed`]: !!dashed
      }, className);
      return /* @__PURE__ */ reactExports.createElement(Divider$2, Object.assign({
        className: classString
      }, restProps));
    };
    const MenuItem = (props) => {
      var _a;
      const {
        className,
        children,
        icon,
        title,
        danger,
        extra
      } = props;
      const {
        prefixCls,
        firstLevel,
        direction,
        disableMenuItemTitleTooltip,
        inlineCollapsed: isInlineCollapsed
      } = reactExports.useContext(MenuContext);
      const renderItemChildren = (inlineCollapsed) => {
        const label = children === null || children === void 0 ? void 0 : children[0];
        const wrapNode = /* @__PURE__ */ reactExports.createElement("span", {
          className: classNames(`${prefixCls}-title-content`, {
            [`${prefixCls}-title-content-with-extra`]: !!extra || extra === 0
          })
        }, children);
        if (!icon || /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "span") {
          if (children && inlineCollapsed && firstLevel && typeof label === "string") {
            return /* @__PURE__ */ reactExports.createElement("div", {
              className: `${prefixCls}-inline-collapsed-noicon`
            }, label.charAt(0));
          }
        }
        return wrapNode;
      };
      const {
        siderCollapsed
      } = reactExports.useContext(SiderContext);
      let tooltipTitle = title;
      if (typeof title === "undefined") {
        tooltipTitle = firstLevel ? children : "";
      } else if (title === false) {
        tooltipTitle = "";
      }
      const tooltipProps = {
        title: tooltipTitle
      };
      if (!siderCollapsed && !isInlineCollapsed) {
        tooltipProps.title = null;
        tooltipProps.open = false;
      }
      const childrenLength = toArray$5(children).length;
      let returnNode = /* @__PURE__ */ reactExports.createElement(MenuItem$2, Object.assign({}, omit(props, ["title", "icon", "danger"]), {
        className: classNames({
          [`${prefixCls}-item-danger`]: danger,
          [`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
        }, className),
        title: typeof title === "string" ? title : void 0
      }), cloneElement(icon, {
        className: classNames(/* @__PURE__ */ reactExports.isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : "", `${prefixCls}-item-icon`)
      }), renderItemChildren(isInlineCollapsed));
      if (!disableMenuItemTitleTooltip) {
        returnNode = /* @__PURE__ */ reactExports.createElement(Tooltip, Object.assign({}, tooltipProps, {
          placement: direction === "rtl" ? "left" : "right",
          classNames: {
            root: `${prefixCls}-inline-collapsed-tooltip`
          }
        }), returnNode);
      }
      return returnNode;
    };
    (function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    });
    const OverrideContext = /* @__PURE__ */ reactExports.createContext(null);
    const getHorizontalStyle = (token2) => {
      const {
        componentCls,
        motionDurationSlow,
        horizontalLineHeight,
        colorSplit,
        lineWidth,
        lineType,
        itemPaddingInline
      } = token2;
      return {
        [`${componentCls}-horizontal`]: {
          lineHeight: horizontalLineHeight,
          border: 0,
          borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
          boxShadow: "none",
          "&::after": {
            display: "block",
            clear: "both",
            height: 0,
            content: '"\\20"'
          },
          // ======================= Item =======================
          [`${componentCls}-item, ${componentCls}-submenu`]: {
            position: "relative",
            display: "inline-block",
            verticalAlign: "bottom",
            paddingInline: itemPaddingInline
          },
          [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
            backgroundColor: "transparent"
          },
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",")
          },
          // ===================== Sub Menu =====================
          [`${componentCls}-submenu-arrow`]: {
            display: "none"
          }
        }
      };
    };
    const getRTLStyle = (_ref) => {
      let {
        componentCls,
        menuArrowOffset,
        calc
      } = _ref;
      return {
        [`${componentCls}-rtl`]: {
          direction: "rtl"
        },
        [`${componentCls}-submenu-rtl`]: {
          transformOrigin: "100% 0"
        },
        // Vertical Arrow
        [`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
          [`${componentCls}-submenu-arrow`]: {
            "&::before": {
              transform: `rotate(-45deg) translateY(${unit$1(calc(menuArrowOffset).mul(-1).equal())})`
            },
            "&::after": {
              transform: `rotate(45deg) translateY(${unit$1(menuArrowOffset)})`
            }
          }
        }
      };
    };
    const accessibilityFocus = (token2) => Object.assign({}, genFocusOutline(token2));
    const getThemeStyle = (token2, themeSuffix) => {
      const {
        componentCls,
        itemColor,
        itemSelectedColor,
        subMenuItemSelectedColor,
        groupTitleColor,
        itemBg,
        subMenuItemBg,
        itemSelectedBg,
        activeBarHeight,
        activeBarWidth,
        activeBarBorderWidth,
        motionDurationSlow,
        motionEaseInOut,
        motionEaseOut,
        itemPaddingInline,
        motionDurationMid,
        itemHoverColor,
        lineType,
        colorSplit,
        // Disabled
        itemDisabledColor,
        // Danger
        dangerItemColor,
        dangerItemHoverColor,
        dangerItemSelectedColor,
        dangerItemActiveBg,
        dangerItemSelectedBg,
        // Bg
        popupBg,
        itemHoverBg,
        itemActiveBg,
        menuSubMenuBg,
        // Horizontal
        horizontalItemSelectedColor,
        horizontalItemSelectedBg,
        horizontalItemBorderRadius,
        horizontalItemHoverBg
      } = token2;
      return {
        [`${componentCls}-${themeSuffix}, ${componentCls}-${themeSuffix} > ${componentCls}`]: {
          color: itemColor,
          background: itemBg,
          [`&${componentCls}-root:focus-visible`]: Object.assign({}, accessibilityFocus(token2)),
          // ======================== Item ========================
          [`${componentCls}-item`]: {
            "&-group-title, &-extra": {
              color: groupTitleColor
            }
          },
          [`${componentCls}-submenu-selected > ${componentCls}-submenu-title`]: {
            color: subMenuItemSelectedColor
          },
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            color: itemColor,
            [`&:not(${componentCls}-item-disabled):focus-visible`]: Object.assign({}, accessibilityFocus(token2))
          },
          // Disabled
          [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
            color: `${itemDisabledColor} !important`
          },
          // Hover
          [`${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
            [`&:hover, > ${componentCls}-submenu-title:hover`]: {
              color: itemHoverColor
            }
          },
          [`&:not(${componentCls}-horizontal)`]: {
            [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
              "&:hover": {
                backgroundColor: itemHoverBg
              },
              "&:active": {
                backgroundColor: itemActiveBg
              }
            },
            [`${componentCls}-submenu-title`]: {
              "&:hover": {
                backgroundColor: itemHoverBg
              },
              "&:active": {
                backgroundColor: itemActiveBg
              }
            }
          },
          // Danger - only Item has
          [`${componentCls}-item-danger`]: {
            color: dangerItemColor,
            [`&${componentCls}-item:hover`]: {
              [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
                color: dangerItemHoverColor
              }
            },
            [`&${componentCls}-item:active`]: {
              background: dangerItemActiveBg
            }
          },
          [`${componentCls}-item a`]: {
            "&, &:hover": {
              color: "inherit"
            }
          },
          [`${componentCls}-item-selected`]: {
            color: itemSelectedColor,
            // Danger
            [`&${componentCls}-item-danger`]: {
              color: dangerItemSelectedColor
            },
            "a, a:hover": {
              color: "inherit"
            }
          },
          [`& ${componentCls}-item-selected`]: {
            backgroundColor: itemSelectedBg,
            // Danger
            [`&${componentCls}-item-danger`]: {
              backgroundColor: dangerItemSelectedBg
            }
          },
          [`&${componentCls}-submenu > ${componentCls}`]: {
            backgroundColor: menuSubMenuBg
          },
          // =====  =======
          // dark popupBg rest  darkPopupBg
          [`&${componentCls}-popup > ${componentCls}`]: {
            backgroundColor: popupBg
          },
          [`&${componentCls}-submenu-popup > ${componentCls}`]: {
            backgroundColor: popupBg
          },
          // =====  end =======
          // ====================== Horizontal ======================
          [`&${componentCls}-horizontal`]: Object.assign(Object.assign({}, themeSuffix === "dark" ? {
            borderBottom: 0
          } : {}), {
            [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
              top: activeBarBorderWidth,
              marginTop: token2.calc(activeBarBorderWidth).mul(-1).equal(),
              marginBottom: 0,
              borderRadius: horizontalItemBorderRadius,
              "&::after": {
                position: "absolute",
                insetInline: itemPaddingInline,
                bottom: 0,
                borderBottom: `${unit$1(activeBarHeight)} solid transparent`,
                transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
                content: '""'
              },
              "&:hover, &-active, &-open": {
                background: horizontalItemHoverBg,
                "&::after": {
                  borderBottomWidth: activeBarHeight,
                  borderBottomColor: horizontalItemSelectedColor
                }
              },
              "&-selected": {
                color: horizontalItemSelectedColor,
                backgroundColor: horizontalItemSelectedBg,
                "&:hover": {
                  backgroundColor: horizontalItemSelectedBg
                },
                "&::after": {
                  borderBottomWidth: activeBarHeight,
                  borderBottomColor: horizontalItemSelectedColor
                }
              }
            }
          }),
          // ================== Inline & Vertical ===================
          //
          [`&${componentCls}-root`]: {
            [`&${componentCls}-inline, &${componentCls}-vertical`]: {
              borderInlineEnd: `${unit$1(activeBarBorderWidth)} ${lineType} ${colorSplit}`
            }
          },
          // ======================== Inline ========================
          [`&${componentCls}-inline`]: {
            // Sub
            [`${componentCls}-sub${componentCls}-inline`]: {
              background: subMenuItemBg
            },
            [`${componentCls}-item`]: {
              position: "relative",
              "&::after": {
                position: "absolute",
                insetBlock: 0,
                insetInlineEnd: 0,
                borderInlineEnd: `${unit$1(activeBarWidth)} solid ${itemSelectedColor}`,
                transform: "scaleY(0.0001)",
                opacity: 0,
                transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
                content: '""'
              },
              // Danger
              [`&${componentCls}-item-danger`]: {
                "&::after": {
                  borderInlineEndColor: dangerItemSelectedColor
                }
              }
            },
            [`${componentCls}-selected, ${componentCls}-item-selected`]: {
              "&::after": {
                transform: "scaleY(1)",
                opacity: 1,
                transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
              }
            }
          }
        }
      };
    };
    const getVerticalInlineStyle = (token2) => {
      const {
        componentCls,
        itemHeight,
        itemMarginInline,
        padding,
        menuArrowSize,
        marginXS,
        itemMarginBlock,
        itemWidth,
        itemPaddingInline
      } = token2;
      const paddingWithArrow = token2.calc(menuArrowSize).add(padding).add(marginXS).equal();
      return {
        [`${componentCls}-item`]: {
          position: "relative",
          overflow: "hidden"
        },
        [`${componentCls}-item, ${componentCls}-submenu-title`]: {
          height: itemHeight,
          lineHeight: unit$1(itemHeight),
          paddingInline: itemPaddingInline,
          overflow: "hidden",
          textOverflow: "ellipsis",
          marginInline: itemMarginInline,
          marginBlock: itemMarginBlock,
          width: itemWidth
        },
        [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
          height: itemHeight,
          lineHeight: unit$1(itemHeight)
        },
        [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
          paddingInlineEnd: paddingWithArrow
        }
      };
    };
    const getVerticalStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        itemHeight,
        colorTextLightSolid,
        dropdownWidth,
        controlHeightLG,
        motionEaseOut,
        paddingXL,
        itemMarginInline,
        fontSizeLG,
        motionDurationFast,
        motionDurationSlow,
        paddingXS,
        boxShadowSecondary,
        collapsedWidth,
        collapsedIconSize
      } = token2;
      const inlineItemStyle = {
        height: itemHeight,
        lineHeight: unit$1(itemHeight),
        listStylePosition: "inside",
        listStyleType: "disc"
      };
      return [
        {
          [componentCls]: {
            "&-inline, &-vertical": Object.assign({
              [`&${componentCls}-root`]: {
                boxShadow: "none"
              }
            }, getVerticalInlineStyle(token2))
          },
          [`${componentCls}-submenu-popup`]: {
            [`${componentCls}-vertical`]: Object.assign(Object.assign({}, getVerticalInlineStyle(token2)), {
              boxShadow: boxShadowSecondary
            })
          }
        },
        // Vertical only
        {
          [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
            minWidth: dropdownWidth,
            maxHeight: `calc(100vh - ${unit$1(token2.calc(controlHeightLG).mul(2.5).equal())})`,
            padding: "0",
            overflow: "hidden",
            borderInlineEnd: 0,
            // https://github.com/ant-design/ant-design/issues/22244
            // https://github.com/ant-design/ant-design/issues/26812
            "&:not([class*='-active'])": {
              overflowX: "hidden",
              overflowY: "auto"
            }
          }
        },
        // Inline Only
        {
          [`${componentCls}-inline`]: {
            width: "100%",
            // Motion enhance for first level
            [`&${componentCls}-root`]: {
              [`${componentCls}-item, ${componentCls}-submenu-title`]: {
                display: "flex",
                alignItems: "center",
                transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationFast} ${motionEaseOut}`].join(","),
                [`> ${componentCls}-title-content`]: {
                  flex: "auto",
                  minWidth: 0,
                  overflow: "hidden",
                  textOverflow: "ellipsis"
                },
                "> *": {
                  flex: "none"
                }
              }
            },
            // >>>>> Sub
            [`${componentCls}-sub${componentCls}-inline`]: {
              padding: 0,
              border: 0,
              borderRadius: 0,
              boxShadow: "none",
              [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
              [`& ${componentCls}-item-group-title`]: {
                paddingInlineStart: paddingXL
              }
            },
            // >>>>> Item
            [`${componentCls}-item`]: inlineItemStyle
          }
        },
        // Inline Collapse Only
        {
          [`${componentCls}-inline-collapsed`]: {
            width: collapsedWidth,
            [`&${componentCls}-root`]: {
              [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
                [`> ${componentCls}-inline-collapsed-noicon`]: {
                  fontSize: fontSizeLG,
                  textAlign: "center"
                }
              }
            },
            [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
              insetInlineStart: 0,
              paddingInline: `calc(50% - ${unit$1(token2.calc(collapsedIconSize).div(2).equal())} - ${unit$1(itemMarginInline)})`,
              textOverflow: "clip",
              [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
                opacity: 0
              },
              [`${componentCls}-item-icon, ${iconCls}`]: {
                margin: 0,
                fontSize: collapsedIconSize,
                lineHeight: unit$1(itemHeight),
                "+ span": {
                  display: "inline-block",
                  opacity: 0
                }
              }
            },
            [`${componentCls}-item-icon, ${iconCls}`]: {
              display: "inline-block"
            },
            "&-tooltip": {
              pointerEvents: "none",
              [`${componentCls}-item-icon, ${iconCls}`]: {
                display: "none"
              },
              "a, a:hover": {
                color: colorTextLightSolid
              }
            },
            [`${componentCls}-item-group-title`]: Object.assign(Object.assign({}, textEllipsis), {
              paddingInline: paddingXS
            })
          }
        }
      ];
    };
    const genMenuItemStyle = (token2) => {
      const {
        componentCls,
        motionDurationSlow,
        motionDurationMid,
        motionEaseInOut,
        motionEaseOut,
        iconCls,
        iconSize,
        iconMarginInlineEnd
      } = token2;
      return {
        // >>>>> Item
        [`${componentCls}-item, ${componentCls}-submenu-title`]: {
          position: "relative",
          display: "block",
          margin: 0,
          whiteSpace: "nowrap",
          cursor: "pointer",
          transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding calc(${motionDurationSlow} + 0.1s) ${motionEaseInOut}`].join(","),
          [`${componentCls}-item-icon, ${iconCls}`]: {
            minWidth: iconSize,
            fontSize: iconSize,
            transition: [`font-size ${motionDurationMid} ${motionEaseOut}`, `margin ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow}`].join(","),
            "+ span": {
              marginInlineStart: iconMarginInlineEnd,
              opacity: 1,
              transition: [`opacity ${motionDurationSlow} ${motionEaseInOut}`, `margin ${motionDurationSlow}`, `color ${motionDurationSlow}`].join(",")
            }
          },
          [`${componentCls}-item-icon`]: Object.assign({}, resetIcon()),
          [`&${componentCls}-item-only-child`]: {
            [`> ${iconCls}, > ${componentCls}-item-icon`]: {
              marginInlineEnd: 0
            }
          }
        },
        // Disabled state sets text to gray and nukes hover/tab effects
        [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
          background: "none !important",
          cursor: "not-allowed",
          "&::after": {
            borderColor: "transparent !important"
          },
          a: {
            color: "inherit !important",
            cursor: "not-allowed",
            pointerEvents: "none"
          },
          [`> ${componentCls}-submenu-title`]: {
            color: "inherit !important",
            cursor: "not-allowed"
          }
        }
      };
    };
    const genSubMenuArrowStyle = (token2) => {
      const {
        componentCls,
        motionDurationSlow,
        motionEaseInOut,
        borderRadius,
        menuArrowSize,
        menuArrowOffset
      } = token2;
      return {
        [`${componentCls}-submenu`]: {
          "&-expand-icon, &-arrow": {
            position: "absolute",
            top: "50%",
            insetInlineEnd: token2.margin,
            width: menuArrowSize,
            color: "currentcolor",
            transform: "translateY(-50%)",
            transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
          },
          "&-arrow": {
            // 
            "&::before, &::after": {
              position: "absolute",
              width: token2.calc(menuArrowSize).mul(0.6).equal(),
              height: token2.calc(menuArrowSize).mul(0.15).equal(),
              backgroundColor: "currentcolor",
              borderRadius,
              transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `transform ${motionDurationSlow} ${motionEaseInOut}`, `top ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow} ${motionEaseInOut}`].join(","),
              content: '""'
            },
            "&::before": {
              transform: `rotate(45deg) translateY(${unit$1(token2.calc(menuArrowOffset).mul(-1).equal())})`
            },
            "&::after": {
              transform: `rotate(-45deg) translateY(${unit$1(menuArrowOffset)})`
            }
          }
        }
      };
    };
    const getBaseStyle = (token2) => {
      const {
        antCls,
        componentCls,
        fontSize,
        motionDurationSlow,
        motionDurationMid,
        motionEaseInOut,
        paddingXS,
        padding,
        colorSplit,
        lineWidth,
        zIndexPopup,
        borderRadiusLG,
        subMenuItemBorderRadius,
        menuArrowSize,
        menuArrowOffset,
        lineType,
        groupTitleLineHeight,
        groupTitleFontSize
      } = token2;
      return [
        // Misc
        {
          "": {
            [componentCls]: Object.assign(Object.assign({}, clearFix()), {
              // Hidden
              "&-hidden": {
                display: "none"
              }
            })
          },
          [`${componentCls}-submenu-hidden`]: {
            display: "none"
          }
        },
        {
          [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), clearFix()), {
            marginBottom: 0,
            paddingInlineStart: 0,
            // Override default ul/ol
            fontSize,
            lineHeight: 0,
            listStyle: "none",
            outline: "none",
            // Magic cubic here but smooth transition
            transition: `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`,
            "ul, ol": {
              margin: 0,
              padding: 0,
              listStyle: "none"
            },
            // Overflow ellipsis
            "&-overflow": {
              display: "flex",
              [`${componentCls}-item`]: {
                flex: "none"
              }
            },
            [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
              borderRadius: token2.itemBorderRadius
            },
            [`${componentCls}-item-group-title`]: {
              padding: `${unit$1(paddingXS)} ${unit$1(padding)}`,
              fontSize: groupTitleFontSize,
              lineHeight: groupTitleLineHeight,
              transition: `all ${motionDurationSlow}`
            },
            [`&-horizontal ${componentCls}-submenu`]: {
              transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",")
            },
            [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
              transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationMid} ${motionEaseInOut}`].join(",")
            },
            [`${componentCls}-submenu ${componentCls}-sub`]: {
              cursor: "initial",
              transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
            },
            [`${componentCls}-title-content`]: {
              transition: `color ${motionDurationSlow}`,
              "&-with-extra": {
                display: "inline-flex",
                alignItems: "center",
                width: "100%"
              },
              // https://github.com/ant-design/ant-design/issues/41143
              [`> ${antCls}-typography-ellipsis-single-line`]: {
                display: "inline",
                verticalAlign: "unset"
              },
              [`${componentCls}-item-extra`]: {
                marginInlineStart: "auto",
                paddingInlineStart: token2.padding
              }
            },
            [`${componentCls}-item a`]: {
              "&::before": {
                position: "absolute",
                inset: 0,
                backgroundColor: "transparent",
                content: '""'
              }
            },
            // Removed a Badge related style seems it's safe
            // https://github.com/ant-design/ant-design/issues/19809
            // >>>>> Divider
            [`${componentCls}-item-divider`]: {
              overflow: "hidden",
              lineHeight: 0,
              borderColor: colorSplit,
              borderStyle: lineType,
              borderWidth: 0,
              borderTopWidth: lineWidth,
              marginBlock: lineWidth,
              padding: 0,
              "&-dashed": {
                borderStyle: "dashed"
              }
            }
          }), genMenuItemStyle(token2)), {
            [`${componentCls}-item-group`]: {
              [`${componentCls}-item-group-list`]: {
                margin: 0,
                padding: 0,
                [`${componentCls}-item, ${componentCls}-submenu-title`]: {
                  paddingInline: `${unit$1(token2.calc(fontSize).mul(2).equal())} ${unit$1(padding)}`
                }
              }
            },
            // ======================= Sub Menu =======================
            "&-submenu": {
              "&-popup": {
                position: "absolute",
                zIndex: zIndexPopup,
                borderRadius: borderRadiusLG,
                boxShadow: "none",
                transformOrigin: "0 0",
                [`&${componentCls}-submenu`]: {
                  background: "transparent"
                },
                // https://github.com/ant-design/ant-design/issues/13955
                "&::before": {
                  position: "absolute",
                  inset: 0,
                  zIndex: -1,
                  width: "100%",
                  height: "100%",
                  opacity: 0,
                  content: '""'
                },
                [`> ${componentCls}`]: Object.assign(Object.assign(Object.assign({
                  borderRadius: borderRadiusLG
                }, genMenuItemStyle(token2)), genSubMenuArrowStyle(token2)), {
                  [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
                    borderRadius: subMenuItemBorderRadius
                  },
                  [`${componentCls}-submenu-title::after`]: {
                    transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
                  }
                })
              },
              [`
          &-placement-leftTop,
          &-placement-bottomRight,
          `]: {
                transformOrigin: "100% 0"
              },
              [`
          &-placement-leftBottom,
          &-placement-topRight,
          `]: {
                transformOrigin: "100% 100%"
              },
              [`
          &-placement-rightBottom,
          &-placement-topLeft,
          `]: {
                transformOrigin: "0 100%"
              },
              [`
          &-placement-bottomLeft,
          &-placement-rightTop,
          `]: {
                transformOrigin: "0 0"
              },
              [`
          &-placement-leftTop,
          &-placement-leftBottom
          `]: {
                paddingInlineEnd: token2.paddingXS
              },
              [`
          &-placement-rightTop,
          &-placement-rightBottom
          `]: {
                paddingInlineStart: token2.paddingXS
              },
              [`
          &-placement-topRight,
          &-placement-topLeft
          `]: {
                paddingBottom: token2.paddingXS
              },
              [`
          &-placement-bottomRight,
          &-placement-bottomLeft
          `]: {
                paddingTop: token2.paddingXS
              }
            }
          }), genSubMenuArrowStyle(token2)), {
            [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
              // 
              "&::before": {
                transform: `rotate(-45deg) translateX(${unit$1(menuArrowOffset)})`
              },
              "&::after": {
                transform: `rotate(45deg) translateX(${unit$1(token2.calc(menuArrowOffset).mul(-1).equal())})`
              }
            },
            [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
              // 
              transform: `translateY(${unit$1(token2.calc(menuArrowSize).mul(0.2).mul(-1).equal())})`,
              "&::after": {
                transform: `rotate(-45deg) translateX(${unit$1(token2.calc(menuArrowOffset).mul(-1).equal())})`
              },
              "&::before": {
                transform: `rotate(45deg) translateX(${unit$1(menuArrowOffset)})`
              }
            }
          })
        },
        // Integration with header element so menu items have the same height
        {
          [`${antCls}-layout-header`]: {
            [componentCls]: {
              lineHeight: "inherit"
            }
          }
        }
      ];
    };
    const prepareComponentToken$f = (token2) => {
      var _a, _b, _c;
      const {
        colorPrimary,
        colorError,
        colorTextDisabled,
        colorErrorBg,
        colorText,
        colorTextDescription,
        colorBgContainer,
        colorFillAlter,
        colorFillContent,
        lineWidth,
        lineWidthBold,
        controlItemBgActive,
        colorBgTextHover,
        controlHeightLG,
        lineHeight,
        colorBgElevated,
        marginXXS,
        padding,
        fontSize,
        controlHeightSM,
        fontSizeLG,
        colorTextLightSolid,
        colorErrorHover
      } = token2;
      const activeBarWidth = (_a = token2.activeBarWidth) !== null && _a !== void 0 ? _a : 0;
      const activeBarBorderWidth = (_b = token2.activeBarBorderWidth) !== null && _b !== void 0 ? _b : lineWidth;
      const itemMarginInline = (_c = token2.itemMarginInline) !== null && _c !== void 0 ? _c : token2.marginXXS;
      const colorTextDark = new FastColor(colorTextLightSolid).setA(0.65).toRgbString();
      return {
        dropdownWidth: 160,
        zIndexPopup: token2.zIndexPopupBase + 50,
        radiusItem: token2.borderRadiusLG,
        itemBorderRadius: token2.borderRadiusLG,
        radiusSubMenuItem: token2.borderRadiusSM,
        subMenuItemBorderRadius: token2.borderRadiusSM,
        colorItemText: colorText,
        itemColor: colorText,
        colorItemTextHover: colorText,
        itemHoverColor: colorText,
        colorItemTextHoverHorizontal: colorPrimary,
        horizontalItemHoverColor: colorPrimary,
        colorGroupTitle: colorTextDescription,
        groupTitleColor: colorTextDescription,
        colorItemTextSelected: colorPrimary,
        itemSelectedColor: colorPrimary,
        subMenuItemSelectedColor: colorPrimary,
        colorItemTextSelectedHorizontal: colorPrimary,
        horizontalItemSelectedColor: colorPrimary,
        colorItemBg: colorBgContainer,
        itemBg: colorBgContainer,
        colorItemBgHover: colorBgTextHover,
        itemHoverBg: colorBgTextHover,
        colorItemBgActive: colorFillContent,
        itemActiveBg: controlItemBgActive,
        colorSubItemBg: colorFillAlter,
        subMenuItemBg: colorFillAlter,
        colorItemBgSelected: controlItemBgActive,
        itemSelectedBg: controlItemBgActive,
        colorItemBgSelectedHorizontal: "transparent",
        horizontalItemSelectedBg: "transparent",
        colorActiveBarWidth: 0,
        activeBarWidth,
        colorActiveBarHeight: lineWidthBold,
        activeBarHeight: lineWidthBold,
        colorActiveBarBorderSize: lineWidth,
        activeBarBorderWidth,
        // Disabled
        colorItemTextDisabled: colorTextDisabled,
        itemDisabledColor: colorTextDisabled,
        // Danger
        colorDangerItemText: colorError,
        dangerItemColor: colorError,
        colorDangerItemTextHover: colorError,
        dangerItemHoverColor: colorError,
        colorDangerItemTextSelected: colorError,
        dangerItemSelectedColor: colorError,
        colorDangerItemBgActive: colorErrorBg,
        dangerItemActiveBg: colorErrorBg,
        colorDangerItemBgSelected: colorErrorBg,
        dangerItemSelectedBg: colorErrorBg,
        itemMarginInline,
        horizontalItemBorderRadius: 0,
        horizontalItemHoverBg: "transparent",
        itemHeight: controlHeightLG,
        groupTitleLineHeight: lineHeight,
        collapsedWidth: controlHeightLG * 2,
        popupBg: colorBgElevated,
        itemMarginBlock: marginXXS,
        itemPaddingInline: padding,
        horizontalLineHeight: `${controlHeightLG * 1.15}px`,
        iconSize: fontSize,
        iconMarginInlineEnd: controlHeightSM - fontSize,
        collapsedIconSize: fontSizeLG,
        groupTitleFontSize: fontSize,
        // Disabled
        darkItemDisabledColor: new FastColor(colorTextLightSolid).setA(0.25).toRgbString(),
        // Dark
        darkItemColor: colorTextDark,
        darkDangerItemColor: colorError,
        darkItemBg: "#001529",
        darkPopupBg: "#001529",
        darkSubMenuItemBg: "#000c17",
        darkItemSelectedColor: colorTextLightSolid,
        darkItemSelectedBg: colorPrimary,
        darkDangerItemSelectedBg: colorError,
        darkItemHoverBg: "transparent",
        darkGroupTitleColor: colorTextDark,
        darkItemHoverColor: colorTextLightSolid,
        darkDangerItemHoverColor: colorErrorHover,
        darkDangerItemSelectedColor: colorTextLightSolid,
        darkDangerItemActiveBg: colorError,
        // internal
        itemWidth: activeBarWidth ? `calc(100% + ${activeBarBorderWidth}px)` : `calc(100% - ${itemMarginInline * 2}px)`
      };
    };
    const useStyle$j = function(prefixCls) {
      let rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
      let injectStyle = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      const useStyle2 = genStyleHooks("Menu", (token2) => {
        const {
          colorBgElevated,
          controlHeightLG,
          fontSize,
          darkItemColor,
          darkDangerItemColor,
          darkItemBg,
          darkSubMenuItemBg,
          darkItemSelectedColor,
          darkItemSelectedBg,
          darkDangerItemSelectedBg,
          darkItemHoverBg,
          darkGroupTitleColor,
          darkItemHoverColor,
          darkItemDisabledColor,
          darkDangerItemHoverColor,
          darkDangerItemSelectedColor,
          darkDangerItemActiveBg,
          popupBg,
          darkPopupBg
        } = token2;
        const menuArrowSize = token2.calc(fontSize).div(7).mul(5).equal();
        const menuToken = merge(token2, {
          menuArrowSize,
          menuHorizontalHeight: token2.calc(controlHeightLG).mul(1.15).equal(),
          menuArrowOffset: token2.calc(menuArrowSize).mul(0.25).equal(),
          menuSubMenuBg: colorBgElevated,
          calc: token2.calc,
          popupBg
        });
        const menuDarkToken = merge(menuToken, {
          itemColor: darkItemColor,
          itemHoverColor: darkItemHoverColor,
          groupTitleColor: darkGroupTitleColor,
          itemSelectedColor: darkItemSelectedColor,
          subMenuItemSelectedColor: darkItemSelectedColor,
          itemBg: darkItemBg,
          popupBg: darkPopupBg,
          subMenuItemBg: darkSubMenuItemBg,
          itemActiveBg: "transparent",
          itemSelectedBg: darkItemSelectedBg,
          activeBarHeight: 0,
          activeBarBorderWidth: 0,
          itemHoverBg: darkItemHoverBg,
          // Disabled
          itemDisabledColor: darkItemDisabledColor,
          // Danger
          dangerItemColor: darkDangerItemColor,
          dangerItemHoverColor: darkDangerItemHoverColor,
          dangerItemSelectedColor: darkDangerItemSelectedColor,
          dangerItemActiveBg: darkDangerItemActiveBg,
          dangerItemSelectedBg: darkDangerItemSelectedBg,
          menuSubMenuBg: darkSubMenuItemBg,
          // Horizontal
          horizontalItemSelectedColor: darkItemSelectedColor,
          horizontalItemSelectedBg: darkItemSelectedBg
        });
        return [
          // Basic
          getBaseStyle(menuToken),
          // Horizontal
          getHorizontalStyle(menuToken),
          // Hard code for some light style
          // Vertical
          getVerticalStyle(menuToken),
          // Hard code for some light style
          // Theme
          getThemeStyle(menuToken, "light"),
          getThemeStyle(menuDarkToken, "dark"),
          // RTL
          getRTLStyle(menuToken),
          // Motion
          genCollapseMotion(menuToken),
          initSlideMotion(menuToken, "slide-up"),
          initSlideMotion(menuToken, "slide-down"),
          initZoomMotion(menuToken, "zoom-big")
        ];
      }, prepareComponentToken$f, {
        deprecatedTokens: [["colorGroupTitle", "groupTitleColor"], ["radiusItem", "itemBorderRadius"], ["radiusSubMenuItem", "subMenuItemBorderRadius"], ["colorItemText", "itemColor"], ["colorItemTextHover", "itemHoverColor"], ["colorItemTextHoverHorizontal", "horizontalItemHoverColor"], ["colorItemTextSelected", "itemSelectedColor"], ["colorItemTextSelectedHorizontal", "horizontalItemSelectedColor"], ["colorItemTextDisabled", "itemDisabledColor"], ["colorDangerItemText", "dangerItemColor"], ["colorDangerItemTextHover", "dangerItemHoverColor"], ["colorDangerItemTextSelected", "dangerItemSelectedColor"], ["colorDangerItemBgActive", "dangerItemActiveBg"], ["colorDangerItemBgSelected", "dangerItemSelectedBg"], ["colorItemBg", "itemBg"], ["colorItemBgHover", "itemHoverBg"], ["colorSubItemBg", "subMenuItemBg"], ["colorItemBgActive", "itemActiveBg"], ["colorItemBgSelectedHorizontal", "horizontalItemSelectedBg"], ["colorActiveBarWidth", "activeBarWidth"], ["colorActiveBarHeight", "activeBarHeight"], ["colorActiveBarBorderSize", "activeBarBorderWidth"], ["colorItemBgSelected", "itemSelectedBg"]],
        // Dropdown will handle menu style self. We do not need to handle this.
        injectStyle,
        unitless: {
          groupTitleLineHeight: true
        }
      });
      return useStyle2(prefixCls, rootCls);
    };
    const SubMenu = (props) => {
      var _a;
      const {
        popupClassName,
        icon,
        title,
        theme: customTheme
      } = props;
      const context = reactExports.useContext(MenuContext);
      const {
        prefixCls,
        inlineCollapsed,
        theme: contextTheme
      } = context;
      const parentPath = useFullPath();
      let titleNode;
      if (!icon) {
        titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-inline-collapsed-noicon`
        }, title.charAt(0)) : /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-title-content`
        }, title);
      } else {
        const titleIsSpan = /* @__PURE__ */ reactExports.isValidElement(title) && title.type === "span";
        titleNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, cloneElement(icon, {
          className: classNames(/* @__PURE__ */ reactExports.isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : "", `${prefixCls}-item-icon`)
        }), titleIsSpan ? title : /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-title-content`
        }, title));
      }
      const contextValue = reactExports.useMemo(() => Object.assign(Object.assign({}, context), {
        firstLevel: false
      }), [context]);
      const [zIndex] = useZIndex("Menu");
      return /* @__PURE__ */ reactExports.createElement(MenuContext.Provider, {
        value: contextValue
      }, /* @__PURE__ */ reactExports.createElement(SubMenu$1, Object.assign({}, omit(props, ["icon"]), {
        title: titleNode,
        popupClassName: classNames(prefixCls, popupClassName, `${prefixCls}-${customTheme || contextTheme}`),
        popupStyle: Object.assign({
          zIndex
        }, props.popupStyle)
      })));
    };
    var __rest$G = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function isEmptyIcon(icon) {
      return icon === null || icon === false;
    }
    const MENU_COMPONENTS = {
      item: MenuItem,
      submenu: SubMenu,
      divider: MenuDivider
    };
    const InternalMenu = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a;
      const override = reactExports.useContext(OverrideContext);
      const overrideObj = override || {};
      const {
        getPrefixCls,
        getPopupContainer,
        direction,
        menu
      } = reactExports.useContext(ConfigContext);
      const rootPrefixCls = getPrefixCls();
      const {
        prefixCls: customizePrefixCls,
        className,
        style: style2,
        theme = "light",
        expandIcon,
        _internalDisableMenuItemTitleTooltip,
        inlineCollapsed,
        siderCollapsed,
        rootClassName,
        mode,
        selectable,
        onClick,
        overflowedIndicatorPopupClassName
      } = props, restProps = __rest$G(props, ["prefixCls", "className", "style", "theme", "expandIcon", "_internalDisableMenuItemTitleTooltip", "inlineCollapsed", "siderCollapsed", "rootClassName", "mode", "selectable", "onClick", "overflowedIndicatorPopupClassName"]);
      const passedProps = omit(restProps, ["collapsedWidth"]);
      (_a = overrideObj.validator) === null || _a === void 0 ? void 0 : _a.call(overrideObj, {
        mode
      });
      const onItemClick = useEvent(function() {
        var _a2;
        onClick === null || onClick === void 0 ? void 0 : onClick.apply(void 0, arguments);
        (_a2 = overrideObj.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(overrideObj);
      });
      const mergedMode = overrideObj.mode || mode;
      const mergedSelectable = selectable !== null && selectable !== void 0 ? selectable : overrideObj.selectable;
      const mergedInlineCollapsed = inlineCollapsed !== null && inlineCollapsed !== void 0 ? inlineCollapsed : siderCollapsed;
      const defaultMotions = {
        horizontal: {
          motionName: `${rootPrefixCls}-slide-up`
        },
        inline: initCollapseMotion(rootPrefixCls),
        other: {
          motionName: `${rootPrefixCls}-zoom-big`
        }
      };
      const prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls);
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$j(prefixCls, rootCls, !override);
      const menuClassName = classNames(`${prefixCls}-${theme}`, menu === null || menu === void 0 ? void 0 : menu.className, className);
      const mergedExpandIcon = reactExports.useMemo(() => {
        var _a2, _b;
        if (typeof expandIcon === "function" || isEmptyIcon(expandIcon)) {
          return expandIcon || null;
        }
        if (typeof overrideObj.expandIcon === "function" || isEmptyIcon(overrideObj.expandIcon)) {
          return overrideObj.expandIcon || null;
        }
        if (typeof (menu === null || menu === void 0 ? void 0 : menu.expandIcon) === "function" || isEmptyIcon(menu === null || menu === void 0 ? void 0 : menu.expandIcon)) {
          return (menu === null || menu === void 0 ? void 0 : menu.expandIcon) || null;
        }
        const mergedIcon = (_a2 = expandIcon !== null && expandIcon !== void 0 ? expandIcon : overrideObj === null || overrideObj === void 0 ? void 0 : overrideObj.expandIcon) !== null && _a2 !== void 0 ? _a2 : menu === null || menu === void 0 ? void 0 : menu.expandIcon;
        return cloneElement(mergedIcon, {
          className: classNames(`${prefixCls}-submenu-expand-icon`, /* @__PURE__ */ reactExports.isValidElement(mergedIcon) ? (_b = mergedIcon.props) === null || _b === void 0 ? void 0 : _b.className : void 0)
        });
      }, [expandIcon, overrideObj === null || overrideObj === void 0 ? void 0 : overrideObj.expandIcon, menu === null || menu === void 0 ? void 0 : menu.expandIcon, prefixCls]);
      const contextValue = reactExports.useMemo(() => ({
        prefixCls,
        inlineCollapsed: mergedInlineCollapsed || false,
        direction,
        firstLevel: true,
        theme,
        mode: mergedMode,
        disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip
      }), [prefixCls, mergedInlineCollapsed, direction, _internalDisableMenuItemTitleTooltip, theme]);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(OverrideContext.Provider, {
        value: null
      }, /* @__PURE__ */ reactExports.createElement(MenuContext.Provider, {
        value: contextValue
      }, /* @__PURE__ */ reactExports.createElement(ExportMenu, Object.assign({
        getPopupContainer,
        overflowedIndicator: /* @__PURE__ */ reactExports.createElement(RefIcon$q, null),
        overflowedIndicatorPopupClassName: classNames(prefixCls, `${prefixCls}-${theme}`, overflowedIndicatorPopupClassName),
        mode: mergedMode,
        selectable: mergedSelectable,
        onClick: onItemClick
      }, passedProps, {
        inlineCollapsed: mergedInlineCollapsed,
        style: Object.assign(Object.assign({}, menu === null || menu === void 0 ? void 0 : menu.style), style2),
        className: menuClassName,
        prefixCls,
        direction,
        defaultMotions,
        expandIcon: mergedExpandIcon,
        ref,
        rootClassName: classNames(rootClassName, hashId, overrideObj.rootClassName, cssVarCls, rootCls),
        _internalComponents: MENU_COMPONENTS
      })))));
    });
    const Menu = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const menuRef = reactExports.useRef(null);
      const context = reactExports.useContext(SiderContext);
      reactExports.useImperativeHandle(ref, () => ({
        menu: menuRef.current,
        focus: (options2) => {
          var _a;
          (_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.focus(options2);
        }
      }));
      return /* @__PURE__ */ reactExports.createElement(InternalMenu, Object.assign({
        ref: menuRef
      }, props, context));
    });
    Menu.Item = MenuItem;
    Menu.SubMenu = SubMenu;
    Menu.Divider = MenuDivider;
    Menu.ItemGroup = MenuItemGroup;
    var dayjs_min = { exports: {} };
    (function(module2, exports2) {
      !function(t2, e2) {
        module2.exports = e2();
      }(commonjsGlobal, function() {
        var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s = "minute", u2 = "hour", a = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
          var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
          return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
        } }, m2 = function(t3, e3, n3) {
          var r3 = String(t3);
          return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
        }, v2 = { s: m2, z: function(t3) {
          var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
          return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
        }, m: function t3(e3, n3) {
          if (e3.date() < n3.date()) return -t3(n3, e3);
          var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s2 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s2 ? -1 : 1), c2);
          return +(-(r3 + (n3 - i3) / (s2 ? i3 - u3 : u3 - i3)) || 0);
        }, a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function(t3) {
          return { M: c2, y: h2, w: o2, d: a, D: d2, h: u2, m: s, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t3) {
          return void 0 === t3;
        } }, g2 = "en", D2 = {};
        D2[g2] = M2;
        var p2 = "$isDayjsObject", S = function(t3) {
          return t3 instanceof _2 || !(!t3 || !t3[p2]);
        }, w2 = function t3(e3, n3, r3) {
          var i3;
          if (!e3) return g2;
          if ("string" == typeof e3) {
            var s2 = e3.toLowerCase();
            D2[s2] && (i3 = s2), n3 && (D2[s2] = n3, i3 = s2);
            var u3 = e3.split("-");
            if (!i3 && u3.length > 1) return t3(u3[0]);
          } else {
            var a2 = e3.name;
            D2[a2] = e3, i3 = a2;
          }
          return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
        }, O = function(t3, e3) {
          if (S(t3)) return t3.clone();
          var n3 = "object" == typeof e3 ? e3 : {};
          return n3.date = t3, n3.args = arguments, new _2(n3);
        }, b2 = v2;
        b2.l = w2, b2.i = S, b2.w = function(t3, e3) {
          return O(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
        };
        var _2 = function() {
          function M3(t3) {
            this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
          }
          var m3 = M3.prototype;
          return m3.parse = function(t3) {
            this.$d = function(t4) {
              var e3 = t4.date, n3 = t4.utc;
              if (null === e3) return /* @__PURE__ */ new Date(NaN);
              if (b2.u(e3)) return /* @__PURE__ */ new Date();
              if (e3 instanceof Date) return new Date(e3);
              if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                var r3 = e3.match($2);
                if (r3) {
                  var i3 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                  return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
                }
              }
              return new Date(e3);
            }(t3), this.init();
          }, m3.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, m3.$utils = function() {
            return b2;
          }, m3.isValid = function() {
            return !(this.$d.toString() === l2);
          }, m3.isSame = function(t3, e3) {
            var n3 = O(t3);
            return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
          }, m3.isAfter = function(t3, e3) {
            return O(t3) < this.startOf(e3);
          }, m3.isBefore = function(t3, e3) {
            return this.endOf(e3) < O(t3);
          }, m3.$g = function(t3, e3, n3) {
            return b2.u(t3) ? this[e3] : this.set(n3, t3);
          }, m3.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m3.valueOf = function() {
            return this.$d.getTime();
          }, m3.startOf = function(t3, e3) {
            var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
              var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
              return r3 ? i3 : i3.endOf(a);
            }, $3 = function(t4, e4) {
              return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
            }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
            switch (f3) {
              case h2:
                return r3 ? l3(1, 0) : l3(31, 11);
              case c2:
                return r3 ? l3(1, M4) : l3(0, M4 + 1);
              case o2:
                var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
                return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
              case a:
              case d2:
                return $3(v3 + "Hours", 0);
              case u2:
                return $3(v3 + "Minutes", 1);
              case s:
                return $3(v3 + "Seconds", 2);
              case i2:
                return $3(v3 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m3.endOf = function(t3) {
            return this.startOf(t3, false);
          }, m3.$set = function(t3, e3) {
            var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $3 = o3 === a ? this.$D + (e3 - this.$W) : e3;
            if (o3 === c2 || o3 === h2) {
              var y3 = this.clone().set(d2, 1);
              y3.$d[l3]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
            } else l3 && this.$d[l3]($3);
            return this.init(), this;
          }, m3.set = function(t3, e3) {
            return this.clone().$set(t3, e3);
          }, m3.get = function(t3) {
            return this[b2.p(t3)]();
          }, m3.add = function(r3, f3) {
            var d3, l3 = this;
            r3 = Number(r3);
            var $3 = b2.p(f3), y3 = function(t3) {
              var e3 = O(l3);
              return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
            };
            if ($3 === c2) return this.set(c2, this.$M + r3);
            if ($3 === h2) return this.set(h2, this.$y + r3);
            if ($3 === a) return y3(1);
            if ($3 === o2) return y3(7);
            var M4 = (d3 = {}, d3[s] = e2, d3[u2] = n2, d3[i2] = t2, d3)[$3] || 1, m4 = this.$d.getTime() + r3 * M4;
            return b2.w(m4, this);
          }, m3.subtract = function(t3, e3) {
            return this.add(-1 * t3, e3);
          }, m3.format = function(t3) {
            var e3 = this, n3 = this.$locale();
            if (!this.isValid()) return n3.invalidDate || l2;
            var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s2 = this.$H, u3 = this.$m, a2 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s3) {
              return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s3);
            }, d3 = function(t4) {
              return b2.s(s2 % 12 || 12, t4, "0");
            }, $3 = f3 || function(t4, e4, n4) {
              var r4 = t4 < 12 ? "AM" : "PM";
              return n4 ? r4.toLowerCase() : r4;
            };
            return r3.replace(y2, function(t4, r4) {
              return r4 || function(t5) {
                switch (t5) {
                  case "YY":
                    return String(e3.$y).slice(-2);
                  case "YYYY":
                    return b2.s(e3.$y, 4, "0");
                  case "M":
                    return a2 + 1;
                  case "MM":
                    return b2.s(a2 + 1, 2, "0");
                  case "MMM":
                    return h3(n3.monthsShort, a2, c3, 3);
                  case "MMMM":
                    return h3(c3, a2);
                  case "D":
                    return e3.$D;
                  case "DD":
                    return b2.s(e3.$D, 2, "0");
                  case "d":
                    return String(e3.$W);
                  case "dd":
                    return h3(n3.weekdaysMin, e3.$W, o3, 2);
                  case "ddd":
                    return h3(n3.weekdaysShort, e3.$W, o3, 3);
                  case "dddd":
                    return o3[e3.$W];
                  case "H":
                    return String(s2);
                  case "HH":
                    return b2.s(s2, 2, "0");
                  case "h":
                    return d3(1);
                  case "hh":
                    return d3(2);
                  case "a":
                    return $3(s2, u3, true);
                  case "A":
                    return $3(s2, u3, false);
                  case "m":
                    return String(u3);
                  case "mm":
                    return b2.s(u3, 2, "0");
                  case "s":
                    return String(e3.$s);
                  case "ss":
                    return b2.s(e3.$s, 2, "0");
                  case "SSS":
                    return b2.s(e3.$ms, 3, "0");
                  case "Z":
                    return i3;
                }
                return null;
              }(t4) || i3.replace(":", "");
            });
          }, m3.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m3.diff = function(r3, d3, l3) {
            var $3, y3 = this, M4 = b2.p(d3), m4 = O(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
              return b2.m(y3, m4);
            };
            switch (M4) {
              case h2:
                $3 = D3() / 12;
                break;
              case c2:
                $3 = D3();
                break;
              case f2:
                $3 = D3() / 3;
                break;
              case o2:
                $3 = (g3 - v3) / 6048e5;
                break;
              case a:
                $3 = (g3 - v3) / 864e5;
                break;
              case u2:
                $3 = g3 / n2;
                break;
              case s:
                $3 = g3 / e2;
                break;
              case i2:
                $3 = g3 / t2;
                break;
              default:
                $3 = g3;
            }
            return l3 ? $3 : b2.a($3);
          }, m3.daysInMonth = function() {
            return this.endOf(c2).$D;
          }, m3.$locale = function() {
            return D2[this.$L];
          }, m3.locale = function(t3, e3) {
            if (!t3) return this.$L;
            var n3 = this.clone(), r3 = w2(t3, e3, true);
            return r3 && (n3.$L = r3), n3;
          }, m3.clone = function() {
            return b2.w(this.$d, this);
          }, m3.toDate = function() {
            return new Date(this.valueOf());
          }, m3.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m3.toISOString = function() {
            return this.$d.toISOString();
          }, m3.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), k2 = _2.prototype;
        return O.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s], ["$H", u2], ["$W", a], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
          k2[t3[1]] = function(e3) {
            return this.$g(e3, t3[0], t3[1]);
          };
        }), O.extend = function(t3, e3) {
          return t3.$i || (t3(e3, _2, O), t3.$i = true), O;
        }, O.locale = w2, O.isDayjs = S, O.unix = function(t3) {
          return O(1e3 * t3);
        }, O.en = D2[g2], O.Ls = D2, O.p = {}, O;
      });
    })(dayjs_min);
    var dayjs_minExports = dayjs_min.exports;
    const N = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
    var weekday$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        return function(e2, t2) {
          t2.prototype.weekday = function(e3) {
            var t3 = this.$locale().weekStart || 0, i2 = this.$W, n2 = (i2 < t3 ? i2 + 7 : i2) - t3;
            return this.$utils().u(e3) ? n2 : this.subtract(n2, "day").add(e3, "day");
          };
        };
      });
    })(weekday$1);
    var weekdayExports = weekday$1.exports;
    const weekday = /* @__PURE__ */ getDefaultExportFromCjs(weekdayExports);
    var localeData$1 = { exports: {} };
    (function(module2, exports2) {
      !function(n2, e2) {
        module2.exports = e2();
      }(commonjsGlobal, function() {
        return function(n2, e2, t2) {
          var r2 = e2.prototype, o2 = function(n3) {
            return n3 && (n3.indexOf ? n3 : n3.s);
          }, u2 = function(n3, e3, t3, r3, u3) {
            var i3 = n3.name ? n3 : n3.$locale(), a2 = o2(i3[e3]), s2 = o2(i3[t3]), f2 = a2 || s2.map(function(n4) {
              return n4.slice(0, r3);
            });
            if (!u3) return f2;
            var d2 = i3.weekStart;
            return f2.map(function(n4, e4) {
              return f2[(e4 + (d2 || 0)) % 7];
            });
          }, i2 = function() {
            return t2.Ls[t2.locale()];
          }, a = function(n3, e3) {
            return n3.formats[e3] || function(n4) {
              return n4.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n5, e4, t3) {
                return e4 || t3.slice(1);
              });
            }(n3.formats[e3.toUpperCase()]);
          }, s = function() {
            var n3 = this;
            return { months: function(e3) {
              return e3 ? e3.format("MMMM") : u2(n3, "months");
            }, monthsShort: function(e3) {
              return e3 ? e3.format("MMM") : u2(n3, "monthsShort", "months", 3);
            }, firstDayOfWeek: function() {
              return n3.$locale().weekStart || 0;
            }, weekdays: function(e3) {
              return e3 ? e3.format("dddd") : u2(n3, "weekdays");
            }, weekdaysMin: function(e3) {
              return e3 ? e3.format("dd") : u2(n3, "weekdaysMin", "weekdays", 2);
            }, weekdaysShort: function(e3) {
              return e3 ? e3.format("ddd") : u2(n3, "weekdaysShort", "weekdays", 3);
            }, longDateFormat: function(e3) {
              return a(n3.$locale(), e3);
            }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
          };
          r2.localeData = function() {
            return s.bind(this)();
          }, t2.localeData = function() {
            var n3 = i2();
            return { firstDayOfWeek: function() {
              return n3.weekStart || 0;
            }, weekdays: function() {
              return t2.weekdays();
            }, weekdaysShort: function() {
              return t2.weekdaysShort();
            }, weekdaysMin: function() {
              return t2.weekdaysMin();
            }, months: function() {
              return t2.months();
            }, monthsShort: function() {
              return t2.monthsShort();
            }, longDateFormat: function(e3) {
              return a(n3, e3);
            }, meridiem: n3.meridiem, ordinal: n3.ordinal };
          }, t2.months = function() {
            return u2(i2(), "months");
          }, t2.monthsShort = function() {
            return u2(i2(), "monthsShort", "months", 3);
          }, t2.weekdays = function(n3) {
            return u2(i2(), "weekdays", null, null, n3);
          }, t2.weekdaysShort = function(n3) {
            return u2(i2(), "weekdaysShort", "weekdays", 3, n3);
          }, t2.weekdaysMin = function(n3) {
            return u2(i2(), "weekdaysMin", "weekdays", 2, n3);
          };
        };
      });
    })(localeData$1);
    var localeDataExports = localeData$1.exports;
    const localeData = /* @__PURE__ */ getDefaultExportFromCjs(localeDataExports);
    var weekOfYear$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = "week", t2 = "year";
        return function(i2, n2, r2) {
          var f2 = n2.prototype;
          f2.week = function(i3) {
            if (void 0 === i3 && (i3 = null), null !== i3) return this.add(7 * (i3 - this.week()), "day");
            var n3 = this.$locale().yearStart || 1;
            if (11 === this.month() && this.date() > 25) {
              var f3 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e2);
              if (f3.isBefore(s)) return 1;
            }
            var a = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o2 = this.diff(a, e2, true);
            return o2 < 0 ? r2(this).startOf("week").week() : Math.ceil(o2);
          }, f2.weeks = function(e3) {
            return void 0 === e3 && (e3 = null), this.week(e3);
          };
        };
      });
    })(weekOfYear$1);
    var weekOfYearExports = weekOfYear$1.exports;
    const weekOfYear = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
    var weekYear$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        return function(e2, t2) {
          t2.prototype.weekYear = function() {
            var e3 = this.month(), t3 = this.week(), n2 = this.year();
            return 1 === t3 && 11 === e3 ? n2 + 1 : 0 === e3 && t3 >= 52 ? n2 - 1 : n2;
          };
        };
      });
    })(weekYear$1);
    var weekYearExports = weekYear$1.exports;
    const weekYear = /* @__PURE__ */ getDefaultExportFromCjs(weekYearExports);
    var advancedFormat$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        return function(e2, t2) {
          var r2 = t2.prototype, n2 = r2.format;
          r2.format = function(e3) {
            var t3 = this, r3 = this.$locale();
            if (!this.isValid()) return n2.bind(this)(e3);
            var s = this.$utils(), a = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
              switch (e4) {
                case "Q":
                  return Math.ceil((t3.$M + 1) / 3);
                case "Do":
                  return r3.ordinal(t3.$D);
                case "gggg":
                  return t3.weekYear();
                case "GGGG":
                  return t3.isoWeekYear();
                case "wo":
                  return r3.ordinal(t3.week(), "W");
                case "w":
                case "ww":
                  return s.s(t3.week(), "w" === e4 ? 1 : 2, "0");
                case "W":
                case "WW":
                  return s.s(t3.isoWeek(), "W" === e4 ? 1 : 2, "0");
                case "k":
                case "kk":
                  return s.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e4 ? 1 : 2, "0");
                case "X":
                  return Math.floor(t3.$d.getTime() / 1e3);
                case "x":
                  return t3.$d.getTime();
                case "z":
                  return "[" + t3.offsetName() + "]";
                case "zzz":
                  return "[" + t3.offsetName("long") + "]";
                default:
                  return e4;
              }
            });
            return n2.bind(this)(a);
          };
        };
      });
    })(advancedFormat$1);
    var advancedFormatExports = advancedFormat$1.exports;
    const advancedFormat = /* @__PURE__ */ getDefaultExportFromCjs(advancedFormatExports);
    var customParseFormat$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d/, r2 = /\d\d/, i2 = /\d\d?/, o2 = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e3) {
          return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
        };
        var f2 = function(e3) {
          return function(t3) {
            this[e3] = +t3;
          };
        }, h2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
          (this.zone || (this.zone = {})).offset = function(e4) {
            if (!e4) return 0;
            if ("Z" === e4) return 0;
            var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
            return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
          }(e3);
        }], u2 = function(e3) {
          var t3 = s[e3];
          return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
        }, d2 = function(e3, t3) {
          var n3, r3 = s.meridiem;
          if (r3) {
            for (var i3 = 1; i3 <= 24; i3 += 1) if (e3.indexOf(r3(i3, 0, t3)) > -1) {
              n3 = i3 > 12;
              break;
            }
          } else n3 = e3 === (t3 ? "pm" : "PM");
          return n3;
        }, c2 = { A: [o2, function(e3) {
          this.afternoon = d2(e3, false);
        }], a: [o2, function(e3) {
          this.afternoon = d2(e3, true);
        }], Q: [n2, function(e3) {
          this.month = 3 * (e3 - 1) + 1;
        }], S: [n2, function(e3) {
          this.milliseconds = 100 * +e3;
        }], SS: [r2, function(e3) {
          this.milliseconds = 10 * +e3;
        }], SSS: [/\d{3}/, function(e3) {
          this.milliseconds = +e3;
        }], s: [i2, f2("seconds")], ss: [i2, f2("seconds")], m: [i2, f2("minutes")], mm: [i2, f2("minutes")], H: [i2, f2("hours")], h: [i2, f2("hours")], HH: [i2, f2("hours")], hh: [i2, f2("hours")], D: [i2, f2("day")], DD: [r2, f2("day")], Do: [o2, function(e3) {
          var t3 = s.ordinal, n3 = e3.match(/\d+/);
          if (this.day = n3[0], t3) for (var r3 = 1; r3 <= 31; r3 += 1) t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
        }], w: [i2, f2("week")], ww: [r2, f2("week")], M: [i2, f2("month")], MM: [r2, f2("month")], MMM: [o2, function(e3) {
          var t3 = u2("months"), n3 = (u2("monthsShort") || t3.map(function(e4) {
            return e4.slice(0, 3);
          })).indexOf(e3) + 1;
          if (n3 < 1) throw new Error();
          this.month = n3 % 12 || n3;
        }], MMMM: [o2, function(e3) {
          var t3 = u2("months").indexOf(e3) + 1;
          if (t3 < 1) throw new Error();
          this.month = t3 % 12 || t3;
        }], Y: [/[+-]?\d+/, f2("year")], YY: [r2, function(e3) {
          this.year = a(e3);
        }], YYYY: [/\d{4}/, f2("year")], Z: h2, ZZ: h2 };
        function l2(n3) {
          var r3, i3;
          r3 = n3, i3 = s && s.formats;
          for (var o3 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
            var o4 = r4 && r4.toUpperCase();
            return n4 || i3[r4] || e2[r4] || i3[o4].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
              return t4 || n5.slice(1);
            });
          })).match(t2), a2 = o3.length, f3 = 0; f3 < a2; f3 += 1) {
            var h3 = o3[f3], u3 = c2[h3], d3 = u3 && u3[0], l3 = u3 && u3[1];
            o3[f3] = l3 ? { regex: d3, parser: l3 } : h3.replace(/^\[|\]$/g, "");
          }
          return function(e3) {
            for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
              var i4 = o3[n4];
              if ("string" == typeof i4) r4 += i4.length;
              else {
                var s2 = i4.regex, f4 = i4.parser, h4 = e3.slice(r4), u4 = s2.exec(h4)[0];
                f4.call(t3, u4), e3 = e3.replace(u4, "");
              }
            }
            return function(e4) {
              var t4 = e4.afternoon;
              if (void 0 !== t4) {
                var n5 = e4.hours;
                t4 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
              }
            }(t3), t3;
          };
        }
        return function(e3, t3, n3) {
          n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (a = e3.parseTwoDigitYear);
          var r3 = t3.prototype, i3 = r3.parse;
          r3.parse = function(e4) {
            var t4 = e4.date, r4 = e4.utc, o3 = e4.args;
            this.$u = r4;
            var a2 = o3[1];
            if ("string" == typeof a2) {
              var f3 = true === o3[2], h3 = true === o3[3], u3 = f3 || h3, d3 = o3[2];
              h3 && (d3 = o3[2]), s = this.$locale(), !f3 && d3 && (s = n3.Ls[d3]), this.$d = function(e5, t5, n4, r5) {
                try {
                  if (["x", "X"].indexOf(t5) > -1) return new Date(("X" === t5 ? 1e3 : 1) * e5);
                  var i4 = l2(t5)(e5), o4 = i4.year, s2 = i4.month, a3 = i4.day, f4 = i4.hours, h4 = i4.minutes, u4 = i4.seconds, d4 = i4.milliseconds, c4 = i4.zone, m3 = i4.week, M3 = /* @__PURE__ */ new Date(), Y2 = a3 || (o4 || s2 ? 1 : M3.getDate()), p2 = o4 || M3.getFullYear(), v2 = 0;
                  o4 && !s2 || (v2 = s2 > 0 ? s2 - 1 : M3.getMonth());
                  var D2, w2 = f4 || 0, g2 = h4 || 0, y2 = u4 || 0, L2 = d4 || 0;
                  return c4 ? new Date(Date.UTC(p2, v2, Y2, w2, g2, y2, L2 + 60 * c4.offset * 1e3)) : n4 ? new Date(Date.UTC(p2, v2, Y2, w2, g2, y2, L2)) : (D2 = new Date(p2, v2, Y2, w2, g2, y2, L2), m3 && (D2 = r5(D2).week(m3).toDate()), D2);
                } catch (e6) {
                  return /* @__PURE__ */ new Date("");
                }
              }(t4, a2, r4, n3), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
            } else if (a2 instanceof Array) for (var c3 = a2.length, m2 = 1; m2 <= c3; m2 += 1) {
              o3[1] = a2[m2 - 1];
              var M2 = n3.apply(this, o3);
              if (M2.isValid()) {
                this.$d = M2.$d, this.$L = M2.$L, this.init();
                break;
              }
              m2 === c3 && (this.$d = /* @__PURE__ */ new Date(""));
            }
            else i3.call(this, e4);
          };
        };
      });
    })(customParseFormat$1);
    var customParseFormatExports = customParseFormat$1.exports;
    const customParseFormat = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
    N.extend(customParseFormat);
    N.extend(advancedFormat);
    N.extend(weekday);
    N.extend(localeData);
    N.extend(weekOfYear);
    N.extend(weekYear);
    N.extend(function(o2, c2) {
      var proto = c2.prototype;
      var oldFormat = proto.format;
      proto.format = function f2(formatStr) {
        var str = (formatStr || "").replace("Wo", "wo");
        return oldFormat.bind(this)(str);
      };
    });
    var localeMap = {
      // ar_EG:
      // az_AZ:
      // bg_BG:
      bn_BD: "bn-bd",
      by_BY: "be",
      // ca_ES:
      // cs_CZ:
      // da_DK:
      // de_DE:
      // el_GR:
      en_GB: "en-gb",
      en_US: "en",
      // es_ES:
      // et_EE:
      // fa_IR:
      // fi_FI:
      fr_BE: "fr",
      // todo: dayjs has no fr_BE locale, use fr at present
      fr_CA: "fr-ca",
      // fr_FR:
      // ga_IE:
      // gl_ES:
      // he_IL:
      // hi_IN:
      // hr_HR:
      // hu_HU:
      hy_AM: "hy-am",
      // id_ID:
      // is_IS:
      // it_IT:
      // ja_JP:
      // ka_GE:
      // kk_KZ:
      // km_KH:
      kmr_IQ: "ku",
      // kn_IN:
      // ko_KR:
      // ku_IQ: // previous ku in antd
      // lt_LT:
      // lv_LV:
      // mk_MK:
      // ml_IN:
      // mn_MN:
      // ms_MY:
      // nb_NO:
      // ne_NP:
      nl_BE: "nl-be",
      // nl_NL:
      // pl_PL:
      pt_BR: "pt-br",
      // pt_PT:
      // ro_RO:
      // ru_RU:
      // sk_SK:
      // sl_SI:
      // sr_RS:
      // sv_SE:
      // ta_IN:
      // th_TH:
      // tr_TR:
      // uk_UA:
      // ur_PK:
      // vi_VN:
      zh_CN: "zh-cn",
      zh_HK: "zh-hk",
      zh_TW: "zh-tw"
    };
    var parseLocale = function parseLocale2(locale2) {
      var mapLocale = localeMap[locale2];
      return mapLocale || locale2.split("_")[0];
    };
    var generateConfig = {
      // get
      getNow: function getNow() {
        var now2 = N();
        if (typeof now2.tz === "function") {
          return now2.tz();
        }
        return now2;
      },
      getFixedDate: function getFixedDate(string2) {
        return N(string2, ["YYYY-M-DD", "YYYY-MM-DD"]);
      },
      getEndDate: function getEndDate(date2) {
        return date2.endOf("month");
      },
      getWeekDay: function getWeekDay(date2) {
        var clone2 = date2.locale("en");
        return clone2.weekday() + clone2.localeData().firstDayOfWeek();
      },
      getYear: function getYear(date2) {
        return date2.year();
      },
      getMonth: function getMonth(date2) {
        return date2.month();
      },
      getDate: function getDate(date2) {
        return date2.date();
      },
      getHour: function getHour(date2) {
        return date2.hour();
      },
      getMinute: function getMinute(date2) {
        return date2.minute();
      },
      getSecond: function getSecond(date2) {
        return date2.second();
      },
      getMillisecond: function getMillisecond(date2) {
        return date2.millisecond();
      },
      // set
      addYear: function addYear(date2, diff) {
        return date2.add(diff, "year");
      },
      addMonth: function addMonth(date2, diff) {
        return date2.add(diff, "month");
      },
      addDate: function addDate(date2, diff) {
        return date2.add(diff, "day");
      },
      setYear: function setYear(date2, year) {
        return date2.year(year);
      },
      setMonth: function setMonth(date2, month) {
        return date2.month(month);
      },
      setDate: function setDate(date2, num) {
        return date2.date(num);
      },
      setHour: function setHour(date2, hour) {
        return date2.hour(hour);
      },
      setMinute: function setMinute(date2, minute) {
        return date2.minute(minute);
      },
      setSecond: function setSecond(date2, second) {
        return date2.second(second);
      },
      setMillisecond: function setMillisecond(date2, milliseconds) {
        return date2.millisecond(milliseconds);
      },
      // Compare
      isAfter: function isAfter(date1, date2) {
        return date1.isAfter(date2);
      },
      isValidate: function isValidate(date2) {
        return date2.isValid();
      },
      locale: {
        getWeekFirstDay: function getWeekFirstDay(locale2) {
          return N().locale(parseLocale(locale2)).localeData().firstDayOfWeek();
        },
        getWeekFirstDate: function getWeekFirstDate(locale2, date2) {
          return date2.locale(parseLocale(locale2)).weekday(0);
        },
        getWeek: function getWeek(locale2, date2) {
          return date2.locale(parseLocale(locale2)).week();
        },
        getShortWeekDays: function getShortWeekDays(locale2) {
          return N().locale(parseLocale(locale2)).localeData().weekdaysMin();
        },
        getShortMonths: function getShortMonths(locale2) {
          return N().locale(parseLocale(locale2)).localeData().monthsShort();
        },
        format: function format2(locale2, date2, _format) {
          return date2.locale(parseLocale(locale2)).format(_format);
        },
        parse: function parse2(locale2, text, formats) {
          var localeStr = parseLocale(locale2);
          for (var i2 = 0; i2 < formats.length; i2 += 1) {
            var format2 = formats[i2];
            var formatText = text;
            if (format2.includes("wo") || format2.includes("Wo")) {
              var year = formatText.split("-")[0];
              var weekStr = formatText.split("-")[1];
              var firstWeek = N(year, "YYYY").startOf("year").locale(localeStr);
              for (var j2 = 0; j2 <= 52; j2 += 1) {
                var nextWeek = firstWeek.add(j2, "week");
                if (nextWeek.format("Wo") === weekStr) {
                  return nextWeek;
                }
              }
              return null;
            }
            var date2 = N(formatText, format2, true).locale(localeStr);
            if (date2.isValid()) {
              return date2;
            }
          }
          return null;
        }
      }
    };
    function getRealPlacement(placement, rtl) {
      if (placement !== void 0) {
        return placement;
      }
      return rtl ? "bottomRight" : "bottomLeft";
    }
    var PickerContext = /* @__PURE__ */ reactExports.createContext(null);
    var BUILT_IN_PLACEMENTS = {
      bottomLeft: {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow: {
          adjustX: 1,
          adjustY: 1
        }
      },
      bottomRight: {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow: {
          adjustX: 1,
          adjustY: 1
        }
      },
      topLeft: {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow: {
          adjustX: 0,
          adjustY: 1
        }
      },
      topRight: {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow: {
          adjustX: 0,
          adjustY: 1
        }
      }
    };
    function PickerTrigger(_ref) {
      var popupElement = _ref.popupElement, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupAlign = _ref.popupAlign, transitionName = _ref.transitionName, getPopupContainer = _ref.getPopupContainer, children = _ref.children, range2 = _ref.range, placement = _ref.placement, _ref$builtinPlacement = _ref.builtinPlacements, builtinPlacements = _ref$builtinPlacement === void 0 ? BUILT_IN_PLACEMENTS : _ref$builtinPlacement, direction = _ref.direction, visible = _ref.visible, onClose = _ref.onClose;
      var _React$useContext = reactExports.useContext(PickerContext), prefixCls = _React$useContext.prefixCls;
      var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
      var realPlacement = getRealPlacement(placement, direction === "rtl");
      return /* @__PURE__ */ reactExports.createElement(Trigger, {
        showAction: [],
        hideAction: ["click"],
        popupPlacement: realPlacement,
        builtinPlacements,
        prefixCls: dropdownPrefixCls,
        popupTransitionName: transitionName,
        popup: popupElement,
        popupAlign,
        popupVisible: visible,
        popupClassName: classNames(popupClassName, _defineProperty(_defineProperty({}, "".concat(dropdownPrefixCls, "-range"), range2), "".concat(dropdownPrefixCls, "-rtl"), direction === "rtl")),
        popupStyle,
        stretch: "minWidth",
        getPopupContainer,
        onPopupVisibleChange: function onPopupVisibleChange(nextVisible) {
          if (!nextVisible) {
            onClose();
          }
        }
      }, children);
    }
    function leftPad(str, length2) {
      var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
      var current = String(str);
      while (current.length < length2) {
        current = "".concat(fill).concat(current);
      }
      return current;
    }
    function toArray$1(val) {
      if (val === null || val === void 0) {
        return [];
      }
      return Array.isArray(val) ? val : [val];
    }
    function fillIndex(ori, index2, value) {
      var clone2 = _toConsumableArray(ori);
      clone2[index2] = value;
      return clone2;
    }
    function pickProps(props, keys2) {
      var clone2 = {};
      var mergedKeys = keys2 || Object.keys(props);
      mergedKeys.forEach(function(key) {
        if (props[key] !== void 0) {
          clone2[key] = props[key];
        }
      });
      return clone2;
    }
    function getRowFormat(picker, locale2, format2) {
      if (format2) {
        return format2;
      }
      switch (picker) {
        case "time":
          return locale2.fieldTimeFormat;
        case "datetime":
          return locale2.fieldDateTimeFormat;
        case "month":
          return locale2.fieldMonthFormat;
        case "year":
          return locale2.fieldYearFormat;
        case "quarter":
          return locale2.fieldQuarterFormat;
        case "week":
          return locale2.fieldWeekFormat;
        default:
          return locale2.fieldDateFormat;
      }
    }
    function getFromDate(calendarValues, activeIndexList, activeIndex) {
      var mergedActiveIndex = activeIndex !== void 0 ? activeIndex : activeIndexList[activeIndexList.length - 1];
      var firstValuedIndex = activeIndexList.find(function(index2) {
        return calendarValues[index2];
      });
      return mergedActiveIndex !== firstValuedIndex ? calendarValues[firstValuedIndex] : void 0;
    }
    function pickTriggerProps(props) {
      return pickProps(props, ["placement", "builtinPlacements", "popupAlign", "getPopupContainer", "transitionName", "direction"]);
    }
    function useCellRender(cellRender, dateRender, monthCellRender, range2) {
      var mergedCellRender = reactExports.useMemo(function() {
        if (cellRender) {
          return cellRender;
        }
        return function(current, info) {
          var date2 = current;
          if (dateRender && info.type === "date") {
            return dateRender(date2, info.today);
          }
          if (monthCellRender && info.type === "month") {
            return monthCellRender(date2, info.locale);
          }
          return info.originNode;
        };
      }, [cellRender, monthCellRender, dateRender]);
      var onInternalCellRender = reactExports.useCallback(function(date2, info) {
        return mergedCellRender(date2, _objectSpread2$3(_objectSpread2$3({}, info), {}, {
          range: range2
        }));
      }, [mergedCellRender, range2]);
      return onInternalCellRender;
    }
    function useFieldsInvalidate(calendarValue, isInvalidateDate) {
      var allowEmpty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      var _React$useState = reactExports.useState([false, false]), _React$useState2 = _slicedToArray(_React$useState, 2), fieldsInvalidates = _React$useState2[0], setFieldsInvalidates = _React$useState2[1];
      var onSelectorInvalid = function onSelectorInvalid2(invalid, index2) {
        setFieldsInvalidates(function(ori) {
          return fillIndex(ori, index2, invalid);
        });
      };
      var submitInvalidates = reactExports.useMemo(function() {
        return fieldsInvalidates.map(function(invalid, index2) {
          if (invalid) {
            return true;
          }
          var current = calendarValue[index2];
          if (!current) {
            return false;
          }
          if (!allowEmpty[index2] && !current) {
            return true;
          }
          if (current && isInvalidateDate(current, {
            activeIndex: index2
          })) {
            return true;
          }
          return false;
        });
      }, [calendarValue, fieldsInvalidates, isInvalidateDate, allowEmpty]);
      return [submitInvalidates, onSelectorInvalid];
    }
    function fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem) {
      var timeFormat = "";
      var cells = [];
      if (showHour) {
        cells.push(showMeridiem ? "hh" : "HH");
      }
      if (showMinute) {
        cells.push("mm");
      }
      if (showSecond) {
        cells.push("ss");
      }
      timeFormat = cells.join(":");
      if (showMillisecond) {
        timeFormat += ".SSS";
      }
      if (showMeridiem) {
        timeFormat += " A";
      }
      return timeFormat;
    }
    function fillLocale(locale2, showHour, showMinute, showSecond, showMillisecond, use12Hours) {
      var fieldDateTimeFormat = locale2.fieldDateTimeFormat, fieldDateFormat = locale2.fieldDateFormat, fieldTimeFormat = locale2.fieldTimeFormat, fieldMonthFormat = locale2.fieldMonthFormat, fieldYearFormat = locale2.fieldYearFormat, fieldWeekFormat = locale2.fieldWeekFormat, fieldQuarterFormat = locale2.fieldQuarterFormat, yearFormat = locale2.yearFormat, cellYearFormat = locale2.cellYearFormat, cellQuarterFormat = locale2.cellQuarterFormat, dayFormat = locale2.dayFormat, cellDateFormat = locale2.cellDateFormat;
      var timeFormat = fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, use12Hours);
      return _objectSpread2$3(_objectSpread2$3({}, locale2), {}, {
        fieldDateTimeFormat: fieldDateTimeFormat || "YYYY-MM-DD ".concat(timeFormat),
        fieldDateFormat: fieldDateFormat || "YYYY-MM-DD",
        fieldTimeFormat: fieldTimeFormat || timeFormat,
        fieldMonthFormat: fieldMonthFormat || "YYYY-MM",
        fieldYearFormat: fieldYearFormat || "YYYY",
        fieldWeekFormat: fieldWeekFormat || "gggg-wo",
        fieldQuarterFormat: fieldQuarterFormat || "YYYY-[Q]Q",
        yearFormat: yearFormat || "YYYY",
        cellYearFormat: cellYearFormat || "YYYY",
        cellQuarterFormat: cellQuarterFormat || "[Q]Q",
        cellDateFormat: cellDateFormat || dayFormat || "D"
      });
    }
    function useLocale(locale2, showProps) {
      var showHour = showProps.showHour, showMinute = showProps.showMinute, showSecond = showProps.showSecond, showMillisecond = showProps.showMillisecond, use12Hours = showProps.use12Hours;
      return i.useMemo(function() {
        return fillLocale(locale2, showHour, showMinute, showSecond, showMillisecond, use12Hours);
      }, [locale2, showHour, showMinute, showSecond, showMillisecond, use12Hours]);
    }
    function checkShow(format2, keywords, show) {
      return show !== null && show !== void 0 ? show : keywords.some(function(keyword) {
        return format2.includes(keyword);
      });
    }
    var showTimeKeys = [
      // 'format',
      "showNow",
      "showHour",
      "showMinute",
      "showSecond",
      "showMillisecond",
      "use12Hours",
      "hourStep",
      "minuteStep",
      "secondStep",
      "millisecondStep",
      "hideDisabledOptions",
      "defaultValue",
      "disabledHours",
      "disabledMinutes",
      "disabledSeconds",
      "disabledMilliseconds",
      "disabledTime",
      "changeOnScroll",
      "defaultOpenValue"
    ];
    function pickTimeProps(props) {
      var timeProps = pickProps(props, showTimeKeys);
      var format2 = props.format, picker = props.picker;
      var propFormat = null;
      if (format2) {
        propFormat = format2;
        if (Array.isArray(propFormat)) {
          propFormat = propFormat[0];
        }
        propFormat = _typeof$1(propFormat) === "object" ? propFormat.format : propFormat;
      }
      if (picker === "time") {
        timeProps.format = propFormat;
      }
      return [timeProps, propFormat];
    }
    function isStringFormat(format2) {
      return format2 && typeof format2 === "string";
    }
    function existShowConfig(showHour, showMinute, showSecond, showMillisecond) {
      return [showHour, showMinute, showSecond, showMillisecond].some(function(show) {
        return show !== void 0;
      });
    }
    function fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond) {
      var parsedShowHour = showHour;
      var parsedShowMinute = showMinute;
      var parsedShowSecond = showSecond;
      if (!hasShowConfig && !parsedShowHour && !parsedShowMinute && !parsedShowSecond && !showMillisecond) {
        parsedShowHour = true;
        parsedShowMinute = true;
        parsedShowSecond = true;
      } else if (hasShowConfig) {
        var _parsedShowHour, _parsedShowMinute, _parsedShowSecond;
        var existFalse = [parsedShowHour, parsedShowMinute, parsedShowSecond].some(function(show) {
          return show === false;
        });
        var existTrue = [parsedShowHour, parsedShowMinute, parsedShowSecond].some(function(show) {
          return show === true;
        });
        var defaultShow = existFalse ? true : !existTrue;
        parsedShowHour = (_parsedShowHour = parsedShowHour) !== null && _parsedShowHour !== void 0 ? _parsedShowHour : defaultShow;
        parsedShowMinute = (_parsedShowMinute = parsedShowMinute) !== null && _parsedShowMinute !== void 0 ? _parsedShowMinute : defaultShow;
        parsedShowSecond = (_parsedShowSecond = parsedShowSecond) !== null && _parsedShowSecond !== void 0 ? _parsedShowSecond : defaultShow;
      }
      return [parsedShowHour, parsedShowMinute, parsedShowSecond, showMillisecond];
    }
    function getTimeProps(componentProps) {
      var showTime = componentProps.showTime;
      var _pickTimeProps = pickTimeProps(componentProps), _pickTimeProps2 = _slicedToArray(_pickTimeProps, 2), pickedProps = _pickTimeProps2[0], propFormat = _pickTimeProps2[1];
      var showTimeConfig = showTime && _typeof$1(showTime) === "object" ? showTime : {};
      var timeConfig = _objectSpread2$3(_objectSpread2$3({
        defaultOpenValue: showTimeConfig.defaultOpenValue || showTimeConfig.defaultValue
      }, pickedProps), showTimeConfig);
      var showMillisecond = timeConfig.showMillisecond;
      var showHour = timeConfig.showHour, showMinute = timeConfig.showMinute, showSecond = timeConfig.showSecond;
      var hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
      var _fillShowConfig = fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond);
      var _fillShowConfig2 = _slicedToArray(_fillShowConfig, 3);
      showHour = _fillShowConfig2[0];
      showMinute = _fillShowConfig2[1];
      showSecond = _fillShowConfig2[2];
      return [timeConfig, _objectSpread2$3(_objectSpread2$3({}, timeConfig), {}, {
        showHour,
        showMinute,
        showSecond,
        showMillisecond
      }), timeConfig.format, propFormat];
    }
    function fillShowTimeConfig(picker, showTimeFormat, propFormat, timeConfig, locale2) {
      var isTimePicker = picker === "time";
      if (picker === "datetime" || isTimePicker) {
        var pickedProps = timeConfig;
        var defaultLocaleFormat = getRowFormat(picker, locale2, null);
        var baselineFormat = defaultLocaleFormat;
        var formatList = [showTimeFormat, propFormat];
        for (var i2 = 0; i2 < formatList.length; i2 += 1) {
          var format2 = toArray$1(formatList[i2])[0];
          if (isStringFormat(format2)) {
            baselineFormat = format2;
            break;
          }
        }
        var showHour = pickedProps.showHour, showMinute = pickedProps.showMinute, showSecond = pickedProps.showSecond, showMillisecond = pickedProps.showMillisecond;
        var use12Hours = pickedProps.use12Hours;
        var showMeridiem = checkShow(baselineFormat, ["a", "A", "LT", "LLL", "LTS"], use12Hours);
        var hasShowConfig = existShowConfig(showHour, showMinute, showSecond, showMillisecond);
        if (!hasShowConfig) {
          showHour = checkShow(baselineFormat, ["H", "h", "k", "LT", "LLL"]);
          showMinute = checkShow(baselineFormat, ["m", "LT", "LLL"]);
          showSecond = checkShow(baselineFormat, ["s", "LTS"]);
          showMillisecond = checkShow(baselineFormat, ["SSS"]);
        }
        var _fillShowConfig3 = fillShowConfig(hasShowConfig, showHour, showMinute, showSecond, showMillisecond);
        var _fillShowConfig4 = _slicedToArray(_fillShowConfig3, 3);
        showHour = _fillShowConfig4[0];
        showMinute = _fillShowConfig4[1];
        showSecond = _fillShowConfig4[2];
        var timeFormat = showTimeFormat || fillTimeFormat(showHour, showMinute, showSecond, showMillisecond, showMeridiem);
        return _objectSpread2$3(_objectSpread2$3({}, pickedProps), {}, {
          // Format
          format: timeFormat,
          // Show Config
          showHour,
          showMinute,
          showSecond,
          showMillisecond,
          use12Hours: showMeridiem
        });
      }
      return null;
    }
    function fillClearIcon(prefixCls, allowClear, clearIcon) {
      if (allowClear === false) {
        return null;
      }
      var config = allowClear && _typeof$1(allowClear) === "object" ? allowClear : {};
      return config.clearIcon || clearIcon || /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-clear-btn")
      });
    }
    var WEEK_DAY_COUNT = 7;
    function nullableCompare(value1, value2, oriCompareFn) {
      if (!value1 && !value2 || value1 === value2) {
        return true;
      }
      if (!value1 || !value2) {
        return false;
      }
      return oriCompareFn();
    }
    function isSameDecade(generateConfig2, decade1, decade2) {
      return nullableCompare(decade1, decade2, function() {
        var num1 = Math.floor(generateConfig2.getYear(decade1) / 10);
        var num2 = Math.floor(generateConfig2.getYear(decade2) / 10);
        return num1 === num2;
      });
    }
    function isSameYear(generateConfig2, year1, year2) {
      return nullableCompare(year1, year2, function() {
        return generateConfig2.getYear(year1) === generateConfig2.getYear(year2);
      });
    }
    function getQuarter(generateConfig2, date2) {
      var quota = Math.floor(generateConfig2.getMonth(date2) / 3);
      return quota + 1;
    }
    function isSameQuarter(generateConfig2, quarter1, quarter2) {
      return nullableCompare(quarter1, quarter2, function() {
        return isSameYear(generateConfig2, quarter1, quarter2) && getQuarter(generateConfig2, quarter1) === getQuarter(generateConfig2, quarter2);
      });
    }
    function isSameMonth(generateConfig2, month1, month2) {
      return nullableCompare(month1, month2, function() {
        return isSameYear(generateConfig2, month1, month2) && generateConfig2.getMonth(month1) === generateConfig2.getMonth(month2);
      });
    }
    function isSameDate(generateConfig2, date1, date2) {
      return nullableCompare(date1, date2, function() {
        return isSameYear(generateConfig2, date1, date2) && isSameMonth(generateConfig2, date1, date2) && generateConfig2.getDate(date1) === generateConfig2.getDate(date2);
      });
    }
    function isSameTime(generateConfig2, time1, time2) {
      return nullableCompare(time1, time2, function() {
        return generateConfig2.getHour(time1) === generateConfig2.getHour(time2) && generateConfig2.getMinute(time1) === generateConfig2.getMinute(time2) && generateConfig2.getSecond(time1) === generateConfig2.getSecond(time2);
      });
    }
    function isSameTimestamp(generateConfig2, time1, time2) {
      return nullableCompare(time1, time2, function() {
        return isSameDate(generateConfig2, time1, time2) && isSameTime(generateConfig2, time1, time2) && generateConfig2.getMillisecond(time1) === generateConfig2.getMillisecond(time2);
      });
    }
    function isSameWeek(generateConfig2, locale2, date1, date2) {
      return nullableCompare(date1, date2, function() {
        var weekStartDate1 = generateConfig2.locale.getWeekFirstDate(locale2, date1);
        var weekStartDate2 = generateConfig2.locale.getWeekFirstDate(locale2, date2);
        return isSameYear(generateConfig2, weekStartDate1, weekStartDate2) && generateConfig2.locale.getWeek(locale2, date1) === generateConfig2.locale.getWeek(locale2, date2);
      });
    }
    function isSame(generateConfig2, locale2, source, target, type2) {
      switch (type2) {
        case "date":
          return isSameDate(generateConfig2, source, target);
        case "week":
          return isSameWeek(generateConfig2, locale2.locale, source, target);
        case "month":
          return isSameMonth(generateConfig2, source, target);
        case "quarter":
          return isSameQuarter(generateConfig2, source, target);
        case "year":
          return isSameYear(generateConfig2, source, target);
        case "decade":
          return isSameDecade(generateConfig2, source, target);
        case "time":
          return isSameTime(generateConfig2, source, target);
        default:
          return isSameTimestamp(generateConfig2, source, target);
      }
    }
    function isInRange(generateConfig2, startDate, endDate, current) {
      if (!startDate || !endDate || !current) {
        return false;
      }
      return generateConfig2.isAfter(current, startDate) && generateConfig2.isAfter(endDate, current);
    }
    function isSameOrAfter(generateConfig2, locale2, date1, date2, type2) {
      if (isSame(generateConfig2, locale2, date1, date2, type2)) {
        return true;
      }
      return generateConfig2.isAfter(date1, date2);
    }
    function getWeekStartDate(locale2, generateConfig2, value) {
      var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2);
      var monthStartDate = generateConfig2.setDate(value, 1);
      var startDateWeekDay = generateConfig2.getWeekDay(monthStartDate);
      var alignStartDate = generateConfig2.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
      if (generateConfig2.getMonth(alignStartDate) === generateConfig2.getMonth(value) && generateConfig2.getDate(alignStartDate) > 1) {
        alignStartDate = generateConfig2.addDate(alignStartDate, -7);
      }
      return alignStartDate;
    }
    function formatValue(value, _ref) {
      var generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, format2 = _ref.format;
      if (!value) {
        return "";
      }
      return typeof format2 === "function" ? format2(value) : generateConfig2.locale.format(locale2.locale, value, format2);
    }
    function fillTime(generateConfig2, date2, time) {
      var tmpDate = date2;
      var getFn = ["getHour", "getMinute", "getSecond", "getMillisecond"];
      var setFn = ["setHour", "setMinute", "setSecond", "setMillisecond"];
      setFn.forEach(function(fn, index2) {
        if (time) {
          tmpDate = generateConfig2[fn](tmpDate, generateConfig2[getFn[index2]](time));
        } else {
          tmpDate = generateConfig2[fn](tmpDate, 0);
        }
      });
      return tmpDate;
    }
    function useDisabledBoundary(generateConfig2, locale2, disabledDate, minDate, maxDate) {
      var mergedDisabledDate = useEvent(function(date2, info) {
        if (disabledDate && disabledDate(date2, info)) {
          return true;
        }
        if (minDate && generateConfig2.isAfter(minDate, date2) && !isSame(generateConfig2, locale2, minDate, date2, info.type)) {
          return true;
        }
        if (maxDate && generateConfig2.isAfter(date2, maxDate) && !isSame(generateConfig2, locale2, maxDate, date2, info.type)) {
          return true;
        }
        return false;
      });
      return mergedDisabledDate;
    }
    function useFieldFormat(picker, locale2, format2) {
      return reactExports.useMemo(function() {
        var rawFormat = getRowFormat(picker, locale2, format2);
        var formatList = toArray$1(rawFormat);
        var firstFormat = formatList[0];
        var maskFormat = _typeof$1(firstFormat) === "object" && firstFormat.type === "mask" ? firstFormat.format : null;
        return [
          // Format list
          formatList.map(function(config) {
            return typeof config === "string" || typeof config === "function" ? config : config.format;
          }),
          // Mask Format
          maskFormat
        ];
      }, [picker, locale2, format2]);
    }
    function useInputReadOnly(formatList, inputReadOnly, multiple) {
      if (typeof formatList[0] === "function" || multiple) {
        return true;
      }
      return inputReadOnly;
    }
    function useInvalidate(generateConfig2, picker, disabledDate, showTime) {
      var isInvalidate = useEvent(function(date2, info) {
        var outsideInfo = _objectSpread2$3({
          type: picker
        }, info);
        delete outsideInfo.activeIndex;
        if (
          // Date object is invalid
          !generateConfig2.isValidate(date2) || // Date is disabled by `disabledDate`
          disabledDate && disabledDate(date2, outsideInfo)
        ) {
          return true;
        }
        if ((picker === "date" || picker === "time") && showTime) {
          var _showTime$disabledTim;
          var range2 = info && info.activeIndex === 1 ? "end" : "start";
          var _ref = ((_showTime$disabledTim = showTime.disabledTime) === null || _showTime$disabledTim === void 0 ? void 0 : _showTime$disabledTim.call(showTime, date2, range2, {
            from: outsideInfo.from
          })) || {}, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds, disabledMilliseconds = _ref.disabledMilliseconds;
          var legacyDisabledHours = showTime.disabledHours, legacyDisabledMinutes = showTime.disabledMinutes, legacyDisabledSeconds = showTime.disabledSeconds;
          var mergedDisabledHours = disabledHours || legacyDisabledHours;
          var mergedDisabledMinutes = disabledMinutes || legacyDisabledMinutes;
          var mergedDisabledSeconds = disabledSeconds || legacyDisabledSeconds;
          var hour = generateConfig2.getHour(date2);
          var minute = generateConfig2.getMinute(date2);
          var second = generateConfig2.getSecond(date2);
          var millisecond = generateConfig2.getMillisecond(date2);
          if (mergedDisabledHours && mergedDisabledHours().includes(hour)) {
            return true;
          }
          if (mergedDisabledMinutes && mergedDisabledMinutes(hour).includes(minute)) {
            return true;
          }
          if (mergedDisabledSeconds && mergedDisabledSeconds(hour, minute).includes(second)) {
            return true;
          }
          if (disabledMilliseconds && disabledMilliseconds(hour, minute, second).includes(millisecond)) {
            return true;
          }
        }
        return false;
      });
      return isInvalidate;
    }
    function useList(value) {
      var fillMode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var values = reactExports.useMemo(function() {
        var list = value ? toArray$1(value) : value;
        if (fillMode && list) {
          list[1] = list[1] || list[0];
        }
        return list;
      }, [value, fillMode]);
      return values;
    }
    function useFilledProps(props, updater) {
      var generateConfig2 = props.generateConfig, locale2 = props.locale, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-picker" : _props$prefixCls, _props$styles = props.styles, styles = _props$styles === void 0 ? {} : _props$styles, _props$classNames = props.classNames, classNames2 = _props$classNames === void 0 ? {} : _props$classNames, _props$order = props.order, order = _props$order === void 0 ? true : _props$order, _props$components = props.components, components = _props$components === void 0 ? {} : _props$components, inputRender = props.inputRender, allowClear = props.allowClear, clearIcon = props.clearIcon, needConfirm = props.needConfirm, multiple = props.multiple, format2 = props.format, inputReadOnly = props.inputReadOnly, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, showTime = props.showTime, value = props.value, defaultValue = props.defaultValue, pickerValue = props.pickerValue, defaultPickerValue = props.defaultPickerValue;
      var values = useList(value);
      var defaultValues = useList(defaultValue);
      var pickerValues = useList(pickerValue);
      var defaultPickerValues = useList(defaultPickerValue);
      var internalPicker = picker === "date" && showTime ? "datetime" : picker;
      var multipleInteractivePicker = internalPicker === "time" || internalPicker === "datetime";
      var complexPicker = multipleInteractivePicker || multiple;
      var mergedNeedConfirm = needConfirm !== null && needConfirm !== void 0 ? needConfirm : multipleInteractivePicker;
      var _getTimeProps = getTimeProps(props), _getTimeProps2 = _slicedToArray(_getTimeProps, 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3];
      var mergedLocale = useLocale(locale2, localeTimeProps);
      var mergedShowTime = reactExports.useMemo(function() {
        return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale);
      }, [internalPicker, showTimeFormat, propFormat, timeProps, mergedLocale]);
      var filledProps = reactExports.useMemo(function() {
        return _objectSpread2$3(_objectSpread2$3({}, props), {}, {
          prefixCls,
          locale: mergedLocale,
          picker,
          styles,
          classNames: classNames2,
          order,
          components: _objectSpread2$3({
            input: inputRender
          }, components),
          clearIcon: fillClearIcon(prefixCls, allowClear, clearIcon),
          showTime: mergedShowTime,
          value: values,
          defaultValue: defaultValues,
          pickerValue: pickerValues,
          defaultPickerValue: defaultPickerValues
        }, updater === null || updater === void 0 ? void 0 : updater());
      }, [props]);
      var _useFieldFormat = useFieldFormat(internalPicker, mergedLocale, format2), _useFieldFormat2 = _slicedToArray(_useFieldFormat, 2), formatList = _useFieldFormat2[0], maskFormat = _useFieldFormat2[1];
      var mergedInputReadOnly = useInputReadOnly(formatList, inputReadOnly, multiple);
      var disabledBoundaryDate = useDisabledBoundary(generateConfig2, locale2, disabledDate, minDate, maxDate);
      var isInvalidateDate = useInvalidate(generateConfig2, picker, disabledBoundaryDate, mergedShowTime);
      var mergedProps = reactExports.useMemo(function() {
        return _objectSpread2$3(_objectSpread2$3({}, filledProps), {}, {
          needConfirm: mergedNeedConfirm,
          inputReadOnly: mergedInputReadOnly,
          disabledDate: disabledBoundaryDate
        });
      }, [filledProps, mergedNeedConfirm, mergedInputReadOnly, disabledBoundaryDate]);
      return [mergedProps, internalPicker, complexPicker, formatList, maskFormat, isInvalidateDate];
    }
    function useDelayState(value, defaultValue, onChange) {
      var _useMergedState = useMergedState(defaultValue, {
        value
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), state = _useMergedState2[0], setState = _useMergedState2[1];
      var nextValueRef = i.useRef(value);
      var rafRef = i.useRef();
      var cancelRaf = function cancelRaf2() {
        wrapperRaf.cancel(rafRef.current);
      };
      var doUpdate = useEvent(function() {
        setState(nextValueRef.current);
        if (onChange && state !== nextValueRef.current) {
          onChange(nextValueRef.current);
        }
      });
      var updateValue = useEvent(function(next2, immediately) {
        cancelRaf();
        nextValueRef.current = next2;
        if (next2 || immediately) {
          doUpdate();
        } else {
          rafRef.current = wrapperRaf(doUpdate);
        }
      });
      i.useEffect(function() {
        return cancelRaf;
      }, []);
      return [state, updateValue];
    }
    function useOpen(open2, defaultOpen) {
      var disabledList = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      var onOpenChange = arguments.length > 3 ? arguments[3] : void 0;
      var mergedOpen = disabledList.every(function(disabled) {
        return disabled;
      }) ? false : open2;
      var _useDelayState = useDelayState(mergedOpen, defaultOpen || false, onOpenChange), _useDelayState2 = _slicedToArray(_useDelayState, 2), rafOpen = _useDelayState2[0], setRafOpen = _useDelayState2[1];
      function setOpen(next2) {
        var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!config.inherit || rafOpen) {
          setRafOpen(next2, config.force);
        }
      }
      return [rafOpen, setOpen];
    }
    function usePickerRef(ref) {
      var selectorRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function() {
        var _selectorRef$current;
        return {
          nativeElement: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.nativeElement,
          focus: function focus(options2) {
            var _selectorRef$current2;
            (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 || _selectorRef$current2.focus(options2);
          },
          blur: function blur() {
            var _selectorRef$current3;
            (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 || _selectorRef$current3.blur();
          }
        };
      });
      return selectorRef;
    }
    function usePresets(presets, legacyRanges) {
      return reactExports.useMemo(function() {
        if (presets) {
          return presets;
        }
        if (legacyRanges) {
          warningOnce$1(false, "`ranges` is deprecated. Please use `presets` instead.");
          return Object.entries(legacyRanges).map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), label = _ref2[0], value = _ref2[1];
            return {
              label,
              value
            };
          });
        }
        return [];
      }, [presets, legacyRanges]);
    }
    function useLockEffect(condition, callback) {
      var delayFrames = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var callbackRef = reactExports.useRef(callback);
      callbackRef.current = callback;
      useLayoutUpdateEffect(function() {
        if (condition) {
          callbackRef.current(condition);
        } else {
          var id = wrapperRaf(function() {
            callbackRef.current(condition);
          }, delayFrames);
          return function() {
            wrapperRaf.cancel(id);
          };
        }
      }, [condition]);
    }
    function useRangeActive(disabled) {
      var empty = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var mergedOpen = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var _React$useState = reactExports.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
      var _React$useState3 = reactExports.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), focused = _React$useState4[0], setFocused = _React$useState4[1];
      var activeListRef = reactExports.useRef([]);
      var submitIndexRef = reactExports.useRef(null);
      var lastOperationRef = reactExports.useRef(null);
      var updateSubmitIndex = function updateSubmitIndex2(index2) {
        submitIndexRef.current = index2;
      };
      var hasActiveSubmitValue = function hasActiveSubmitValue2(index2) {
        return submitIndexRef.current === index2;
      };
      var triggerFocus2 = function triggerFocus3(nextFocus) {
        setFocused(nextFocus);
      };
      var lastOperation = function lastOperation2(type2) {
        if (type2) {
          lastOperationRef.current = type2;
        }
        return lastOperationRef.current;
      };
      var nextActiveIndex = function nextActiveIndex2(nextValue) {
        var list = activeListRef.current;
        var filledActiveSet = new Set(list.filter(function(index2) {
          return nextValue[index2] || empty[index2];
        }));
        var nextIndex = list[list.length - 1] === 0 ? 1 : 0;
        if (filledActiveSet.size >= 2 || disabled[nextIndex]) {
          return null;
        }
        return nextIndex;
      };
      useLockEffect(focused || mergedOpen, function() {
        if (!focused) {
          activeListRef.current = [];
          updateSubmitIndex(null);
        }
      });
      reactExports.useEffect(function() {
        if (focused) {
          activeListRef.current.push(activeIndex);
        }
      }, [focused, activeIndex]);
      return [focused, triggerFocus2, lastOperation, activeIndex, setActiveIndex, nextActiveIndex, activeListRef.current, updateSubmitIndex, hasActiveSubmitValue];
    }
    function useRangeDisabledDate(values, disabled, activeIndexList, generateConfig2, locale2, disabledDate) {
      var activeIndex = activeIndexList[activeIndexList.length - 1];
      var rangeDisabledDate = function rangeDisabledDate2(date2, info) {
        var _values = _slicedToArray(values, 2), start = _values[0], end = _values[1];
        var mergedInfo = _objectSpread2$3(_objectSpread2$3({}, info), {}, {
          from: getFromDate(values, activeIndexList)
        });
        if (activeIndex === 1 && disabled[0] && start && // Same date isOK
        !isSame(generateConfig2, locale2, start, date2, mergedInfo.type) && // Before start date
        generateConfig2.isAfter(start, date2)) {
          return true;
        }
        if (activeIndex === 0 && disabled[1] && end && // Same date isOK
        !isSame(generateConfig2, locale2, end, date2, mergedInfo.type) && // After end date
        generateConfig2.isAfter(date2, end)) {
          return true;
        }
        return disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date2, mergedInfo);
      };
      return rangeDisabledDate;
    }
    function offsetPanelDate(generateConfig2, picker, date2, offset2) {
      switch (picker) {
        case "date":
        case "week":
          return generateConfig2.addMonth(date2, offset2);
        case "month":
        case "quarter":
          return generateConfig2.addYear(date2, offset2);
        case "year":
          return generateConfig2.addYear(date2, offset2 * 10);
        case "decade":
          return generateConfig2.addYear(date2, offset2 * 100);
        default:
          return date2;
      }
    }
    var EMPTY_LIST$1 = [];
    function useRangePickerValue(generateConfig2, locale2, calendarValue, modes, open2, activeIndex, pickerMode, multiplePanel) {
      var defaultPickerValue = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : EMPTY_LIST$1;
      var pickerValue = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : EMPTY_LIST$1;
      var timeDefaultValue = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : EMPTY_LIST$1;
      var onPickerValueChange = arguments.length > 11 ? arguments[11] : void 0;
      var minDate = arguments.length > 12 ? arguments[12] : void 0;
      var maxDate = arguments.length > 13 ? arguments[13] : void 0;
      var isTimePicker = pickerMode === "time";
      var mergedActiveIndex = activeIndex || 0;
      var getDefaultPickerValue = function getDefaultPickerValue2(index2) {
        var now2 = generateConfig2.getNow();
        if (isTimePicker) {
          now2 = fillTime(generateConfig2, now2);
        }
        return defaultPickerValue[index2] || calendarValue[index2] || now2;
      };
      var _pickerValue = _slicedToArray(pickerValue, 2), startPickerValue = _pickerValue[0], endPickerValue = _pickerValue[1];
      var _useMergedState = useMergedState(function() {
        return getDefaultPickerValue(0);
      }, {
        value: startPickerValue
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedStartPickerValue = _useMergedState2[0], setStartPickerValue = _useMergedState2[1];
      var _useMergedState3 = useMergedState(function() {
        return getDefaultPickerValue(1);
      }, {
        value: endPickerValue
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedEndPickerValue = _useMergedState4[0], setEndPickerValue = _useMergedState4[1];
      var currentPickerValue = reactExports.useMemo(function() {
        var current = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex];
        return isTimePicker ? current : fillTime(generateConfig2, current, timeDefaultValue[mergedActiveIndex]);
      }, [isTimePicker, mergedStartPickerValue, mergedEndPickerValue, mergedActiveIndex, generateConfig2, timeDefaultValue]);
      var setCurrentPickerValue = function setCurrentPickerValue2(nextPickerValue) {
        var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "panel";
        var updater = [setStartPickerValue, setEndPickerValue][mergedActiveIndex];
        updater(nextPickerValue);
        var clone2 = [mergedStartPickerValue, mergedEndPickerValue];
        clone2[mergedActiveIndex] = nextPickerValue;
        if (onPickerValueChange && (!isSame(generateConfig2, locale2, mergedStartPickerValue, clone2[0], pickerMode) || !isSame(generateConfig2, locale2, mergedEndPickerValue, clone2[1], pickerMode))) {
          onPickerValueChange(clone2, {
            source,
            range: mergedActiveIndex === 1 ? "end" : "start",
            mode: modes
          });
        }
      };
      var getEndDatePickerValue = function getEndDatePickerValue2(startDate, endDate) {
        if (multiplePanel) {
          var SAME_CHECKER = {
            date: "month",
            week: "month",
            month: "year",
            quarter: "year"
          };
          var mode = SAME_CHECKER[pickerMode];
          if (mode && !isSame(generateConfig2, locale2, startDate, endDate, mode)) {
            return offsetPanelDate(generateConfig2, pickerMode, endDate, -1);
          }
          if (pickerMode === "year" && startDate) {
            var srcYear = Math.floor(generateConfig2.getYear(startDate) / 10);
            var tgtYear = Math.floor(generateConfig2.getYear(endDate) / 10);
            if (srcYear !== tgtYear) {
              return offsetPanelDate(generateConfig2, pickerMode, endDate, -1);
            }
          }
        }
        return endDate;
      };
      var prevActiveIndexRef = reactExports.useRef(null);
      useLayoutEffect$1(function() {
        if (open2) {
          if (!defaultPickerValue[mergedActiveIndex]) {
            var nextPickerValue = isTimePicker ? null : generateConfig2.getNow();
            if (prevActiveIndexRef.current !== null && prevActiveIndexRef.current !== mergedActiveIndex) {
              nextPickerValue = [mergedStartPickerValue, mergedEndPickerValue][mergedActiveIndex ^ 1];
            } else if (calendarValue[mergedActiveIndex]) {
              nextPickerValue = mergedActiveIndex === 0 ? calendarValue[0] : getEndDatePickerValue(calendarValue[0], calendarValue[1]);
            } else if (calendarValue[mergedActiveIndex ^ 1]) {
              nextPickerValue = calendarValue[mergedActiveIndex ^ 1];
            }
            if (nextPickerValue) {
              if (minDate && generateConfig2.isAfter(minDate, nextPickerValue)) {
                nextPickerValue = minDate;
              }
              var offsetPickerValue = multiplePanel ? offsetPanelDate(generateConfig2, pickerMode, nextPickerValue, 1) : nextPickerValue;
              if (maxDate && generateConfig2.isAfter(offsetPickerValue, maxDate)) {
                nextPickerValue = multiplePanel ? offsetPanelDate(generateConfig2, pickerMode, maxDate, -1) : maxDate;
              }
              setCurrentPickerValue(nextPickerValue, "reset");
            }
          }
        }
      }, [open2, mergedActiveIndex, calendarValue[mergedActiveIndex]]);
      reactExports.useEffect(function() {
        if (open2) {
          prevActiveIndexRef.current = mergedActiveIndex;
        } else {
          prevActiveIndexRef.current = null;
        }
      }, [open2, mergedActiveIndex]);
      useLayoutEffect$1(function() {
        if (open2 && defaultPickerValue) {
          if (defaultPickerValue[mergedActiveIndex]) {
            setCurrentPickerValue(defaultPickerValue[mergedActiveIndex], "reset");
          }
        }
      }, [open2, mergedActiveIndex]);
      return [currentPickerValue, setCurrentPickerValue];
    }
    function useSyncState$1(defaultValue, controlledValue) {
      var valueRef = reactExports.useRef(defaultValue);
      var _React$useState = reactExports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
      var getter = function getter2(useControlledValueFirst) {
        return useControlledValueFirst && controlledValue !== void 0 ? controlledValue : valueRef.current;
      };
      var setter = function setter2(nextValue) {
        valueRef.current = nextValue;
        forceUpdate({});
      };
      return [getter, setter, getter(true)];
    }
    var EMPTY_VALUE = [];
    function useUtil(generateConfig2, locale2, formatList) {
      var getDateTexts = function getDateTexts2(dates) {
        return dates.map(function(date2) {
          return formatValue(date2, {
            generateConfig: generateConfig2,
            locale: locale2,
            format: formatList[0]
          });
        });
      };
      var isSameDates = function isSameDates2(source, target) {
        var maxLen = Math.max(source.length, target.length);
        var diffIndex = -1;
        for (var i2 = 0; i2 < maxLen; i2 += 1) {
          var prev2 = source[i2] || null;
          var next2 = target[i2] || null;
          if (prev2 !== next2 && !isSameTimestamp(generateConfig2, prev2, next2)) {
            diffIndex = i2;
            break;
          }
        }
        return [diffIndex < 0, diffIndex !== 0];
      };
      return [getDateTexts, isSameDates];
    }
    function orderDates(dates, generateConfig2) {
      return _toConsumableArray(dates).sort(function(a, b2) {
        return generateConfig2.isAfter(a, b2) ? 1 : -1;
      });
    }
    function useCalendarValue(mergedValue) {
      var _useSyncState = useSyncState$1(mergedValue), _useSyncState2 = _slicedToArray(_useSyncState, 2), calendarValue = _useSyncState2[0], setCalendarValue = _useSyncState2[1];
      var syncWithValue = useEvent(function() {
        setCalendarValue(mergedValue);
      });
      reactExports.useEffect(function() {
        syncWithValue();
      }, [mergedValue]);
      return [calendarValue, setCalendarValue];
    }
    function useInnerValue(generateConfig2, locale2, formatList, rangeValue, order, defaultValue, value, onCalendarChange, onOk) {
      var _useMergedState = useMergedState(defaultValue, {
        value
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
      var mergedValue = innerValue || EMPTY_VALUE;
      var _useCalendarValue = useCalendarValue(mergedValue), _useCalendarValue2 = _slicedToArray(_useCalendarValue, 2), calendarValue = _useCalendarValue2[0], setCalendarValue = _useCalendarValue2[1];
      var _useUtil = useUtil(generateConfig2, locale2, formatList), _useUtil2 = _slicedToArray(_useUtil, 2), getDateTexts = _useUtil2[0], isSameDates = _useUtil2[1];
      var triggerCalendarChange = useEvent(function(nextCalendarValues) {
        var clone2 = _toConsumableArray(nextCalendarValues);
        if (rangeValue) {
          for (var i2 = 0; i2 < 2; i2 += 1) {
            clone2[i2] = clone2[i2] || null;
          }
        } else if (order) {
          clone2 = orderDates(clone2.filter(function(date2) {
            return date2;
          }), generateConfig2);
        }
        var _isSameDates = isSameDates(calendarValue(), clone2), _isSameDates2 = _slicedToArray(_isSameDates, 2), isSameMergedDates = _isSameDates2[0], isSameStart = _isSameDates2[1];
        if (!isSameMergedDates) {
          setCalendarValue(clone2);
          if (onCalendarChange) {
            var cellTexts = getDateTexts(clone2);
            onCalendarChange(clone2, cellTexts, {
              range: isSameStart ? "end" : "start"
            });
          }
        }
      });
      var triggerOk = function triggerOk2() {
        if (onOk) {
          onOk(calendarValue());
        }
      };
      return [mergedValue, setInnerValue, calendarValue, triggerCalendarChange, triggerOk];
    }
    function useRangeValue(info, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, open2, isInvalidateDate) {
      var generateConfig2 = info.generateConfig, locale2 = info.locale, picker = info.picker, onChange = info.onChange, allowEmpty = info.allowEmpty, order = info.order;
      var orderOnChange = disabled.some(function(d2) {
        return d2;
      }) ? false : order;
      var _useUtil3 = useUtil(generateConfig2, locale2, formatList), _useUtil4 = _slicedToArray(_useUtil3, 2), getDateTexts = _useUtil4[0], isSameDates = _useUtil4[1];
      var _useSyncState3 = useSyncState$1(mergedValue), _useSyncState4 = _slicedToArray(_useSyncState3, 2), submitValue = _useSyncState4[0], setSubmitValue = _useSyncState4[1];
      var syncWithValue = useEvent(function() {
        setSubmitValue(mergedValue);
      });
      reactExports.useEffect(function() {
        syncWithValue();
      }, [mergedValue]);
      var triggerSubmit = useEvent(function(nextValue) {
        var isNullValue = nextValue === null;
        var clone2 = _toConsumableArray(nextValue || submitValue());
        if (isNullValue) {
          var maxLen = Math.max(disabled.length, clone2.length);
          for (var i2 = 0; i2 < maxLen; i2 += 1) {
            if (!disabled[i2]) {
              clone2[i2] = null;
            }
          }
        }
        if (orderOnChange && clone2[0] && clone2[1]) {
          clone2 = orderDates(clone2, generateConfig2);
        }
        triggerCalendarChange(clone2);
        var _clone = clone2, _clone2 = _slicedToArray(_clone, 2), start = _clone2[0], end = _clone2[1];
        var startEmpty = !start;
        var endEmpty = !end;
        var validateEmptyDateRange = allowEmpty ? (
          // Validate empty start
          (!startEmpty || allowEmpty[0]) && // Validate empty end
          (!endEmpty || allowEmpty[1])
        ) : true;
        var validateOrder = !order || startEmpty || endEmpty || isSame(generateConfig2, locale2, start, end, picker) || generateConfig2.isAfter(end, start);
        var validateDates = (
          // Validate start
          (disabled[0] || !start || !isInvalidateDate(start, {
            activeIndex: 0
          })) && // Validate end
          (disabled[1] || !end || !isInvalidateDate(end, {
            from: start,
            activeIndex: 1
          }))
        );
        var allPassed = (
          // Null value is from clear button
          isNullValue || // Normal check
          validateEmptyDateRange && validateOrder && validateDates
        );
        if (allPassed) {
          setInnerValue(clone2);
          var _isSameDates3 = isSameDates(clone2, mergedValue), _isSameDates4 = _slicedToArray(_isSameDates3, 1), isSameMergedDates = _isSameDates4[0];
          if (onChange && !isSameMergedDates) {
            onChange(
              // Return null directly if all date are empty
              isNullValue && clone2.every(function(val) {
                return !val;
              }) ? null : clone2,
              getDateTexts(clone2)
            );
          }
        }
        return allPassed;
      });
      var flushSubmit = useEvent(function(index2, needTriggerChange) {
        var nextSubmitValue = fillIndex(submitValue(), index2, getCalendarValue()[index2]);
        setSubmitValue(nextSubmitValue);
        if (needTriggerChange) {
          triggerSubmit();
        }
      });
      var interactiveFinished = !focused && !open2;
      useLockEffect(!interactiveFinished, function() {
        if (interactiveFinished) {
          triggerSubmit();
          triggerCalendarChange(mergedValue);
          syncWithValue();
        }
      }, 2);
      return [flushSubmit, triggerSubmit];
    }
    function useShowNow(picker, mode, showNow, showToday, rangePicker) {
      if (mode !== "date" && mode !== "time") {
        return false;
      }
      if (showNow !== void 0) {
        return showNow;
      }
      if (showToday !== void 0) {
        return showToday;
      }
      return !rangePicker && (picker === "date" || picker === "time");
    }
    function findValidateTime(date2, getHourUnits, getMinuteUnits, getSecondUnits, getMillisecondUnits, generateConfig2) {
      var nextDate = date2;
      function alignValidate(getUnitValue2, setUnitValue, units) {
        var nextValue = generateConfig2[getUnitValue2](nextDate);
        var nextUnit = units.find(function(unit2) {
          return unit2.value === nextValue;
        });
        if (!nextUnit || nextUnit.disabled) {
          var validateUnits = units.filter(function(unit2) {
            return !unit2.disabled;
          });
          var reverseEnabledUnits = _toConsumableArray(validateUnits).reverse();
          var validateUnit = reverseEnabledUnits.find(function(unit2) {
            return unit2.value <= nextValue;
          }) || validateUnits[0];
          if (validateUnit) {
            nextValue = validateUnit.value;
            nextDate = generateConfig2[setUnitValue](nextDate, nextValue);
          }
        }
        return nextValue;
      }
      var nextHour = alignValidate("getHour", "setHour", getHourUnits());
      var nextMinute = alignValidate("getMinute", "setMinute", getMinuteUnits(nextHour));
      var nextSecond = alignValidate("getSecond", "setSecond", getSecondUnits(nextHour, nextMinute));
      alignValidate("getMillisecond", "setMillisecond", getMillisecondUnits(nextHour, nextMinute, nextSecond));
      return nextDate;
    }
    function emptyDisabled() {
      return [];
    }
    function generateUnits(start, end) {
      var step = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var hideDisabledOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      var disabledUnits = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
      var pad = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 2;
      var units = [];
      var integerStep = step >= 1 ? step | 0 : 1;
      for (var i2 = start; i2 <= end; i2 += integerStep) {
        var disabled = disabledUnits.includes(i2);
        if (!disabled || !hideDisabledOptions) {
          units.push({
            label: leftPad(i2, pad),
            value: i2,
            disabled
          });
        }
      }
      return units;
    }
    function useTimeInfo(generateConfig2) {
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var date2 = arguments.length > 2 ? arguments[2] : void 0;
      var _ref = props || {}, use12Hours = _ref.use12Hours, _ref$hourStep = _ref.hourStep, hourStep = _ref$hourStep === void 0 ? 1 : _ref$hourStep, _ref$minuteStep = _ref.minuteStep, minuteStep = _ref$minuteStep === void 0 ? 1 : _ref$minuteStep, _ref$secondStep = _ref.secondStep, secondStep = _ref$secondStep === void 0 ? 1 : _ref$secondStep, _ref$millisecondStep = _ref.millisecondStep, millisecondStep = _ref$millisecondStep === void 0 ? 100 : _ref$millisecondStep, hideDisabledOptions = _ref.hideDisabledOptions, disabledTime = _ref.disabledTime, disabledHours = _ref.disabledHours, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds;
      var mergedDate = reactExports.useMemo(function() {
        return date2 || generateConfig2.getNow();
      }, [date2, generateConfig2]);
      var getDisabledTimes = reactExports.useCallback(function(targetDate) {
        var disabledConfig = (disabledTime === null || disabledTime === void 0 ? void 0 : disabledTime(targetDate)) || {};
        return [disabledConfig.disabledHours || disabledHours || emptyDisabled, disabledConfig.disabledMinutes || disabledMinutes || emptyDisabled, disabledConfig.disabledSeconds || disabledSeconds || emptyDisabled, disabledConfig.disabledMilliseconds || emptyDisabled];
      }, [disabledTime, disabledHours, disabledMinutes, disabledSeconds]);
      var _React$useMemo = reactExports.useMemo(function() {
        return getDisabledTimes(mergedDate);
      }, [mergedDate, getDisabledTimes]), _React$useMemo2 = _slicedToArray(_React$useMemo, 4), mergedDisabledHours = _React$useMemo2[0], mergedDisabledMinutes = _React$useMemo2[1], mergedDisabledSeconds = _React$useMemo2[2], mergedDisabledMilliseconds = _React$useMemo2[3];
      var getAllUnits = reactExports.useCallback(function(getDisabledHours, getDisabledMinutes, getDisabledSeconds, getDisabledMilliseconds) {
        var hours = generateUnits(0, 23, hourStep, hideDisabledOptions, getDisabledHours());
        var rowHourUnits2 = use12Hours ? hours.map(function(unit2) {
          return _objectSpread2$3(_objectSpread2$3({}, unit2), {}, {
            label: leftPad(unit2.value % 12 || 12, 2)
          });
        }) : hours;
        var getMinuteUnits2 = function getMinuteUnits3(nextHour) {
          return generateUnits(0, 59, minuteStep, hideDisabledOptions, getDisabledMinutes(nextHour));
        };
        var getSecondUnits2 = function getSecondUnits3(nextHour, nextMinute) {
          return generateUnits(0, 59, secondStep, hideDisabledOptions, getDisabledSeconds(nextHour, nextMinute));
        };
        var getMillisecondUnits2 = function getMillisecondUnits3(nextHour, nextMinute, nextSecond) {
          return generateUnits(0, 999, millisecondStep, hideDisabledOptions, getDisabledMilliseconds(nextHour, nextMinute, nextSecond), 3);
        };
        return [rowHourUnits2, getMinuteUnits2, getSecondUnits2, getMillisecondUnits2];
      }, [hideDisabledOptions, hourStep, use12Hours, millisecondStep, minuteStep, secondStep]);
      var _React$useMemo3 = reactExports.useMemo(function() {
        return getAllUnits(mergedDisabledHours, mergedDisabledMinutes, mergedDisabledSeconds, mergedDisabledMilliseconds);
      }, [getAllUnits, mergedDisabledHours, mergedDisabledMinutes, mergedDisabledSeconds, mergedDisabledMilliseconds]), _React$useMemo4 = _slicedToArray(_React$useMemo3, 4), rowHourUnits = _React$useMemo4[0], getMinuteUnits = _React$useMemo4[1], getSecondUnits = _React$useMemo4[2], getMillisecondUnits = _React$useMemo4[3];
      var getValidTime = function getValidTime2(nextTime, certainDate) {
        var getCheckHourUnits = function getCheckHourUnits2() {
          return rowHourUnits;
        };
        var getCheckMinuteUnits = getMinuteUnits;
        var getCheckSecondUnits = getSecondUnits;
        var getCheckMillisecondUnits = getMillisecondUnits;
        if (certainDate) {
          var _getDisabledTimes = getDisabledTimes(certainDate), _getDisabledTimes2 = _slicedToArray(_getDisabledTimes, 4), targetDisabledHours = _getDisabledTimes2[0], targetDisabledMinutes = _getDisabledTimes2[1], targetDisabledSeconds = _getDisabledTimes2[2], targetDisabledMilliseconds = _getDisabledTimes2[3];
          var _getAllUnits = getAllUnits(targetDisabledHours, targetDisabledMinutes, targetDisabledSeconds, targetDisabledMilliseconds), _getAllUnits2 = _slicedToArray(_getAllUnits, 4), targetRowHourUnits = _getAllUnits2[0], targetGetMinuteUnits = _getAllUnits2[1], targetGetSecondUnits = _getAllUnits2[2], targetGetMillisecondUnits = _getAllUnits2[3];
          getCheckHourUnits = function getCheckHourUnits2() {
            return targetRowHourUnits;
          };
          getCheckMinuteUnits = targetGetMinuteUnits;
          getCheckSecondUnits = targetGetSecondUnits;
          getCheckMillisecondUnits = targetGetMillisecondUnits;
        }
        var validateDate = findValidateTime(nextTime, getCheckHourUnits, getCheckMinuteUnits, getCheckSecondUnits, getCheckMillisecondUnits, generateConfig2);
        return validateDate;
      };
      return [
        // getValidTime
        getValidTime,
        // Units
        rowHourUnits,
        getMinuteUnits,
        getSecondUnits,
        getMillisecondUnits
      ];
    }
    function Footer(props) {
      var mode = props.mode, internalMode = props.internalMode, renderExtraFooter = props.renderExtraFooter, showNow = props.showNow, showTime = props.showTime, onSubmit = props.onSubmit, onNow = props.onNow, invalid = props.invalid, needConfirm = props.needConfirm, generateConfig2 = props.generateConfig, disabledDate = props.disabledDate;
      var _React$useContext = reactExports.useContext(PickerContext), prefixCls = _React$useContext.prefixCls, locale2 = _React$useContext.locale, _React$useContext$but = _React$useContext.button, Button2 = _React$useContext$but === void 0 ? "button" : _React$useContext$but;
      var now2 = generateConfig2.getNow();
      var _useTimeInfo = useTimeInfo(generateConfig2, showTime, now2), _useTimeInfo2 = _slicedToArray(_useTimeInfo, 1), getValidTime = _useTimeInfo2[0];
      var extraNode = renderExtraFooter === null || renderExtraFooter === void 0 ? void 0 : renderExtraFooter(mode);
      var nowDisabled = disabledDate(now2, {
        type: mode
      });
      var onInternalNow = function onInternalNow2() {
        if (!nowDisabled) {
          var validateNow = getValidTime(now2);
          onNow(validateNow);
        }
      };
      var nowPrefixCls = "".concat(prefixCls, "-now");
      var nowBtnPrefixCls = "".concat(nowPrefixCls, "-btn");
      var presetNode = showNow && /* @__PURE__ */ reactExports.createElement("li", {
        className: nowPrefixCls
      }, /* @__PURE__ */ reactExports.createElement("a", {
        className: classNames(nowBtnPrefixCls, nowDisabled && "".concat(nowBtnPrefixCls, "-disabled")),
        "aria-disabled": nowDisabled,
        onClick: onInternalNow
      }, internalMode === "date" ? locale2.today : locale2.now));
      var okNode = needConfirm && /* @__PURE__ */ reactExports.createElement("li", {
        className: "".concat(prefixCls, "-ok")
      }, /* @__PURE__ */ reactExports.createElement(Button2, {
        disabled: invalid,
        onClick: onSubmit
      }, locale2.ok));
      var rangeNode = (presetNode || okNode) && /* @__PURE__ */ reactExports.createElement("ul", {
        className: "".concat(prefixCls, "-ranges")
      }, presetNode, okNode);
      if (!extraNode && !rangeNode) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-footer")
      }, extraNode && /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-footer-extra")
      }, extraNode), rangeNode);
    }
    function useToggleDates(generateConfig2, locale2, panelMode) {
      function toggleDates(list, target) {
        var index2 = list.findIndex(function(date2) {
          return isSame(generateConfig2, locale2, date2, target, panelMode);
        });
        if (index2 === -1) {
          return [].concat(_toConsumableArray(list), [target]);
        }
        var sliceList = _toConsumableArray(list);
        sliceList.splice(index2, 1);
        return sliceList;
      }
      return toggleDates;
    }
    var PanelContext = /* @__PURE__ */ reactExports.createContext(null);
    function usePanelContext() {
      return reactExports.useContext(PanelContext);
    }
    function useInfo(props, panelType) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, disabledDate = props.disabledDate, minDate = props.minDate, maxDate = props.maxDate, cellRender = props.cellRender, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, onHover = props.onHover, values = props.values, pickerValue = props.pickerValue, onSelect = props.onSelect, prevIcon = props.prevIcon, nextIcon = props.nextIcon, superPrevIcon = props.superPrevIcon, superNextIcon = props.superNextIcon;
      var now2 = generateConfig2.getNow();
      var info = {
        now: now2,
        values,
        pickerValue,
        prefixCls,
        disabledDate,
        minDate,
        maxDate,
        cellRender,
        hoverValue,
        hoverRangeValue,
        onHover,
        locale: locale2,
        generateConfig: generateConfig2,
        onSelect,
        panelType,
        // Icons
        prevIcon,
        nextIcon,
        superPrevIcon,
        superNextIcon
      };
      return [info, now2];
    }
    var PickerHackContext = /* @__PURE__ */ reactExports.createContext({});
    function PanelBody(props) {
      var rowNum = props.rowNum, colNum = props.colNum, baseDate = props.baseDate, getCellDate = props.getCellDate, prefixColumn = props.prefixColumn, rowClassName = props.rowClassName, titleFormat = props.titleFormat, getCellText = props.getCellText, getCellClassName = props.getCellClassName, headerCells = props.headerCells, _props$cellSelection = props.cellSelection, cellSelection = _props$cellSelection === void 0 ? true : _props$cellSelection, disabledDate = props.disabledDate;
      var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, type2 = _usePanelContext.panelType, now2 = _usePanelContext.now, contextDisabledDate = _usePanelContext.disabledDate, cellRender = _usePanelContext.cellRender, onHover = _usePanelContext.onHover, hoverValue = _usePanelContext.hoverValue, hoverRangeValue = _usePanelContext.hoverRangeValue, generateConfig2 = _usePanelContext.generateConfig, values = _usePanelContext.values, locale2 = _usePanelContext.locale, onSelect = _usePanelContext.onSelect;
      var mergedDisabledDate = disabledDate || contextDisabledDate;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var _React$useContext = reactExports.useContext(PickerHackContext), onCellDblClick = _React$useContext.onCellDblClick;
      var matchValues = function matchValues2(date2) {
        return values.some(function(singleValue) {
          return singleValue && isSame(generateConfig2, locale2, date2, singleValue, type2);
        });
      };
      var rows = [];
      for (var row = 0; row < rowNum; row += 1) {
        var rowNode = [];
        var rowStartDate = void 0;
        var _loop = function _loop2() {
          var offset2 = row * colNum + col;
          var currentDate = getCellDate(baseDate, offset2);
          var disabled = mergedDisabledDate === null || mergedDisabledDate === void 0 ? void 0 : mergedDisabledDate(currentDate, {
            type: type2
          });
          if (col === 0) {
            rowStartDate = currentDate;
            if (prefixColumn) {
              rowNode.push(prefixColumn(rowStartDate));
            }
          }
          var inRange = false;
          var rangeStart = false;
          var rangeEnd = false;
          if (cellSelection && hoverRangeValue) {
            var _hoverRangeValue = _slicedToArray(hoverRangeValue, 2), hoverStart = _hoverRangeValue[0], hoverEnd = _hoverRangeValue[1];
            inRange = isInRange(generateConfig2, hoverStart, hoverEnd, currentDate);
            rangeStart = isSame(generateConfig2, locale2, currentDate, hoverStart, type2);
            rangeEnd = isSame(generateConfig2, locale2, currentDate, hoverEnd, type2);
          }
          var title = titleFormat ? formatValue(currentDate, {
            locale: locale2,
            format: titleFormat,
            generateConfig: generateConfig2
          }) : void 0;
          var inner = /* @__PURE__ */ reactExports.createElement("div", {
            className: "".concat(cellPrefixCls, "-inner")
          }, getCellText(currentDate));
          rowNode.push(/* @__PURE__ */ reactExports.createElement("td", {
            key: col,
            title,
            className: classNames(cellPrefixCls, _objectSpread2$3(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(cellPrefixCls, "-disabled"), disabled), "".concat(cellPrefixCls, "-hover"), (hoverValue || []).some(function(date2) {
              return isSame(generateConfig2, locale2, currentDate, date2, type2);
            })), "".concat(cellPrefixCls, "-in-range"), inRange && !rangeStart && !rangeEnd), "".concat(cellPrefixCls, "-range-start"), rangeStart), "".concat(cellPrefixCls, "-range-end"), rangeEnd), "".concat(prefixCls, "-cell-selected"), !hoverRangeValue && // WeekPicker use row instead
            type2 !== "week" && matchValues(currentDate)), getCellClassName(currentDate))),
            onClick: function onClick() {
              if (!disabled) {
                onSelect(currentDate);
              }
            },
            onDoubleClick: function onDoubleClick() {
              if (!disabled && onCellDblClick) {
                onCellDblClick();
              }
            },
            onMouseEnter: function onMouseEnter() {
              if (!disabled) {
                onHover === null || onHover === void 0 || onHover(currentDate);
              }
            },
            onMouseLeave: function onMouseLeave() {
              if (!disabled) {
                onHover === null || onHover === void 0 || onHover(null);
              }
            }
          }, cellRender ? cellRender(currentDate, {
            prefixCls,
            originNode: inner,
            today: now2,
            type: type2,
            locale: locale2
          }) : inner));
        };
        for (var col = 0; col < colNum; col += 1) {
          _loop();
        }
        rows.push(/* @__PURE__ */ reactExports.createElement("tr", {
          key: row,
          className: rowClassName === null || rowClassName === void 0 ? void 0 : rowClassName(rowStartDate)
        }, rowNode));
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-body")
      }, /* @__PURE__ */ reactExports.createElement("table", {
        className: "".concat(prefixCls, "-content")
      }, headerCells && /* @__PURE__ */ reactExports.createElement("thead", null, /* @__PURE__ */ reactExports.createElement("tr", null, headerCells)), /* @__PURE__ */ reactExports.createElement("tbody", null, rows)));
    }
    var HIDDEN_STYLE = {
      visibility: "hidden"
    };
    function PanelHeader(props) {
      var offset2 = props.offset, superOffset = props.superOffset, onChange = props.onChange, getStart = props.getStart, getEnd = props.getEnd, children = props.children;
      var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, _usePanelContext$prev = _usePanelContext.prevIcon, prevIcon = _usePanelContext$prev === void 0 ? "" : _usePanelContext$prev, _usePanelContext$next = _usePanelContext.nextIcon, nextIcon = _usePanelContext$next === void 0 ? "" : _usePanelContext$next, _usePanelContext$supe = _usePanelContext.superPrevIcon, superPrevIcon = _usePanelContext$supe === void 0 ? "" : _usePanelContext$supe, _usePanelContext$supe2 = _usePanelContext.superNextIcon, superNextIcon = _usePanelContext$supe2 === void 0 ? "" : _usePanelContext$supe2, minDate = _usePanelContext.minDate, maxDate = _usePanelContext.maxDate, generateConfig2 = _usePanelContext.generateConfig, locale2 = _usePanelContext.locale, pickerValue = _usePanelContext.pickerValue, type2 = _usePanelContext.panelType;
      var headerPrefixCls = "".concat(prefixCls, "-header");
      var _React$useContext = reactExports.useContext(PickerHackContext), hidePrev = _React$useContext.hidePrev, hideNext = _React$useContext.hideNext, hideHeader = _React$useContext.hideHeader;
      var disabledOffsetPrev = reactExports.useMemo(function() {
        if (!minDate || !offset2 || !getEnd) {
          return false;
        }
        var prevPanelLimitDate = getEnd(offset2(-1, pickerValue));
        return !isSameOrAfter(generateConfig2, locale2, prevPanelLimitDate, minDate, type2);
      }, [minDate, offset2, pickerValue, getEnd, generateConfig2, locale2, type2]);
      var disabledSuperOffsetPrev = reactExports.useMemo(function() {
        if (!minDate || !superOffset || !getEnd) {
          return false;
        }
        var prevPanelLimitDate = getEnd(superOffset(-1, pickerValue));
        return !isSameOrAfter(generateConfig2, locale2, prevPanelLimitDate, minDate, type2);
      }, [minDate, superOffset, pickerValue, getEnd, generateConfig2, locale2, type2]);
      var disabledOffsetNext = reactExports.useMemo(function() {
        if (!maxDate || !offset2 || !getStart) {
          return false;
        }
        var nextPanelLimitDate = getStart(offset2(1, pickerValue));
        return !isSameOrAfter(generateConfig2, locale2, maxDate, nextPanelLimitDate, type2);
      }, [maxDate, offset2, pickerValue, getStart, generateConfig2, locale2, type2]);
      var disabledSuperOffsetNext = reactExports.useMemo(function() {
        if (!maxDate || !superOffset || !getStart) {
          return false;
        }
        var nextPanelLimitDate = getStart(superOffset(1, pickerValue));
        return !isSameOrAfter(generateConfig2, locale2, maxDate, nextPanelLimitDate, type2);
      }, [maxDate, superOffset, pickerValue, getStart, generateConfig2, locale2, type2]);
      var onOffset = function onOffset2(distance) {
        if (offset2) {
          onChange(offset2(distance, pickerValue));
        }
      };
      var onSuperOffset = function onSuperOffset2(distance) {
        if (superOffset) {
          onChange(superOffset(distance, pickerValue));
        }
      };
      if (hideHeader) {
        return null;
      }
      var prevBtnCls = "".concat(headerPrefixCls, "-prev-btn");
      var nextBtnCls = "".concat(headerPrefixCls, "-next-btn");
      var superPrevBtnCls = "".concat(headerPrefixCls, "-super-prev-btn");
      var superNextBtnCls = "".concat(headerPrefixCls, "-super-next-btn");
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: headerPrefixCls
      }, superOffset && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        "aria-label": locale2.previousYear,
        onClick: function onClick() {
          return onSuperOffset(-1);
        },
        tabIndex: -1,
        className: classNames(superPrevBtnCls, disabledSuperOffsetPrev && "".concat(superPrevBtnCls, "-disabled")),
        disabled: disabledSuperOffsetPrev,
        style: hidePrev ? HIDDEN_STYLE : {}
      }, superPrevIcon), offset2 && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        "aria-label": locale2.previousMonth,
        onClick: function onClick() {
          return onOffset(-1);
        },
        tabIndex: -1,
        className: classNames(prevBtnCls, disabledOffsetPrev && "".concat(prevBtnCls, "-disabled")),
        disabled: disabledOffsetPrev,
        style: hidePrev ? HIDDEN_STYLE : {}
      }, prevIcon), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(headerPrefixCls, "-view")
      }, children), offset2 && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        "aria-label": locale2.nextMonth,
        onClick: function onClick() {
          return onOffset(1);
        },
        tabIndex: -1,
        className: classNames(nextBtnCls, disabledOffsetNext && "".concat(nextBtnCls, "-disabled")),
        disabled: disabledOffsetNext,
        style: hideNext ? HIDDEN_STYLE : {}
      }, nextIcon), superOffset && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        "aria-label": locale2.nextYear,
        onClick: function onClick() {
          return onSuperOffset(1);
        },
        tabIndex: -1,
        className: classNames(superNextBtnCls, disabledSuperOffsetNext && "".concat(superNextBtnCls, "-disabled")),
        disabled: disabledSuperOffsetNext,
        style: hideNext ? HIDDEN_STYLE : {}
      }, superNextIcon));
    }
    function DatePanel(props) {
      var prefixCls = props.prefixCls, _props$panelName = props.panelName, panelName = _props$panelName === void 0 ? "date" : _props$panelName, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange, _props$mode = props.mode, mode = _props$mode === void 0 ? "date" : _props$mode, disabledDate = props.disabledDate, onSelect = props.onSelect, onHover = props.onHover, showWeek = props.showWeek;
      var panelPrefixCls = "".concat(prefixCls, "-").concat(panelName, "-panel");
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var isWeek = mode === "week";
      var _useInfo = useInfo(props, mode), _useInfo2 = _slicedToArray(_useInfo, 2), info = _useInfo2[0], now2 = _useInfo2[1];
      var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2.locale);
      var monthStartDate = generateConfig2.setDate(pickerValue, 1);
      var baseDate = getWeekStartDate(locale2.locale, generateConfig2, monthStartDate);
      var month = generateConfig2.getMonth(pickerValue);
      var showPrefixColumn = showWeek === void 0 ? isWeek : showWeek;
      var prefixColumn = showPrefixColumn ? function(date2) {
        var disabled = disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date2, {
          type: "week"
        });
        return /* @__PURE__ */ reactExports.createElement("td", {
          key: "week",
          className: classNames(cellPrefixCls, "".concat(cellPrefixCls, "-week"), _defineProperty({}, "".concat(cellPrefixCls, "-disabled"), disabled)),
          onClick: function onClick() {
            if (!disabled) {
              onSelect(date2);
            }
          },
          onMouseEnter: function onMouseEnter() {
            if (!disabled) {
              onHover === null || onHover === void 0 || onHover(date2);
            }
          },
          onMouseLeave: function onMouseLeave() {
            if (!disabled) {
              onHover === null || onHover === void 0 || onHover(null);
            }
          }
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(cellPrefixCls, "-inner")
        }, generateConfig2.locale.getWeek(locale2.locale, date2)));
      } : null;
      var headerCells = [];
      var weekDaysLocale = locale2.shortWeekDays || (generateConfig2.locale.getShortWeekDays ? generateConfig2.locale.getShortWeekDays(locale2.locale) : []);
      if (prefixColumn) {
        headerCells.push(/* @__PURE__ */ reactExports.createElement("th", {
          key: "empty"
        }, /* @__PURE__ */ reactExports.createElement("span", {
          style: {
            width: 0,
            height: 0,
            position: "absolute",
            overflow: "hidden",
            opacity: 0
          }
        }, locale2.week)));
      }
      for (var i2 = 0; i2 < WEEK_DAY_COUNT; i2 += 1) {
        headerCells.push(/* @__PURE__ */ reactExports.createElement("th", {
          key: i2
        }, weekDaysLocale[(i2 + weekFirstDay) % WEEK_DAY_COUNT]));
      }
      var getCellDate = function getCellDate2(date2, offset2) {
        return generateConfig2.addDate(date2, offset2);
      };
      var getCellText = function getCellText2(date2) {
        return formatValue(date2, {
          locale: locale2,
          format: locale2.cellDateFormat,
          generateConfig: generateConfig2
        });
      };
      var getCellClassName = function getCellClassName2(date2) {
        var classObj = _defineProperty(_defineProperty({}, "".concat(prefixCls, "-cell-in-view"), isSameMonth(generateConfig2, date2, pickerValue)), "".concat(prefixCls, "-cell-today"), isSameDate(generateConfig2, date2, now2));
        return classObj;
      };
      var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
      var yearNode = /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        "aria-label": locale2.yearSelect,
        key: "year",
        onClick: function onClick() {
          onModeChange("year", pickerValue);
        },
        tabIndex: -1,
        className: "".concat(prefixCls, "-year-btn")
      }, formatValue(pickerValue, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      }));
      var monthNode = /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        "aria-label": locale2.monthSelect,
        key: "month",
        onClick: function onClick() {
          onModeChange("month", pickerValue);
        },
        tabIndex: -1,
        className: "".concat(prefixCls, "-month-btn")
      }, locale2.monthFormat ? formatValue(pickerValue, {
        locale: locale2,
        format: locale2.monthFormat,
        generateConfig: generateConfig2
      }) : monthsLocale[month]);
      var monthYearNodes = locale2.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
      return /* @__PURE__ */ reactExports.createElement(PanelContext.Provider, {
        value: info
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(panelPrefixCls, showWeek && "".concat(panelPrefixCls, "-show-week"))
      }, /* @__PURE__ */ reactExports.createElement(PanelHeader, {
        offset: function offset2(distance) {
          return generateConfig2.addMonth(pickerValue, distance);
        },
        superOffset: function superOffset(distance) {
          return generateConfig2.addYear(pickerValue, distance);
        },
        onChange: onPickerValueChange,
        getStart: function getStart(date2) {
          return generateConfig2.setDate(date2, 1);
        },
        getEnd: function getEnd(date2) {
          var clone2 = generateConfig2.setDate(date2, 1);
          clone2 = generateConfig2.addMonth(clone2, 1);
          return generateConfig2.addDate(clone2, -1);
        }
      }, monthYearNodes), /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$2({
        titleFormat: locale2.fieldDateFormat
      }, props, {
        colNum: WEEK_DAY_COUNT,
        rowNum: 6,
        baseDate,
        headerCells,
        getCellDate,
        getCellText,
        getCellClassName,
        prefixColumn,
        cellSelection: !isWeek
      }))));
    }
    var SPEED_PTG = 1 / 3;
    function useScrollTo(ulRef, value) {
      var scrollingRef = reactExports.useRef(false);
      var scrollRafRef = reactExports.useRef(null);
      var scrollDistRef = reactExports.useRef(null);
      var isScrolling = function isScrolling2() {
        return scrollingRef.current;
      };
      var stopScroll = function stopScroll2() {
        wrapperRaf.cancel(scrollRafRef.current);
        scrollingRef.current = false;
      };
      var scrollRafTimesRef = reactExports.useRef();
      var startScroll = function startScroll2() {
        var ul = ulRef.current;
        scrollDistRef.current = null;
        scrollRafTimesRef.current = 0;
        if (ul) {
          var targetLi = ul.querySelector('[data-value="'.concat(value, '"]'));
          var firstLi = ul.querySelector("li");
          var doScroll = function doScroll2() {
            stopScroll();
            scrollingRef.current = true;
            scrollRafTimesRef.current += 1;
            var currentTop = ul.scrollTop;
            var firstLiTop = firstLi.offsetTop;
            var targetLiTop = targetLi.offsetTop;
            var targetTop = targetLiTop - firstLiTop;
            if (targetLiTop === 0 && targetLi !== firstLi || !isVisible(ul)) {
              if (scrollRafTimesRef.current <= 5) {
                scrollRafRef.current = wrapperRaf(doScroll2);
              }
              return;
            }
            var nextTop = currentTop + (targetTop - currentTop) * SPEED_PTG;
            var dist = Math.abs(targetTop - nextTop);
            if (scrollDistRef.current !== null && scrollDistRef.current < dist) {
              stopScroll();
              return;
            }
            scrollDistRef.current = dist;
            if (dist <= 1) {
              ul.scrollTop = targetTop;
              stopScroll();
              return;
            }
            ul.scrollTop = nextTop;
            scrollRafRef.current = wrapperRaf(doScroll2);
          };
          if (targetLi && firstLi) {
            doScroll();
          }
        }
      };
      var syncScroll = useEvent(startScroll);
      return [syncScroll, stopScroll, isScrolling];
    }
    var SCROLL_DELAY = 300;
    function flattenUnits(units) {
      return units.map(function(_ref) {
        var value = _ref.value, label = _ref.label, disabled = _ref.disabled;
        return [value, label, disabled].join(",");
      }).join(";");
    }
    function TimeColumn(props) {
      var units = props.units, value = props.value, optionalValue = props.optionalValue, type2 = props.type, onChange = props.onChange, onHover = props.onHover, onDblClick = props.onDblClick, changeOnScroll = props.changeOnScroll;
      var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, cellRender = _usePanelContext.cellRender, now2 = _usePanelContext.now, locale2 = _usePanelContext.locale;
      var panelPrefixCls = "".concat(prefixCls, "-time-panel");
      var cellPrefixCls = "".concat(prefixCls, "-time-panel-cell");
      var ulRef = reactExports.useRef(null);
      var checkDelayRef = reactExports.useRef();
      var clearDelayCheck = function clearDelayCheck2() {
        clearTimeout(checkDelayRef.current);
      };
      var _useScrollTo = useScrollTo(ulRef, value !== null && value !== void 0 ? value : optionalValue), _useScrollTo2 = _slicedToArray(_useScrollTo, 3), syncScroll = _useScrollTo2[0], stopScroll = _useScrollTo2[1], isScrolling = _useScrollTo2[2];
      useLayoutEffect$1(function() {
        syncScroll();
        clearDelayCheck();
        return function() {
          stopScroll();
          clearDelayCheck();
        };
      }, [value, optionalValue, flattenUnits(units)]);
      var onInternalScroll = function onInternalScroll2(event) {
        clearDelayCheck();
        var target = event.target;
        if (!isScrolling() && changeOnScroll) {
          checkDelayRef.current = setTimeout(function() {
            var ul = ulRef.current;
            var firstLiTop = ul.querySelector("li").offsetTop;
            var liList = Array.from(ul.querySelectorAll("li"));
            var liTopList = liList.map(function(li) {
              return li.offsetTop - firstLiTop;
            });
            var liDistList = liTopList.map(function(top, index2) {
              if (units[index2].disabled) {
                return Number.MAX_SAFE_INTEGER;
              }
              return Math.abs(top - target.scrollTop);
            });
            var minDist = Math.min.apply(Math, _toConsumableArray(liDistList));
            var minDistIndex = liDistList.findIndex(function(dist) {
              return dist === minDist;
            });
            var targetUnit = units[minDistIndex];
            if (targetUnit && !targetUnit.disabled) {
              onChange(targetUnit.value);
            }
          }, SCROLL_DELAY);
        }
      };
      var columnPrefixCls = "".concat(panelPrefixCls, "-column");
      return /* @__PURE__ */ reactExports.createElement("ul", {
        className: columnPrefixCls,
        ref: ulRef,
        "data-type": type2,
        onScroll: onInternalScroll
      }, units.map(function(_ref2) {
        var label = _ref2.label, unitValue = _ref2.value, disabled = _ref2.disabled;
        var inner = /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(cellPrefixCls, "-inner")
        }, label);
        return /* @__PURE__ */ reactExports.createElement("li", {
          key: unitValue,
          className: classNames(cellPrefixCls, _defineProperty(_defineProperty({}, "".concat(cellPrefixCls, "-selected"), value === unitValue), "".concat(cellPrefixCls, "-disabled"), disabled)),
          onClick: function onClick() {
            if (!disabled) {
              onChange(unitValue);
            }
          },
          onDoubleClick: function onDoubleClick() {
            if (!disabled && onDblClick) {
              onDblClick();
            }
          },
          onMouseEnter: function onMouseEnter() {
            onHover(unitValue);
          },
          onMouseLeave: function onMouseLeave() {
            onHover(null);
          },
          "data-value": unitValue
        }, cellRender ? cellRender(unitValue, {
          prefixCls,
          originNode: inner,
          today: now2,
          type: "time",
          subType: type2,
          locale: locale2
        }) : inner);
      }));
    }
    function isAM(hour) {
      return hour < 12;
    }
    function TimePanelBody(props) {
      var showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, showMillisecond = props.showMillisecond, showMeridiem = props.use12Hours, changeOnScroll = props.changeOnScroll;
      var _usePanelContext = usePanelContext(), prefixCls = _usePanelContext.prefixCls, values = _usePanelContext.values, generateConfig2 = _usePanelContext.generateConfig, locale2 = _usePanelContext.locale, onSelect = _usePanelContext.onSelect, _usePanelContext$onHo = _usePanelContext.onHover, onHover = _usePanelContext$onHo === void 0 ? function() {
      } : _usePanelContext$onHo, pickerValue = _usePanelContext.pickerValue;
      var value = (values === null || values === void 0 ? void 0 : values[0]) || null;
      var _React$useContext = reactExports.useContext(PickerHackContext), onCellDblClick = _React$useContext.onCellDblClick;
      var _useTimeInfo = useTimeInfo(generateConfig2, props, value), _useTimeInfo2 = _slicedToArray(_useTimeInfo, 5), getValidTime = _useTimeInfo2[0], rowHourUnits = _useTimeInfo2[1], getMinuteUnits = _useTimeInfo2[2], getSecondUnits = _useTimeInfo2[3], getMillisecondUnits = _useTimeInfo2[4];
      var getUnitValue2 = function getUnitValue3(func) {
        var valueUnitVal = value && generateConfig2[func](value);
        var pickerUnitValue = pickerValue && generateConfig2[func](pickerValue);
        return [valueUnitVal, pickerUnitValue];
      };
      var _getUnitValue = getUnitValue2("getHour"), _getUnitValue2 = _slicedToArray(_getUnitValue, 2), hour = _getUnitValue2[0], pickerHour = _getUnitValue2[1];
      var _getUnitValue3 = getUnitValue2("getMinute"), _getUnitValue4 = _slicedToArray(_getUnitValue3, 2), minute = _getUnitValue4[0], pickerMinute = _getUnitValue4[1];
      var _getUnitValue5 = getUnitValue2("getSecond"), _getUnitValue6 = _slicedToArray(_getUnitValue5, 2), second = _getUnitValue6[0], pickerSecond = _getUnitValue6[1];
      var _getUnitValue7 = getUnitValue2("getMillisecond"), _getUnitValue8 = _slicedToArray(_getUnitValue7, 2), millisecond = _getUnitValue8[0], pickerMillisecond = _getUnitValue8[1];
      var meridiem = hour === null ? null : isAM(hour) ? "am" : "pm";
      var hourUnits = reactExports.useMemo(function() {
        if (!showMeridiem) {
          return rowHourUnits;
        }
        return isAM(hour) ? rowHourUnits.filter(function(h2) {
          return isAM(h2.value);
        }) : rowHourUnits.filter(function(h2) {
          return !isAM(h2.value);
        });
      }, [hour, rowHourUnits, showMeridiem]);
      var getEnabled = function getEnabled2(units, val) {
        var _enabledUnits$;
        var enabledUnits = units.filter(function(unit2) {
          return !unit2.disabled;
        });
        return val !== null && val !== void 0 ? val : (
          // Fallback to enabled value
          enabledUnits === null || enabledUnits === void 0 || (_enabledUnits$ = enabledUnits[0]) === null || _enabledUnits$ === void 0 ? void 0 : _enabledUnits$.value
        );
      };
      var validHour = getEnabled(rowHourUnits, hour);
      var minuteUnits = reactExports.useMemo(function() {
        return getMinuteUnits(validHour);
      }, [getMinuteUnits, validHour]);
      var validMinute = getEnabled(minuteUnits, minute);
      var secondUnits = reactExports.useMemo(function() {
        return getSecondUnits(validHour, validMinute);
      }, [getSecondUnits, validHour, validMinute]);
      var validSecond = getEnabled(secondUnits, second);
      var millisecondUnits = reactExports.useMemo(function() {
        return getMillisecondUnits(validHour, validMinute, validSecond);
      }, [getMillisecondUnits, validHour, validMinute, validSecond]);
      var validMillisecond = getEnabled(millisecondUnits, millisecond);
      var meridiemUnits = reactExports.useMemo(function() {
        if (!showMeridiem) {
          return [];
        }
        var base = generateConfig2.getNow();
        var amDate = generateConfig2.setHour(base, 6);
        var pmDate = generateConfig2.setHour(base, 18);
        var formatMeridiem = function formatMeridiem2(date2, defaultLabel) {
          var cellMeridiemFormat = locale2.cellMeridiemFormat;
          return cellMeridiemFormat ? formatValue(date2, {
            generateConfig: generateConfig2,
            locale: locale2,
            format: cellMeridiemFormat
          }) : defaultLabel;
        };
        return [{
          label: formatMeridiem(amDate, "AM"),
          value: "am",
          disabled: rowHourUnits.every(function(h2) {
            return h2.disabled || !isAM(h2.value);
          })
        }, {
          label: formatMeridiem(pmDate, "PM"),
          value: "pm",
          disabled: rowHourUnits.every(function(h2) {
            return h2.disabled || isAM(h2.value);
          })
        }];
      }, [rowHourUnits, showMeridiem, generateConfig2, locale2]);
      var triggerChange = function triggerChange2(nextDate) {
        var validateDate = getValidTime(nextDate);
        onSelect(validateDate);
      };
      var triggerDateTmpl = reactExports.useMemo(function() {
        var tmpl = value || pickerValue || generateConfig2.getNow();
        var isNotNull = function isNotNull2(num) {
          return num !== null && num !== void 0;
        };
        if (isNotNull(hour)) {
          tmpl = generateConfig2.setHour(tmpl, hour);
          tmpl = generateConfig2.setMinute(tmpl, minute);
          tmpl = generateConfig2.setSecond(tmpl, second);
          tmpl = generateConfig2.setMillisecond(tmpl, millisecond);
        } else if (isNotNull(pickerHour)) {
          tmpl = generateConfig2.setHour(tmpl, pickerHour);
          tmpl = generateConfig2.setMinute(tmpl, pickerMinute);
          tmpl = generateConfig2.setSecond(tmpl, pickerSecond);
          tmpl = generateConfig2.setMillisecond(tmpl, pickerMillisecond);
        } else if (isNotNull(validHour)) {
          tmpl = generateConfig2.setHour(tmpl, validHour);
          tmpl = generateConfig2.setMinute(tmpl, validMinute);
          tmpl = generateConfig2.setSecond(tmpl, validSecond);
          tmpl = generateConfig2.setMillisecond(tmpl, validMillisecond);
        }
        return tmpl;
      }, [value, pickerValue, hour, minute, second, millisecond, validHour, validMinute, validSecond, validMillisecond, pickerHour, pickerMinute, pickerSecond, pickerMillisecond, generateConfig2]);
      var fillColumnValue = function fillColumnValue2(val, func) {
        if (val === null) {
          return null;
        }
        return generateConfig2[func](triggerDateTmpl, val);
      };
      var getNextHourTime = function getNextHourTime2(val) {
        return fillColumnValue(val, "setHour");
      };
      var getNextMinuteTime = function getNextMinuteTime2(val) {
        return fillColumnValue(val, "setMinute");
      };
      var getNextSecondTime = function getNextSecondTime2(val) {
        return fillColumnValue(val, "setSecond");
      };
      var getNextMillisecondTime = function getNextMillisecondTime2(val) {
        return fillColumnValue(val, "setMillisecond");
      };
      var getMeridiemTime = function getMeridiemTime2(val) {
        if (val === null) {
          return null;
        }
        if (val === "am" && !isAM(hour)) {
          return generateConfig2.setHour(triggerDateTmpl, hour - 12);
        } else if (val === "pm" && isAM(hour)) {
          return generateConfig2.setHour(triggerDateTmpl, hour + 12);
        }
        return triggerDateTmpl;
      };
      var onHourChange = function onHourChange2(val) {
        triggerChange(getNextHourTime(val));
      };
      var onMinuteChange = function onMinuteChange2(val) {
        triggerChange(getNextMinuteTime(val));
      };
      var onSecondChange = function onSecondChange2(val) {
        triggerChange(getNextSecondTime(val));
      };
      var onMillisecondChange = function onMillisecondChange2(val) {
        triggerChange(getNextMillisecondTime(val));
      };
      var onMeridiemChange = function onMeridiemChange2(val) {
        triggerChange(getMeridiemTime(val));
      };
      var onHourHover = function onHourHover2(val) {
        onHover(getNextHourTime(val));
      };
      var onMinuteHover = function onMinuteHover2(val) {
        onHover(getNextMinuteTime(val));
      };
      var onSecondHover = function onSecondHover2(val) {
        onHover(getNextSecondTime(val));
      };
      var onMillisecondHover = function onMillisecondHover2(val) {
        onHover(getNextMillisecondTime(val));
      };
      var onMeridiemHover = function onMeridiemHover2(val) {
        onHover(getMeridiemTime(val));
      };
      var sharedColumnProps = {
        onDblClick: onCellDblClick,
        changeOnScroll
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-content")
      }, showHour && /* @__PURE__ */ reactExports.createElement(TimeColumn, _extends$2({
        units: hourUnits,
        value: hour,
        optionalValue: pickerHour,
        type: "hour",
        onChange: onHourChange,
        onHover: onHourHover
      }, sharedColumnProps)), showMinute && /* @__PURE__ */ reactExports.createElement(TimeColumn, _extends$2({
        units: minuteUnits,
        value: minute,
        optionalValue: pickerMinute,
        type: "minute",
        onChange: onMinuteChange,
        onHover: onMinuteHover
      }, sharedColumnProps)), showSecond && /* @__PURE__ */ reactExports.createElement(TimeColumn, _extends$2({
        units: secondUnits,
        value: second,
        optionalValue: pickerSecond,
        type: "second",
        onChange: onSecondChange,
        onHover: onSecondHover
      }, sharedColumnProps)), showMillisecond && /* @__PURE__ */ reactExports.createElement(TimeColumn, _extends$2({
        units: millisecondUnits,
        value: millisecond,
        optionalValue: pickerMillisecond,
        type: "millisecond",
        onChange: onMillisecondChange,
        onHover: onMillisecondHover
      }, sharedColumnProps)), showMeridiem && /* @__PURE__ */ reactExports.createElement(TimeColumn, _extends$2({
        units: meridiemUnits,
        value: meridiem,
        type: "meridiem",
        onChange: onMeridiemChange,
        onHover: onMeridiemHover
      }, sharedColumnProps)));
    }
    function TimePanel(props) {
      var prefixCls = props.prefixCls, value = props.value, locale2 = props.locale, generateConfig2 = props.generateConfig, showTime = props.showTime;
      var _ref = showTime || {}, format2 = _ref.format;
      var panelPrefixCls = "".concat(prefixCls, "-time-panel");
      var _useInfo = useInfo(props, "time"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0];
      return /* @__PURE__ */ reactExports.createElement(PanelContext.Provider, {
        value: info
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(panelPrefixCls)
      }, /* @__PURE__ */ reactExports.createElement(PanelHeader, null, value ? formatValue(value, {
        locale: locale2,
        format: format2,
        generateConfig: generateConfig2
      }) : ""), /* @__PURE__ */ reactExports.createElement(TimePanelBody, showTime)));
    }
    function DateTimePanel(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, showTime = props.showTime, onSelect = props.onSelect, value = props.value, pickerValue = props.pickerValue, onHover = props.onHover;
      var panelPrefixCls = "".concat(prefixCls, "-datetime-panel");
      var _useTimeInfo = useTimeInfo(generateConfig2, showTime), _useTimeInfo2 = _slicedToArray(_useTimeInfo, 1), getValidTime = _useTimeInfo2[0];
      var mergeTime = function mergeTime2(date2) {
        if (value) {
          return fillTime(generateConfig2, date2, value);
        }
        return fillTime(generateConfig2, date2, pickerValue);
      };
      var onDateHover = function onDateHover2(date2) {
        onHover === null || onHover === void 0 || onHover(date2 ? mergeTime(date2) : date2);
      };
      var onDateSelect = function onDateSelect2(date2) {
        var cloneDate = mergeTime(date2);
        onSelect(getValidTime(cloneDate, cloneDate));
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(DatePanel, _extends$2({}, props, {
        onSelect: onDateSelect,
        onHover: onDateHover
      })), /* @__PURE__ */ reactExports.createElement(TimePanel, props));
    }
    function DecadePanel(props) {
      var prefixCls = props.prefixCls, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange;
      var panelPrefixCls = "".concat(prefixCls, "-decade-panel");
      var _useInfo = useInfo(props, "decade"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0];
      var getStartYear = function getStartYear2(date2) {
        var startYear = Math.floor(generateConfig2.getYear(date2) / 100) * 100;
        return generateConfig2.setYear(date2, startYear);
      };
      var getEndYear = function getEndYear2(date2) {
        var startYear = getStartYear(date2);
        return generateConfig2.addYear(startYear, 99);
      };
      var startYearDate = getStartYear(pickerValue);
      var endYearDate = getEndYear(pickerValue);
      var baseDate = generateConfig2.addYear(startYearDate, -10);
      var getCellDate = function getCellDate2(date2, offset2) {
        return generateConfig2.addYear(date2, offset2 * 10);
      };
      var getCellText = function getCellText2(date2) {
        var cellYearFormat = locale2.cellYearFormat;
        var startYearStr = formatValue(date2, {
          locale: locale2,
          format: cellYearFormat,
          generateConfig: generateConfig2
        });
        var endYearStr = formatValue(generateConfig2.addYear(date2, 9), {
          locale: locale2,
          format: cellYearFormat,
          generateConfig: generateConfig2
        });
        return "".concat(startYearStr, "-").concat(endYearStr);
      };
      var getCellClassName = function getCellClassName2(date2) {
        return _defineProperty({}, "".concat(prefixCls, "-cell-in-view"), isSameDecade(generateConfig2, date2, startYearDate) || isSameDecade(generateConfig2, date2, endYearDate) || isInRange(generateConfig2, startYearDate, endYearDate, date2));
      };
      var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
        var baseStartDate = generateConfig2.setDate(currentDate, 1);
        var baseStartMonth = generateConfig2.setMonth(baseStartDate, 0);
        var baseStartYear = generateConfig2.setYear(baseStartMonth, Math.floor(generateConfig2.getYear(baseStartMonth) / 10) * 10);
        var baseEndYear = generateConfig2.addYear(baseStartYear, 10);
        var baseEndDate = generateConfig2.addDate(baseEndYear, -1);
        return disabledDate(baseStartYear, disabledInfo) && disabledDate(baseEndDate, disabledInfo);
      } : null;
      var yearNode = "".concat(formatValue(startYearDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      }), "-").concat(formatValue(endYearDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      }));
      return /* @__PURE__ */ reactExports.createElement(PanelContext.Provider, {
        value: info
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(PanelHeader, {
        superOffset: function superOffset(distance) {
          return generateConfig2.addYear(pickerValue, distance * 100);
        },
        onChange: onPickerValueChange,
        getStart: getStartYear,
        getEnd: getEndYear
      }, yearNode), /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$2({}, props, {
        disabledDate: mergedDisabledDate,
        colNum: 3,
        rowNum: 4,
        baseDate,
        getCellDate,
        getCellText,
        getCellClassName
      }))));
    }
    function MonthPanel(props) {
      var prefixCls = props.prefixCls, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
      var panelPrefixCls = "".concat(prefixCls, "-month-panel");
      var _useInfo = useInfo(props, "month"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0];
      var baseDate = generateConfig2.setMonth(pickerValue, 0);
      var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
      var getCellDate = function getCellDate2(date2, offset2) {
        return generateConfig2.addMonth(date2, offset2);
      };
      var getCellText = function getCellText2(date2) {
        var month = generateConfig2.getMonth(date2);
        return locale2.monthFormat ? formatValue(date2, {
          locale: locale2,
          format: locale2.monthFormat,
          generateConfig: generateConfig2
        }) : monthsLocale[month];
      };
      var getCellClassName = function getCellClassName2() {
        return _defineProperty({}, "".concat(prefixCls, "-cell-in-view"), true);
      };
      var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
        var startDate = generateConfig2.setDate(currentDate, 1);
        var nextMonthStartDate = generateConfig2.setMonth(startDate, generateConfig2.getMonth(startDate) + 1);
        var endDate = generateConfig2.addDate(nextMonthStartDate, -1);
        return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
      } : null;
      var yearNode = /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        key: "year",
        "aria-label": locale2.yearSelect,
        onClick: function onClick() {
          onModeChange("year");
        },
        tabIndex: -1,
        className: "".concat(prefixCls, "-year-btn")
      }, formatValue(pickerValue, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      }));
      return /* @__PURE__ */ reactExports.createElement(PanelContext.Provider, {
        value: info
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(PanelHeader, {
        superOffset: function superOffset(distance) {
          return generateConfig2.addYear(pickerValue, distance);
        },
        onChange: onPickerValueChange,
        getStart: function getStart(date2) {
          return generateConfig2.setMonth(date2, 0);
        },
        getEnd: function getEnd(date2) {
          return generateConfig2.setMonth(date2, 11);
        }
      }, yearNode), /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$2({}, props, {
        disabledDate: mergedDisabledDate,
        titleFormat: locale2.fieldMonthFormat,
        colNum: 3,
        rowNum: 4,
        baseDate,
        getCellDate,
        getCellText,
        getCellClassName
      }))));
    }
    function QuarterPanel(props) {
      var prefixCls = props.prefixCls, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
      var panelPrefixCls = "".concat(prefixCls, "-quarter-panel");
      var _useInfo = useInfo(props, "quarter"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0];
      var baseDate = generateConfig2.setMonth(pickerValue, 0);
      var getCellDate = function getCellDate2(date2, offset2) {
        return generateConfig2.addMonth(date2, offset2 * 3);
      };
      var getCellText = function getCellText2(date2) {
        return formatValue(date2, {
          locale: locale2,
          format: locale2.cellQuarterFormat,
          generateConfig: generateConfig2
        });
      };
      var getCellClassName = function getCellClassName2() {
        return _defineProperty({}, "".concat(prefixCls, "-cell-in-view"), true);
      };
      var yearNode = /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        key: "year",
        "aria-label": locale2.yearSelect,
        onClick: function onClick() {
          onModeChange("year");
        },
        tabIndex: -1,
        className: "".concat(prefixCls, "-year-btn")
      }, formatValue(pickerValue, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      }));
      return /* @__PURE__ */ reactExports.createElement(PanelContext.Provider, {
        value: info
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(PanelHeader, {
        superOffset: function superOffset(distance) {
          return generateConfig2.addYear(pickerValue, distance);
        },
        onChange: onPickerValueChange,
        getStart: function getStart(date2) {
          return generateConfig2.setMonth(date2, 0);
        },
        getEnd: function getEnd(date2) {
          return generateConfig2.setMonth(date2, 11);
        }
      }, yearNode), /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$2({}, props, {
        titleFormat: locale2.fieldQuarterFormat,
        colNum: 4,
        rowNum: 1,
        baseDate,
        getCellDate,
        getCellText,
        getCellClassName
      }))));
    }
    function WeekPanel(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, value = props.value, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue;
      var localeName = locale2.locale;
      var rowPrefixCls = "".concat(prefixCls, "-week-panel-row");
      var rowClassName = function rowClassName2(currentDate) {
        var rangeCls = {};
        if (hoverRangeValue) {
          var _hoverRangeValue = _slicedToArray(hoverRangeValue, 2), rangeStart = _hoverRangeValue[0], rangeEnd = _hoverRangeValue[1];
          var isRangeStart = isSameWeek(generateConfig2, localeName, rangeStart, currentDate);
          var isRangeEnd = isSameWeek(generateConfig2, localeName, rangeEnd, currentDate);
          rangeCls["".concat(rowPrefixCls, "-range-start")] = isRangeStart;
          rangeCls["".concat(rowPrefixCls, "-range-end")] = isRangeEnd;
          rangeCls["".concat(rowPrefixCls, "-range-hover")] = !isRangeStart && !isRangeEnd && isInRange(generateConfig2, rangeStart, rangeEnd, currentDate);
        }
        if (hoverValue) {
          rangeCls["".concat(rowPrefixCls, "-hover")] = hoverValue.some(function(date2) {
            return isSameWeek(generateConfig2, localeName, currentDate, date2);
          });
        }
        return classNames(
          rowPrefixCls,
          _defineProperty({}, "".concat(rowPrefixCls, "-selected"), !hoverRangeValue && isSameWeek(generateConfig2, localeName, value, currentDate)),
          // Patch for hover range
          rangeCls
        );
      };
      return /* @__PURE__ */ reactExports.createElement(DatePanel, _extends$2({}, props, {
        mode: "week",
        panelName: "week",
        rowClassName
      }));
    }
    function YearPanel(props) {
      var prefixCls = props.prefixCls, locale2 = props.locale, generateConfig2 = props.generateConfig, pickerValue = props.pickerValue, disabledDate = props.disabledDate, onPickerValueChange = props.onPickerValueChange, onModeChange = props.onModeChange;
      var panelPrefixCls = "".concat(prefixCls, "-year-panel");
      var _useInfo = useInfo(props, "year"), _useInfo2 = _slicedToArray(_useInfo, 1), info = _useInfo2[0];
      var getStartYear = function getStartYear2(date2) {
        var startYear = Math.floor(generateConfig2.getYear(date2) / 10) * 10;
        return generateConfig2.setYear(date2, startYear);
      };
      var getEndYear = function getEndYear2(date2) {
        var startYear = getStartYear(date2);
        return generateConfig2.addYear(startYear, 9);
      };
      var startYearDate = getStartYear(pickerValue);
      var endYearDate = getEndYear(pickerValue);
      var baseDate = generateConfig2.addYear(startYearDate, -1);
      var getCellDate = function getCellDate2(date2, offset2) {
        return generateConfig2.addYear(date2, offset2);
      };
      var getCellText = function getCellText2(date2) {
        return formatValue(date2, {
          locale: locale2,
          format: locale2.cellYearFormat,
          generateConfig: generateConfig2
        });
      };
      var getCellClassName = function getCellClassName2(date2) {
        return _defineProperty({}, "".concat(prefixCls, "-cell-in-view"), isSameYear(generateConfig2, date2, startYearDate) || isSameYear(generateConfig2, date2, endYearDate) || isInRange(generateConfig2, startYearDate, endYearDate, date2));
      };
      var mergedDisabledDate = disabledDate ? function(currentDate, disabledInfo) {
        var startMonth = generateConfig2.setMonth(currentDate, 0);
        var startDate = generateConfig2.setDate(startMonth, 1);
        var endMonth = generateConfig2.addYear(startDate, 1);
        var endDate = generateConfig2.addDate(endMonth, -1);
        return disabledDate(startDate, disabledInfo) && disabledDate(endDate, disabledInfo);
      } : null;
      var yearNode = /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        key: "decade",
        "aria-label": locale2.decadeSelect,
        onClick: function onClick() {
          onModeChange("decade");
        },
        tabIndex: -1,
        className: "".concat(prefixCls, "-decade-btn")
      }, formatValue(startYearDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      }), "-", formatValue(endYearDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      }));
      return /* @__PURE__ */ reactExports.createElement(PanelContext.Provider, {
        value: info
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(PanelHeader, {
        superOffset: function superOffset(distance) {
          return generateConfig2.addYear(pickerValue, distance * 10);
        },
        onChange: onPickerValueChange,
        getStart: getStartYear,
        getEnd: getEndYear
      }, yearNode), /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$2({}, props, {
        disabledDate: mergedDisabledDate,
        titleFormat: locale2.fieldYearFormat,
        colNum: 3,
        rowNum: 4,
        baseDate,
        getCellDate,
        getCellText,
        getCellClassName
      }))));
    }
    var DefaultComponents = {
      date: DatePanel,
      datetime: DateTimePanel,
      week: WeekPanel,
      month: MonthPanel,
      quarter: QuarterPanel,
      year: YearPanel,
      decade: DecadePanel,
      time: TimePanel
    };
    function PickerPanel(props, ref) {
      var _React$useContext;
      var locale2 = props.locale, generateConfig2 = props.generateConfig, direction = props.direction, prefixCls = props.prefixCls, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, multiple = props.multiple, defaultValue = props.defaultValue, value = props.value, onChange = props.onChange, onSelect = props.onSelect, defaultPickerValue = props.defaultPickerValue, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, mode = props.mode, onPanelChange = props.onPanelChange, _props$picker = props.picker, picker = _props$picker === void 0 ? "date" : _props$picker, showTime = props.showTime, hoverValue = props.hoverValue, hoverRangeValue = props.hoverRangeValue, cellRender = props.cellRender, dateRender = props.dateRender, monthCellRender = props.monthCellRender, _props$components = props.components, components = _props$components === void 0 ? {} : _props$components, hideHeader = props.hideHeader;
      var mergedPrefixCls = ((_React$useContext = reactExports.useContext(PickerContext)) === null || _React$useContext === void 0 ? void 0 : _React$useContext.prefixCls) || prefixCls || "rc-picker";
      var rootRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function() {
        return {
          nativeElement: rootRef.current
        };
      });
      var _getTimeProps = getTimeProps(props), _getTimeProps2 = _slicedToArray(_getTimeProps, 4), timeProps = _getTimeProps2[0], localeTimeProps = _getTimeProps2[1], showTimeFormat = _getTimeProps2[2], propFormat = _getTimeProps2[3];
      var filledLocale = useLocale(locale2, localeTimeProps);
      var internalPicker = picker === "date" && showTime ? "datetime" : picker;
      var mergedShowTime = reactExports.useMemo(function() {
        return fillShowTimeConfig(internalPicker, showTimeFormat, propFormat, timeProps, filledLocale);
      }, [internalPicker, showTimeFormat, propFormat, timeProps, filledLocale]);
      var now2 = generateConfig2.getNow();
      var _useMergedState = useMergedState(picker, {
        value: mode,
        postState: function postState(val) {
          return val || "date";
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedMode = _useMergedState2[0], setMergedMode = _useMergedState2[1];
      var internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
      var toggleDates = useToggleDates(generateConfig2, locale2, internalPicker);
      var _useMergedState3 = useMergedState(defaultValue, {
        value
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), innerValue = _useMergedState4[0], setMergedValue = _useMergedState4[1];
      var mergedValue = reactExports.useMemo(function() {
        var values = toArray$1(innerValue).filter(function(val) {
          return val;
        });
        return multiple ? values : values.slice(0, 1);
      }, [innerValue, multiple]);
      var triggerChange = useEvent(function(nextValue) {
        setMergedValue(nextValue);
        if (onChange && (nextValue === null || mergedValue.length !== nextValue.length || mergedValue.some(function(ori, index2) {
          return !isSame(generateConfig2, locale2, ori, nextValue[index2], internalPicker);
        }))) {
          onChange === null || onChange === void 0 || onChange(multiple ? nextValue : nextValue[0]);
        }
      });
      var onInternalSelect = useEvent(function(newDate) {
        onSelect === null || onSelect === void 0 || onSelect(newDate);
        if (mergedMode === picker) {
          var nextValues = multiple ? toggleDates(mergedValue, newDate) : [newDate];
          triggerChange(nextValues);
        }
      });
      var _useMergedState5 = useMergedState(defaultPickerValue || mergedValue[0] || now2, {
        value: pickerValue
      }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedPickerValue = _useMergedState6[0], setInternalPickerValue = _useMergedState6[1];
      reactExports.useEffect(function() {
        if (mergedValue[0] && !pickerValue) {
          setInternalPickerValue(mergedValue[0]);
        }
      }, [mergedValue[0]]);
      var triggerPanelChange = function triggerPanelChange2(viewDate, nextMode) {
        onPanelChange === null || onPanelChange === void 0 || onPanelChange(viewDate || pickerValue, nextMode || mergedMode);
      };
      var setPickerValue = function setPickerValue2(nextPickerValue) {
        var triggerPanelEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        setInternalPickerValue(nextPickerValue);
        onPickerValueChange === null || onPickerValueChange === void 0 || onPickerValueChange(nextPickerValue);
        if (triggerPanelEvent) {
          triggerPanelChange(nextPickerValue);
        }
      };
      var triggerModeChange = function triggerModeChange2(nextMode, viewDate) {
        setMergedMode(nextMode);
        if (viewDate) {
          setPickerValue(viewDate);
        }
        triggerPanelChange(viewDate, nextMode);
      };
      var onPanelValueSelect = function onPanelValueSelect2(nextValue) {
        onInternalSelect(nextValue);
        setPickerValue(nextValue);
        if (mergedMode !== picker) {
          var decadeYearQueue = ["decade", "year"];
          var decadeYearMonthQueue = [].concat(decadeYearQueue, ["month"]);
          var pickerQueue = {
            quarter: [].concat(decadeYearQueue, ["quarter"]),
            week: [].concat(_toConsumableArray(decadeYearMonthQueue), ["week"]),
            date: [].concat(_toConsumableArray(decadeYearMonthQueue), ["date"])
          };
          var queue = pickerQueue[picker] || decadeYearMonthQueue;
          var index2 = queue.indexOf(mergedMode);
          var nextMode = queue[index2 + 1];
          if (nextMode) {
            triggerModeChange(nextMode, nextValue);
          }
        }
      };
      var hoverRangeDate = reactExports.useMemo(function() {
        var start;
        var end;
        if (Array.isArray(hoverRangeValue)) {
          var _hoverRangeValue = _slicedToArray(hoverRangeValue, 2);
          start = _hoverRangeValue[0];
          end = _hoverRangeValue[1];
        } else {
          start = hoverRangeValue;
        }
        if (!start && !end) {
          return null;
        }
        start = start || end;
        end = end || start;
        return generateConfig2.isAfter(start, end) ? [end, start] : [start, end];
      }, [hoverRangeValue, generateConfig2]);
      var onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender);
      var PanelComponent = components[internalMode] || DefaultComponents[internalMode] || DatePanel;
      var parentHackContext = reactExports.useContext(PickerHackContext);
      var pickerPanelContext = reactExports.useMemo(function() {
        return _objectSpread2$3(_objectSpread2$3({}, parentHackContext), {}, {
          hideHeader
        });
      }, [parentHackContext, hideHeader]);
      var panelCls = "".concat(mergedPrefixCls, "-panel");
      var panelProps = pickProps(props, [
        // Week
        "showWeek",
        // Icons
        "prevIcon",
        "nextIcon",
        "superPrevIcon",
        "superNextIcon",
        // Disabled
        "disabledDate",
        "minDate",
        "maxDate",
        // Hover
        "onHover"
      ]);
      return /* @__PURE__ */ reactExports.createElement(PickerHackContext.Provider, {
        value: pickerPanelContext
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: rootRef,
        tabIndex,
        className: classNames(panelCls, _defineProperty({}, "".concat(panelCls, "-rtl"), direction === "rtl"))
      }, /* @__PURE__ */ reactExports.createElement(PanelComponent, _extends$2({}, panelProps, {
        // Time
        showTime: mergedShowTime,
        prefixCls: mergedPrefixCls,
        locale: filledLocale,
        generateConfig: generateConfig2,
        onModeChange: triggerModeChange,
        pickerValue: mergedPickerValue,
        onPickerValueChange: function onPickerValueChange2(nextPickerValue) {
          setPickerValue(nextPickerValue, true);
        },
        value: mergedValue[0],
        onSelect: onPanelValueSelect,
        values: mergedValue,
        cellRender: onInternalCellRender,
        hoverRangeValue: hoverRangeDate,
        hoverValue
      }))));
    }
    var RefPanelPicker = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(PickerPanel));
    function PopupPanel(props) {
      var picker = props.picker, multiplePanel = props.multiplePanel, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, needConfirm = props.needConfirm, onSubmit = props.onSubmit, range2 = props.range, hoverValue = props.hoverValue;
      var _React$useContext = reactExports.useContext(PickerContext), prefixCls = _React$useContext.prefixCls, generateConfig2 = _React$useContext.generateConfig;
      var internalOffsetDate = reactExports.useCallback(function(date2, offset2) {
        return offsetPanelDate(generateConfig2, picker, date2, offset2);
      }, [generateConfig2, picker]);
      var nextPickerValue = reactExports.useMemo(function() {
        return internalOffsetDate(pickerValue, 1);
      }, [pickerValue, internalOffsetDate]);
      var onSecondPickerValueChange = function onSecondPickerValueChange2(nextDate) {
        onPickerValueChange(internalOffsetDate(nextDate, -1));
      };
      var sharedContext = {
        onCellDblClick: function onCellDblClick() {
          if (needConfirm) {
            onSubmit();
          }
        }
      };
      var hideHeader = picker === "time";
      var pickerProps = _objectSpread2$3(_objectSpread2$3({}, props), {}, {
        hoverValue: null,
        hoverRangeValue: null,
        hideHeader
      });
      if (range2) {
        pickerProps.hoverRangeValue = hoverValue;
      } else {
        pickerProps.hoverValue = hoverValue;
      }
      if (multiplePanel) {
        return /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(prefixCls, "-panels")
        }, /* @__PURE__ */ reactExports.createElement(PickerHackContext.Provider, {
          value: _objectSpread2$3(_objectSpread2$3({}, sharedContext), {}, {
            hideNext: true
          })
        }, /* @__PURE__ */ reactExports.createElement(RefPanelPicker, pickerProps)), /* @__PURE__ */ reactExports.createElement(PickerHackContext.Provider, {
          value: _objectSpread2$3(_objectSpread2$3({}, sharedContext), {}, {
            hidePrev: true
          })
        }, /* @__PURE__ */ reactExports.createElement(RefPanelPicker, _extends$2({}, pickerProps, {
          pickerValue: nextPickerValue,
          onPickerValueChange: onSecondPickerValueChange
        }))));
      }
      return /* @__PURE__ */ reactExports.createElement(PickerHackContext.Provider, {
        value: _objectSpread2$3({}, sharedContext)
      }, /* @__PURE__ */ reactExports.createElement(RefPanelPicker, pickerProps));
    }
    function executeValue(value) {
      return typeof value === "function" ? value() : value;
    }
    function PresetPanel(props) {
      var prefixCls = props.prefixCls, presets = props.presets, _onClick = props.onClick, onHover = props.onHover;
      if (!presets.length) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-presets")
      }, /* @__PURE__ */ reactExports.createElement("ul", null, presets.map(function(_ref, index2) {
        var label = _ref.label, value = _ref.value;
        return /* @__PURE__ */ reactExports.createElement("li", {
          key: index2,
          onClick: function onClick() {
            _onClick(executeValue(value));
          },
          onMouseEnter: function onMouseEnter() {
            onHover(executeValue(value));
          },
          onMouseLeave: function onMouseLeave() {
            onHover(null);
          }
        }, label);
      })));
    }
    function Popup(props) {
      var panelRender = props.panelRender, internalMode = props.internalMode, picker = props.picker, showNow = props.showNow, range2 = props.range, multiple = props.multiple, _props$activeInfo = props.activeInfo, activeInfo = _props$activeInfo === void 0 ? [0, 0, 0] : _props$activeInfo, presets = props.presets, onPresetHover = props.onPresetHover, onPresetSubmit = props.onPresetSubmit, onFocus = props.onFocus, onBlur = props.onBlur, onPanelMouseDown = props.onPanelMouseDown, direction = props.direction, value = props.value, onSelect = props.onSelect, isInvalid = props.isInvalid, defaultOpenValue = props.defaultOpenValue, onOk = props.onOk, onSubmit = props.onSubmit;
      var _React$useContext = reactExports.useContext(PickerContext), prefixCls = _React$useContext.prefixCls;
      var panelPrefixCls = "".concat(prefixCls, "-panel");
      var rtl = direction === "rtl";
      var arrowRef = reactExports.useRef(null);
      var wrapperRef = reactExports.useRef(null);
      var _React$useState = reactExports.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), containerWidth = _React$useState2[0], setContainerWidth = _React$useState2[1];
      var _React$useState3 = reactExports.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), containerOffset = _React$useState4[0], setContainerOffset = _React$useState4[1];
      var _React$useState5 = reactExports.useState(0), _React$useState6 = _slicedToArray(_React$useState5, 2), arrowOffset = _React$useState6[0], setArrowOffset = _React$useState6[1];
      var onResize2 = function onResize3(info) {
        if (info.width) {
          setContainerWidth(info.width);
        }
      };
      var _activeInfo = _slicedToArray(activeInfo, 3), activeInputLeft = _activeInfo[0], activeInputRight = _activeInfo[1], selectorWidth = _activeInfo[2];
      var _React$useState7 = reactExports.useState(0), _React$useState8 = _slicedToArray(_React$useState7, 2), retryTimes = _React$useState8[0], setRetryTimes = _React$useState8[1];
      reactExports.useEffect(function() {
        setRetryTimes(10);
      }, [activeInputLeft]);
      reactExports.useEffect(function() {
        if (range2 && wrapperRef.current) {
          var _arrowRef$current;
          var arrowWidth = ((_arrowRef$current = arrowRef.current) === null || _arrowRef$current === void 0 ? void 0 : _arrowRef$current.offsetWidth) || 0;
          var wrapperRect = wrapperRef.current.getBoundingClientRect();
          if (!wrapperRect.height || wrapperRect.right < 0) {
            setRetryTimes(function(times) {
              return Math.max(0, times - 1);
            });
            return;
          }
          var nextArrowOffset = (rtl ? activeInputRight - arrowWidth : activeInputLeft) - wrapperRect.left;
          setArrowOffset(nextArrowOffset);
          if (containerWidth && containerWidth < selectorWidth) {
            var offset2 = rtl ? wrapperRect.right - (activeInputRight - arrowWidth + containerWidth) : activeInputLeft + arrowWidth - wrapperRect.left - containerWidth;
            var safeOffset = Math.max(0, offset2);
            setContainerOffset(safeOffset);
          } else {
            setContainerOffset(0);
          }
        }
      }, [retryTimes, rtl, containerWidth, activeInputLeft, activeInputRight, selectorWidth, range2]);
      function filterEmpty(list) {
        return list.filter(function(item) {
          return item;
        });
      }
      var valueList = reactExports.useMemo(function() {
        return filterEmpty(toArray$1(value));
      }, [value]);
      var isTimePickerEmptyValue = picker === "time" && !valueList.length;
      var footerSubmitValue = reactExports.useMemo(function() {
        if (isTimePickerEmptyValue) {
          return filterEmpty([defaultOpenValue]);
        }
        return valueList;
      }, [isTimePickerEmptyValue, valueList, defaultOpenValue]);
      var popupPanelValue = isTimePickerEmptyValue ? defaultOpenValue : valueList;
      var disableSubmit = reactExports.useMemo(function() {
        if (!footerSubmitValue.length) {
          return true;
        }
        return footerSubmitValue.some(function(val) {
          return isInvalid(val);
        });
      }, [footerSubmitValue, isInvalid]);
      var onFooterSubmit = function onFooterSubmit2() {
        if (isTimePickerEmptyValue) {
          onSelect(defaultOpenValue);
        }
        onOk();
        onSubmit();
      };
      var mergedNodes = /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-panel-layout")
      }, /* @__PURE__ */ reactExports.createElement(PresetPanel, {
        prefixCls,
        presets,
        onClick: onPresetSubmit,
        onHover: onPresetHover
      }), /* @__PURE__ */ reactExports.createElement("div", null, /* @__PURE__ */ reactExports.createElement(PopupPanel, _extends$2({}, props, {
        value: popupPanelValue
      })), /* @__PURE__ */ reactExports.createElement(Footer, _extends$2({}, props, {
        showNow: multiple ? false : showNow,
        invalid: disableSubmit,
        onSubmit: onFooterSubmit
      }))));
      if (panelRender) {
        mergedNodes = panelRender(mergedNodes);
      }
      var containerPrefixCls = "".concat(panelPrefixCls, "-container");
      var marginLeft = "marginLeft";
      var marginRight = "marginRight";
      var renderNode = /* @__PURE__ */ reactExports.createElement("div", {
        onMouseDown: onPanelMouseDown,
        tabIndex: -1,
        className: classNames(
          containerPrefixCls,
          // Used for Today Button style, safe to remove if no need
          "".concat(prefixCls, "-").concat(internalMode, "-panel-container")
        ),
        style: _defineProperty(_defineProperty({}, rtl ? marginRight : marginLeft, containerOffset), rtl ? marginLeft : marginRight, "auto"),
        onFocus,
        onBlur
      }, mergedNodes);
      if (range2) {
        renderNode = /* @__PURE__ */ reactExports.createElement("div", {
          onMouseDown: onPanelMouseDown,
          ref: wrapperRef,
          className: classNames("".concat(prefixCls, "-range-wrapper"), "".concat(prefixCls, "-").concat(picker, "-range-wrapper"))
        }, /* @__PURE__ */ reactExports.createElement("div", {
          ref: arrowRef,
          className: "".concat(prefixCls, "-range-arrow"),
          style: {
            left: arrowOffset
          }
        }), /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          onResize: onResize2
        }, renderNode));
      }
      return renderNode;
    }
    function useInputProps(props, postProps) {
      var format2 = props.format, maskFormat = props.maskFormat, generateConfig2 = props.generateConfig, locale2 = props.locale, preserveInvalidOnBlur = props.preserveInvalidOnBlur, inputReadOnly = props.inputReadOnly, required2 = props.required, ariaRequired = props["aria-required"], onSubmit = props.onSubmit, _onFocus = props.onFocus, _onBlur = props.onBlur, onInputChange = props.onInputChange, onInvalid = props.onInvalid, open2 = props.open, onOpenChange = props.onOpenChange, _onKeyDown = props.onKeyDown, _onChange = props.onChange, activeHelp = props.activeHelp, name = props.name, autoComplete = props.autoComplete, id = props.id, value = props.value, invalid = props.invalid, placeholder = props.placeholder, disabled = props.disabled, activeIndex = props.activeIndex, allHelp = props.allHelp, picker = props.picker;
      var parseDate = function parseDate2(str, formatStr) {
        var parsed = generateConfig2.locale.parse(locale2.locale, str, [formatStr]);
        return parsed && generateConfig2.isValidate(parsed) ? parsed : null;
      };
      var firstFormat = format2[0];
      var getText = reactExports.useCallback(function(date2) {
        return formatValue(date2, {
          locale: locale2,
          format: firstFormat,
          generateConfig: generateConfig2
        });
      }, [locale2, generateConfig2, firstFormat]);
      var valueTexts = reactExports.useMemo(function() {
        return value.map(getText);
      }, [value, getText]);
      var size = reactExports.useMemo(function() {
        var defaultSize = picker === "time" ? 8 : 10;
        var length2 = typeof firstFormat === "function" ? firstFormat(generateConfig2.getNow()).length : firstFormat.length;
        return Math.max(defaultSize, length2) + 2;
      }, [firstFormat, picker, generateConfig2]);
      var _validateFormat = function validateFormat(text) {
        for (var i2 = 0; i2 < format2.length; i2 += 1) {
          var singleFormat = format2[i2];
          if (typeof singleFormat === "string") {
            var parsed = parseDate(text, singleFormat);
            if (parsed) {
              return parsed;
            }
          }
        }
        return false;
      };
      var getInputProps = function getInputProps2(index2) {
        function getProp(propValue) {
          return index2 !== void 0 ? propValue[index2] : propValue;
        }
        var pickedAttrs = pickAttrs(props, {
          aria: true,
          data: true
        });
        var inputProps = _objectSpread2$3(_objectSpread2$3({}, pickedAttrs), {}, {
          // ============== Shared ==============
          format: maskFormat,
          validateFormat: function validateFormat(text) {
            return !!_validateFormat(text);
          },
          preserveInvalidOnBlur,
          readOnly: inputReadOnly,
          required: required2,
          "aria-required": ariaRequired,
          name,
          autoComplete,
          size,
          // ============= By Index =============
          id: getProp(id),
          value: getProp(valueTexts) || "",
          invalid: getProp(invalid),
          placeholder: getProp(placeholder),
          active: activeIndex === index2,
          helped: allHelp || activeHelp && activeIndex === index2,
          disabled: getProp(disabled),
          onFocus: function onFocus(event) {
            _onFocus(event, index2);
          },
          onBlur: function onBlur(event) {
            _onBlur(event, index2);
          },
          onSubmit,
          // Get validate text value
          onChange: function onChange(text) {
            onInputChange();
            var parsed = _validateFormat(text);
            if (parsed) {
              onInvalid(false, index2);
              _onChange(parsed, index2);
              return;
            }
            onInvalid(!!text, index2);
          },
          onHelp: function onHelp() {
            onOpenChange(true, {
              index: index2
            });
          },
          onKeyDown: function onKeyDown(event) {
            var prevented = false;
            _onKeyDown === null || _onKeyDown === void 0 || _onKeyDown(event, function() {
              prevented = true;
            });
            if (!event.defaultPrevented && !prevented) {
              switch (event.key) {
                case "Escape":
                  onOpenChange(false, {
                    index: index2
                  });
                  break;
                case "Enter":
                  if (!open2) {
                    onOpenChange(true);
                  }
                  break;
              }
            }
          }
        }, postProps === null || postProps === void 0 ? void 0 : postProps({
          valueTexts
        }));
        Object.keys(inputProps).forEach(function(key) {
          if (inputProps[key] === void 0) {
            delete inputProps[key];
          }
        });
        return inputProps;
      };
      return [getInputProps, getText];
    }
    var propNames = ["onMouseEnter", "onMouseLeave"];
    function useRootProps(props) {
      return reactExports.useMemo(function() {
        return pickProps(props, propNames);
      }, [props]);
    }
    var _excluded$g = ["icon", "type"], _excluded2$3 = ["onClear"];
    function Icon$1(props) {
      var icon = props.icon, type2 = props.type, restProps = _objectWithoutProperties(props, _excluded$g);
      var _React$useContext = reactExports.useContext(PickerContext), prefixCls = _React$useContext.prefixCls;
      return icon ? /* @__PURE__ */ reactExports.createElement("span", _extends$2({
        className: "".concat(prefixCls, "-").concat(type2)
      }, restProps), icon) : null;
    }
    function ClearIcon(_ref) {
      var onClear = _ref.onClear, restProps = _objectWithoutProperties(_ref, _excluded2$3);
      return /* @__PURE__ */ reactExports.createElement(Icon$1, _extends$2({}, restProps, {
        type: "clear",
        role: "button",
        onMouseDown: function onMouseDown(e2) {
          e2.preventDefault();
        },
        onClick: function onClick(e2) {
          e2.stopPropagation();
          onClear();
        }
      }));
    }
    var FORMAT_KEYS = ["YYYY", "MM", "DD", "HH", "mm", "ss", "SSS"];
    var REPLACE_KEY = "";
    var MaskFormat = /* @__PURE__ */ function() {
      function MaskFormat2(format2) {
        _classCallCheck(this, MaskFormat2);
        _defineProperty(this, "format", void 0);
        _defineProperty(this, "maskFormat", void 0);
        _defineProperty(this, "cells", void 0);
        _defineProperty(this, "maskCells", void 0);
        this.format = format2;
        var replaceKeys = FORMAT_KEYS.map(function(key) {
          return "(".concat(key, ")");
        }).join("|");
        var replaceReg = new RegExp(replaceKeys, "g");
        this.maskFormat = format2.replace(
          replaceReg,
          // Use Chinese character to avoid user use it in format
          function(key) {
            return REPLACE_KEY.repeat(key.length);
          }
        );
        var cellReg = new RegExp("(".concat(FORMAT_KEYS.join("|"), ")"));
        var strCells = (format2.split(cellReg) || []).filter(function(str) {
          return str;
        });
        var offset2 = 0;
        this.cells = strCells.map(function(text) {
          var mask = FORMAT_KEYS.includes(text);
          var start = offset2;
          var end = offset2 + text.length;
          offset2 = end;
          return {
            text,
            mask,
            start,
            end
          };
        });
        this.maskCells = this.cells.filter(function(cell) {
          return cell.mask;
        });
      }
      _createClass(MaskFormat2, [{
        key: "getSelection",
        value: function getSelection(maskCellIndex) {
          var _ref = this.maskCells[maskCellIndex] || {}, start = _ref.start, end = _ref.end;
          return [start || 0, end || 0];
        }
        /** Check given text match format */
      }, {
        key: "match",
        value: function match2(text) {
          for (var i2 = 0; i2 < this.maskFormat.length; i2 += 1) {
            var maskChar = this.maskFormat[i2];
            var textChar = text[i2];
            if (!textChar || maskChar !== REPLACE_KEY && maskChar !== textChar) {
              return false;
            }
          }
          return true;
        }
        /** Get mask cell count */
      }, {
        key: "size",
        value: function size() {
          return this.maskCells.length;
        }
      }, {
        key: "getMaskCellIndex",
        value: function getMaskCellIndex(anchorIndex) {
          var closetDist = Number.MAX_SAFE_INTEGER;
          var closetIndex = 0;
          for (var i2 = 0; i2 < this.maskCells.length; i2 += 1) {
            var _this$maskCells$i = this.maskCells[i2], start = _this$maskCells$i.start, end = _this$maskCells$i.end;
            if (anchorIndex >= start && anchorIndex <= end) {
              return i2;
            }
            var dist = Math.min(Math.abs(anchorIndex - start), Math.abs(anchorIndex - end));
            if (dist < closetDist) {
              closetDist = dist;
              closetIndex = i2;
            }
          }
          return closetIndex;
        }
      }]);
      return MaskFormat2;
    }();
    function getMaskRange(key) {
      var PresetRange = {
        YYYY: [0, 9999, (/* @__PURE__ */ new Date()).getFullYear()],
        MM: [1, 12],
        DD: [1, 31],
        HH: [0, 23],
        mm: [0, 59],
        ss: [0, 59],
        SSS: [0, 999]
      };
      return PresetRange[key];
    }
    var _excluded$f = ["active", "showActiveCls", "suffixIcon", "format", "validateFormat", "onChange", "onInput", "helped", "onHelp", "onSubmit", "onKeyDown", "preserveInvalidOnBlur", "invalid", "clearIcon"];
    var Input$4 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var active = props.active, _props$showActiveCls = props.showActiveCls, showActiveCls = _props$showActiveCls === void 0 ? true : _props$showActiveCls, suffixIcon = props.suffixIcon, format2 = props.format, validateFormat = props.validateFormat, onChange = props.onChange;
      props.onInput;
      var helped = props.helped, onHelp = props.onHelp, onSubmit = props.onSubmit, onKeyDown = props.onKeyDown, _props$preserveInvali = props.preserveInvalidOnBlur, preserveInvalidOnBlur = _props$preserveInvali === void 0 ? false : _props$preserveInvali, invalid = props.invalid, clearIcon = props.clearIcon, restProps = _objectWithoutProperties(props, _excluded$f);
      var value = props.value, onFocus = props.onFocus, onBlur = props.onBlur, onMouseUp = props.onMouseUp;
      var _React$useContext = reactExports.useContext(PickerContext), prefixCls = _React$useContext.prefixCls, _React$useContext$inp = _React$useContext.input, Component2 = _React$useContext$inp === void 0 ? "input" : _React$useContext$inp;
      var inputPrefixCls = "".concat(prefixCls, "-input");
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
      var _React$useState3 = reactExports.useState(value), _React$useState4 = _slicedToArray(_React$useState3, 2), internalInputValue = _React$useState4[0], setInputValue = _React$useState4[1];
      var _React$useState5 = reactExports.useState(""), _React$useState6 = _slicedToArray(_React$useState5, 2), focusCellText = _React$useState6[0], setFocusCellText = _React$useState6[1];
      var _React$useState7 = reactExports.useState(null), _React$useState8 = _slicedToArray(_React$useState7, 2), focusCellIndex = _React$useState8[0], setFocusCellIndex = _React$useState8[1];
      var _React$useState9 = reactExports.useState(null), _React$useState10 = _slicedToArray(_React$useState9, 2), forceSelectionSyncMark = _React$useState10[0], forceSelectionSync = _React$useState10[1];
      var inputValue = internalInputValue || "";
      reactExports.useEffect(function() {
        setInputValue(value);
      }, [value]);
      var holderRef = reactExports.useRef();
      var inputRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function() {
        return {
          nativeElement: holderRef.current,
          inputElement: inputRef.current,
          focus: function focus(options2) {
            inputRef.current.focus(options2);
          },
          blur: function blur() {
            inputRef.current.blur();
          }
        };
      });
      var maskFormat = reactExports.useMemo(function() {
        return new MaskFormat(format2 || "");
      }, [format2]);
      var _React$useMemo = reactExports.useMemo(function() {
        if (helped) {
          return [0, 0];
        }
        return maskFormat.getSelection(focusCellIndex);
      }, [maskFormat, focusCellIndex, helped]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), selectionStart = _React$useMemo2[0], selectionEnd = _React$useMemo2[1];
      var onModify = function onModify2(text) {
        if (text && text !== format2 && text !== value) {
          onHelp();
        }
      };
      var triggerInputChange = useEvent(function(text) {
        if (validateFormat(text)) {
          onChange(text);
        }
        setInputValue(text);
        onModify(text);
      });
      var onInternalChange = function onInternalChange2(event) {
        if (!format2) {
          var text = event.target.value;
          onModify(text);
          setInputValue(text);
          onChange(text);
        }
      };
      var onFormatPaste = function onFormatPaste2(event) {
        var pasteText = event.clipboardData.getData("text");
        if (validateFormat(pasteText)) {
          triggerInputChange(pasteText);
        }
      };
      var mouseDownRef = reactExports.useRef(false);
      var onFormatMouseDown = function onFormatMouseDown2() {
        mouseDownRef.current = true;
      };
      var onFormatMouseUp = function onFormatMouseUp2(event) {
        var _ref = event.target, start = _ref.selectionStart;
        var closeMaskIndex = maskFormat.getMaskCellIndex(start);
        setFocusCellIndex(closeMaskIndex);
        forceSelectionSync({});
        onMouseUp === null || onMouseUp === void 0 || onMouseUp(event);
        mouseDownRef.current = false;
      };
      var onFormatFocus = function onFormatFocus2(event) {
        setFocused(true);
        setFocusCellIndex(0);
        setFocusCellText("");
        onFocus(event);
      };
      var onSharedBlur = function onSharedBlur2(event) {
        onBlur(event);
      };
      var onFormatBlur = function onFormatBlur2(event) {
        setFocused(false);
        onSharedBlur(event);
      };
      useLockEffect(active, function() {
        if (!active && !preserveInvalidOnBlur) {
          setInputValue(value);
        }
      });
      var onSharedKeyDown = function onSharedKeyDown2(event) {
        if (event.key === "Enter" && validateFormat(inputValue)) {
          onSubmit();
        }
        onKeyDown === null || onKeyDown === void 0 || onKeyDown(event);
      };
      var onFormatKeyDown = function onFormatKeyDown2(event) {
        onSharedKeyDown(event);
        var key = event.key;
        var nextCellText = null;
        var nextFillText = null;
        var maskCellLen = selectionEnd - selectionStart;
        var cellFormat = format2.slice(selectionStart, selectionEnd);
        var offsetCellIndex = function offsetCellIndex2(offset2) {
          setFocusCellIndex(function(idx) {
            var nextIndex = idx + offset2;
            nextIndex = Math.max(nextIndex, 0);
            nextIndex = Math.min(nextIndex, maskFormat.size() - 1);
            return nextIndex;
          });
        };
        var offsetCellValue = function offsetCellValue2(offset2) {
          var _getMaskRange = getMaskRange(cellFormat), _getMaskRange2 = _slicedToArray(_getMaskRange, 3), rangeStart = _getMaskRange2[0], rangeEnd = _getMaskRange2[1], rangeDefault = _getMaskRange2[2];
          var currentText = inputValue.slice(selectionStart, selectionEnd);
          var currentTextNum = Number(currentText);
          if (isNaN(currentTextNum)) {
            return String(rangeDefault ? rangeDefault : offset2 > 0 ? rangeStart : rangeEnd);
          }
          var num = currentTextNum + offset2;
          var range2 = rangeEnd - rangeStart + 1;
          return String(rangeStart + (range2 + num - rangeStart) % range2);
        };
        switch (key) {
          case "Backspace":
          case "Delete":
            nextCellText = "";
            nextFillText = cellFormat;
            break;
          case "ArrowLeft":
            nextCellText = "";
            offsetCellIndex(-1);
            break;
          case "ArrowRight":
            nextCellText = "";
            offsetCellIndex(1);
            break;
          case "ArrowUp":
            nextCellText = "";
            nextFillText = offsetCellValue(1);
            break;
          case "ArrowDown":
            nextCellText = "";
            nextFillText = offsetCellValue(-1);
            break;
          default:
            if (!isNaN(Number(key))) {
              nextCellText = focusCellText + key;
              nextFillText = nextCellText;
            }
            break;
        }
        if (nextCellText !== null) {
          setFocusCellText(nextCellText);
          if (nextCellText.length >= maskCellLen) {
            offsetCellIndex(1);
            setFocusCellText("");
          }
        }
        if (nextFillText !== null) {
          var nextFocusValue = (
            // before
            inputValue.slice(0, selectionStart) + // replace
            leftPad(nextFillText, maskCellLen) + // after
            inputValue.slice(selectionEnd)
          );
          triggerInputChange(nextFocusValue.slice(0, format2.length));
        }
        forceSelectionSync({});
      };
      var rafRef = reactExports.useRef();
      useLayoutEffect$1(function() {
        if (!focused || !format2 || mouseDownRef.current) {
          return;
        }
        if (!maskFormat.match(inputValue)) {
          triggerInputChange(format2);
          return;
        }
        inputRef.current.setSelectionRange(selectionStart, selectionEnd);
        rafRef.current = wrapperRaf(function() {
          inputRef.current.setSelectionRange(selectionStart, selectionEnd);
        });
        return function() {
          wrapperRaf.cancel(rafRef.current);
        };
      }, [maskFormat, format2, focused, inputValue, focusCellIndex, selectionStart, selectionEnd, forceSelectionSyncMark, triggerInputChange]);
      var inputProps = format2 ? {
        onFocus: onFormatFocus,
        onBlur: onFormatBlur,
        onKeyDown: onFormatKeyDown,
        onMouseDown: onFormatMouseDown,
        onMouseUp: onFormatMouseUp,
        onPaste: onFormatPaste
      } : {};
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: holderRef,
        className: classNames(inputPrefixCls, _defineProperty(_defineProperty({}, "".concat(inputPrefixCls, "-active"), active && showActiveCls), "".concat(inputPrefixCls, "-placeholder"), helped))
      }, /* @__PURE__ */ reactExports.createElement(Component2, _extends$2({
        ref: inputRef,
        "aria-invalid": invalid,
        autoComplete: "off"
      }, restProps, {
        onKeyDown: onSharedKeyDown,
        onBlur: onSharedBlur
        // Replace with format
      }, inputProps, {
        // Value
        value: inputValue,
        onChange: onInternalChange
      })), /* @__PURE__ */ reactExports.createElement(Icon$1, {
        type: "suffix",
        icon: suffixIcon
      }), clearIcon);
    });
    var _excluded$e = ["id", "prefix", "clearIcon", "suffixIcon", "separator", "activeIndex", "activeHelp", "allHelp", "focused", "onFocus", "onBlur", "onKeyDown", "locale", "generateConfig", "placeholder", "className", "style", "onClick", "onClear", "value", "onChange", "onSubmit", "onInputChange", "format", "maskFormat", "preserveInvalidOnBlur", "onInvalid", "disabled", "invalid", "inputReadOnly", "direction", "onOpenChange", "onActiveInfo", "placement", "onMouseDown", "required", "aria-required", "autoFocus", "tabIndex"], _excluded2$2 = ["index"];
    function RangeSelector(props, ref) {
      var id = props.id, prefix2 = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon, _props$separator = props.separator, separator = _props$separator === void 0 ? "~" : _props$separator, activeIndex = props.activeIndex;
      props.activeHelp;
      props.allHelp;
      var focused = props.focused;
      props.onFocus;
      props.onBlur;
      props.onKeyDown;
      props.locale;
      props.generateConfig;
      var placeholder = props.placeholder, className = props.className, style2 = props.style, onClick = props.onClick, onClear = props.onClear, value = props.value;
      props.onChange;
      props.onSubmit;
      props.onInputChange;
      props.format;
      props.maskFormat;
      props.preserveInvalidOnBlur;
      props.onInvalid;
      var disabled = props.disabled, invalid = props.invalid;
      props.inputReadOnly;
      var direction = props.direction;
      props.onOpenChange;
      var onActiveInfo = props.onActiveInfo;
      props.placement;
      var _onMouseDown = props.onMouseDown;
      props.required;
      props["aria-required"];
      var autoFocus = props.autoFocus, tabIndex = props.tabIndex, restProps = _objectWithoutProperties(props, _excluded$e);
      var rtl = direction === "rtl";
      var _React$useContext = reactExports.useContext(PickerContext), prefixCls = _React$useContext.prefixCls;
      var ids = reactExports.useMemo(function() {
        if (typeof id === "string") {
          return [id];
        }
        var mergedId = id || {};
        return [mergedId.start, mergedId.end];
      }, [id]);
      var rootRef = reactExports.useRef();
      var inputStartRef = reactExports.useRef();
      var inputEndRef = reactExports.useRef();
      var getInput = function getInput2(index2) {
        var _index;
        return (_index = [inputStartRef, inputEndRef][index2]) === null || _index === void 0 ? void 0 : _index.current;
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          nativeElement: rootRef.current,
          focus: function focus(options2) {
            if (_typeof$1(options2) === "object") {
              var _getInput;
              var _ref = options2 || {}, _ref$index = _ref.index, _index2 = _ref$index === void 0 ? 0 : _ref$index, rest = _objectWithoutProperties(_ref, _excluded2$2);
              (_getInput = getInput(_index2)) === null || _getInput === void 0 || _getInput.focus(rest);
            } else {
              var _getInput2;
              (_getInput2 = getInput(options2 !== null && options2 !== void 0 ? options2 : 0)) === null || _getInput2 === void 0 || _getInput2.focus();
            }
          },
          blur: function blur() {
            var _getInput3, _getInput4;
            (_getInput3 = getInput(0)) === null || _getInput3 === void 0 || _getInput3.blur();
            (_getInput4 = getInput(1)) === null || _getInput4 === void 0 || _getInput4.blur();
          }
        };
      });
      var rootProps = useRootProps(restProps);
      var mergedPlaceholder = reactExports.useMemo(function() {
        return Array.isArray(placeholder) ? placeholder : [placeholder, placeholder];
      }, [placeholder]);
      var _useInputProps = useInputProps(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
        id: ids,
        placeholder: mergedPlaceholder
      })), _useInputProps2 = _slicedToArray(_useInputProps, 1), getInputProps = _useInputProps2[0];
      var _React$useState = reactExports.useState({
        position: "absolute",
        width: 0
      }), _React$useState2 = _slicedToArray(_React$useState, 2), activeBarStyle = _React$useState2[0], setActiveBarStyle = _React$useState2[1];
      var syncActiveOffset = useEvent(function() {
        var input = getInput(activeIndex);
        if (input) {
          var inputRect = input.nativeElement.getBoundingClientRect();
          var parentRect = rootRef.current.getBoundingClientRect();
          var rectOffset = inputRect.left - parentRect.left;
          setActiveBarStyle(function(ori) {
            return _objectSpread2$3(_objectSpread2$3({}, ori), {}, {
              width: inputRect.width,
              left: rectOffset
            });
          });
          onActiveInfo([inputRect.left, inputRect.right, parentRect.width]);
        }
      });
      reactExports.useEffect(function() {
        syncActiveOffset();
      }, [activeIndex]);
      var showClear = clearIcon && (value[0] && !disabled[0] || value[1] && !disabled[1]);
      var startAutoFocus = autoFocus && !disabled[0];
      var endAutoFocus = autoFocus && !startAutoFocus && !disabled[1];
      return /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: syncActiveOffset
      }, /* @__PURE__ */ reactExports.createElement("div", _extends$2({}, rootProps, {
        className: classNames(prefixCls, "".concat(prefixCls, "-range"), _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled.every(function(i2) {
          return i2;
        })), "".concat(prefixCls, "-invalid"), invalid.some(function(i2) {
          return i2;
        })), "".concat(prefixCls, "-rtl"), rtl), className),
        style: style2,
        ref: rootRef,
        onClick,
        onMouseDown: function onMouseDown(e2) {
          var target = e2.target;
          if (target !== inputStartRef.current.inputElement && target !== inputEndRef.current.inputElement) {
            e2.preventDefault();
          }
          _onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(e2);
        }
      }), prefix2 && /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-prefix")
      }, prefix2), /* @__PURE__ */ reactExports.createElement(Input$4, _extends$2({
        ref: inputStartRef
      }, getInputProps(0), {
        autoFocus: startAutoFocus,
        tabIndex,
        "date-range": "start"
      })), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-range-separator")
      }, separator), /* @__PURE__ */ reactExports.createElement(Input$4, _extends$2({
        ref: inputEndRef
      }, getInputProps(1), {
        autoFocus: endAutoFocus,
        tabIndex,
        "date-range": "end"
      })), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-active-bar"),
        style: activeBarStyle
      }), /* @__PURE__ */ reactExports.createElement(Icon$1, {
        type: "suffix",
        icon: suffixIcon
      }), showClear && /* @__PURE__ */ reactExports.createElement(ClearIcon, {
        icon: clearIcon,
        onClear
      })));
    }
    var RefRangeSelector = /* @__PURE__ */ reactExports.forwardRef(RangeSelector);
    function separateConfig(config, defaultConfig2) {
      var singleConfig = config !== null && config !== void 0 ? config : defaultConfig2;
      if (Array.isArray(singleConfig)) {
        return singleConfig;
      }
      return [singleConfig, singleConfig];
    }
    function getActiveRange(activeIndex) {
      return activeIndex === 1 ? "end" : "start";
    }
    function RangePicker$1(props, ref) {
      var _useFilledProps = useFilledProps(props, function() {
        var disabled2 = props.disabled, allowEmpty2 = props.allowEmpty;
        var mergedDisabled = separateConfig(disabled2, false);
        var mergedAllowEmpty = separateConfig(allowEmpty2, false);
        return {
          disabled: mergedDisabled,
          allowEmpty: mergedAllowEmpty
        };
      }), _useFilledProps2 = _slicedToArray(_useFilledProps, 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5];
      var prefixCls = filledProps.prefixCls, styles = filledProps.styles, classNames2 = filledProps.classNames, defaultValue = filledProps.defaultValue, value = filledProps.value, needConfirm = filledProps.needConfirm, onKeyDown = filledProps.onKeyDown, disabled = filledProps.disabled, allowEmpty = filledProps.allowEmpty, disabledDate = filledProps.disabledDate, minDate = filledProps.minDate, maxDate = filledProps.maxDate, defaultOpen = filledProps.defaultOpen, open2 = filledProps.open, onOpenChange = filledProps.onOpenChange, locale2 = filledProps.locale, generateConfig2 = filledProps.generateConfig, picker = filledProps.picker, showNow = filledProps.showNow, showToday = filledProps.showToday, showTime = filledProps.showTime, mode = filledProps.mode, onPanelChange = filledProps.onPanelChange, onCalendarChange = filledProps.onCalendarChange, onOk = filledProps.onOk, defaultPickerValue = filledProps.defaultPickerValue, pickerValue = filledProps.pickerValue, onPickerValueChange = filledProps.onPickerValueChange, inputReadOnly = filledProps.inputReadOnly, suffixIcon = filledProps.suffixIcon, onFocus = filledProps.onFocus, onBlur = filledProps.onBlur, presets = filledProps.presets, ranges = filledProps.ranges, components = filledProps.components, cellRender = filledProps.cellRender, dateRender = filledProps.dateRender, monthCellRender = filledProps.monthCellRender, onClick = filledProps.onClick;
      var selectorRef = usePickerRef(ref);
      var _useOpen = useOpen(open2, defaultOpen, disabled, onOpenChange), _useOpen2 = _slicedToArray(_useOpen, 2), mergedOpen = _useOpen2[0], setMergeOpen = _useOpen2[1];
      var triggerOpen = function triggerOpen2(nextOpen, config) {
        if (disabled.some(function(fieldDisabled) {
          return !fieldDisabled;
        }) || !nextOpen) {
          setMergeOpen(nextOpen, config);
        }
      };
      var _useInnerValue = useInnerValue(generateConfig2, locale2, formatList, true, false, defaultValue, value, onCalendarChange, onOk), _useInnerValue2 = _slicedToArray(_useInnerValue, 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4];
      var calendarValue = getCalendarValue();
      var _useRangeActive = useRangeActive(disabled, allowEmpty, mergedOpen), _useRangeActive2 = _slicedToArray(_useRangeActive, 9), focused = _useRangeActive2[0], triggerFocus2 = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3], setActiveIndex = _useRangeActive2[4], nextActiveIndex = _useRangeActive2[5], activeIndexList = _useRangeActive2[6], updateSubmitIndex = _useRangeActive2[7], hasActiveSubmitValue = _useRangeActive2[8];
      var onSharedFocus = function onSharedFocus2(event, index2) {
        triggerFocus2(true);
        onFocus === null || onFocus === void 0 || onFocus(event, {
          range: getActiveRange(index2 !== null && index2 !== void 0 ? index2 : activeIndex)
        });
      };
      var onSharedBlur = function onSharedBlur2(event, index2) {
        triggerFocus2(false);
        onBlur === null || onBlur === void 0 || onBlur(event, {
          range: getActiveRange(index2 !== null && index2 !== void 0 ? index2 : activeIndex)
        });
      };
      var mergedShowTime = reactExports.useMemo(function() {
        if (!showTime) {
          return null;
        }
        var disabledTime = showTime.disabledTime;
        var proxyDisabledTime = disabledTime ? function(date2) {
          var range2 = getActiveRange(activeIndex);
          var fromDate = getFromDate(calendarValue, activeIndexList, activeIndex);
          return disabledTime(date2, range2, {
            from: fromDate
          });
        } : void 0;
        return _objectSpread2$3(_objectSpread2$3({}, showTime), {}, {
          disabledTime: proxyDisabledTime
        });
      }, [showTime, activeIndex, calendarValue, activeIndexList]);
      var _useMergedState = useMergedState([picker, picker], {
        value: mode
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), modes = _useMergedState2[0], setModes = _useMergedState2[1];
      var mergedMode = modes[activeIndex] || picker;
      var internalMode = mergedMode === "date" && mergedShowTime ? "datetime" : mergedMode;
      var multiplePanel = internalMode === picker && internalMode !== "time";
      var mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday, true);
      var _useRangeValue = useRangeValue(filledProps, mergedValue, setInnerValue, getCalendarValue, triggerCalendarChange, disabled, formatList, focused, mergedOpen, isInvalidateDate), _useRangeValue2 = _slicedToArray(_useRangeValue, 2), flushSubmit = _useRangeValue2[0], triggerSubmitChange = _useRangeValue2[1];
      var mergedDisabledDate = useRangeDisabledDate(calendarValue, disabled, activeIndexList, generateConfig2, locale2, disabledDate);
      var _useFieldsInvalidate = useFieldsInvalidate(calendarValue, isInvalidateDate, allowEmpty), _useFieldsInvalidate2 = _slicedToArray(_useFieldsInvalidate, 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1];
      var _useRangePickerValue = useRangePickerValue(generateConfig2, locale2, calendarValue, modes, mergedOpen, activeIndex, internalPicker, multiplePanel, defaultPickerValue, pickerValue, mergedShowTime === null || mergedShowTime === void 0 ? void 0 : mergedShowTime.defaultOpenValue, onPickerValueChange, minDate, maxDate), _useRangePickerValue2 = _slicedToArray(_useRangePickerValue, 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1];
      var triggerModeChange = useEvent(function(nextPickerValue, nextMode, triggerEvent) {
        var clone2 = fillIndex(modes, activeIndex, nextMode);
        if (clone2[0] !== modes[0] || clone2[1] !== modes[1]) {
          setModes(clone2);
        }
        if (onPanelChange && triggerEvent !== false) {
          var clonePickerValue = _toConsumableArray(calendarValue);
          if (nextPickerValue) {
            clonePickerValue[activeIndex] = nextPickerValue;
          }
          onPanelChange(clonePickerValue, clone2);
        }
      });
      var fillCalendarValue = function fillCalendarValue2(date2, index2) {
        return (
          // Trigger change only when date changed
          fillIndex(calendarValue, index2, date2)
        );
      };
      var triggerPartConfirm = function triggerPartConfirm2(date2, skipFocus) {
        var nextValue = calendarValue;
        if (date2) {
          nextValue = fillCalendarValue(date2, activeIndex);
        }
        updateSubmitIndex(activeIndex);
        var nextIndex = nextActiveIndex(nextValue);
        triggerCalendarChange(nextValue);
        flushSubmit(activeIndex, nextIndex === null);
        if (nextIndex === null) {
          triggerOpen(false, {
            force: true
          });
        } else if (!skipFocus) {
          selectorRef.current.focus({
            index: nextIndex
          });
        }
      };
      var onSelectorClick = function onSelectorClick2(event) {
        var _activeElement;
        var rootNode = event.target.getRootNode();
        if (!selectorRef.current.nativeElement.contains((_activeElement = rootNode.activeElement) !== null && _activeElement !== void 0 ? _activeElement : document.activeElement)) {
          var enabledIndex = disabled.findIndex(function(d2) {
            return !d2;
          });
          if (enabledIndex >= 0) {
            selectorRef.current.focus({
              index: enabledIndex
            });
          }
        }
        triggerOpen(true);
        onClick === null || onClick === void 0 || onClick(event);
      };
      var onSelectorClear = function onSelectorClear2() {
        triggerSubmitChange(null);
        triggerOpen(false, {
          force: true
        });
      };
      var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1];
      var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), internalHoverValues = _React$useState4[0], setInternalHoverValues = _React$useState4[1];
      var hoverValues = reactExports.useMemo(function() {
        return internalHoverValues || calendarValue;
      }, [calendarValue, internalHoverValues]);
      reactExports.useEffect(function() {
        if (!mergedOpen) {
          setInternalHoverValues(null);
        }
      }, [mergedOpen]);
      var _React$useState5 = reactExports.useState([0, 0, 0]), _React$useState6 = _slicedToArray(_React$useState5, 2), activeInfo = _React$useState6[0], setActiveInfo = _React$useState6[1];
      var presetList = usePresets(presets, ranges);
      var onPresetHover = function onPresetHover2(nextValues) {
        setInternalHoverValues(nextValues);
        setHoverSource("preset");
      };
      var onPresetSubmit = function onPresetSubmit2(nextValues) {
        var passed = triggerSubmitChange(nextValues);
        if (passed) {
          triggerOpen(false, {
            force: true
          });
        }
      };
      var onNow = function onNow2(now2) {
        triggerPartConfirm(now2);
      };
      var onPanelHover = function onPanelHover2(date2) {
        setInternalHoverValues(date2 ? fillCalendarValue(date2, activeIndex) : null);
        setHoverSource("cell");
      };
      var onPanelFocus = function onPanelFocus2(event) {
        triggerOpen(true);
        onSharedFocus(event);
      };
      var onPanelMouseDown = function onPanelMouseDown2() {
        lastOperation("panel");
      };
      var onPanelSelect = function onPanelSelect2(date2) {
        var clone2 = fillIndex(calendarValue, activeIndex, date2);
        triggerCalendarChange(clone2);
        if (!needConfirm && !complexPicker && internalPicker === internalMode) {
          triggerPartConfirm(date2);
        }
      };
      var onPopupClose = function onPopupClose2() {
        triggerOpen(false);
      };
      var onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender, getActiveRange(activeIndex));
      var panelValue = calendarValue[activeIndex] || null;
      var isPopupInvalidateDate = useEvent(function(date2) {
        return isInvalidateDate(date2, {
          activeIndex
        });
      });
      var panelProps = reactExports.useMemo(function() {
        var domProps = pickAttrs(filledProps, false);
        var restProps = omit(filledProps, [].concat(_toConsumableArray(Object.keys(domProps)), ["onChange", "onCalendarChange", "style", "className", "onPanelChange", "disabledTime"]));
        return restProps;
      }, [filledProps]);
      var panel = /* @__PURE__ */ reactExports.createElement(Popup, _extends$2({}, panelProps, {
        showNow: mergedShowNow,
        showTime: mergedShowTime,
        range: true,
        multiplePanel,
        activeInfo,
        disabledDate: mergedDisabledDate,
        onFocus: onPanelFocus,
        onBlur: onSharedBlur,
        onPanelMouseDown,
        picker,
        mode: mergedMode,
        internalMode,
        onPanelChange: triggerModeChange,
        format: maskFormat,
        value: panelValue,
        isInvalid: isPopupInvalidateDate,
        onChange: null,
        onSelect: onPanelSelect,
        pickerValue: currentPickerValue,
        defaultOpenValue: toArray$1(showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue)[activeIndex],
        onPickerValueChange: setCurrentPickerValue,
        hoverValue: hoverValues,
        onHover: onPanelHover,
        needConfirm,
        onSubmit: triggerPartConfirm,
        onOk: triggerOk,
        presets: presetList,
        onPresetHover,
        onPresetSubmit,
        onNow,
        cellRender: onInternalCellRender
      }));
      var onSelectorChange = function onSelectorChange2(date2, index2) {
        var clone2 = fillCalendarValue(date2, index2);
        triggerCalendarChange(clone2);
      };
      var onSelectorInputChange = function onSelectorInputChange2() {
        lastOperation("input");
      };
      var onSelectorFocus = function onSelectorFocus2(event, index2) {
        var activeListLen = activeIndexList.length;
        var lastActiveIndex = activeIndexList[activeListLen - 1];
        if (activeListLen && lastActiveIndex !== index2 && needConfirm && // Not change index if is not filled
        !allowEmpty[lastActiveIndex] && !hasActiveSubmitValue(lastActiveIndex) && calendarValue[lastActiveIndex]) {
          selectorRef.current.focus({
            index: lastActiveIndex
          });
          return;
        }
        lastOperation("input");
        triggerOpen(true, {
          inherit: true
        });
        if (activeIndex !== index2 && mergedOpen && !needConfirm && complexPicker) {
          triggerPartConfirm(null, true);
        }
        setActiveIndex(index2);
        onSharedFocus(event, index2);
      };
      var onSelectorBlur = function onSelectorBlur2(event, index2) {
        triggerOpen(false);
        if (!needConfirm && lastOperation() === "input") {
          var nextIndex = nextActiveIndex(calendarValue);
          flushSubmit(activeIndex, nextIndex === null);
        }
        onSharedBlur(event, index2);
      };
      var onSelectorKeyDown = function onSelectorKeyDown2(event, preventDefault) {
        if (event.key === "Tab") {
          triggerPartConfirm(null, true);
        }
        onKeyDown === null || onKeyDown === void 0 || onKeyDown(event, preventDefault);
      };
      var context = reactExports.useMemo(function() {
        return {
          prefixCls,
          locale: locale2,
          generateConfig: generateConfig2,
          button: components.button,
          input: components.input
        };
      }, [prefixCls, locale2, generateConfig2, components.button, components.input]);
      useLayoutEffect$1(function() {
        if (mergedOpen && activeIndex !== void 0) {
          triggerModeChange(null, picker, false);
        }
      }, [mergedOpen, activeIndex, picker]);
      useLayoutEffect$1(function() {
        var lastOp = lastOperation();
        if (!mergedOpen && lastOp === "input") {
          triggerOpen(false);
          triggerPartConfirm(null, true);
        }
        if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") {
          triggerOpen(true);
          triggerPartConfirm();
        }
      }, [mergedOpen]);
      return /* @__PURE__ */ reactExports.createElement(PickerContext.Provider, {
        value: context
      }, /* @__PURE__ */ reactExports.createElement(PickerTrigger, _extends$2({}, pickTriggerProps(filledProps), {
        popupElement: panel,
        popupStyle: styles.popup,
        popupClassName: classNames2.popup,
        visible: mergedOpen,
        onClose: onPopupClose,
        range: true
      }), /* @__PURE__ */ reactExports.createElement(
        RefRangeSelector,
        _extends$2({}, filledProps, {
          // Ref
          ref: selectorRef,
          suffixIcon,
          activeIndex: focused || mergedOpen ? activeIndex : null,
          activeHelp: !!internalHoverValues,
          allHelp: !!internalHoverValues && hoverSource === "preset",
          focused,
          onFocus: onSelectorFocus,
          onBlur: onSelectorBlur,
          onKeyDown: onSelectorKeyDown,
          onSubmit: triggerPartConfirm,
          value: hoverValues,
          maskFormat,
          onChange: onSelectorChange,
          onInputChange: onSelectorInputChange,
          format: formatList,
          inputReadOnly,
          disabled,
          open: mergedOpen,
          onOpenChange: triggerOpen,
          onClick: onSelectorClick,
          onClear: onSelectorClear,
          invalid: submitInvalidates,
          onInvalid: onSelectorInvalid,
          onActiveInfo: setActiveInfo
        })
      )));
    }
    var RefRangePicker = /* @__PURE__ */ reactExports.forwardRef(RangePicker$1);
    function MultipleDates(props) {
      var prefixCls = props.prefixCls, value = props.value, onRemove = props.onRemove, _props$removeIcon = props.removeIcon, removeIcon = _props$removeIcon === void 0 ? "" : _props$removeIcon, formatDate = props.formatDate, disabled = props.disabled, maxTagCount = props.maxTagCount, placeholder = props.placeholder;
      var selectorCls = "".concat(prefixCls, "-selector");
      var selectionCls = "".concat(prefixCls, "-selection");
      var overflowCls = "".concat(selectionCls, "-overflow");
      function renderSelector(content, onClose) {
        return /* @__PURE__ */ reactExports.createElement("span", {
          className: classNames("".concat(selectionCls, "-item")),
          title: typeof content === "string" ? content : null
        }, /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(selectionCls, "-item-content")
        }, content), !disabled && onClose && /* @__PURE__ */ reactExports.createElement("span", {
          onMouseDown: function onMouseDown(e2) {
            e2.preventDefault();
          },
          onClick: onClose,
          className: "".concat(selectionCls, "-item-remove")
        }, removeIcon));
      }
      function renderItem(date2) {
        var displayLabel = formatDate(date2);
        var onClose = function onClose2(event) {
          if (event) event.stopPropagation();
          onRemove(date2);
        };
        return renderSelector(displayLabel, onClose);
      }
      function renderRest(omittedValues) {
        var content = "+ ".concat(omittedValues.length, " ...");
        return renderSelector(content);
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: selectorCls
      }, /* @__PURE__ */ reactExports.createElement(ForwardOverflow, {
        prefixCls: overflowCls,
        data: value,
        renderItem,
        renderRest,
        itemKey: function itemKey2(date2) {
          return formatDate(date2);
        },
        maxCount: maxTagCount
      }), !value.length && /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-selection-placeholder")
      }, placeholder));
    }
    var _excluded$d = ["id", "open", "prefix", "clearIcon", "suffixIcon", "activeHelp", "allHelp", "focused", "onFocus", "onBlur", "onKeyDown", "locale", "generateConfig", "placeholder", "className", "style", "onClick", "onClear", "internalPicker", "value", "onChange", "onSubmit", "onInputChange", "multiple", "maxTagCount", "format", "maskFormat", "preserveInvalidOnBlur", "onInvalid", "disabled", "invalid", "inputReadOnly", "direction", "onOpenChange", "onMouseDown", "required", "aria-required", "autoFocus", "tabIndex", "removeIcon"];
    function SingleSelector(props, ref) {
      props.id;
      var open2 = props.open, prefix2 = props.prefix, clearIcon = props.clearIcon, suffixIcon = props.suffixIcon;
      props.activeHelp;
      props.allHelp;
      var focused = props.focused;
      props.onFocus;
      props.onBlur;
      props.onKeyDown;
      var locale2 = props.locale, generateConfig2 = props.generateConfig, placeholder = props.placeholder, className = props.className, style2 = props.style, onClick = props.onClick, onClear = props.onClear, internalPicker = props.internalPicker, value = props.value, onChange = props.onChange, onSubmit = props.onSubmit;
      props.onInputChange;
      var multiple = props.multiple, maxTagCount = props.maxTagCount;
      props.format;
      props.maskFormat;
      props.preserveInvalidOnBlur;
      props.onInvalid;
      var disabled = props.disabled, invalid = props.invalid;
      props.inputReadOnly;
      var direction = props.direction;
      props.onOpenChange;
      var _onMouseDown = props.onMouseDown;
      props.required;
      props["aria-required"];
      var autoFocus = props.autoFocus, tabIndex = props.tabIndex, removeIcon = props.removeIcon, restProps = _objectWithoutProperties(props, _excluded$d);
      var rtl = direction === "rtl";
      var _React$useContext = reactExports.useContext(PickerContext), prefixCls = _React$useContext.prefixCls;
      var rootRef = reactExports.useRef();
      var inputRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function() {
        return {
          nativeElement: rootRef.current,
          focus: function focus(options2) {
            var _inputRef$current;
            (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus(options2);
          },
          blur: function blur() {
            var _inputRef$current2;
            (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.blur();
          }
        };
      });
      var rootProps = useRootProps(restProps);
      var onSingleChange = function onSingleChange2(date2) {
        onChange([date2]);
      };
      var onMultipleRemove = function onMultipleRemove2(date2) {
        var nextValues = value.filter(function(oriDate) {
          return oriDate && !isSame(generateConfig2, locale2, oriDate, date2, internalPicker);
        });
        onChange(nextValues);
        if (!open2) {
          onSubmit();
        }
      };
      var _useInputProps = useInputProps(_objectSpread2$3(_objectSpread2$3({}, props), {}, {
        onChange: onSingleChange
      }), function(_ref) {
        var valueTexts = _ref.valueTexts;
        return {
          value: valueTexts[0] || "",
          active: focused
        };
      }), _useInputProps2 = _slicedToArray(_useInputProps, 2), getInputProps = _useInputProps2[0], getText = _useInputProps2[1];
      var showClear = !!(clearIcon && value.length && !disabled);
      var selectorNode = multiple ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(MultipleDates, {
        prefixCls,
        value,
        onRemove: onMultipleRemove,
        formatDate: getText,
        maxTagCount,
        disabled,
        removeIcon,
        placeholder
      }), /* @__PURE__ */ reactExports.createElement("input", {
        className: "".concat(prefixCls, "-multiple-input"),
        value: value.map(getText).join(","),
        ref: inputRef,
        readOnly: true,
        autoFocus,
        tabIndex
      }), /* @__PURE__ */ reactExports.createElement(Icon$1, {
        type: "suffix",
        icon: suffixIcon
      }), showClear && /* @__PURE__ */ reactExports.createElement(ClearIcon, {
        icon: clearIcon,
        onClear
      })) : /* @__PURE__ */ reactExports.createElement(Input$4, _extends$2({
        ref: inputRef
      }, getInputProps(), {
        autoFocus,
        tabIndex,
        suffixIcon,
        clearIcon: showClear && /* @__PURE__ */ reactExports.createElement(ClearIcon, {
          icon: clearIcon,
          onClear
        }),
        showActiveCls: false
      }));
      return /* @__PURE__ */ reactExports.createElement("div", _extends$2({}, rootProps, {
        className: classNames(prefixCls, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-multiple"), multiple), "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-invalid"), invalid), "".concat(prefixCls, "-rtl"), rtl), className),
        style: style2,
        ref: rootRef,
        onClick,
        onMouseDown: function onMouseDown(e2) {
          var _inputRef$current3;
          var target = e2.target;
          if (target !== ((_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.inputElement)) {
            e2.preventDefault();
          }
          _onMouseDown === null || _onMouseDown === void 0 || _onMouseDown(e2);
        }
      }), prefix2 && /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-prefix")
      }, prefix2), selectorNode);
    }
    var RefSingleSelector = /* @__PURE__ */ reactExports.forwardRef(SingleSelector);
    function Picker(props, ref) {
      var _useFilledProps = useFilledProps(props), _useFilledProps2 = _slicedToArray(_useFilledProps, 6), filledProps = _useFilledProps2[0], internalPicker = _useFilledProps2[1], complexPicker = _useFilledProps2[2], formatList = _useFilledProps2[3], maskFormat = _useFilledProps2[4], isInvalidateDate = _useFilledProps2[5];
      var _ref = filledProps, prefixCls = _ref.prefixCls, styles = _ref.styles, classNames2 = _ref.classNames, order = _ref.order, defaultValue = _ref.defaultValue, value = _ref.value, needConfirm = _ref.needConfirm, onChange = _ref.onChange, onKeyDown = _ref.onKeyDown, disabled = _ref.disabled, disabledDate = _ref.disabledDate, minDate = _ref.minDate, maxDate = _ref.maxDate, defaultOpen = _ref.defaultOpen, open2 = _ref.open, onOpenChange = _ref.onOpenChange, locale2 = _ref.locale, generateConfig2 = _ref.generateConfig, picker = _ref.picker, showNow = _ref.showNow, showToday = _ref.showToday, showTime = _ref.showTime, mode = _ref.mode, onPanelChange = _ref.onPanelChange, onCalendarChange = _ref.onCalendarChange, onOk = _ref.onOk, multiple = _ref.multiple, defaultPickerValue = _ref.defaultPickerValue, pickerValue = _ref.pickerValue, onPickerValueChange = _ref.onPickerValueChange, inputReadOnly = _ref.inputReadOnly, suffixIcon = _ref.suffixIcon, removeIcon = _ref.removeIcon, onFocus = _ref.onFocus, onBlur = _ref.onBlur, presets = _ref.presets, components = _ref.components, cellRender = _ref.cellRender, dateRender = _ref.dateRender, monthCellRender = _ref.monthCellRender, onClick = _ref.onClick;
      var selectorRef = usePickerRef(ref);
      function pickerParam(values) {
        if (values === null) {
          return null;
        }
        return multiple ? values : values[0];
      }
      var toggleDates = useToggleDates(generateConfig2, locale2, internalPicker);
      var _useOpen = useOpen(open2, defaultOpen, [disabled], onOpenChange), _useOpen2 = _slicedToArray(_useOpen, 2), mergedOpen = _useOpen2[0], triggerOpen = _useOpen2[1];
      var onInternalCalendarChange = function onInternalCalendarChange2(dates, dateStrings, info) {
        if (onCalendarChange) {
          var filteredInfo = _objectSpread2$3({}, info);
          delete filteredInfo.range;
          onCalendarChange(pickerParam(dates), pickerParam(dateStrings), filteredInfo);
        }
      };
      var onInternalOk = function onInternalOk2(dates) {
        onOk === null || onOk === void 0 || onOk(pickerParam(dates));
      };
      var _useInnerValue = useInnerValue(generateConfig2, locale2, formatList, false, order, defaultValue, value, onInternalCalendarChange, onInternalOk), _useInnerValue2 = _slicedToArray(_useInnerValue, 5), mergedValue = _useInnerValue2[0], setInnerValue = _useInnerValue2[1], getCalendarValue = _useInnerValue2[2], triggerCalendarChange = _useInnerValue2[3], triggerOk = _useInnerValue2[4];
      var calendarValue = getCalendarValue();
      var _useRangeActive = useRangeActive([disabled]), _useRangeActive2 = _slicedToArray(_useRangeActive, 4), focused = _useRangeActive2[0], triggerFocus2 = _useRangeActive2[1], lastOperation = _useRangeActive2[2], activeIndex = _useRangeActive2[3];
      var onSharedFocus = function onSharedFocus2(event) {
        triggerFocus2(true);
        onFocus === null || onFocus === void 0 || onFocus(event, {});
      };
      var onSharedBlur = function onSharedBlur2(event) {
        triggerFocus2(false);
        onBlur === null || onBlur === void 0 || onBlur(event, {});
      };
      var _useMergedState = useMergedState(picker, {
        value: mode
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedMode = _useMergedState2[0], setMode = _useMergedState2[1];
      var internalMode = mergedMode === "date" && showTime ? "datetime" : mergedMode;
      var mergedShowNow = useShowNow(picker, mergedMode, showNow, showToday);
      var onInternalChange = onChange && function(dates, dateStrings) {
        onChange(pickerParam(dates), pickerParam(dateStrings));
      };
      var _useRangeValue = useRangeValue(
        _objectSpread2$3(_objectSpread2$3({}, filledProps), {}, {
          onChange: onInternalChange
        }),
        mergedValue,
        setInnerValue,
        getCalendarValue,
        triggerCalendarChange,
        [],
        //disabled,
        formatList,
        focused,
        mergedOpen,
        isInvalidateDate
      ), _useRangeValue2 = _slicedToArray(_useRangeValue, 2), triggerSubmitChange = _useRangeValue2[1];
      var _useFieldsInvalidate = useFieldsInvalidate(calendarValue, isInvalidateDate), _useFieldsInvalidate2 = _slicedToArray(_useFieldsInvalidate, 2), submitInvalidates = _useFieldsInvalidate2[0], onSelectorInvalid = _useFieldsInvalidate2[1];
      var submitInvalidate = reactExports.useMemo(function() {
        return submitInvalidates.some(function(invalidated) {
          return invalidated;
        });
      }, [submitInvalidates]);
      var onInternalPickerValueChange = function onInternalPickerValueChange2(dates, info) {
        if (onPickerValueChange) {
          var cleanInfo = _objectSpread2$3(_objectSpread2$3({}, info), {}, {
            mode: info.mode[0]
          });
          delete cleanInfo.range;
          onPickerValueChange(dates[0], cleanInfo);
        }
      };
      var _useRangePickerValue = useRangePickerValue(
        generateConfig2,
        locale2,
        calendarValue,
        [mergedMode],
        mergedOpen,
        activeIndex,
        internalPicker,
        false,
        // multiplePanel,
        defaultPickerValue,
        pickerValue,
        toArray$1(showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue),
        onInternalPickerValueChange,
        minDate,
        maxDate
      ), _useRangePickerValue2 = _slicedToArray(_useRangePickerValue, 2), currentPickerValue = _useRangePickerValue2[0], setCurrentPickerValue = _useRangePickerValue2[1];
      var triggerModeChange = useEvent(function(nextPickerValue, nextMode, triggerEvent) {
        setMode(nextMode);
        if (onPanelChange && triggerEvent !== false) {
          var lastPickerValue = nextPickerValue || calendarValue[calendarValue.length - 1];
          onPanelChange(lastPickerValue, nextMode);
        }
      });
      var triggerConfirm = function triggerConfirm2() {
        triggerSubmitChange(getCalendarValue());
        triggerOpen(false, {
          force: true
        });
      };
      var onSelectorClick = function onSelectorClick2(event) {
        if (!disabled && !selectorRef.current.nativeElement.contains(document.activeElement)) {
          selectorRef.current.focus();
        }
        triggerOpen(true);
        onClick === null || onClick === void 0 || onClick(event);
      };
      var onSelectorClear = function onSelectorClear2() {
        triggerSubmitChange(null);
        triggerOpen(false, {
          force: true
        });
      };
      var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), hoverSource = _React$useState2[0], setHoverSource = _React$useState2[1];
      var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), internalHoverValue = _React$useState4[0], setInternalHoverValue = _React$useState4[1];
      var hoverValues = reactExports.useMemo(function() {
        var values = [internalHoverValue].concat(_toConsumableArray(calendarValue)).filter(function(date2) {
          return date2;
        });
        return multiple ? values : values.slice(0, 1);
      }, [calendarValue, internalHoverValue, multiple]);
      var selectorValues = reactExports.useMemo(function() {
        if (!multiple && internalHoverValue) {
          return [internalHoverValue];
        }
        return calendarValue.filter(function(date2) {
          return date2;
        });
      }, [calendarValue, internalHoverValue, multiple]);
      reactExports.useEffect(function() {
        if (!mergedOpen) {
          setInternalHoverValue(null);
        }
      }, [mergedOpen]);
      var presetList = usePresets(presets);
      var onPresetHover = function onPresetHover2(nextValue) {
        setInternalHoverValue(nextValue);
        setHoverSource("preset");
      };
      var onPresetSubmit = function onPresetSubmit2(nextValue) {
        var nextCalendarValues = multiple ? toggleDates(getCalendarValue(), nextValue) : [nextValue];
        var passed = triggerSubmitChange(nextCalendarValues);
        if (passed && !multiple) {
          triggerOpen(false, {
            force: true
          });
        }
      };
      var onNow = function onNow2(now2) {
        onPresetSubmit(now2);
      };
      var onPanelHover = function onPanelHover2(date2) {
        setInternalHoverValue(date2);
        setHoverSource("cell");
      };
      var onPanelFocus = function onPanelFocus2(event) {
        triggerOpen(true);
        onSharedFocus(event);
      };
      var onPanelSelect = function onPanelSelect2(date2) {
        lastOperation("panel");
        if (multiple && internalMode !== picker) {
          return;
        }
        var nextValues = multiple ? toggleDates(getCalendarValue(), date2) : [date2];
        triggerCalendarChange(nextValues);
        if (!needConfirm && !complexPicker && internalPicker === internalMode) {
          triggerConfirm();
        }
      };
      var onPopupClose = function onPopupClose2() {
        triggerOpen(false);
      };
      var onInternalCellRender = useCellRender(cellRender, dateRender, monthCellRender);
      var panelProps = reactExports.useMemo(function() {
        var domProps = pickAttrs(filledProps, false);
        var restProps = omit(filledProps, [].concat(_toConsumableArray(Object.keys(domProps)), ["onChange", "onCalendarChange", "style", "className", "onPanelChange"]));
        return _objectSpread2$3(_objectSpread2$3({}, restProps), {}, {
          multiple: filledProps.multiple
        });
      }, [filledProps]);
      var panel = /* @__PURE__ */ reactExports.createElement(Popup, _extends$2({}, panelProps, {
        showNow: mergedShowNow,
        showTime,
        disabledDate,
        onFocus: onPanelFocus,
        onBlur: onSharedBlur,
        picker,
        mode: mergedMode,
        internalMode,
        onPanelChange: triggerModeChange,
        format: maskFormat,
        value: calendarValue,
        isInvalid: isInvalidateDate,
        onChange: null,
        onSelect: onPanelSelect,
        pickerValue: currentPickerValue,
        defaultOpenValue: showTime === null || showTime === void 0 ? void 0 : showTime.defaultOpenValue,
        onPickerValueChange: setCurrentPickerValue,
        hoverValue: hoverValues,
        onHover: onPanelHover,
        needConfirm,
        onSubmit: triggerConfirm,
        onOk: triggerOk,
        presets: presetList,
        onPresetHover,
        onPresetSubmit,
        onNow,
        cellRender: onInternalCellRender
      }));
      var onSelectorChange = function onSelectorChange2(date2) {
        triggerCalendarChange(date2);
      };
      var onSelectorInputChange = function onSelectorInputChange2() {
        lastOperation("input");
      };
      var onSelectorFocus = function onSelectorFocus2(event) {
        lastOperation("input");
        triggerOpen(true, {
          inherit: true
        });
        onSharedFocus(event);
      };
      var onSelectorBlur = function onSelectorBlur2(event) {
        triggerOpen(false);
        onSharedBlur(event);
      };
      var onSelectorKeyDown = function onSelectorKeyDown2(event, preventDefault) {
        if (event.key === "Tab") {
          triggerConfirm();
        }
        onKeyDown === null || onKeyDown === void 0 || onKeyDown(event, preventDefault);
      };
      var context = reactExports.useMemo(function() {
        return {
          prefixCls,
          locale: locale2,
          generateConfig: generateConfig2,
          button: components.button,
          input: components.input
        };
      }, [prefixCls, locale2, generateConfig2, components.button, components.input]);
      useLayoutEffect$1(function() {
        if (mergedOpen && activeIndex !== void 0) {
          triggerModeChange(null, picker, false);
        }
      }, [mergedOpen, activeIndex, picker]);
      useLayoutEffect$1(function() {
        var lastOp = lastOperation();
        if (!mergedOpen && lastOp === "input") {
          triggerOpen(false);
          triggerConfirm();
        }
        if (!mergedOpen && complexPicker && !needConfirm && lastOp === "panel") {
          triggerConfirm();
        }
      }, [mergedOpen]);
      return /* @__PURE__ */ reactExports.createElement(PickerContext.Provider, {
        value: context
      }, /* @__PURE__ */ reactExports.createElement(PickerTrigger, _extends$2({}, pickTriggerProps(filledProps), {
        popupElement: panel,
        popupStyle: styles.popup,
        popupClassName: classNames2.popup,
        visible: mergedOpen,
        onClose: onPopupClose
      }), /* @__PURE__ */ reactExports.createElement(
        RefSingleSelector,
        _extends$2({}, filledProps, {
          // Ref
          ref: selectorRef,
          suffixIcon,
          removeIcon,
          activeHelp: !!internalHoverValue,
          allHelp: !!internalHoverValue && hoverSource === "preset",
          focused,
          onFocus: onSelectorFocus,
          onBlur: onSelectorBlur,
          onKeyDown: onSelectorKeyDown,
          onSubmit: triggerConfirm,
          value: selectorValues,
          maskFormat,
          onChange: onSelectorChange,
          onInputChange: onSelectorInputChange,
          internalPicker,
          format: formatList,
          inputReadOnly,
          disabled,
          open: mergedOpen,
          onOpenChange: triggerOpen,
          onClick: onSelectorClick,
          onClear: onSelectorClear,
          invalid: submitInvalidate,
          onInvalid: function onInvalid(invalid) {
            onSelectorInvalid(invalid, 0);
          }
        })
      )));
    }
    var RefPicker = /* @__PURE__ */ reactExports.forwardRef(Picker);
    const RadioGroupContext = /* @__PURE__ */ reactExports.createContext(null);
    const RadioGroupContextProvider = RadioGroupContext.Provider;
    const RadioOptionTypeContext = /* @__PURE__ */ reactExports.createContext(null);
    const RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;
    var _excluded$c = ["prefixCls", "className", "style", "checked", "disabled", "defaultChecked", "type", "title", "onChange"];
    var Checkbox$2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-checkbox" : _props$prefixCls, className = props.className, style2 = props.style, checked = props.checked, disabled = props.disabled, _props$defaultChecked = props.defaultChecked, defaultChecked = _props$defaultChecked === void 0 ? false : _props$defaultChecked, _props$type = props.type, type2 = _props$type === void 0 ? "checkbox" : _props$type, title = props.title, onChange = props.onChange, inputProps = _objectWithoutProperties(props, _excluded$c);
      var inputRef = reactExports.useRef(null);
      var holderRef = reactExports.useRef(null);
      var _useMergedState = useMergedState(defaultChecked, {
        value: checked
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), rawValue = _useMergedState2[0], setRawValue = _useMergedState2[1];
      reactExports.useImperativeHandle(ref, function() {
        return {
          focus: function focus(options2) {
            var _inputRef$current;
            (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus(options2);
          },
          blur: function blur() {
            var _inputRef$current2;
            (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.blur();
          },
          input: inputRef.current,
          nativeElement: holderRef.current
        };
      });
      var classString = classNames(prefixCls, className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-checked"), rawValue), "".concat(prefixCls, "-disabled"), disabled));
      var handleChange = function handleChange2(e2) {
        if (disabled) {
          return;
        }
        if (!("checked" in props)) {
          setRawValue(e2.target.checked);
        }
        onChange === null || onChange === void 0 || onChange({
          target: _objectSpread2$3(_objectSpread2$3({}, props), {}, {
            type: type2,
            checked: e2.target.checked
          }),
          stopPropagation: function stopPropagation() {
            e2.stopPropagation();
          },
          preventDefault: function preventDefault() {
            e2.preventDefault();
          },
          nativeEvent: e2.nativeEvent
        });
      };
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: classString,
        title,
        style: style2,
        ref: holderRef
      }, /* @__PURE__ */ reactExports.createElement("input", _extends$2({}, inputProps, {
        className: "".concat(prefixCls, "-input"),
        ref: inputRef,
        onChange: handleChange,
        disabled,
        checked: !!rawValue,
        type: type2
      })), /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-inner")
      }));
    });
    function useBubbleLock(onOriginInputClick) {
      const labelClickLockRef = i.useRef(null);
      const clearLock = () => {
        wrapperRaf.cancel(labelClickLockRef.current);
        labelClickLockRef.current = null;
      };
      const onLabelClick = () => {
        clearLock();
        labelClickLockRef.current = wrapperRaf(() => {
          labelClickLockRef.current = null;
        });
      };
      const onInputClick = (e2) => {
        if (labelClickLockRef.current) {
          e2.stopPropagation();
          clearLock();
        }
        onOriginInputClick === null || onOriginInputClick === void 0 ? void 0 : onOriginInputClick(e2);
      };
      return [onLabelClick, onInputClick];
    }
    const getGroupRadioStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      const groupPrefixCls = `${componentCls}-group`;
      return {
        [groupPrefixCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          display: "inline-block",
          fontSize: 0,
          // RTL
          [`&${groupPrefixCls}-rtl`]: {
            direction: "rtl"
          },
          [`&${groupPrefixCls}-block`]: {
            display: "flex"
          },
          [`${antCls}-badge ${antCls}-badge-count`]: {
            zIndex: 1
          },
          [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
            borderInlineStart: "none"
          }
        })
      };
    };
    const getRadioBasicStyle = (token2) => {
      const {
        componentCls,
        wrapperMarginInlineEnd,
        colorPrimary,
        radioSize,
        motionDurationSlow,
        motionDurationMid,
        motionEaseInOutCirc,
        colorBgContainer,
        colorBorder,
        lineWidth,
        colorBgContainerDisabled,
        colorTextDisabled,
        paddingXS,
        dotColorDisabled,
        lineType,
        radioColor,
        radioBgColor,
        calc
      } = token2;
      const radioInnerPrefixCls = `${componentCls}-inner`;
      const dotPadding = 4;
      const radioDotDisabledSize = calc(radioSize).sub(calc(dotPadding).mul(2));
      const radioSizeCalc = calc(1).mul(radioSize).equal({
        unit: true
      });
      return {
        [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, resetComponent(token2)), {
          display: "inline-flex",
          alignItems: "baseline",
          marginInlineStart: 0,
          marginInlineEnd: wrapperMarginInlineEnd,
          cursor: "pointer",
          "&:last-child": {
            marginInlineEnd: 0
          },
          // RTL
          [`&${componentCls}-wrapper-rtl`]: {
            direction: "rtl"
          },
          "&-disabled": {
            cursor: "not-allowed",
            color: token2.colorTextDisabled
          },
          "&::after": {
            display: "inline-block",
            width: 0,
            overflow: "hidden",
            content: '"\\a0"'
          },
          "&-block": {
            flex: 1,
            justifyContent: "center"
          },
          // hashId  wrapper 
          [`${componentCls}-checked::after`]: {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            border: `${unit$1(lineWidth)} ${lineType} ${colorPrimary}`,
            borderRadius: "50%",
            visibility: "hidden",
            opacity: 0,
            content: '""'
          },
          [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
            position: "relative",
            display: "inline-block",
            outline: "none",
            cursor: "pointer",
            alignSelf: "center",
            borderRadius: "50%"
          }),
          [`${componentCls}-wrapper:hover &,
        &:hover ${radioInnerPrefixCls}`]: {
            borderColor: colorPrimary
          },
          [`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: Object.assign({}, genFocusOutline(token2)),
          [`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: {
            visibility: "visible"
          },
          [`${componentCls}-inner`]: {
            "&::after": {
              boxSizing: "border-box",
              position: "absolute",
              insetBlockStart: "50%",
              insetInlineStart: "50%",
              display: "block",
              width: radioSizeCalc,
              height: radioSizeCalc,
              marginBlockStart: calc(1).mul(radioSize).div(-2).equal({
                unit: true
              }),
              marginInlineStart: calc(1).mul(radioSize).div(-2).equal({
                unit: true
              }),
              backgroundColor: radioColor,
              borderBlockStart: 0,
              borderInlineStart: 0,
              borderRadius: radioSizeCalc,
              transform: "scale(0)",
              opacity: 0,
              transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
              content: '""'
            },
            boxSizing: "border-box",
            position: "relative",
            insetBlockStart: 0,
            insetInlineStart: 0,
            display: "block",
            width: radioSizeCalc,
            height: radioSizeCalc,
            backgroundColor: colorBgContainer,
            borderColor: colorBorder,
            borderStyle: "solid",
            borderWidth: lineWidth,
            borderRadius: "50%",
            transition: `all ${motionDurationMid}`
          },
          [`${componentCls}-input`]: {
            position: "absolute",
            inset: 0,
            zIndex: 1,
            cursor: "pointer",
            opacity: 0
          },
          // 
          [`${componentCls}-checked`]: {
            [radioInnerPrefixCls]: {
              borderColor: colorPrimary,
              backgroundColor: radioBgColor,
              "&::after": {
                transform: `scale(${token2.calc(token2.dotSize).div(radioSize).equal()})`,
                opacity: 1,
                transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
              }
            }
          },
          [`${componentCls}-disabled`]: {
            cursor: "not-allowed",
            [radioInnerPrefixCls]: {
              backgroundColor: colorBgContainerDisabled,
              borderColor: colorBorder,
              cursor: "not-allowed",
              "&::after": {
                backgroundColor: dotColorDisabled
              }
            },
            [`${componentCls}-input`]: {
              cursor: "not-allowed"
            },
            [`${componentCls}-disabled + span`]: {
              color: colorTextDisabled,
              cursor: "not-allowed"
            },
            [`&${componentCls}-checked`]: {
              [radioInnerPrefixCls]: {
                "&::after": {
                  transform: `scale(${calc(radioDotDisabledSize).div(radioSize).equal()})`
                }
              }
            }
          },
          [`span${componentCls} + *`]: {
            paddingInlineStart: paddingXS,
            paddingInlineEnd: paddingXS
          }
        })
      };
    };
    const getRadioButtonStyle = (token2) => {
      const {
        buttonColor,
        controlHeight,
        componentCls,
        lineWidth,
        lineType,
        colorBorder,
        motionDurationSlow,
        motionDurationMid,
        buttonPaddingInline,
        fontSize,
        buttonBg,
        fontSizeLG,
        controlHeightLG,
        controlHeightSM,
        paddingXS,
        borderRadius,
        borderRadiusSM,
        borderRadiusLG,
        buttonCheckedBg,
        buttonSolidCheckedColor,
        colorTextDisabled,
        colorBgContainerDisabled,
        buttonCheckedBgDisabled,
        buttonCheckedColorDisabled,
        colorPrimary,
        colorPrimaryHover,
        colorPrimaryActive,
        buttonSolidCheckedBg,
        buttonSolidCheckedHoverBg,
        buttonSolidCheckedActiveBg,
        calc
      } = token2;
      return {
        [`${componentCls}-button-wrapper`]: {
          position: "relative",
          display: "inline-block",
          height: controlHeight,
          margin: 0,
          paddingInline: buttonPaddingInline,
          paddingBlock: 0,
          color: buttonColor,
          fontSize,
          lineHeight: unit$1(calc(controlHeight).sub(calc(lineWidth).mul(2)).equal()),
          background: buttonBg,
          border: `${unit$1(lineWidth)} ${lineType} ${colorBorder}`,
          // strange align fix for chrome but works
          // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
          borderBlockStartWidth: calc(lineWidth).add(0.02).equal(),
          borderInlineStartWidth: 0,
          borderInlineEndWidth: lineWidth,
          cursor: "pointer",
          transition: [`color ${motionDurationMid}`, `background ${motionDurationMid}`, `box-shadow ${motionDurationMid}`].join(","),
          a: {
            color: buttonColor
          },
          [`> ${componentCls}-button`]: {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineStart: 0,
            zIndex: -1,
            width: "100%",
            height: "100%"
          },
          "&:not(:first-child)": {
            "&::before": {
              position: "absolute",
              insetBlockStart: calc(lineWidth).mul(-1).equal(),
              insetInlineStart: calc(lineWidth).mul(-1).equal(),
              display: "block",
              boxSizing: "content-box",
              width: 1,
              height: "100%",
              paddingBlock: lineWidth,
              paddingInline: 0,
              backgroundColor: colorBorder,
              transition: `background-color ${motionDurationSlow}`,
              content: '""'
            }
          },
          "&:first-child": {
            borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${colorBorder}`,
            borderStartStartRadius: borderRadius,
            borderEndStartRadius: borderRadius
          },
          "&:last-child": {
            borderStartEndRadius: borderRadius,
            borderEndEndRadius: borderRadius
          },
          "&:first-child:last-child": {
            borderRadius
          },
          [`${componentCls}-group-large &`]: {
            height: controlHeightLG,
            fontSize: fontSizeLG,
            lineHeight: unit$1(calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal()),
            "&:first-child": {
              borderStartStartRadius: borderRadiusLG,
              borderEndStartRadius: borderRadiusLG
            },
            "&:last-child": {
              borderStartEndRadius: borderRadiusLG,
              borderEndEndRadius: borderRadiusLG
            }
          },
          [`${componentCls}-group-small &`]: {
            height: controlHeightSM,
            paddingInline: calc(paddingXS).sub(lineWidth).equal(),
            paddingBlock: 0,
            lineHeight: unit$1(calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal()),
            "&:first-child": {
              borderStartStartRadius: borderRadiusSM,
              borderEndStartRadius: borderRadiusSM
            },
            "&:last-child": {
              borderStartEndRadius: borderRadiusSM,
              borderEndEndRadius: borderRadiusSM
            }
          },
          "&:hover": {
            position: "relative",
            color: colorPrimary
          },
          "&:has(:focus-visible)": Object.assign({}, genFocusOutline(token2)),
          [`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
            width: 0,
            height: 0,
            opacity: 0,
            pointerEvents: "none"
          },
          [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
            zIndex: 1,
            color: colorPrimary,
            background: buttonCheckedBg,
            borderColor: colorPrimary,
            "&::before": {
              backgroundColor: colorPrimary
            },
            "&:first-child": {
              borderColor: colorPrimary
            },
            "&:hover": {
              color: colorPrimaryHover,
              borderColor: colorPrimaryHover,
              "&::before": {
                backgroundColor: colorPrimaryHover
              }
            },
            "&:active": {
              color: colorPrimaryActive,
              borderColor: colorPrimaryActive,
              "&::before": {
                backgroundColor: colorPrimaryActive
              }
            }
          },
          [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
            color: buttonSolidCheckedColor,
            background: buttonSolidCheckedBg,
            borderColor: buttonSolidCheckedBg,
            "&:hover": {
              color: buttonSolidCheckedColor,
              background: buttonSolidCheckedHoverBg,
              borderColor: buttonSolidCheckedHoverBg
            },
            "&:active": {
              color: buttonSolidCheckedColor,
              background: buttonSolidCheckedActiveBg,
              borderColor: buttonSolidCheckedActiveBg
            }
          },
          "&-disabled": {
            color: colorTextDisabled,
            backgroundColor: colorBgContainerDisabled,
            borderColor: colorBorder,
            cursor: "not-allowed",
            "&:first-child, &:hover": {
              color: colorTextDisabled,
              backgroundColor: colorBgContainerDisabled,
              borderColor: colorBorder
            }
          },
          [`&-disabled${componentCls}-button-wrapper-checked`]: {
            color: buttonCheckedColorDisabled,
            backgroundColor: buttonCheckedBgDisabled,
            borderColor: colorBorder,
            boxShadow: "none"
          },
          "&-block": {
            flex: 1,
            textAlign: "center"
          }
        }
      };
    };
    const prepareComponentToken$e = (token2) => {
      const {
        wireframe,
        padding,
        marginXS,
        lineWidth,
        fontSizeLG,
        colorText,
        colorBgContainer,
        colorTextDisabled,
        controlItemBgActiveDisabled,
        colorTextLightSolid,
        colorPrimary,
        colorPrimaryHover,
        colorPrimaryActive,
        colorWhite
      } = token2;
      const dotPadding = 4;
      const radioSize = fontSizeLG;
      const radioDotSize = wireframe ? radioSize - dotPadding * 2 : radioSize - (dotPadding + lineWidth) * 2;
      return {
        // Radio
        radioSize,
        dotSize: radioDotSize,
        dotColorDisabled: colorTextDisabled,
        // Radio buttons
        buttonSolidCheckedColor: colorTextLightSolid,
        buttonSolidCheckedBg: colorPrimary,
        buttonSolidCheckedHoverBg: colorPrimaryHover,
        buttonSolidCheckedActiveBg: colorPrimaryActive,
        buttonBg: colorBgContainer,
        buttonCheckedBg: colorBgContainer,
        buttonColor: colorText,
        buttonCheckedBgDisabled: controlItemBgActiveDisabled,
        buttonCheckedColorDisabled: colorTextDisabled,
        buttonPaddingInline: padding - lineWidth,
        wrapperMarginInlineEnd: marginXS,
        // internal
        radioColor: wireframe ? colorPrimary : colorWhite,
        radioBgColor: wireframe ? colorBgContainer : colorPrimary
      };
    };
    const useStyle$i = genStyleHooks("Radio", (token2) => {
      const {
        controlOutline,
        controlOutlineWidth
      } = token2;
      const radioFocusShadow = `0 0 0 ${unit$1(controlOutlineWidth)} ${controlOutline}`;
      const radioButtonFocusShadow = radioFocusShadow;
      const radioToken = merge(token2, {
        radioFocusShadow,
        radioButtonFocusShadow
      });
      return [getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken)];
    }, prepareComponentToken$e, {
      unitless: {
        radioSize: true,
        dotSize: true
      }
    });
    var __rest$F = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const InternalRadio = (props, ref) => {
      var _a, _b;
      const groupContext = reactExports.useContext(RadioGroupContext);
      const radioOptionTypeContext = reactExports.useContext(RadioOptionTypeContext);
      const {
        getPrefixCls,
        direction,
        radio
      } = reactExports.useContext(ConfigContext);
      const innerRef = reactExports.useRef(null);
      const mergedRef = composeRef(ref, innerRef);
      const {
        isFormItemInput
      } = reactExports.useContext(FormItemInputContext);
      const onChange = (e2) => {
        var _a2, _b2;
        (_a2 = props.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, e2);
        (_b2 = groupContext === null || groupContext === void 0 ? void 0 : groupContext.onChange) === null || _b2 === void 0 ? void 0 : _b2.call(groupContext, e2);
      };
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        children,
        style: style2,
        title
      } = props, restProps = __rest$F(props, ["prefixCls", "className", "rootClassName", "children", "style", "title"]);
      const radioPrefixCls = getPrefixCls("radio", customizePrefixCls);
      const isButtonType = ((groupContext === null || groupContext === void 0 ? void 0 : groupContext.optionType) || radioOptionTypeContext) === "button";
      const prefixCls = isButtonType ? `${radioPrefixCls}-button` : radioPrefixCls;
      const rootCls = useCSSVarCls(radioPrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$i(radioPrefixCls, rootCls);
      const radioProps = Object.assign({}, restProps);
      const disabled = reactExports.useContext(DisabledContext);
      if (groupContext) {
        radioProps.name = groupContext.name;
        radioProps.onChange = onChange;
        radioProps.checked = props.value === groupContext.value;
        radioProps.disabled = (_a = radioProps.disabled) !== null && _a !== void 0 ? _a : groupContext.disabled;
      }
      radioProps.disabled = (_b = radioProps.disabled) !== null && _b !== void 0 ? _b : disabled;
      const wrapperClassString = classNames(`${prefixCls}-wrapper`, {
        [`${prefixCls}-wrapper-checked`]: radioProps.checked,
        [`${prefixCls}-wrapper-disabled`]: radioProps.disabled,
        [`${prefixCls}-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput,
        [`${prefixCls}-wrapper-block`]: !!(groupContext === null || groupContext === void 0 ? void 0 : groupContext.block)
      }, radio === null || radio === void 0 ? void 0 : radio.className, className, rootClassName, hashId, cssVarCls, rootCls);
      const [onLabelClick, onInputClick] = useBubbleLock(radioProps.onClick);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(Wave, {
        component: "Radio",
        disabled: radioProps.disabled
      }, /* @__PURE__ */ reactExports.createElement("label", {
        className: wrapperClassString,
        style: Object.assign(Object.assign({}, radio === null || radio === void 0 ? void 0 : radio.style), style2),
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        title,
        onClick: onLabelClick
      }, /* @__PURE__ */ reactExports.createElement(Checkbox$2, Object.assign({}, radioProps, {
        className: classNames(radioProps.className, {
          [TARGET_CLS]: !isButtonType
        }),
        type: "radio",
        prefixCls,
        ref: mergedRef,
        onClick: onInputClick
      })), children !== void 0 ? /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-label`
      }, children) : null)));
    };
    const Radio$1 = /* @__PURE__ */ reactExports.forwardRef(InternalRadio);
    const RadioGroup$1 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const defaultName = useId$1();
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        options: options2,
        buttonStyle = "outline",
        disabled,
        children,
        size: customizeSize,
        style: style2,
        id,
        optionType,
        name = defaultName,
        defaultValue,
        value: customizedValue,
        block = false,
        onChange,
        onMouseEnter,
        onMouseLeave,
        onFocus,
        onBlur
      } = props;
      const [value, setValue] = useMergedState(defaultValue, {
        value: customizedValue
      });
      const onRadioChange = reactExports.useCallback((event) => {
        const lastValue = value;
        const val = event.target.value;
        if (!("value" in props)) {
          setValue(val);
        }
        if (val !== lastValue) {
          onChange === null || onChange === void 0 ? void 0 : onChange(event);
        }
      }, [value, setValue, onChange]);
      const prefixCls = getPrefixCls("radio", customizePrefixCls);
      const groupPrefixCls = `${prefixCls}-group`;
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$i(prefixCls, rootCls);
      let childrenToRender = children;
      if (options2 && options2.length > 0) {
        childrenToRender = options2.map((option) => {
          if (typeof option === "string" || typeof option === "number") {
            return /* @__PURE__ */ reactExports.createElement(Radio$1, {
              key: option.toString(),
              prefixCls,
              disabled,
              value: option,
              checked: value === option
            }, option);
          }
          return /* @__PURE__ */ reactExports.createElement(Radio$1, {
            key: `radio-group-value-options-${option.value}`,
            prefixCls,
            disabled: option.disabled || disabled,
            value: option.value,
            checked: value === option.value,
            title: option.title,
            style: option.style,
            id: option.id,
            required: option.required
          }, option.label);
        });
      }
      const mergedSize = useSize(customizeSize);
      const classString = classNames(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
        [`${groupPrefixCls}-${mergedSize}`]: mergedSize,
        [`${groupPrefixCls}-rtl`]: direction === "rtl",
        [`${groupPrefixCls}-block`]: block
      }, className, rootClassName, hashId, cssVarCls, rootCls);
      const memoizedValue = reactExports.useMemo(() => ({
        onChange: onRadioChange,
        value,
        disabled,
        name,
        optionType,
        block
      }), [onRadioChange, value, disabled, name, optionType, block]);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({}, pickAttrs(props, {
        aria: true,
        data: true
      }), {
        className: classString,
        style: style2,
        onMouseEnter,
        onMouseLeave,
        onFocus,
        onBlur,
        id,
        ref
      }), /* @__PURE__ */ reactExports.createElement(RadioGroupContextProvider, {
        value: memoizedValue
      }, childrenToRender)));
    });
    const Group$1 = /* @__PURE__ */ reactExports.memo(RadioGroup$1);
    var __rest$E = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const RadioButton = (props, ref) => {
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls
      } = props, radioProps = __rest$E(props, ["prefixCls"]);
      const prefixCls = getPrefixCls("radio", customizePrefixCls);
      return /* @__PURE__ */ reactExports.createElement(RadioOptionTypeContextProvider, {
        value: "button"
      }, /* @__PURE__ */ reactExports.createElement(Radio$1, Object.assign({
        prefixCls
      }, radioProps, {
        type: "radio",
        ref
      })));
    };
    const Button = /* @__PURE__ */ reactExports.forwardRef(RadioButton);
    const Radio = Radio$1;
    Radio.Button = Button;
    Radio.Group = Group$1;
    Radio.__ANT_RADIO = true;
    function initInputToken(token2) {
      return merge(token2, {
        inputAffixPadding: token2.paddingXXS
      });
    }
    const initComponentToken = (token2) => {
      const {
        controlHeight,
        fontSize,
        lineHeight,
        lineWidth,
        controlHeightSM,
        controlHeightLG,
        fontSizeLG,
        lineHeightLG,
        paddingSM,
        controlPaddingHorizontalSM,
        controlPaddingHorizontal,
        colorFillAlter,
        colorPrimaryHover,
        colorPrimary,
        controlOutlineWidth,
        controlOutline,
        colorErrorOutline,
        colorWarningOutline,
        colorBgContainer,
        inputFontSize,
        inputFontSizeLG,
        inputFontSizeSM
      } = token2;
      const mergedFontSize = inputFontSize || fontSize;
      const mergedFontSizeSM = inputFontSizeSM || mergedFontSize;
      const mergedFontSizeLG = inputFontSizeLG || fontSizeLG;
      const paddingBlock = Math.round((controlHeight - mergedFontSize * lineHeight) / 2 * 10) / 10 - lineWidth;
      const paddingBlockSM = Math.round((controlHeightSM - mergedFontSizeSM * lineHeight) / 2 * 10) / 10 - lineWidth;
      const paddingBlockLG = Math.ceil((controlHeightLG - mergedFontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth;
      return {
        paddingBlock: Math.max(paddingBlock, 0),
        paddingBlockSM: Math.max(paddingBlockSM, 0),
        paddingBlockLG: Math.max(paddingBlockLG, 0),
        paddingInline: paddingSM - lineWidth,
        paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
        paddingInlineLG: controlPaddingHorizontal - lineWidth,
        addonBg: colorFillAlter,
        activeBorderColor: colorPrimary,
        hoverBorderColor: colorPrimaryHover,
        activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
        errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
        warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
        hoverBg: colorBgContainer,
        activeBg: colorBgContainer,
        inputFontSize: mergedFontSize,
        inputFontSizeLG: mergedFontSizeLG,
        inputFontSizeSM: mergedFontSizeSM
      };
    };
    const genHoverStyle = (token2) => ({
      borderColor: token2.hoverBorderColor,
      backgroundColor: token2.hoverBg
    });
    const genDisabledStyle = (token2) => ({
      color: token2.colorTextDisabled,
      backgroundColor: token2.colorBgContainerDisabled,
      borderColor: token2.colorBorder,
      boxShadow: "none",
      cursor: "not-allowed",
      opacity: 1,
      "input[disabled], textarea[disabled]": {
        cursor: "not-allowed"
      },
      "&:hover:not([disabled])": Object.assign({}, genHoverStyle(merge(token2, {
        hoverBorderColor: token2.colorBorder,
        hoverBg: token2.colorBgContainerDisabled
      })))
    });
    const genBaseOutlinedStyle = (token2, options2) => ({
      background: token2.colorBgContainer,
      borderWidth: token2.lineWidth,
      borderStyle: token2.lineType,
      borderColor: options2.borderColor,
      "&:hover": {
        borderColor: options2.hoverBorderColor,
        backgroundColor: token2.hoverBg
      },
      "&:focus, &:focus-within": {
        borderColor: options2.activeBorderColor,
        boxShadow: options2.activeShadow,
        outline: 0,
        backgroundColor: token2.activeBg
      }
    });
    const genOutlinedStatusStyle = (token2, options2) => ({
      [`&${token2.componentCls}-status-${options2.status}:not(${token2.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseOutlinedStyle(token2, options2)), {
        [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
          color: options2.affixColor
        }
      }),
      [`&${token2.componentCls}-status-${options2.status}${token2.componentCls}-disabled`]: {
        borderColor: options2.borderColor
      }
    });
    const genOutlinedStyle = (token2, extraStyles) => ({
      "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseOutlinedStyle(token2, {
        borderColor: token2.colorBorder,
        hoverBorderColor: token2.hoverBorderColor,
        activeBorderColor: token2.activeBorderColor,
        activeShadow: token2.activeShadow
      })), {
        [`&${token2.componentCls}-disabled, &[disabled]`]: Object.assign({}, genDisabledStyle(token2))
      }), genOutlinedStatusStyle(token2, {
        status: "error",
        borderColor: token2.colorError,
        hoverBorderColor: token2.colorErrorBorderHover,
        activeBorderColor: token2.colorError,
        activeShadow: token2.errorActiveShadow,
        affixColor: token2.colorError
      })), genOutlinedStatusStyle(token2, {
        status: "warning",
        borderColor: token2.colorWarning,
        hoverBorderColor: token2.colorWarningBorderHover,
        activeBorderColor: token2.colorWarning,
        activeShadow: token2.warningActiveShadow,
        affixColor: token2.colorWarning
      })), extraStyles)
    });
    const genOutlinedGroupStatusStyle = (token2, options2) => ({
      [`&${token2.componentCls}-group-wrapper-status-${options2.status}`]: {
        [`${token2.componentCls}-group-addon`]: {
          borderColor: options2.addonBorderColor,
          color: options2.addonColor
        }
      }
    });
    const genOutlinedGroupStyle = (token2) => ({
      "&-outlined": Object.assign(Object.assign(Object.assign({
        [`${token2.componentCls}-group`]: {
          "&-addon": {
            background: token2.addonBg,
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
          },
          "&-addon:first-child": {
            borderInlineEnd: 0
          },
          "&-addon:last-child": {
            borderInlineStart: 0
          }
        }
      }, genOutlinedGroupStatusStyle(token2, {
        status: "error",
        addonBorderColor: token2.colorError,
        addonColor: token2.colorErrorText
      })), genOutlinedGroupStatusStyle(token2, {
        status: "warning",
        addonBorderColor: token2.colorWarning,
        addonColor: token2.colorWarningText
      })), {
        [`&${token2.componentCls}-group-wrapper-disabled`]: {
          [`${token2.componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token2))
        }
      })
    });
    const genBorderlessStyle = (token2, extraStyles) => {
      const {
        componentCls
      } = token2;
      return {
        "&-borderless": Object.assign({
          background: "transparent",
          border: "none",
          "&:focus, &:focus-within": {
            outline: "none"
          },
          // >>>>> Disabled
          [`&${componentCls}-disabled, &[disabled]`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed"
          },
          // >>>>> Status
          [`&${componentCls}-status-error`]: {
            "&, & input, & textarea": {
              color: token2.colorError
            }
          },
          [`&${componentCls}-status-warning`]: {
            "&, & input, & textarea": {
              color: token2.colorWarning
            }
          }
        }, extraStyles)
      };
    };
    const genBaseFilledStyle = (token2, options2) => {
      var _a;
      return {
        background: options2.bg,
        borderWidth: token2.lineWidth,
        borderStyle: token2.lineType,
        borderColor: "transparent",
        "input&, & input, textarea&, & textarea": {
          color: (_a = options2 === null || options2 === void 0 ? void 0 : options2.inputColor) !== null && _a !== void 0 ? _a : "unset"
        },
        "&:hover": {
          background: options2.hoverBg
        },
        "&:focus, &:focus-within": {
          outline: 0,
          borderColor: options2.activeBorderColor,
          backgroundColor: token2.activeBg
        }
      };
    };
    const genFilledStatusStyle = (token2, options2) => ({
      [`&${token2.componentCls}-status-${options2.status}:not(${token2.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseFilledStyle(token2, options2)), {
        [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
          color: options2.affixColor
        }
      })
    });
    const genFilledStyle = (token2, extraStyles) => ({
      "&-filled": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseFilledStyle(token2, {
        bg: token2.colorFillTertiary,
        hoverBg: token2.colorFillSecondary,
        activeBorderColor: token2.activeBorderColor
      })), {
        [`&${token2.componentCls}-disabled, &[disabled]`]: Object.assign({}, genDisabledStyle(token2))
      }), genFilledStatusStyle(token2, {
        status: "error",
        bg: token2.colorErrorBg,
        hoverBg: token2.colorErrorBgHover,
        activeBorderColor: token2.colorError,
        inputColor: token2.colorErrorText,
        affixColor: token2.colorError
      })), genFilledStatusStyle(token2, {
        status: "warning",
        bg: token2.colorWarningBg,
        hoverBg: token2.colorWarningBgHover,
        activeBorderColor: token2.colorWarning,
        inputColor: token2.colorWarningText,
        affixColor: token2.colorWarning
      })), extraStyles)
    });
    const genFilledGroupStatusStyle = (token2, options2) => ({
      [`&${token2.componentCls}-group-wrapper-status-${options2.status}`]: {
        [`${token2.componentCls}-group-addon`]: {
          background: options2.addonBg,
          color: options2.addonColor
        }
      }
    });
    const genFilledGroupStyle = (token2) => ({
      "&-filled": Object.assign(Object.assign(Object.assign({
        [`${token2.componentCls}-group`]: {
          "&-addon": {
            background: token2.colorFillTertiary
          },
          [`${token2.componentCls}-filled:not(:focus):not(:focus-within)`]: {
            "&:not(:first-child)": {
              borderInlineStart: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
            },
            "&:not(:last-child)": {
              borderInlineEnd: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
            }
          }
        }
      }, genFilledGroupStatusStyle(token2, {
        status: "error",
        addonBg: token2.colorErrorBg,
        addonColor: token2.colorErrorText
      })), genFilledGroupStatusStyle(token2, {
        status: "warning",
        addonBg: token2.colorWarningBg,
        addonColor: token2.colorWarningText
      })), {
        [`&${token2.componentCls}-group-wrapper-disabled`]: {
          [`${token2.componentCls}-group`]: {
            "&-addon": {
              background: token2.colorFillTertiary,
              color: token2.colorTextDisabled
            },
            "&-addon:first-child": {
              borderInlineStart: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
              borderTop: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
              borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
            },
            "&-addon:last-child": {
              borderInlineEnd: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
              borderTop: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
              borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
            }
          }
        }
      })
    });
    const genBaseUnderlinedStyle = (token2, options2) => ({
      background: token2.colorBgContainer,
      borderWidth: `${unit$1(token2.lineWidth)} 0`,
      borderStyle: `${token2.lineType} none`,
      borderColor: `transparent transparent ${options2.borderColor} transparent`,
      borderRadius: 0,
      "&:hover": {
        borderColor: `transparent transparent ${options2.borderColor} transparent`,
        backgroundColor: token2.hoverBg
      },
      "&:focus, &:focus-within": {
        borderColor: `transparent transparent ${options2.borderColor} transparent`,
        outline: 0,
        backgroundColor: token2.activeBg
      }
    });
    const genUnderlinedStatusStyle = (token2, options2) => ({
      [`&${token2.componentCls}-status-${options2.status}:not(${token2.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseUnderlinedStyle(token2, options2)), {
        [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
          color: options2.affixColor
        }
      }),
      [`&${token2.componentCls}-status-${options2.status}${token2.componentCls}-disabled`]: {
        borderColor: `transparent transparent ${options2.borderColor} transparent`
      }
    });
    const genUnderlinedStyle = (token2, extraStyles) => ({
      "&-underlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseUnderlinedStyle(token2, {
        borderColor: token2.colorBorder,
        hoverBorderColor: token2.hoverBorderColor,
        activeBorderColor: token2.activeBorderColor,
        activeShadow: token2.activeShadow
      })), {
        // >>>>> Disabled
        [`&${token2.componentCls}-disabled, &[disabled]`]: {
          color: token2.colorTextDisabled,
          boxShadow: "none",
          cursor: "not-allowed",
          "&:hover": {
            borderColor: `transparent transparent ${token2.colorBorder} transparent`
          }
        },
        "input[disabled], textarea[disabled]": {
          cursor: "not-allowed"
        }
      }), genUnderlinedStatusStyle(token2, {
        status: "error",
        borderColor: token2.colorError,
        hoverBorderColor: token2.colorErrorBorderHover,
        activeBorderColor: token2.colorError,
        activeShadow: token2.errorActiveShadow,
        affixColor: token2.colorError
      })), genUnderlinedStatusStyle(token2, {
        status: "warning",
        borderColor: token2.colorWarning,
        hoverBorderColor: token2.colorWarningBorderHover,
        activeBorderColor: token2.colorWarning,
        activeShadow: token2.warningActiveShadow,
        affixColor: token2.colorWarning
      })), extraStyles)
    });
    const genPlaceholderStyle = (color) => ({
      // Firefox
      "&::-moz-placeholder": {
        opacity: 1
      },
      "&::placeholder": {
        color,
        userSelect: "none"
        // https://github.com/ant-design/ant-design/pull/32639
      },
      "&:placeholder-shown": {
        textOverflow: "ellipsis"
      }
    });
    const genInputLargeStyle = (token2) => {
      const {
        paddingBlockLG,
        lineHeightLG,
        borderRadiusLG,
        paddingInlineLG
      } = token2;
      return {
        padding: `${unit$1(paddingBlockLG)} ${unit$1(paddingInlineLG)}`,
        fontSize: token2.inputFontSizeLG,
        lineHeight: lineHeightLG,
        borderRadius: borderRadiusLG
      };
    };
    const genInputSmallStyle = (token2) => ({
      padding: `${unit$1(token2.paddingBlockSM)} ${unit$1(token2.paddingInlineSM)}`,
      fontSize: token2.inputFontSizeSM,
      borderRadius: token2.borderRadiusSM
    });
    const genBasicInputStyle = (token2) => Object.assign(Object.assign({
      position: "relative",
      display: "inline-block",
      width: "100%",
      minWidth: 0,
      padding: `${unit$1(token2.paddingBlock)} ${unit$1(token2.paddingInline)}`,
      color: token2.colorText,
      fontSize: token2.inputFontSize,
      lineHeight: token2.lineHeight,
      borderRadius: token2.borderRadius,
      transition: `all ${token2.motionDurationMid}`
    }, genPlaceholderStyle(token2.colorTextPlaceholder)), {
      // Size
      "&-lg": Object.assign({}, genInputLargeStyle(token2)),
      "&-sm": Object.assign({}, genInputSmallStyle(token2)),
      // RTL
      "&-rtl, &-textarea-rtl": {
        direction: "rtl"
      }
    });
    const genInputGroupStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      return {
        position: "relative",
        display: "table",
        width: "100%",
        borderCollapse: "separate",
        borderSpacing: 0,
        // Undo padding and float of grid classes
        "&[class*='col-']": {
          paddingInlineEnd: token2.paddingXS,
          "&:last-child": {
            paddingInlineEnd: 0
          }
        },
        // Sizing options
        [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token2)),
        [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token2)),
        // Fix https://github.com/ant-design/ant-design/issues/5754
        [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
          height: token2.controlHeightLG
        },
        [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
          height: token2.controlHeightSM
        },
        [`> ${componentCls}`]: {
          display: "table-cell",
          "&:not(:first-child):not(:last-child)": {
            borderRadius: 0
          }
        },
        [`${componentCls}-group`]: {
          "&-addon, &-wrap": {
            display: "table-cell",
            width: 1,
            whiteSpace: "nowrap",
            verticalAlign: "middle",
            "&:not(:first-child):not(:last-child)": {
              borderRadius: 0
            }
          },
          "&-wrap > *": {
            display: "block !important"
          },
          "&-addon": {
            position: "relative",
            padding: `0 ${unit$1(token2.paddingInline)}`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize: token2.inputFontSize,
            textAlign: "center",
            borderRadius: token2.borderRadius,
            transition: `all ${token2.motionDurationSlow}`,
            lineHeight: 1,
            // Reset Select's style in addon
            [`${antCls}-select`]: {
              margin: `${unit$1(token2.calc(token2.paddingBlock).add(1).mul(-1).equal())} ${unit$1(token2.calc(token2.paddingInline).mul(-1).equal())}`,
              [`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
                [`${antCls}-select-selector`]: {
                  backgroundColor: "inherit",
                  border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
                  boxShadow: "none"
                }
              }
            },
            // https://github.com/ant-design/ant-design/issues/31333
            [`${antCls}-cascader-picker`]: {
              margin: `-9px ${unit$1(token2.calc(token2.paddingInline).mul(-1).equal())}`,
              backgroundColor: "transparent",
              [`${antCls}-cascader-input`]: {
                textAlign: "start",
                border: 0,
                boxShadow: "none"
              }
            }
          }
        },
        [componentCls]: {
          width: "100%",
          marginBottom: 0,
          textAlign: "inherit",
          "&:focus": {
            zIndex: 1,
            // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
            borderInlineEndWidth: 1
          },
          "&:hover": {
            zIndex: 1,
            borderInlineEndWidth: 1,
            [`${componentCls}-search-with-button &`]: {
              zIndex: 0
            }
          }
        },
        // Reset rounded corners
        [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          // Reset Select's style in addon
          [`${antCls}-select ${antCls}-select-selector`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`> ${componentCls}-affix-wrapper`]: {
          [`&:not(:first-child) ${componentCls}`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          },
          [`&:not(:last-child) ${componentCls}`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          // Reset Select's style in addon
          [`${antCls}-select ${antCls}-select-selector`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`${componentCls}-affix-wrapper`]: {
          "&:not(:last-child)": {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            [`${componentCls}-search &`]: {
              borderStartStartRadius: token2.borderRadius,
              borderEndStartRadius: token2.borderRadius
            }
          },
          [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
          display: "block"
        }, clearFix()), {
          [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
            "&:not(:first-child):not(:last-child)": {
              borderInlineEndWidth: token2.lineWidth,
              "&:hover, &:focus": {
                zIndex: 1
              }
            }
          },
          "& > *": {
            display: "inline-flex",
            float: "none",
            verticalAlign: "top",
            // https://github.com/ant-design/ant-design-pro/issues/139
            borderRadius: 0
          },
          [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
            display: "inline-flex"
          },
          "& > *:not(:last-child)": {
            marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
            borderInlineEndWidth: token2.lineWidth
          },
          // Undo float for .ant-input-group .ant-input
          [componentCls]: {
            float: "none"
          },
          // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
          [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
            borderInlineEndWidth: token2.lineWidth,
            borderRadius: 0,
            "&:hover, &:focus": {
              zIndex: 1
            }
          },
          [`& > ${antCls}-select-focused`]: {
            zIndex: 1
          },
          // update z-index for arrow icon
          [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
            zIndex: 1
            // https://github.com/ant-design/ant-design/issues/20371
          },
          [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
            borderStartStartRadius: token2.borderRadius,
            borderEndStartRadius: token2.borderRadius
          },
          [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
            borderInlineEndWidth: token2.lineWidth,
            borderStartEndRadius: token2.borderRadius,
            borderEndEndRadius: token2.borderRadius
          },
          // https://github.com/ant-design/ant-design/issues/12493
          [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
            verticalAlign: "top"
          },
          [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
            marginInlineStart: token2.calc(token2.lineWidth).mul(-1).equal(),
            [`${componentCls}-affix-wrapper`]: {
              borderRadius: 0
            }
          },
          [`${componentCls}-group-wrapper:not(:last-child)`]: {
            [`&${componentCls}-search > ${componentCls}-group`]: {
              [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
                borderRadius: 0
              },
              [`& > ${componentCls}`]: {
                borderStartStartRadius: token2.borderRadius,
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
                borderEndStartRadius: token2.borderRadius
              }
            }
          }
        })
      };
    };
    const genInputStyle = (token2) => {
      const {
        componentCls,
        controlHeightSM,
        lineWidth,
        calc
      } = token2;
      const FIXED_CHROME_COLOR_HEIGHT = 16;
      const colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(FIXED_CHROME_COLOR_HEIGHT).div(2).equal();
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genBasicInputStyle(token2)), genOutlinedStyle(token2)), genFilledStyle(token2)), genBorderlessStyle(token2)), genUnderlinedStyle(token2)), {
          '&[type="color"]': {
            height: token2.controlHeight,
            [`&${componentCls}-lg`]: {
              height: token2.controlHeightLG
            },
            [`&${componentCls}-sm`]: {
              height: controlHeightSM,
              paddingTop: colorSmallPadding,
              paddingBottom: colorSmallPadding
            }
          },
          '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
            appearance: "none"
          }
        })
      };
    };
    const genAllowClearStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        // ========================= Input =========================
        [`${componentCls}-clear-icon`]: {
          margin: 0,
          padding: 0,
          lineHeight: 0,
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          verticalAlign: -1,
          // https://github.com/ant-design/ant-design/pull/18151
          // https://codesandbox.io/s/wizardly-sun-u10br
          cursor: "pointer",
          transition: `color ${token2.motionDurationSlow}`,
          border: "none",
          outline: "none",
          backgroundColor: "transparent",
          "&:hover": {
            color: token2.colorTextTertiary
          },
          "&:active": {
            color: token2.colorText
          },
          "&-hidden": {
            visibility: "hidden"
          },
          "&-has-suffix": {
            margin: `0 ${unit$1(token2.inputAffixPadding)}`
          }
        }
      };
    };
    const genAffixStyle = (token2) => {
      const {
        componentCls,
        inputAffixPadding,
        colorTextDescription,
        motionDurationSlow,
        colorIcon,
        colorIconHover,
        iconCls
      } = token2;
      const affixCls = `${componentCls}-affix-wrapper`;
      const affixClsDisabled = `${componentCls}-affix-wrapper-disabled`;
      return {
        [affixCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
          display: "inline-flex",
          [`&:not(${componentCls}-disabled):hover`]: {
            zIndex: 1,
            [`${componentCls}-search-with-button &`]: {
              zIndex: 0
            }
          },
          "&-focused, &:focus": {
            zIndex: 1
          },
          [`> input${componentCls}`]: {
            padding: 0
          },
          [`> input${componentCls}, > textarea${componentCls}`]: {
            fontSize: "inherit",
            border: "none",
            borderRadius: 0,
            outline: "none",
            background: "transparent",
            color: "inherit",
            "&::-ms-reveal": {
              display: "none"
            },
            "&:focus": {
              boxShadow: "none !important"
            }
          },
          "&::before": {
            display: "inline-block",
            width: 0,
            visibility: "hidden",
            content: '"\\a0"'
          },
          [componentCls]: {
            "&-prefix, &-suffix": {
              display: "flex",
              flex: "none",
              alignItems: "center",
              "> *:not(:last-child)": {
                marginInlineEnd: token2.paddingXS
              }
            },
            "&-show-count-suffix": {
              color: colorTextDescription
            },
            "&-show-count-has-suffix": {
              marginInlineEnd: token2.paddingXXS
            },
            "&-prefix": {
              marginInlineEnd: inputAffixPadding
            },
            "&-suffix": {
              marginInlineStart: inputAffixPadding
            }
          }
        }), genAllowClearStyle(token2)), {
          // password
          [`${iconCls}${componentCls}-password-icon`]: {
            color: colorIcon,
            cursor: "pointer",
            transition: `all ${motionDurationSlow}`,
            "&:hover": {
              color: colorIconHover
            }
          }
        }),
        //  affix-wrapper borderRadius
        [`${componentCls}-underlined`]: {
          borderRadius: 0
        },
        [affixClsDisabled]: {
          // password disabled
          [`${iconCls}${componentCls}-password-icon`]: {
            color: colorIcon,
            cursor: "not-allowed",
            "&:hover": {
              color: colorIcon
            }
          }
        }
      };
    };
    const genGroupStyle = (token2) => {
      const {
        componentCls,
        borderRadiusLG,
        borderRadiusSM
      } = token2;
      return {
        [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genInputGroupStyle(token2)), {
          "&-rtl": {
            direction: "rtl"
          },
          "&-wrapper": Object.assign(Object.assign(Object.assign({
            display: "inline-block",
            width: "100%",
            textAlign: "start",
            verticalAlign: "top",
            "&-rtl": {
              direction: "rtl"
            },
            // Size
            "&-lg": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusLG,
                fontSize: token2.inputFontSizeLG
              }
            },
            "&-sm": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusSM
              }
            }
          }, genOutlinedGroupStyle(token2)), genFilledGroupStyle(token2)), {
            // '&-disabled': {
            //   [`${componentCls}-group-addon`]: {
            //     ...genDisabledStyle(token),
            //   },
            // },
            // Fix the issue of using icons in Space Compact mode
            // https://github.com/ant-design/ant-design/issues/42122
            [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderRadius: 0
              }
            },
            [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            },
            // Fix the issue of input use show-count param in space compact mode
            // https://github.com/ant-design/ant-design/issues/46872
            [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
              [`${componentCls}-affix-wrapper`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            // Fix the issue of input use `addonAfter` param in space compact mode
            // https://github.com/ant-design/ant-design/issues/52483
            [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-item`]: {
              [`${componentCls}-affix-wrapper`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            }
          })
        })
      };
    };
    const genSearchInputStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      const searchPrefixCls = `${componentCls}-search`;
      return {
        [searchPrefixCls]: {
          [componentCls]: {
            "&:hover, &:focus": {
              [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                borderInlineStartColor: token2.colorPrimaryHover
              }
            }
          },
          [`${componentCls}-affix-wrapper`]: {
            height: token2.controlHeight,
            borderRadius: 0
          },
          // fix slight height diff in Firefox:
          // https://ant.design/components/auto-complete-cn/#auto-complete-demo-certain-category
          [`${componentCls}-lg`]: {
            lineHeight: token2.calc(token2.lineHeightLG).sub(2e-4).equal()
          },
          [`> ${componentCls}-group`]: {
            [`> ${componentCls}-group-addon:last-child`]: {
              insetInlineStart: -1,
              padding: 0,
              border: 0,
              [`${searchPrefixCls}-button`]: {
                // Fix https://github.com/ant-design/ant-design/issues/47150
                marginInlineEnd: -1,
                borderStartStartRadius: 0,
                borderEndStartRadius: 0,
                boxShadow: "none"
              },
              [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                color: token2.colorTextDescription,
                "&:hover": {
                  color: token2.colorPrimaryHover
                },
                "&:active": {
                  color: token2.colorPrimaryActive
                },
                [`&${antCls}-btn-loading::before`]: {
                  insetInlineStart: 0,
                  insetInlineEnd: 0,
                  insetBlockStart: 0,
                  insetBlockEnd: 0
                }
              }
            }
          },
          [`${searchPrefixCls}-button`]: {
            height: token2.controlHeight,
            "&:hover, &:focus": {
              zIndex: 1
            }
          },
          "&-large": {
            [`${componentCls}-affix-wrapper, ${searchPrefixCls}-button`]: {
              height: token2.controlHeightLG
            }
          },
          "&-small": {
            [`${componentCls}-affix-wrapper, ${searchPrefixCls}-button`]: {
              height: token2.controlHeightSM
            }
          },
          "&-rtl": {
            direction: "rtl"
          },
          // ===================== Compact Item Customized Styles =====================
          [`&${componentCls}-compact-item`]: {
            [`&:not(${componentCls}-compact-last-item)`]: {
              [`${componentCls}-group-addon`]: {
                [`${componentCls}-search-button`]: {
                  marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
                  borderRadius: 0
                }
              }
            },
            [`&:not(${componentCls}-compact-first-item)`]: {
              [`${componentCls},${componentCls}-affix-wrapper`]: {
                borderRadius: 0
              }
            },
            [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
              "&:hover, &:focus, &:active": {
                zIndex: 2
              }
            },
            [`> ${componentCls}-affix-wrapper-focused`]: {
              zIndex: 2
            }
          }
        }
      };
    };
    const genRangeStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-out-of-range`]: {
          [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: {
            color: token2.colorError
          }
        }
      };
    };
    const useSharedStyle = genStyleHooks(["Input", "Shared"], (token2) => {
      const inputToken = merge(token2, initInputToken(token2));
      return [genInputStyle(inputToken), genAffixStyle(inputToken)];
    }, initComponentToken, {
      resetFont: false
    });
    const useStyle$h = genStyleHooks(["Input", "Component"], (token2) => {
      const inputToken = merge(token2, initInputToken(token2));
      return [
        genGroupStyle(inputToken),
        genSearchInputStyle(inputToken),
        genRangeStyle(inputToken),
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        genCompactItemStyle(inputToken)
      ];
    }, initComponentToken, {
      resetFont: false
    });
    const genSize = (token2, suffix2) => {
      const {
        componentCls,
        controlHeight
      } = token2;
      const suffixCls = suffix2 ? `${componentCls}-${suffix2}` : "";
      const multipleSelectorUnit = getMultipleSelectorUnit(token2);
      return [
        // genSelectionStyle(token, suffix),
        {
          [`${componentCls}-multiple${suffixCls}`]: {
            paddingBlock: multipleSelectorUnit.containerPadding,
            paddingInlineStart: multipleSelectorUnit.basePadding,
            minHeight: controlHeight,
            // ======================== Selections ========================
            [`${componentCls}-selection-item`]: {
              height: multipleSelectorUnit.itemHeight,
              lineHeight: unit$1(multipleSelectorUnit.itemLineHeight)
            }
          }
        }
      ];
    };
    const genPickerMultipleStyle = (token2) => {
      const {
        componentCls,
        calc,
        lineWidth
      } = token2;
      const smallToken = merge(token2, {
        fontHeight: token2.fontSize,
        selectHeight: token2.controlHeightSM,
        multipleSelectItemHeight: token2.multipleItemHeightSM,
        borderRadius: token2.borderRadiusSM,
        borderRadiusSM: token2.borderRadiusXS,
        controlHeight: token2.controlHeightSM
      });
      const largeToken = merge(token2, {
        fontHeight: calc(token2.multipleItemHeightLG).sub(calc(lineWidth).mul(2).equal()).equal(),
        fontSize: token2.fontSizeLG,
        selectHeight: token2.controlHeightLG,
        multipleSelectItemHeight: token2.multipleItemHeightLG,
        borderRadius: token2.borderRadiusLG,
        borderRadiusSM: token2.borderRadius,
        controlHeight: token2.controlHeightLG
      });
      return [
        // ======================== Size ========================
        genSize(smallToken, "small"),
        genSize(token2),
        genSize(largeToken, "large"),
        // ====================== Selection ======================
        {
          [`${componentCls}${componentCls}-multiple`]: Object.assign(Object.assign({
            width: "100%",
            cursor: "text",
            // ==================== Selector =====================
            [`${componentCls}-selector`]: {
              flex: "auto",
              padding: 0,
              position: "relative",
              "&:after": {
                margin: 0
              },
              // ================== placeholder ==================
              [`${componentCls}-selection-placeholder`]: {
                position: "absolute",
                top: "50%",
                insetInlineStart: token2.inputPaddingHorizontalBase,
                insetInlineEnd: 0,
                transform: "translateY(-50%)",
                transition: `all ${token2.motionDurationSlow}`,
                overflow: "hidden",
                whiteSpace: "nowrap",
                textOverflow: "ellipsis",
                flex: 1,
                color: token2.colorTextPlaceholder,
                pointerEvents: "none"
              }
            }
          }, genOverflowStyle(token2)), {
            // ====================== Input ======================
            // Input is `readonly`, which is used for a11y only
            [`${componentCls}-multiple-input`]: {
              width: 0,
              height: 0,
              border: 0,
              visibility: "hidden",
              position: "absolute",
              zIndex: -1
            }
          })
        }
      ];
    };
    const genPickerCellInnerStyle = (token2) => {
      const {
        pickerCellCls,
        pickerCellInnerCls,
        cellHeight,
        borderRadiusSM,
        motionDurationMid,
        cellHoverBg,
        lineWidth,
        lineType,
        colorPrimary,
        cellActiveWithRangeBg,
        colorTextLightSolid,
        colorTextDisabled,
        cellBgDisabled,
        colorFillSecondary
      } = token2;
      return {
        "&::before": {
          position: "absolute",
          top: "50%",
          insetInlineStart: 0,
          insetInlineEnd: 0,
          zIndex: 1,
          height: cellHeight,
          transform: "translateY(-50%)",
          content: '""',
          pointerEvents: "none"
        },
        // >>> Default
        [pickerCellInnerCls]: {
          position: "relative",
          zIndex: 2,
          display: "inline-block",
          minWidth: cellHeight,
          height: cellHeight,
          lineHeight: unit$1(cellHeight),
          borderRadius: borderRadiusSM,
          transition: `background ${motionDurationMid}`
        },
        // >>> Hover
        [`&:hover:not(${pickerCellCls}-in-view):not(${pickerCellCls}-disabled),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end):not(${pickerCellCls}-disabled)`]: {
          [pickerCellInnerCls]: {
            background: cellHoverBg
          }
        },
        // >>> Today
        [`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: {
          "&::before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 1,
            border: `${unit$1(lineWidth)} ${lineType} ${colorPrimary}`,
            borderRadius: borderRadiusSM,
            content: '""'
          }
        },
        // >>> In Range
        [`&-in-view${pickerCellCls}-in-range,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
          position: "relative",
          [`&:not(${pickerCellCls}-disabled):before`]: {
            background: cellActiveWithRangeBg
          }
        },
        // >>> Selected
        [`&-in-view${pickerCellCls}-selected,
      &-in-view${pickerCellCls}-range-start,
      &-in-view${pickerCellCls}-range-end`]: {
          [`&:not(${pickerCellCls}-disabled) ${pickerCellInnerCls}`]: {
            color: colorTextLightSolid,
            background: colorPrimary
          },
          [`&${pickerCellCls}-disabled ${pickerCellInnerCls}`]: {
            background: colorFillSecondary
          }
        },
        [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-disabled):before`]: {
          insetInlineStart: "50%"
        },
        [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-disabled):before`]: {
          insetInlineEnd: "50%"
        },
        // range start border-radius
        [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
          borderStartStartRadius: borderRadiusSM,
          borderEndStartRadius: borderRadiusSM,
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        },
        // range end border-radius
        [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          borderStartEndRadius: borderRadiusSM,
          borderEndEndRadius: borderRadiusSM
        },
        // >>> Disabled
        "&-disabled": {
          color: colorTextDisabled,
          cursor: "not-allowed",
          [pickerCellInnerCls]: {
            background: "transparent"
          },
          "&::before": {
            background: cellBgDisabled
          }
        },
        [`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: {
          borderColor: colorTextDisabled
        }
      };
    };
    const genPanelStyle = (token2) => {
      const {
        componentCls,
        pickerCellCls,
        pickerCellInnerCls,
        pickerYearMonthCellWidth,
        pickerControlIconSize,
        cellWidth,
        paddingSM,
        paddingXS,
        paddingXXS,
        colorBgContainer,
        lineWidth,
        lineType,
        borderRadiusLG,
        colorPrimary,
        colorTextHeading,
        colorSplit,
        pickerControlIconBorderWidth,
        colorIcon,
        textHeight,
        motionDurationMid,
        colorIconHover,
        fontWeightStrong,
        cellHeight,
        pickerCellPaddingVertical,
        colorTextDisabled,
        colorText,
        fontSize,
        motionDurationSlow,
        withoutTimeCellHeight,
        pickerQuarterPanelContentHeight,
        borderRadiusSM,
        colorTextLightSolid,
        cellHoverBg,
        timeColumnHeight,
        timeColumnWidth,
        timeCellHeight,
        controlItemBgActive,
        marginXXS,
        pickerDatePanelPaddingHorizontal,
        pickerControlIconMargin
      } = token2;
      const pickerPanelWidth = token2.calc(cellWidth).mul(7).add(token2.calc(pickerDatePanelPaddingHorizontal).mul(2)).equal();
      return {
        [componentCls]: {
          "&-panel": {
            display: "inline-flex",
            flexDirection: "column",
            textAlign: "center",
            background: colorBgContainer,
            borderRadius: borderRadiusLG,
            outline: "none",
            "&-focused": {
              borderColor: colorPrimary
            },
            "&-rtl": {
              [`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: {
                transform: "rotate(45deg)"
              },
              [`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: {
                transform: "rotate(-135deg)"
              },
              [`${componentCls}-time-panel`]: {
                [`${componentCls}-content`]: {
                  direction: "ltr",
                  "> *": {
                    direction: "rtl"
                  }
                }
              }
            }
          },
          // ========================================================
          // =                     Shared Panel                     =
          // ========================================================
          [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel,
        &-week-panel,
        &-date-panel,
        &-time-panel`]: {
            display: "flex",
            flexDirection: "column",
            width: pickerPanelWidth
          },
          // ======================= Header =======================
          "&-header": {
            display: "flex",
            padding: `0 ${unit$1(paddingXS)}`,
            color: colorTextHeading,
            borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
            "> *": {
              flex: "none"
            },
            button: {
              padding: 0,
              color: colorIcon,
              lineHeight: unit$1(textHeight),
              background: "transparent",
              border: 0,
              cursor: "pointer",
              transition: `color ${motionDurationMid}`,
              fontSize: "inherit",
              display: "inline-flex",
              alignItems: "center",
              justifyContent: "center",
              "&:empty": {
                display: "none"
              }
            },
            "> button": {
              minWidth: "1.6em",
              fontSize,
              "&:hover": {
                color: colorIconHover
              },
              "&:disabled": {
                opacity: 0.25,
                pointerEvents: "none"
              }
            },
            "&-view": {
              flex: "auto",
              fontWeight: fontWeightStrong,
              lineHeight: unit$1(textHeight),
              "> button": {
                color: "inherit",
                fontWeight: "inherit",
                verticalAlign: "top",
                "&:not(:first-child)": {
                  marginInlineStart: paddingXS
                },
                "&:hover": {
                  color: colorPrimary
                }
              }
            }
          },
          // Arrow button
          [`&-prev-icon,
        &-next-icon,
        &-super-prev-icon,
        &-super-next-icon`]: {
            position: "relative",
            width: pickerControlIconSize,
            height: pickerControlIconSize,
            "&::before": {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              width: pickerControlIconSize,
              height: pickerControlIconSize,
              border: `0 solid currentcolor`,
              borderBlockStartWidth: pickerControlIconBorderWidth,
              borderInlineStartWidth: pickerControlIconBorderWidth,
              content: '""'
            }
          },
          [`&-super-prev-icon,
        &-super-next-icon`]: {
            "&::after": {
              position: "absolute",
              top: pickerControlIconMargin,
              insetInlineStart: pickerControlIconMargin,
              display: "inline-block",
              width: pickerControlIconSize,
              height: pickerControlIconSize,
              border: "0 solid currentcolor",
              borderBlockStartWidth: pickerControlIconBorderWidth,
              borderInlineStartWidth: pickerControlIconBorderWidth,
              content: '""'
            }
          },
          "&-prev-icon, &-super-prev-icon": {
            transform: "rotate(-45deg)"
          },
          "&-next-icon, &-super-next-icon": {
            transform: "rotate(135deg)"
          },
          // ======================== Body ========================
          "&-content": {
            width: "100%",
            tableLayout: "fixed",
            borderCollapse: "collapse",
            "th, td": {
              position: "relative",
              minWidth: cellHeight,
              fontWeight: "normal"
            },
            th: {
              height: token2.calc(cellHeight).add(token2.calc(pickerCellPaddingVertical).mul(2)).equal(),
              color: colorText,
              verticalAlign: "middle"
            }
          },
          "&-cell": Object.assign({
            padding: `${unit$1(pickerCellPaddingVertical)} 0`,
            color: colorTextDisabled,
            cursor: "pointer",
            // In view
            "&-in-view": {
              color: colorText
            }
          }, genPickerCellInnerStyle(token2)),
          [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
            [`${componentCls}-content`]: {
              height: token2.calc(withoutTimeCellHeight).mul(4).equal()
            },
            [pickerCellInnerCls]: {
              padding: `0 ${unit$1(paddingXS)}`
            }
          },
          "&-quarter-panel": {
            [`${componentCls}-content`]: {
              height: pickerQuarterPanelContentHeight
            }
          },
          // ========================================================
          // =                       Special                        =
          // ========================================================
          // ===================== Decade Panel =====================
          "&-decade-panel": {
            [pickerCellInnerCls]: {
              padding: `0 ${unit$1(token2.calc(paddingXS).div(2).equal())}`
            },
            [`${componentCls}-cell::before`]: {
              display: "none"
            }
          },
          // ============= Year & Quarter & Month Panel =============
          [`&-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
            [`${componentCls}-body`]: {
              padding: `0 ${unit$1(paddingXS)}`
            },
            [pickerCellInnerCls]: {
              width: pickerYearMonthCellWidth
            }
          },
          // ====================== Date Panel ======================
          "&-date-panel": {
            [`${componentCls}-body`]: {
              padding: `${unit$1(paddingXS)} ${unit$1(pickerDatePanelPaddingHorizontal)}`
            },
            [`${componentCls}-content th`]: {
              boxSizing: "border-box",
              padding: 0
            }
          },
          // ====================== Week Panel ======================
          "&-week-panel": {
            // Clear cell style
            [`${componentCls}-cell`]: {
              [`&:hover ${pickerCellInnerCls},
            &-selected ${pickerCellInnerCls},
            ${pickerCellInnerCls}`]: {
                background: "transparent !important"
              }
            },
            "&-row": {
              td: {
                "&:before": {
                  transition: `background ${motionDurationMid}`
                },
                "&:first-child:before": {
                  borderStartStartRadius: borderRadiusSM,
                  borderEndStartRadius: borderRadiusSM
                },
                "&:last-child:before": {
                  borderStartEndRadius: borderRadiusSM,
                  borderEndEndRadius: borderRadiusSM
                }
              },
              "&:hover td:before": {
                background: cellHoverBg
              },
              "&-range-start td, &-range-end td, &-selected td, &-hover td": {
                // Rise priority to override hover style
                [`&${pickerCellCls}`]: {
                  "&:before": {
                    background: colorPrimary
                  },
                  [`&${componentCls}-cell-week`]: {
                    color: new FastColor(colorTextLightSolid).setA(0.5).toHexString()
                  },
                  [pickerCellInnerCls]: {
                    color: colorTextLightSolid
                  }
                }
              },
              "&-range-hover td:before": {
                background: controlItemBgActive
              }
            }
          },
          // >>> ShowWeek
          "&-week-panel, &-date-panel-show-week": {
            [`${componentCls}-body`]: {
              padding: `${unit$1(paddingXS)} ${unit$1(paddingSM)}`
            },
            [`${componentCls}-content th`]: {
              width: "auto"
            }
          },
          // ==================== Datetime Panel ====================
          "&-datetime-panel": {
            display: "flex",
            [`${componentCls}-time-panel`]: {
              borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`
            },
            [`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: {
              transition: `opacity ${motionDurationSlow}`
            },
            // Keyboard
            "&-active": {
              [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
                opacity: 0.3,
                "&-active": {
                  opacity: 1
                }
              }
            }
          },
          // ====================== Time Panel ======================
          "&-time-panel": {
            width: "auto",
            minWidth: "auto",
            [`${componentCls}-content`]: {
              display: "flex",
              flex: "auto",
              height: timeColumnHeight
            },
            "&-column": {
              flex: "1 0 auto",
              width: timeColumnWidth,
              margin: `${unit$1(paddingXXS)} 0`,
              padding: 0,
              overflowY: "hidden",
              textAlign: "start",
              listStyle: "none",
              transition: `background ${motionDurationMid}`,
              overflowX: "hidden",
              "&::-webkit-scrollbar": {
                width: 8,
                backgroundColor: "transparent"
              },
              "&::-webkit-scrollbar-thumb": {
                backgroundColor: token2.colorTextTertiary,
                borderRadius: token2.borderRadiusSM
              },
              // For Firefox
              "&": {
                scrollbarWidth: "thin",
                scrollbarColor: `${token2.colorTextTertiary} transparent`
              },
              "&::after": {
                display: "block",
                height: `calc(100% - ${unit$1(timeCellHeight)})`,
                content: '""'
              },
              "&:not(:first-child)": {
                borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`
              },
              "&-active": {
                background: new FastColor(controlItemBgActive).setA(0.2).toHexString()
              },
              "&:hover": {
                overflowY: "auto"
              },
              "> li": {
                margin: 0,
                padding: 0,
                [`&${componentCls}-time-panel-cell`]: {
                  marginInline: marginXXS,
                  [`${componentCls}-time-panel-cell-inner`]: {
                    display: "block",
                    width: token2.calc(timeColumnWidth).sub(token2.calc(marginXXS).mul(2)).equal(),
                    height: timeCellHeight,
                    margin: 0,
                    paddingBlock: 0,
                    paddingInlineEnd: 0,
                    paddingInlineStart: token2.calc(timeColumnWidth).sub(timeCellHeight).div(2).equal(),
                    color: colorText,
                    lineHeight: unit$1(timeCellHeight),
                    borderRadius: borderRadiusSM,
                    cursor: "pointer",
                    transition: `background ${motionDurationMid}`,
                    "&:hover": {
                      background: cellHoverBg
                    }
                  },
                  "&-selected": {
                    [`${componentCls}-time-panel-cell-inner`]: {
                      background: controlItemBgActive
                    }
                  },
                  "&-disabled": {
                    [`${componentCls}-time-panel-cell-inner`]: {
                      color: colorTextDisabled,
                      background: "transparent",
                      cursor: "not-allowed"
                    }
                  }
                }
              }
            }
          }
        }
      };
    };
    const genPickerPanelStyle = (token2) => {
      const {
        componentCls,
        textHeight,
        lineWidth,
        paddingSM,
        antCls,
        colorPrimary,
        cellActiveWithRangeBg,
        colorPrimaryBorder,
        lineType,
        colorSplit
      } = token2;
      return {
        [`${componentCls}-dropdown`]: {
          // ======================== Footer ========================
          [`${componentCls}-footer`]: {
            borderTop: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
            "&-extra": {
              padding: `0 ${unit$1(paddingSM)}`,
              lineHeight: unit$1(token2.calc(textHeight).sub(token2.calc(lineWidth).mul(2)).equal()),
              textAlign: "start",
              "&:not(:last-child)": {
                borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`
              }
            }
          },
          // ==================== Footer > Ranges ===================
          [`${componentCls}-panels + ${componentCls}-footer ${componentCls}-ranges`]: {
            justifyContent: "space-between"
          },
          [`${componentCls}-ranges`]: {
            marginBlock: 0,
            paddingInline: unit$1(paddingSM),
            overflow: "hidden",
            textAlign: "start",
            listStyle: "none",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            "> li": {
              lineHeight: unit$1(token2.calc(textHeight).sub(token2.calc(lineWidth).mul(2)).equal()),
              display: "inline-block"
            },
            [`${componentCls}-now-btn-disabled`]: {
              pointerEvents: "none",
              color: token2.colorTextDisabled
            },
            // https://github.com/ant-design/ant-design/issues/23687
            [`${componentCls}-preset > ${antCls}-tag-blue`]: {
              color: colorPrimary,
              background: cellActiveWithRangeBg,
              borderColor: colorPrimaryBorder,
              cursor: "pointer"
            },
            [`${componentCls}-ok`]: {
              paddingBlock: token2.calc(lineWidth).mul(2).equal(),
              marginInlineStart: "auto"
            }
          }
        }
      };
    };
    const initPickerPanelToken = (token2) => {
      const {
        componentCls,
        controlHeightLG,
        paddingXXS,
        padding
      } = token2;
      return {
        pickerCellCls: `${componentCls}-cell`,
        pickerCellInnerCls: `${componentCls}-cell-inner`,
        pickerYearMonthCellWidth: token2.calc(controlHeightLG).mul(1.5).equal(),
        pickerQuarterPanelContentHeight: token2.calc(controlHeightLG).mul(1.4).equal(),
        pickerCellPaddingVertical: token2.calc(paddingXXS).add(token2.calc(paddingXXS).div(2)).equal(),
        pickerCellBorderGap: 2,
        // Magic for gap between cells
        pickerControlIconSize: 7,
        pickerControlIconMargin: 4,
        pickerControlIconBorderWidth: 1.5,
        pickerDatePanelPaddingHorizontal: token2.calc(padding).add(token2.calc(paddingXXS).div(2)).equal()
        // 18 in normal
      };
    };
    const initPanelComponentToken = (token2) => {
      const {
        colorBgContainerDisabled,
        controlHeight,
        controlHeightSM,
        controlHeightLG,
        paddingXXS,
        lineWidth
      } = token2;
      const dblPaddingXXS = paddingXXS * 2;
      const dblLineWidth = lineWidth * 2;
      const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
      const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
      const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
      const INTERNAL_FIXED_ITEM_MARGIN = Math.floor(paddingXXS / 2);
      const filledToken = {
        INTERNAL_FIXED_ITEM_MARGIN,
        cellHoverBg: token2.controlItemBgHover,
        cellActiveWithRangeBg: token2.controlItemBgActive,
        cellHoverWithRangeBg: new FastColor(token2.colorPrimary).lighten(35).toHexString(),
        cellRangeBorderColor: new FastColor(token2.colorPrimary).lighten(20).toHexString(),
        cellBgDisabled: colorBgContainerDisabled,
        timeColumnWidth: controlHeightLG * 1.4,
        timeColumnHeight: 28 * 8,
        timeCellHeight: 28,
        cellWidth: controlHeightSM * 1.5,
        cellHeight: controlHeightSM,
        textHeight: controlHeightLG,
        withoutTimeCellHeight: controlHeightLG * 1.65,
        multipleItemBg: token2.colorFillSecondary,
        multipleItemBorderColor: "transparent",
        multipleItemHeight,
        multipleItemHeightSM,
        multipleItemHeightLG,
        multipleSelectorBgDisabled: colorBgContainerDisabled,
        multipleItemColorDisabled: token2.colorTextDisabled,
        multipleItemBorderColorDisabled: "transparent"
      };
      return filledToken;
    };
    const prepareComponentToken$d = (token2) => Object.assign(Object.assign(Object.assign(Object.assign({}, initComponentToken(token2)), initPanelComponentToken(token2)), getArrowToken(token2)), {
      presetsWidth: 120,
      presetsMaxWidth: 200,
      zIndexPopup: token2.zIndexPopupBase + 50
    });
    const genVariantsStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: [
          Object.assign(Object.assign(Object.assign(Object.assign({}, genOutlinedStyle(token2)), genUnderlinedStyle(token2)), genFilledStyle(token2)), genBorderlessStyle(token2)),
          // ========================= Multiple =========================
          {
            "&-outlined": {
              [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
                background: token2.multipleItemBg,
                border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
              }
            },
            "&-filled": {
              [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
                background: token2.colorBgContainer,
                border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
              }
            },
            "&-borderless": {
              [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
                background: token2.multipleItemBg,
                border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
              }
            },
            "&-underlined": {
              [`&${componentCls}-multiple ${componentCls}-selection-item`]: {
                background: token2.multipleItemBg,
                border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`
              }
            }
          }
        ]
      };
    };
    const genPickerPadding = (token2, inputHeight, fontHeight, paddingHorizontal) => {
      const height = token2.calc(fontHeight).add(2).equal();
      const paddingTop = token2.max(token2.calc(inputHeight).sub(height).div(2).equal(), 0);
      const paddingBottom = token2.max(token2.calc(inputHeight).sub(height).sub(paddingTop).equal(), 0);
      return {
        padding: `${unit$1(paddingTop)} ${unit$1(paddingHorizontal)} ${unit$1(paddingBottom)}`
      };
    };
    const genPickerStatusStyle = (token2) => {
      const {
        componentCls,
        colorError,
        colorWarning
      } = token2;
      return {
        [`${componentCls}:not(${componentCls}-disabled):not([disabled])`]: {
          [`&${componentCls}-status-error`]: {
            [`${componentCls}-active-bar`]: {
              background: colorError
            }
          },
          [`&${componentCls}-status-warning`]: {
            [`${componentCls}-active-bar`]: {
              background: colorWarning
            }
          }
        }
      };
    };
    const genPickerStyle = (token2) => {
      const {
        componentCls,
        antCls,
        controlHeight,
        paddingInline,
        lineWidth,
        lineType,
        colorBorder,
        borderRadius,
        motionDurationMid,
        colorTextDisabled,
        colorTextPlaceholder,
        controlHeightLG,
        fontSizeLG,
        controlHeightSM,
        paddingInlineSM,
        paddingXS,
        marginXS,
        colorTextDescription,
        lineWidthBold,
        colorPrimary,
        motionDurationSlow,
        zIndexPopup,
        paddingXXS,
        sizePopupArrow,
        colorBgElevated,
        borderRadiusLG,
        boxShadowSecondary,
        borderRadiusSM,
        colorSplit,
        cellHoverBg,
        presetsWidth,
        presetsMaxWidth,
        boxShadowPopoverArrow,
        fontHeight,
        fontHeightLG,
        lineHeightLG
      } = token2;
      return [
        {
          [componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genPickerPadding(token2, controlHeight, fontHeight, paddingInline)), {
            position: "relative",
            display: "inline-flex",
            alignItems: "center",
            lineHeight: 1,
            borderRadius,
            transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}, background ${motionDurationMid}`,
            [`${componentCls}-prefix`]: {
              flex: "0 0 auto",
              marginInlineEnd: token2.inputAffixPadding
            },
            // ======================== Input =========================
            [`${componentCls}-input`]: {
              position: "relative",
              display: "inline-flex",
              alignItems: "center",
              width: "100%",
              "> input": Object.assign(Object.assign({
                position: "relative",
                display: "inline-block",
                width: "100%",
                color: "inherit",
                fontSize: token2.fontSize,
                lineHeight: token2.lineHeight,
                transition: `all ${motionDurationMid}`
              }, genPlaceholderStyle(colorTextPlaceholder)), {
                flex: "auto",
                // Fix Firefox flex not correct:
                // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
                minWidth: 1,
                height: "auto",
                padding: 0,
                background: "transparent",
                border: 0,
                fontFamily: "inherit",
                "&:focus": {
                  boxShadow: "none",
                  outline: 0
                },
                "&[disabled]": {
                  background: "transparent",
                  color: colorTextDisabled,
                  cursor: "not-allowed"
                }
              }),
              "&-placeholder": {
                "> input": {
                  color: colorTextPlaceholder
                }
              }
            },
            // Size
            "&-large": Object.assign(Object.assign({}, genPickerPadding(token2, controlHeightLG, fontHeightLG, paddingInline)), {
              [`${componentCls}-input > input`]: {
                fontSize: fontSizeLG,
                lineHeight: lineHeightLG
              }
            }),
            "&-small": Object.assign({}, genPickerPadding(token2, controlHeightSM, fontHeight, paddingInlineSM)),
            [`${componentCls}-suffix`]: {
              display: "flex",
              flex: "none",
              alignSelf: "center",
              marginInlineStart: token2.calc(paddingXS).div(2).equal(),
              color: colorTextDisabled,
              lineHeight: 1,
              pointerEvents: "none",
              transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
              "> *": {
                verticalAlign: "top",
                "&:not(:last-child)": {
                  marginInlineEnd: marginXS
                }
              }
            },
            [`${componentCls}-clear`]: {
              position: "absolute",
              top: "50%",
              insetInlineEnd: 0,
              color: colorTextDisabled,
              lineHeight: 1,
              transform: "translateY(-50%)",
              cursor: "pointer",
              opacity: 0,
              transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
              "> *": {
                verticalAlign: "top"
              },
              "&:hover": {
                color: colorTextDescription
              }
            },
            "&:hover": {
              [`${componentCls}-clear`]: {
                opacity: 1
              },
              // Should use the following selector, but since `:has` has poor compatibility,
              // we use `:not(:last-child)` instead, which may cause some problems in some cases.
              // [`${componentCls}-suffix:has(+ ${componentCls}-clear)`]: {
              [`${componentCls}-suffix:not(:last-child)`]: {
                opacity: 0
              }
            },
            [`${componentCls}-separator`]: {
              position: "relative",
              display: "inline-block",
              width: "1em",
              height: fontSizeLG,
              color: colorTextDisabled,
              fontSize: fontSizeLG,
              verticalAlign: "top",
              cursor: "default",
              [`${componentCls}-focused &`]: {
                color: colorTextDescription
              },
              [`${componentCls}-range-separator &`]: {
                [`${componentCls}-disabled &`]: {
                  cursor: "not-allowed"
                }
              }
            },
            // ======================== Range =========================
            "&-range": {
              position: "relative",
              display: "inline-flex",
              // Active bar
              [`${componentCls}-active-bar`]: {
                bottom: token2.calc(lineWidth).mul(-1).equal(),
                height: lineWidthBold,
                background: colorPrimary,
                opacity: 0,
                transition: `all ${motionDurationSlow} ease-out`,
                pointerEvents: "none"
              },
              [`&${componentCls}-focused`]: {
                [`${componentCls}-active-bar`]: {
                  opacity: 1
                }
              },
              [`${componentCls}-range-separator`]: {
                alignItems: "center",
                padding: `0 ${unit$1(paddingXS)}`,
                lineHeight: 1
              }
            },
            // ======================== Clear =========================
            "&-range, &-multiple": {
              // Clear
              [`${componentCls}-clear`]: {
                insetInlineEnd: paddingInline
              },
              [`&${componentCls}-small`]: {
                [`${componentCls}-clear`]: {
                  insetInlineEnd: paddingInlineSM
                }
              }
            },
            // ======================= Dropdown =======================
            "&-dropdown": Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genPanelStyle(token2)), {
              pointerEvents: "none",
              position: "absolute",
              // Fix incorrect position of picker popup
              // https://github.com/ant-design/ant-design/issues/35590
              top: -9999,
              left: {
                _skip_check_: true,
                value: -9999
              },
              zIndex: zIndexPopup,
              [`&${componentCls}-dropdown-hidden`]: {
                display: "none"
              },
              "&-rtl": {
                direction: "rtl"
              },
              [`&${componentCls}-dropdown-placement-bottomLeft,
            &${componentCls}-dropdown-placement-bottomRight`]: {
                [`${componentCls}-range-arrow`]: {
                  top: 0,
                  display: "block",
                  transform: "translateY(-100%)"
                }
              },
              [`&${componentCls}-dropdown-placement-topLeft,
            &${componentCls}-dropdown-placement-topRight`]: {
                [`${componentCls}-range-arrow`]: {
                  bottom: 0,
                  display: "block",
                  transform: "translateY(100%) rotate(180deg)"
                }
              },
              [`&${antCls}-slide-up-appear, &${antCls}-slide-up-enter`]: {
                [`${componentCls}-range-arrow${componentCls}-range-arrow`]: {
                  transition: "none"
                }
              },
              [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: {
                animationName: slideDownIn
              },
              [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: {
                animationName: slideUpIn
              },
              // https://github.com/ant-design/ant-design/issues/48727
              [`&${antCls}-slide-up-leave ${componentCls}-panel-container`]: {
                pointerEvents: "none"
              },
              [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: {
                animationName: slideDownOut
              },
              [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: {
                animationName: slideUpOut
              },
              // Time picker with additional style
              [`${componentCls}-panel > ${componentCls}-time-panel`]: {
                paddingTop: paddingXXS
              },
              // ======================== Ranges ========================
              [`${componentCls}-range-wrapper`]: {
                display: "flex",
                position: "relative"
              },
              [`${componentCls}-range-arrow`]: Object.assign(Object.assign({
                position: "absolute",
                zIndex: 1,
                display: "none",
                paddingInline: token2.calc(paddingInline).mul(1.5).equal(),
                boxSizing: "content-box",
                transition: `all ${motionDurationSlow} ease-out`
              }, genRoundedArrow(token2, colorBgElevated, boxShadowPopoverArrow)), {
                "&:before": {
                  insetInlineStart: token2.calc(paddingInline).mul(1.5).equal()
                }
              }),
              [`${componentCls}-panel-container`]: {
                overflow: "hidden",
                verticalAlign: "top",
                background: colorBgElevated,
                borderRadius: borderRadiusLG,
                boxShadow: boxShadowSecondary,
                transition: `margin ${motionDurationSlow}`,
                display: "inline-block",
                pointerEvents: "auto",
                // ======================== Layout ========================
                [`${componentCls}-panel-layout`]: {
                  display: "flex",
                  flexWrap: "nowrap",
                  alignItems: "stretch"
                },
                // ======================== Preset ========================
                [`${componentCls}-presets`]: {
                  display: "flex",
                  flexDirection: "column",
                  minWidth: presetsWidth,
                  maxWidth: presetsMaxWidth,
                  ul: {
                    height: 0,
                    flex: "auto",
                    listStyle: "none",
                    overflow: "auto",
                    margin: 0,
                    padding: paddingXS,
                    borderInlineEnd: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
                    li: Object.assign(Object.assign({}, textEllipsis), {
                      borderRadius: borderRadiusSM,
                      paddingInline: paddingXS,
                      paddingBlock: token2.calc(controlHeightSM).sub(fontHeight).div(2).equal(),
                      cursor: "pointer",
                      transition: `all ${motionDurationSlow}`,
                      "+ li": {
                        marginTop: marginXS
                      },
                      "&:hover": {
                        background: cellHoverBg
                      }
                    })
                  }
                },
                // ======================== Panels ========================
                [`${componentCls}-panels`]: {
                  display: "inline-flex",
                  flexWrap: "nowrap",
                  // [`${componentCls}-panel`]: {
                  //   borderWidth: `0 0 ${unit(lineWidth)}`,
                  // },
                  "&:last-child": {
                    [`${componentCls}-panel`]: {
                      borderWidth: 0
                    }
                  }
                },
                [`${componentCls}-panel`]: {
                  verticalAlign: "top",
                  background: "transparent",
                  borderRadius: 0,
                  borderWidth: 0,
                  [`${componentCls}-content, table`]: {
                    textAlign: "center"
                  },
                  "&-focused": {
                    borderColor: colorBorder
                  }
                }
              }
            }),
            "&-dropdown-range": {
              padding: `${unit$1(token2.calc(sizePopupArrow).mul(2).div(3).equal())} 0`,
              "&-hidden": {
                display: "none"
              }
            },
            "&-rtl": {
              direction: "rtl",
              [`${componentCls}-separator`]: {
                transform: "scale(-1, 1)"
              },
              [`${componentCls}-footer`]: {
                "&-extra": {
                  direction: "rtl"
                }
              }
            }
          })
        },
        // Follow code may reuse in other components
        initSlideMotion(token2, "slide-up"),
        initSlideMotion(token2, "slide-down"),
        initMoveMotion(token2, "move-up"),
        initMoveMotion(token2, "move-down")
      ];
    };
    const useStyle$g = genStyleHooks("DatePicker", (token2) => {
      const pickerToken = merge(initInputToken(token2), initPickerPanelToken(token2), {
        inputPaddingHorizontalBase: token2.calc(token2.paddingSM).sub(1).equal(),
        multipleSelectItemHeight: token2.multipleItemHeight,
        selectHeight: token2.controlHeight
      });
      return [
        genPickerPanelStyle(pickerToken),
        genPickerStyle(pickerToken),
        genVariantsStyle(pickerToken),
        genPickerStatusStyle(pickerToken),
        genPickerMultipleStyle(pickerToken),
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        genCompactItemStyle(token2, {
          focusElCls: `${token2.componentCls}-focused`
        })
      ];
    }, prepareComponentToken$d);
    var PlusOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
    var PlusOutlined = function PlusOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: PlusOutlined$1
      }));
    };
    var RefIcon$p = /* @__PURE__ */ reactExports.forwardRef(PlusOutlined);
    const TabContext = /* @__PURE__ */ reactExports.createContext(null);
    var useIndicator = function useIndicator2(options2) {
      var activeTabOffset = options2.activeTabOffset, horizontal = options2.horizontal, rtl = options2.rtl, _options$indicator = options2.indicator, indicator = _options$indicator === void 0 ? {} : _options$indicator;
      var size = indicator.size, _indicator$align = indicator.align, align = _indicator$align === void 0 ? "center" : _indicator$align;
      var _useState = reactExports.useState(), _useState2 = _slicedToArray(_useState, 2), inkStyle = _useState2[0], setInkStyle = _useState2[1];
      var inkBarRafRef = reactExports.useRef();
      var getLength = i.useCallback(function(origin) {
        if (typeof size === "function") {
          return size(origin);
        }
        if (typeof size === "number") {
          return size;
        }
        return origin;
      }, [size]);
      function cleanInkBarRaf() {
        wrapperRaf.cancel(inkBarRafRef.current);
      }
      reactExports.useEffect(function() {
        var newInkStyle = {};
        if (activeTabOffset) {
          if (horizontal) {
            newInkStyle.width = getLength(activeTabOffset.width);
            var key = rtl ? "right" : "left";
            if (align === "start") {
              newInkStyle[key] = activeTabOffset[key];
            }
            if (align === "center") {
              newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width / 2;
              newInkStyle.transform = rtl ? "translateX(50%)" : "translateX(-50%)";
            }
            if (align === "end") {
              newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width;
              newInkStyle.transform = "translateX(-100%)";
            }
          } else {
            newInkStyle.height = getLength(activeTabOffset.height);
            if (align === "start") {
              newInkStyle.top = activeTabOffset.top;
            }
            if (align === "center") {
              newInkStyle.top = activeTabOffset.top + activeTabOffset.height / 2;
              newInkStyle.transform = "translateY(-50%)";
            }
            if (align === "end") {
              newInkStyle.top = activeTabOffset.top + activeTabOffset.height;
              newInkStyle.transform = "translateY(-100%)";
            }
          }
        }
        cleanInkBarRaf();
        inkBarRafRef.current = wrapperRaf(function() {
          setInkStyle(newInkStyle);
        });
        return cleanInkBarRaf;
      }, [activeTabOffset, horizontal, rtl, align, getLength]);
      return {
        style: inkStyle
      };
    };
    var DEFAULT_SIZE$1 = {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    function useOffsets(tabs, tabSizes, holderScrollWidth) {
      return reactExports.useMemo(function() {
        var _tabs$;
        var map = /* @__PURE__ */ new Map();
        var lastOffset = tabSizes.get((_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key) || DEFAULT_SIZE$1;
        var rightOffset = lastOffset.left + lastOffset.width;
        for (var i2 = 0; i2 < tabs.length; i2 += 1) {
          var key = tabs[i2].key;
          var data = tabSizes.get(key);
          if (!data) {
            var _tabs;
            data = tabSizes.get((_tabs = tabs[i2 - 1]) === null || _tabs === void 0 ? void 0 : _tabs.key) || DEFAULT_SIZE$1;
          }
          var entity = map.get(key) || _objectSpread2$3({}, data);
          entity.right = rightOffset - entity.left - entity.width;
          map.set(key, entity);
        }
        return map;
      }, [tabs.map(function(tab) {
        return tab.key;
      }).join("_"), tabSizes, holderScrollWidth]);
    }
    function useSyncState(defaultState, onChange) {
      var stateRef = reactExports.useRef(defaultState);
      var _React$useState = reactExports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
      function setState(updater) {
        var newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
        if (newValue !== stateRef.current) {
          onChange(newValue, stateRef.current);
        }
        stateRef.current = newValue;
        forceUpdate({});
      }
      return [stateRef.current, setState];
    }
    var MIN_SWIPE_DISTANCE = 0.1;
    var STOP_SWIPE_DISTANCE = 0.01;
    var REFRESH_INTERVAL = 20;
    var SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL);
    function useTouchMove(ref, onOffset) {
      var _useState = reactExports.useState(), _useState2 = _slicedToArray(_useState, 2), touchPosition = _useState2[0], setTouchPosition = _useState2[1];
      var _useState3 = reactExports.useState(0), _useState4 = _slicedToArray(_useState3, 2), lastTimestamp = _useState4[0], setLastTimestamp = _useState4[1];
      var _useState5 = reactExports.useState(0), _useState6 = _slicedToArray(_useState5, 2), lastTimeDiff = _useState6[0], setLastTimeDiff = _useState6[1];
      var _useState7 = reactExports.useState(), _useState8 = _slicedToArray(_useState7, 2), lastOffset = _useState8[0], setLastOffset = _useState8[1];
      var motionRef = reactExports.useRef();
      function onTouchStart(e2) {
        var _e$touches$ = e2.touches[0], screenX = _e$touches$.screenX, screenY = _e$touches$.screenY;
        setTouchPosition({
          x: screenX,
          y: screenY
        });
        window.clearInterval(motionRef.current);
      }
      function onTouchMove(e2) {
        if (!touchPosition) return;
        var _e$touches$2 = e2.touches[0], screenX = _e$touches$2.screenX, screenY = _e$touches$2.screenY;
        setTouchPosition({
          x: screenX,
          y: screenY
        });
        var offsetX = screenX - touchPosition.x;
        var offsetY = screenY - touchPosition.y;
        onOffset(offsetX, offsetY);
        var now2 = Date.now();
        setLastTimestamp(now2);
        setLastTimeDiff(now2 - lastTimestamp);
        setLastOffset({
          x: offsetX,
          y: offsetY
        });
      }
      function onTouchEnd() {
        if (!touchPosition) return;
        setTouchPosition(null);
        setLastOffset(null);
        if (lastOffset) {
          var distanceX = lastOffset.x / lastTimeDiff;
          var distanceY = lastOffset.y / lastTimeDiff;
          var absX = Math.abs(distanceX);
          var absY = Math.abs(distanceY);
          if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE) return;
          var currentX = distanceX;
          var currentY = distanceY;
          motionRef.current = window.setInterval(function() {
            if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
              window.clearInterval(motionRef.current);
              return;
            }
            currentX *= SPEED_OFF_MULTIPLE;
            currentY *= SPEED_OFF_MULTIPLE;
            onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
          }, REFRESH_INTERVAL);
        }
      }
      var lastWheelDirectionRef = reactExports.useRef();
      function onWheel(e2) {
        var deltaX = e2.deltaX, deltaY = e2.deltaY;
        var mixed2 = 0;
        var absX = Math.abs(deltaX);
        var absY = Math.abs(deltaY);
        if (absX === absY) {
          mixed2 = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
        } else if (absX > absY) {
          mixed2 = deltaX;
          lastWheelDirectionRef.current = "x";
        } else {
          mixed2 = deltaY;
          lastWheelDirectionRef.current = "y";
        }
        if (onOffset(-mixed2, -mixed2)) {
          e2.preventDefault();
        }
      }
      var touchEventsRef = reactExports.useRef(null);
      touchEventsRef.current = {
        onTouchStart,
        onTouchMove,
        onTouchEnd,
        onWheel
      };
      reactExports.useEffect(function() {
        function onProxyTouchStart(e2) {
          touchEventsRef.current.onTouchStart(e2);
        }
        function onProxyTouchMove(e2) {
          touchEventsRef.current.onTouchMove(e2);
        }
        function onProxyTouchEnd(e2) {
          touchEventsRef.current.onTouchEnd(e2);
        }
        function onProxyWheel(e2) {
          touchEventsRef.current.onWheel(e2);
        }
        document.addEventListener("touchmove", onProxyTouchMove, {
          passive: false
        });
        document.addEventListener("touchend", onProxyTouchEnd, {
          passive: true
        });
        ref.current.addEventListener("touchstart", onProxyTouchStart, {
          passive: true
        });
        ref.current.addEventListener("wheel", onProxyWheel, {
          passive: false
        });
        return function() {
          document.removeEventListener("touchmove", onProxyTouchMove);
          document.removeEventListener("touchend", onProxyTouchEnd);
        };
      }, []);
    }
    function useUpdate(callback) {
      var _useState = reactExports.useState(0), _useState2 = _slicedToArray(_useState, 2), count = _useState2[0], setCount = _useState2[1];
      var effectRef = reactExports.useRef(0);
      var callbackRef = reactExports.useRef();
      callbackRef.current = callback;
      useLayoutUpdateEffect(function() {
        var _callbackRef$current;
        (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 || _callbackRef$current.call(callbackRef);
      }, [count]);
      return function() {
        if (effectRef.current !== count) {
          return;
        }
        effectRef.current += 1;
        setCount(effectRef.current);
      };
    }
    function useUpdateState(defaultState) {
      var batchRef = reactExports.useRef([]);
      var _useState3 = reactExports.useState({}), _useState4 = _slicedToArray(_useState3, 2), forceUpdate = _useState4[1];
      var state = reactExports.useRef(typeof defaultState === "function" ? defaultState() : defaultState);
      var flushUpdate = useUpdate(function() {
        var current = state.current;
        batchRef.current.forEach(function(callback) {
          current = callback(current);
        });
        batchRef.current = [];
        state.current = current;
        forceUpdate({});
      });
      function updater(callback) {
        batchRef.current.push(callback);
        flushUpdate();
      }
      return [state.current, updater];
    }
    var DEFAULT_SIZE = {
      width: 0,
      height: 0,
      left: 0,
      top: 0,
      right: 0
    };
    function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, _ref) {
      var tabs = _ref.tabs, tabPosition = _ref.tabPosition, rtl = _ref.rtl;
      var charUnit;
      var position2;
      var transformSize;
      if (["top", "bottom"].includes(tabPosition)) {
        charUnit = "width";
        position2 = rtl ? "right" : "left";
        transformSize = Math.abs(transform);
      } else {
        charUnit = "height";
        position2 = "top";
        transformSize = -transform;
      }
      return reactExports.useMemo(function() {
        if (!tabs.length) {
          return [0, 0];
        }
        var len = tabs.length;
        var endIndex = len;
        for (var i2 = 0; i2 < len; i2 += 1) {
          var offset2 = tabOffsets.get(tabs[i2].key) || DEFAULT_SIZE;
          if (Math.floor(offset2[position2] + offset2[charUnit]) > Math.floor(transformSize + visibleTabContentValue)) {
            endIndex = i2 - 1;
            break;
          }
        }
        var startIndex = 0;
        for (var _i = len - 1; _i >= 0; _i -= 1) {
          var _offset = tabOffsets.get(tabs[_i].key) || DEFAULT_SIZE;
          if (_offset[position2] < transformSize) {
            startIndex = _i + 1;
            break;
          }
        }
        return startIndex >= endIndex ? [0, 0] : [startIndex, endIndex];
      }, [tabOffsets, visibleTabContentValue, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, transformSize, tabPosition, tabs.map(function(tab) {
        return tab.key;
      }).join("_"), rtl]);
    }
    function stringify(obj) {
      var tgt;
      if (obj instanceof Map) {
        tgt = {};
        obj.forEach(function(v2, k2) {
          tgt[k2] = v2;
        });
      } else {
        tgt = obj;
      }
      return JSON.stringify(tgt);
    }
    var RC_TABS_DOUBLE_QUOTE = "TABS_DQ";
    function genDataNodeKey(key) {
      return String(key).replace(/"/g, RC_TABS_DOUBLE_QUOTE);
    }
    function getRemovable(closable, closeIcon, editable, disabled) {
      if (
        // Only editable tabs can be removed
        !editable || // Tabs cannot be removed when disabled
        disabled || // closable is false
        closable === false || // If closable is undefined, the remove button should be hidden when closeIcon is null or false
        closable === void 0 && (closeIcon === false || closeIcon === null)
      ) {
        return false;
      }
      return true;
    }
    var AddButton = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, editable = props.editable, locale2 = props.locale, style2 = props.style;
      if (!editable || editable.showAdd === false) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("button", {
        ref,
        type: "button",
        className: "".concat(prefixCls, "-nav-add"),
        style: style2,
        "aria-label": (locale2 === null || locale2 === void 0 ? void 0 : locale2.addAriaLabel) || "Add tab",
        onClick: function onClick(event) {
          editable.onEdit("add", {
            event
          });
        }
      }, editable.addIcon || "+");
    });
    var ExtraContent = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var position2 = props.position, prefixCls = props.prefixCls, extra = props.extra;
      if (!extra) {
        return null;
      }
      var content;
      var assertExtra = {};
      if (_typeof$1(extra) === "object" && !/* @__PURE__ */ reactExports.isValidElement(extra)) {
        assertExtra = extra;
      } else {
        assertExtra.right = extra;
      }
      if (position2 === "right") {
        content = assertExtra.right;
      }
      if (position2 === "left") {
        content = assertExtra.left;
      }
      return content ? /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-extra-content"),
        ref
      }, content) : null;
    });
    var OperationNode = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, id = props.id, tabs = props.tabs, locale2 = props.locale, mobile = props.mobile, _props$more = props.more, moreProps = _props$more === void 0 ? {} : _props$more, style2 = props.style, className = props.className, editable = props.editable, tabBarGutter = props.tabBarGutter, rtl = props.rtl, removeAriaLabel = props.removeAriaLabel, onTabClick = props.onTabClick, getPopupContainer = props.getPopupContainer, popupClassName = props.popupClassName;
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), open2 = _useState2[0], setOpen = _useState2[1];
      var _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), selectedKey = _useState4[0], setSelectedKey = _useState4[1];
      var _moreProps$icon = moreProps.icon, moreIcon = _moreProps$icon === void 0 ? "More" : _moreProps$icon;
      var popupId = "".concat(id, "-more-popup");
      var dropdownPrefix = "".concat(prefixCls, "-dropdown");
      var selectedItemId = selectedKey !== null ? "".concat(popupId, "-").concat(selectedKey) : null;
      var dropdownAriaLabel = locale2 === null || locale2 === void 0 ? void 0 : locale2.dropdownAriaLabel;
      function onRemoveTab(event, key) {
        event.preventDefault();
        event.stopPropagation();
        editable.onEdit("remove", {
          key,
          event
        });
      }
      var menu = /* @__PURE__ */ reactExports.createElement(ExportMenu, {
        onClick: function onClick(_ref) {
          var key = _ref.key, domEvent = _ref.domEvent;
          onTabClick(key, domEvent);
          setOpen(false);
        },
        prefixCls: "".concat(dropdownPrefix, "-menu"),
        id: popupId,
        tabIndex: -1,
        role: "listbox",
        "aria-activedescendant": selectedItemId,
        selectedKeys: [selectedKey],
        "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
      }, tabs.map(function(tab) {
        var closable = tab.closable, disabled = tab.disabled, closeIcon = tab.closeIcon, key = tab.key, label = tab.label;
        var removable = getRemovable(closable, closeIcon, editable, disabled);
        return /* @__PURE__ */ reactExports.createElement(MenuItem$2, {
          key,
          id: "".concat(popupId, "-").concat(key),
          role: "option",
          "aria-controls": id && "".concat(id, "-panel-").concat(key),
          disabled
        }, /* @__PURE__ */ reactExports.createElement("span", null, label), removable && /* @__PURE__ */ reactExports.createElement("button", {
          type: "button",
          "aria-label": removeAriaLabel || "remove",
          tabIndex: 0,
          className: "".concat(dropdownPrefix, "-menu-item-remove"),
          onClick: function onClick(e2) {
            e2.stopPropagation();
            onRemoveTab(e2, key);
          }
        }, closeIcon || editable.removeIcon || ""));
      }));
      function selectOffset(offset2) {
        var enabledTabs = tabs.filter(function(tab2) {
          return !tab2.disabled;
        });
        var selectedIndex = enabledTabs.findIndex(function(tab2) {
          return tab2.key === selectedKey;
        }) || 0;
        var len = enabledTabs.length;
        for (var i2 = 0; i2 < len; i2 += 1) {
          selectedIndex = (selectedIndex + offset2 + len) % len;
          var tab = enabledTabs[selectedIndex];
          if (!tab.disabled) {
            setSelectedKey(tab.key);
            return;
          }
        }
      }
      function onKeyDown(e2) {
        var which = e2.which;
        if (!open2) {
          if ([KeyCode.DOWN, KeyCode.SPACE, KeyCode.ENTER].includes(which)) {
            setOpen(true);
            e2.preventDefault();
          }
          return;
        }
        switch (which) {
          case KeyCode.UP:
            selectOffset(-1);
            e2.preventDefault();
            break;
          case KeyCode.DOWN:
            selectOffset(1);
            e2.preventDefault();
            break;
          case KeyCode.ESC:
            setOpen(false);
            break;
          case KeyCode.SPACE:
          case KeyCode.ENTER:
            if (selectedKey !== null) {
              onTabClick(selectedKey, e2);
            }
            break;
        }
      }
      reactExports.useEffect(function() {
        var ele = document.getElementById(selectedItemId);
        if (ele && ele.scrollIntoView) {
          ele.scrollIntoView(false);
        }
      }, [selectedKey]);
      reactExports.useEffect(function() {
        if (!open2) {
          setSelectedKey(null);
        }
      }, [open2]);
      var moreStyle = _defineProperty({}, rtl ? "marginRight" : "marginLeft", tabBarGutter);
      if (!tabs.length) {
        moreStyle.visibility = "hidden";
        moreStyle.order = 1;
      }
      var overlayClassName = classNames(_defineProperty({}, "".concat(dropdownPrefix, "-rtl"), rtl));
      var moreNode = mobile ? null : /* @__PURE__ */ reactExports.createElement(Dropdown$1, _extends$2({
        prefixCls: dropdownPrefix,
        overlay: menu,
        visible: tabs.length ? open2 : false,
        onVisibleChange: setOpen,
        overlayClassName: classNames(overlayClassName, popupClassName),
        mouseEnterDelay: 0.1,
        mouseLeaveDelay: 0.1,
        getPopupContainer
      }, moreProps), /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        className: "".concat(prefixCls, "-nav-more"),
        style: moreStyle,
        "aria-haspopup": "listbox",
        "aria-controls": popupId,
        id: "".concat(id, "-more"),
        "aria-expanded": open2,
        onKeyDown
      }, moreIcon));
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-nav-operations"), className),
        style: style2,
        ref
      }, moreNode, /* @__PURE__ */ reactExports.createElement(AddButton, {
        prefixCls,
        locale: locale2,
        editable
      }));
    });
    const OperationNode$1 = /* @__PURE__ */ reactExports.memo(OperationNode, function(_2, next2) {
      return (
        // https://github.com/ant-design/ant-design/issues/32544
        // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
        next2.tabMoving
      );
    });
    var TabNode = function TabNode2(props) {
      var prefixCls = props.prefixCls, id = props.id, active = props.active, focus = props.focus, _props$tab = props.tab, key = _props$tab.key, label = _props$tab.label, disabled = _props$tab.disabled, closeIcon = _props$tab.closeIcon, icon = _props$tab.icon, closable = props.closable, renderWrapper = props.renderWrapper, removeAriaLabel = props.removeAriaLabel, editable = props.editable, onClick = props.onClick, onFocus = props.onFocus, onBlur = props.onBlur, onKeyDown = props.onKeyDown, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, style2 = props.style, tabCount = props.tabCount, currentPosition = props.currentPosition;
      var tabPrefix = "".concat(prefixCls, "-tab");
      var removable = getRemovable(closable, closeIcon, editable, disabled);
      function onInternalClick(e2) {
        if (disabled) {
          return;
        }
        onClick(e2);
      }
      function onRemoveTab(event) {
        event.preventDefault();
        event.stopPropagation();
        editable.onEdit("remove", {
          key,
          event
        });
      }
      var labelNode = reactExports.useMemo(function() {
        return icon && typeof label === "string" ? /* @__PURE__ */ reactExports.createElement("span", null, label) : label;
      }, [label, icon]);
      var btnRef = reactExports.useRef(null);
      reactExports.useEffect(function() {
        if (focus && btnRef.current) {
          btnRef.current.focus();
        }
      }, [focus]);
      var node2 = /* @__PURE__ */ reactExports.createElement("div", {
        key,
        "data-node-key": genDataNodeKey(key),
        className: classNames(tabPrefix, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(tabPrefix, "-with-remove"), removable), "".concat(tabPrefix, "-active"), active), "".concat(tabPrefix, "-disabled"), disabled), "".concat(tabPrefix, "-focus"), focus)),
        style: style2,
        onClick: onInternalClick
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: btnRef,
        role: "tab",
        "aria-selected": active,
        id: id && "".concat(id, "-tab-").concat(key),
        className: "".concat(tabPrefix, "-btn"),
        "aria-controls": id && "".concat(id, "-panel-").concat(key),
        "aria-disabled": disabled,
        tabIndex: disabled ? null : active ? 0 : -1,
        onClick: function onClick2(e2) {
          e2.stopPropagation();
          onInternalClick(e2);
        },
        onKeyDown,
        onMouseDown,
        onMouseUp,
        onFocus,
        onBlur
      }, focus && /* @__PURE__ */ reactExports.createElement("div", {
        "aria-live": "polite",
        style: {
          width: 0,
          height: 0,
          position: "absolute",
          overflow: "hidden",
          opacity: 0
        }
      }, "Tab ".concat(currentPosition, " of ").concat(tabCount)), icon && /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(tabPrefix, "-icon")
      }, icon), label && labelNode), removable && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        role: "tab",
        "aria-label": removeAriaLabel || "remove",
        tabIndex: active ? 0 : -1,
        className: "".concat(tabPrefix, "-remove"),
        onClick: function onClick2(e2) {
          e2.stopPropagation();
          onRemoveTab(e2);
        }
      }, closeIcon || editable.removeIcon || ""));
      return renderWrapper ? renderWrapper(node2) : node2;
    };
    var getTabSize = function getTabSize2(tab, containerRect) {
      var offsetWidth = tab.offsetWidth, offsetHeight = tab.offsetHeight, offsetTop = tab.offsetTop, offsetLeft = tab.offsetLeft;
      var _tab$getBoundingClien = tab.getBoundingClientRect(), width = _tab$getBoundingClien.width, height = _tab$getBoundingClien.height, left = _tab$getBoundingClien.left, top = _tab$getBoundingClien.top;
      if (Math.abs(width - offsetWidth) < 1) {
        return [width, height, left - containerRect.left, top - containerRect.top];
      }
      return [offsetWidth, offsetHeight, offsetLeft, offsetTop];
    };
    var getSize = function getSize2(refObj) {
      var _ref = refObj.current || {}, _ref$offsetWidth = _ref.offsetWidth, offsetWidth = _ref$offsetWidth === void 0 ? 0 : _ref$offsetWidth, _ref$offsetHeight = _ref.offsetHeight, offsetHeight = _ref$offsetHeight === void 0 ? 0 : _ref$offsetHeight;
      if (refObj.current) {
        var _refObj$current$getBo = refObj.current.getBoundingClientRect(), width = _refObj$current$getBo.width, height = _refObj$current$getBo.height;
        if (Math.abs(width - offsetWidth) < 1) {
          return [width, height];
        }
      }
      return [offsetWidth, offsetHeight];
    };
    var getUnitValue = function getUnitValue2(size, tabPositionTopOrBottom) {
      return size[tabPositionTopOrBottom ? 0 : 1];
    };
    var TabNavList = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var className = props.className, style2 = props.style, id = props.id, animated = props.animated, activeKey = props.activeKey, rtl = props.rtl, extra = props.extra, editable = props.editable, locale2 = props.locale, tabPosition = props.tabPosition, tabBarGutter = props.tabBarGutter, children = props.children, onTabClick = props.onTabClick, onTabScroll = props.onTabScroll, indicator = props.indicator;
      var _React$useContext = reactExports.useContext(TabContext), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
      var containerRef = reactExports.useRef(null);
      var extraLeftRef = reactExports.useRef(null);
      var extraRightRef = reactExports.useRef(null);
      var tabsWrapperRef = reactExports.useRef(null);
      var tabListRef = reactExports.useRef(null);
      var operationsRef = reactExports.useRef(null);
      var innerAddButtonRef = reactExports.useRef(null);
      var tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom";
      var _useSyncState = useSyncState(0, function(next2, prev2) {
        if (tabPositionTopOrBottom && onTabScroll) {
          onTabScroll({
            direction: next2 > prev2 ? "left" : "right"
          });
        }
      }), _useSyncState2 = _slicedToArray(_useSyncState, 2), transformLeft = _useSyncState2[0], setTransformLeft = _useSyncState2[1];
      var _useSyncState3 = useSyncState(0, function(next2, prev2) {
        if (!tabPositionTopOrBottom && onTabScroll) {
          onTabScroll({
            direction: next2 > prev2 ? "top" : "bottom"
          });
        }
      }), _useSyncState4 = _slicedToArray(_useSyncState3, 2), transformTop = _useSyncState4[0], setTransformTop = _useSyncState4[1];
      var _useState = reactExports.useState([0, 0]), _useState2 = _slicedToArray(_useState, 2), containerExcludeExtraSize = _useState2[0], setContainerExcludeExtraSize = _useState2[1];
      var _useState3 = reactExports.useState([0, 0]), _useState4 = _slicedToArray(_useState3, 2), tabContentSize = _useState4[0], setTabContentSize = _useState4[1];
      var _useState5 = reactExports.useState([0, 0]), _useState6 = _slicedToArray(_useState5, 2), addSize = _useState6[0], setAddSize = _useState6[1];
      var _useState7 = reactExports.useState([0, 0]), _useState8 = _slicedToArray(_useState7, 2), operationSize = _useState8[0], setOperationSize = _useState8[1];
      var _useUpdateState = useUpdateState(/* @__PURE__ */ new Map()), _useUpdateState2 = _slicedToArray(_useUpdateState, 2), tabSizes = _useUpdateState2[0], setTabSizes = _useUpdateState2[1];
      var tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);
      var containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
      var tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
      var addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
      var operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
      var needScroll = Math.floor(containerExcludeExtraSizeValue) < Math.floor(tabContentSizeValue + addSizeValue);
      var visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;
      var operationsHiddenClassName = "".concat(prefixCls, "-nav-operations-hidden");
      var transformMin = 0;
      var transformMax = 0;
      if (!tabPositionTopOrBottom) {
        transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
        transformMax = 0;
      } else if (rtl) {
        transformMin = 0;
        transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
      } else {
        transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
        transformMax = 0;
      }
      function alignInRange(value) {
        if (value < transformMin) {
          return transformMin;
        }
        if (value > transformMax) {
          return transformMax;
        }
        return value;
      }
      var touchMovingRef = reactExports.useRef(null);
      var _useState9 = reactExports.useState(), _useState10 = _slicedToArray(_useState9, 2), lockAnimation = _useState10[0], setLockAnimation = _useState10[1];
      function doLockAnimation() {
        setLockAnimation(Date.now());
      }
      function clearTouchMoving() {
        if (touchMovingRef.current) {
          clearTimeout(touchMovingRef.current);
        }
      }
      useTouchMove(tabsWrapperRef, function(offsetX, offsetY) {
        function doMove(setState, offset2) {
          setState(function(value) {
            var newValue = alignInRange(value + offset2);
            return newValue;
          });
        }
        if (!needScroll) {
          return false;
        }
        if (tabPositionTopOrBottom) {
          doMove(setTransformLeft, offsetX);
        } else {
          doMove(setTransformTop, offsetY);
        }
        clearTouchMoving();
        doLockAnimation();
        return true;
      });
      reactExports.useEffect(function() {
        clearTouchMoving();
        if (lockAnimation) {
          touchMovingRef.current = setTimeout(function() {
            setLockAnimation(0);
          }, 100);
        }
        return clearTouchMoving;
      }, [lockAnimation]);
      var _useVisibleRange = useVisibleRange(
        tabOffsets,
        // Container
        visibleTabContentValue,
        // Transform
        tabPositionTopOrBottom ? transformLeft : transformTop,
        // Tabs
        tabContentSizeValue,
        // Add
        addSizeValue,
        // Operation
        operationSizeValue,
        _objectSpread2$3(_objectSpread2$3({}, props), {}, {
          tabs
        })
      ), _useVisibleRange2 = _slicedToArray(_useVisibleRange, 2), visibleStart = _useVisibleRange2[0], visibleEnd = _useVisibleRange2[1];
      var scrollToTab = useEvent(function() {
        var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : activeKey;
        var tabOffset = tabOffsets.get(key) || {
          width: 0,
          height: 0,
          left: 0,
          right: 0,
          top: 0
        };
        if (tabPositionTopOrBottom) {
          var newTransform = transformLeft;
          if (rtl) {
            if (tabOffset.right < transformLeft) {
              newTransform = tabOffset.right;
            } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
              newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
            }
          } else if (tabOffset.left < -transformLeft) {
            newTransform = -tabOffset.left;
          } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
            newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
          }
          setTransformTop(0);
          setTransformLeft(alignInRange(newTransform));
        } else {
          var _newTransform = transformTop;
          if (tabOffset.top < -transformTop) {
            _newTransform = -tabOffset.top;
          } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {
            _newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
          }
          setTransformLeft(0);
          setTransformTop(alignInRange(_newTransform));
        }
      });
      var _useState11 = reactExports.useState(), _useState12 = _slicedToArray(_useState11, 2), focusKey = _useState12[0], setFocusKey = _useState12[1];
      var _useState13 = reactExports.useState(false), _useState14 = _slicedToArray(_useState13, 2), isMouse = _useState14[0], setIsMouse = _useState14[1];
      var enabledTabs = tabs.filter(function(tab) {
        return !tab.disabled;
      }).map(function(tab) {
        return tab.key;
      });
      var onOffset = function onOffset2(offset2) {
        var currentIndex = enabledTabs.indexOf(focusKey || activeKey);
        var len = enabledTabs.length;
        var nextIndex = (currentIndex + offset2 + len) % len;
        var newKey = enabledTabs[nextIndex];
        setFocusKey(newKey);
      };
      var handleKeyDown = function handleKeyDown2(e2) {
        var code = e2.code;
        var isRTL = rtl && tabPositionTopOrBottom;
        var firstEnabledTab = enabledTabs[0];
        var lastEnabledTab = enabledTabs[enabledTabs.length - 1];
        switch (code) {
          case "ArrowLeft": {
            if (tabPositionTopOrBottom) {
              onOffset(isRTL ? 1 : -1);
            }
            break;
          }
          case "ArrowRight": {
            if (tabPositionTopOrBottom) {
              onOffset(isRTL ? -1 : 1);
            }
            break;
          }
          case "ArrowUp": {
            e2.preventDefault();
            if (!tabPositionTopOrBottom) {
              onOffset(-1);
            }
            break;
          }
          case "ArrowDown": {
            e2.preventDefault();
            if (!tabPositionTopOrBottom) {
              onOffset(1);
            }
            break;
          }
          case "Home": {
            e2.preventDefault();
            setFocusKey(firstEnabledTab);
            break;
          }
          case "End": {
            e2.preventDefault();
            setFocusKey(lastEnabledTab);
            break;
          }
          case "Enter":
          case "Space": {
            e2.preventDefault();
            onTabClick(focusKey, e2);
            break;
          }
          case "Backspace":
          case "Delete": {
            var removeIndex = enabledTabs.indexOf(focusKey);
            var removeTab = tabs.find(function(tab) {
              return tab.key === focusKey;
            });
            var removable = getRemovable(removeTab === null || removeTab === void 0 ? void 0 : removeTab.closable, removeTab === null || removeTab === void 0 ? void 0 : removeTab.closeIcon, editable, removeTab === null || removeTab === void 0 ? void 0 : removeTab.disabled);
            if (removable) {
              e2.preventDefault();
              e2.stopPropagation();
              editable.onEdit("remove", {
                key: focusKey,
                event: e2
              });
              if (removeIndex === enabledTabs.length - 1) {
                onOffset(-1);
              } else {
                onOffset(1);
              }
            }
            break;
          }
        }
      };
      var tabNodeStyle = {};
      if (tabPositionTopOrBottom) {
        tabNodeStyle[rtl ? "marginRight" : "marginLeft"] = tabBarGutter;
      } else {
        tabNodeStyle.marginTop = tabBarGutter;
      }
      var tabNodes = tabs.map(function(tab, i2) {
        var key = tab.key;
        return /* @__PURE__ */ reactExports.createElement(TabNode, {
          id,
          prefixCls,
          key,
          tab,
          style: i2 === 0 ? void 0 : tabNodeStyle,
          closable: tab.closable,
          editable,
          active: key === activeKey,
          focus: key === focusKey,
          renderWrapper: children,
          removeAriaLabel: locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
          tabCount: enabledTabs.length,
          currentPosition: i2 + 1,
          onClick: function onClick(e2) {
            onTabClick(key, e2);
          },
          onKeyDown: handleKeyDown,
          onFocus: function onFocus() {
            if (!isMouse) {
              setFocusKey(key);
            }
            scrollToTab(key);
            doLockAnimation();
            if (!tabsWrapperRef.current) {
              return;
            }
            if (!rtl) {
              tabsWrapperRef.current.scrollLeft = 0;
            }
            tabsWrapperRef.current.scrollTop = 0;
          },
          onBlur: function onBlur() {
            setFocusKey(void 0);
          },
          onMouseDown: function onMouseDown() {
            setIsMouse(true);
          },
          onMouseUp: function onMouseUp() {
            setIsMouse(false);
          }
        });
      });
      var updateTabSizes = function updateTabSizes2() {
        return setTabSizes(function() {
          var _tabListRef$current;
          var newSizes = /* @__PURE__ */ new Map();
          var listRect = (_tabListRef$current = tabListRef.current) === null || _tabListRef$current === void 0 ? void 0 : _tabListRef$current.getBoundingClientRect();
          tabs.forEach(function(_ref2) {
            var _tabListRef$current2;
            var key = _ref2.key;
            var btnNode = (_tabListRef$current2 = tabListRef.current) === null || _tabListRef$current2 === void 0 ? void 0 : _tabListRef$current2.querySelector('[data-node-key="'.concat(genDataNodeKey(key), '"]'));
            if (btnNode) {
              var _getTabSize = getTabSize(btnNode, listRect), _getTabSize2 = _slicedToArray(_getTabSize, 4), width = _getTabSize2[0], height = _getTabSize2[1], left = _getTabSize2[2], top = _getTabSize2[3];
              newSizes.set(key, {
                width,
                height,
                left,
                top
              });
            }
          });
          return newSizes;
        });
      };
      reactExports.useEffect(function() {
        updateTabSizes();
      }, [tabs.map(function(tab) {
        return tab.key;
      }).join("_")]);
      var onListHolderResize = useUpdate(function() {
        var containerSize = getSize(containerRef);
        var extraLeftSize = getSize(extraLeftRef);
        var extraRightSize = getSize(extraRightRef);
        setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
        var newAddSize = getSize(innerAddButtonRef);
        setAddSize(newAddSize);
        var newOperationSize = getSize(operationsRef);
        setOperationSize(newOperationSize);
        var tabContentFullSize = getSize(tabListRef);
        setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);
        updateTabSizes();
      });
      var startHiddenTabs = tabs.slice(0, visibleStart);
      var endHiddenTabs = tabs.slice(visibleEnd + 1);
      var hiddenTabs = [].concat(_toConsumableArray(startHiddenTabs), _toConsumableArray(endHiddenTabs));
      var activeTabOffset = tabOffsets.get(activeKey);
      var _useIndicator = useIndicator({
        activeTabOffset,
        horizontal: tabPositionTopOrBottom,
        indicator,
        rtl
      }), indicatorStyle = _useIndicator.style;
      reactExports.useEffect(function() {
        scrollToTab();
      }, [activeKey, transformMin, transformMax, stringify(activeTabOffset), stringify(tabOffsets), tabPositionTopOrBottom]);
      reactExports.useEffect(function() {
        onListHolderResize();
      }, [rtl]);
      var hasDropdown = !!hiddenTabs.length;
      var wrapPrefix = "".concat(prefixCls, "-nav-wrap");
      var pingLeft;
      var pingRight;
      var pingTop;
      var pingBottom;
      if (tabPositionTopOrBottom) {
        if (rtl) {
          pingRight = transformLeft > 0;
          pingLeft = transformLeft !== transformMax;
        } else {
          pingLeft = transformLeft < 0;
          pingRight = transformLeft !== transformMin;
        }
      } else {
        pingTop = transformTop < 0;
        pingBottom = transformTop !== transformMin;
      }
      return /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onListHolderResize
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: useComposeRef(ref, containerRef),
        role: "tablist",
        "aria-orientation": tabPositionTopOrBottom ? "horizontal" : "vertical",
        className: classNames("".concat(prefixCls, "-nav"), className),
        style: style2,
        onKeyDown: function onKeyDown() {
          doLockAnimation();
        }
      }, /* @__PURE__ */ reactExports.createElement(ExtraContent, {
        ref: extraLeftRef,
        position: "left",
        extra,
        prefixCls
      }), /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onListHolderResize
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(wrapPrefix, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(wrapPrefix, "-ping-left"), pingLeft), "".concat(wrapPrefix, "-ping-right"), pingRight), "".concat(wrapPrefix, "-ping-top"), pingTop), "".concat(wrapPrefix, "-ping-bottom"), pingBottom)),
        ref: tabsWrapperRef
      }, /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onListHolderResize
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: tabListRef,
        className: "".concat(prefixCls, "-nav-list"),
        style: {
          transform: "translate(".concat(transformLeft, "px, ").concat(transformTop, "px)"),
          transition: lockAnimation ? "none" : void 0
        }
      }, tabNodes, /* @__PURE__ */ reactExports.createElement(AddButton, {
        ref: innerAddButtonRef,
        prefixCls,
        locale: locale2,
        editable,
        style: _objectSpread2$3(_objectSpread2$3({}, tabNodes.length === 0 ? void 0 : tabNodeStyle), {}, {
          visibility: hasDropdown ? "hidden" : null
        })
      }), /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-ink-bar"), _defineProperty({}, "".concat(prefixCls, "-ink-bar-animated"), animated.inkBar)),
        style: indicatorStyle
      }))))), /* @__PURE__ */ reactExports.createElement(OperationNode$1, _extends$2({}, props, {
        removeAriaLabel: locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
        ref: operationsRef,
        prefixCls,
        tabs: hiddenTabs,
        className: !hasDropdown && operationsHiddenClassName,
        tabMoving: !!lockAnimation
      })), /* @__PURE__ */ reactExports.createElement(ExtraContent, {
        ref: extraRightRef,
        position: "right",
        extra,
        prefixCls
      })));
    });
    var TabPane$1 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, className = props.className, style2 = props.style, id = props.id, active = props.active, tabKey = props.tabKey, children = props.children;
      return /* @__PURE__ */ reactExports.createElement("div", {
        id: id && "".concat(id, "-panel-").concat(tabKey),
        role: "tabpanel",
        tabIndex: active ? 0 : -1,
        "aria-labelledby": id && "".concat(id, "-tab-").concat(tabKey),
        "aria-hidden": !active,
        style: style2,
        className: classNames(prefixCls, active && "".concat(prefixCls, "-active"), className),
        ref
      }, children);
    });
    var _excluded$b = ["renderTabBar"], _excluded2$1 = ["label", "key"];
    var TabNavListWrapper = function TabNavListWrapper2(_ref) {
      var renderTabBar = _ref.renderTabBar, restProps = _objectWithoutProperties(_ref, _excluded$b);
      var _React$useContext = reactExports.useContext(TabContext), tabs = _React$useContext.tabs;
      if (renderTabBar) {
        var tabNavBarProps = _objectSpread2$3(_objectSpread2$3({}, restProps), {}, {
          // Legacy support. We do not use this actually
          panes: tabs.map(function(_ref2) {
            var label = _ref2.label, key = _ref2.key, restTabProps = _objectWithoutProperties(_ref2, _excluded2$1);
            return /* @__PURE__ */ reactExports.createElement(TabPane$1, _extends$2({
              tab: label,
              key,
              tabKey: key
            }, restTabProps));
          })
        });
        return renderTabBar(tabNavBarProps, TabNavList);
      }
      return /* @__PURE__ */ reactExports.createElement(TabNavList, restProps);
    };
    var _excluded$a = ["key", "forceRender", "style", "className", "destroyInactiveTabPane"];
    var TabPanelList = function TabPanelList2(props) {
      var id = props.id, activeKey = props.activeKey, animated = props.animated, tabPosition = props.tabPosition, destroyInactiveTabPane = props.destroyInactiveTabPane;
      var _React$useContext = reactExports.useContext(TabContext), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
      var tabPaneAnimated = animated.tabPane;
      var tabPanePrefixCls = "".concat(prefixCls, "-tabpane");
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-content-holder"))
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-content"), "".concat(prefixCls, "-content-").concat(tabPosition), _defineProperty({}, "".concat(prefixCls, "-content-animated"), tabPaneAnimated))
      }, tabs.map(function(item) {
        var key = item.key, forceRender = item.forceRender, paneStyle = item.style, paneClassName = item.className, itemDestroyInactiveTabPane = item.destroyInactiveTabPane, restTabProps = _objectWithoutProperties(item, _excluded$a);
        var active = key === activeKey;
        return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$2({
          key,
          visible: active,
          forceRender,
          removeOnLeave: !!(destroyInactiveTabPane || itemDestroyInactiveTabPane),
          leavedClassName: "".concat(tabPanePrefixCls, "-hidden")
        }, animated.tabPaneMotion), function(_ref, ref) {
          var motionStyle = _ref.style, motionClassName = _ref.className;
          return /* @__PURE__ */ reactExports.createElement(TabPane$1, _extends$2({}, restTabProps, {
            prefixCls: tabPanePrefixCls,
            id,
            tabKey: key,
            animated: tabPaneAnimated,
            active,
            style: _objectSpread2$3(_objectSpread2$3({}, paneStyle), motionStyle),
            className: classNames(paneClassName, motionClassName),
            ref
          }));
        });
      })));
    };
    function useAnimateConfig$1() {
      var animated = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        inkBar: true,
        tabPane: false
      };
      var mergedAnimated;
      if (animated === false) {
        mergedAnimated = {
          inkBar: false,
          tabPane: false
        };
      } else if (animated === true) {
        mergedAnimated = {
          inkBar: true,
          tabPane: false
        };
      } else {
        mergedAnimated = _objectSpread2$3({
          inkBar: true
        }, _typeof$1(animated) === "object" ? animated : {});
      }
      if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0) {
        mergedAnimated.tabPane = true;
      }
      if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
        mergedAnimated.tabPane = false;
      }
      return mergedAnimated;
    }
    var _excluded$9 = ["id", "prefixCls", "className", "items", "direction", "activeKey", "defaultActiveKey", "editable", "animated", "tabPosition", "tabBarGutter", "tabBarStyle", "tabBarExtraContent", "locale", "more", "destroyInactiveTabPane", "renderTabBar", "onChange", "onTabClick", "onTabScroll", "getPopupContainer", "popupClassName", "indicator"];
    var uuid = 0;
    var Tabs$1 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var id = props.id, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tabs" : _props$prefixCls, className = props.className, items = props.items, direction = props.direction, activeKey = props.activeKey, defaultActiveKey = props.defaultActiveKey, editable = props.editable, animated = props.animated, _props$tabPosition = props.tabPosition, tabPosition = _props$tabPosition === void 0 ? "top" : _props$tabPosition, tabBarGutter = props.tabBarGutter, tabBarStyle = props.tabBarStyle, tabBarExtraContent = props.tabBarExtraContent, locale2 = props.locale, more = props.more, destroyInactiveTabPane = props.destroyInactiveTabPane, renderTabBar = props.renderTabBar, onChange = props.onChange, onTabClick = props.onTabClick, onTabScroll = props.onTabScroll, getPopupContainer = props.getPopupContainer, popupClassName = props.popupClassName, indicator = props.indicator, restProps = _objectWithoutProperties(props, _excluded$9);
      var tabs = reactExports.useMemo(function() {
        return (items || []).filter(function(item) {
          return item && _typeof$1(item) === "object" && "key" in item;
        });
      }, [items]);
      var rtl = direction === "rtl";
      var mergedAnimated = useAnimateConfig$1(animated);
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
      reactExports.useEffect(function() {
        setMobile(isMobile());
      }, []);
      var _useMergedState = useMergedState(function() {
        var _tabs$;
        return (_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key;
      }, {
        value: activeKey,
        defaultValue: defaultActiveKey
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedActiveKey = _useMergedState2[0], setMergedActiveKey = _useMergedState2[1];
      var _useState3 = reactExports.useState(function() {
        return tabs.findIndex(function(tab) {
          return tab.key === mergedActiveKey;
        });
      }), _useState4 = _slicedToArray(_useState3, 2), activeIndex = _useState4[0], setActiveIndex = _useState4[1];
      reactExports.useEffect(function() {
        var newActiveIndex = tabs.findIndex(function(tab) {
          return tab.key === mergedActiveKey;
        });
        if (newActiveIndex === -1) {
          var _tabs$newActiveIndex;
          newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
          setMergedActiveKey((_tabs$newActiveIndex = tabs[newActiveIndex]) === null || _tabs$newActiveIndex === void 0 ? void 0 : _tabs$newActiveIndex.key);
        }
        setActiveIndex(newActiveIndex);
      }, [tabs.map(function(tab) {
        return tab.key;
      }).join("_"), mergedActiveKey, activeIndex]);
      var _useMergedState3 = useMergedState(null, {
        value: id
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedId = _useMergedState4[0], setMergedId = _useMergedState4[1];
      reactExports.useEffect(function() {
        if (!id) {
          setMergedId("rc-tabs-".concat(uuid));
          uuid += 1;
        }
      }, []);
      function onInternalTabClick(key, e2) {
        onTabClick === null || onTabClick === void 0 || onTabClick(key, e2);
        var isActiveChanged = key !== mergedActiveKey;
        setMergedActiveKey(key);
        if (isActiveChanged) {
          onChange === null || onChange === void 0 || onChange(key);
        }
      }
      var sharedProps = {
        id: mergedId,
        activeKey: mergedActiveKey,
        animated: mergedAnimated,
        tabPosition,
        rtl,
        mobile
      };
      var tabNavBarProps = _objectSpread2$3(_objectSpread2$3({}, sharedProps), {}, {
        editable,
        locale: locale2,
        more,
        tabBarGutter,
        onTabClick: onInternalTabClick,
        onTabScroll,
        extra: tabBarExtraContent,
        style: tabBarStyle,
        panes: null,
        getPopupContainer,
        popupClassName,
        indicator
      });
      return /* @__PURE__ */ reactExports.createElement(TabContext.Provider, {
        value: {
          tabs,
          prefixCls
        }
      }, /* @__PURE__ */ reactExports.createElement("div", _extends$2({
        ref,
        id,
        className: classNames(prefixCls, "".concat(prefixCls, "-").concat(tabPosition), _defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-mobile"), mobile), "".concat(prefixCls, "-editable"), editable), "".concat(prefixCls, "-rtl"), rtl), className)
      }, restProps), /* @__PURE__ */ reactExports.createElement(TabNavListWrapper, _extends$2({}, tabNavBarProps, {
        renderTabBar
      })), /* @__PURE__ */ reactExports.createElement(TabPanelList, _extends$2({
        destroyInactiveTabPane
      }, sharedProps, {
        animated: mergedAnimated
      }))));
    });
    const motion = {
      motionAppear: false,
      motionEnter: true,
      motionLeave: true
    };
    function useAnimateConfig(prefixCls) {
      let animated = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        inkBar: true,
        tabPane: false
      };
      let mergedAnimated;
      if (animated === false) {
        mergedAnimated = {
          inkBar: false,
          tabPane: false
        };
      } else if (animated === true) {
        mergedAnimated = {
          inkBar: true,
          tabPane: true
        };
      } else {
        mergedAnimated = Object.assign({
          inkBar: true
        }, typeof animated === "object" ? animated : {});
      }
      if (mergedAnimated.tabPane) {
        mergedAnimated.tabPaneMotion = Object.assign(Object.assign({}, motion), {
          motionName: getTransitionName(prefixCls, "switch")
        });
      }
      return mergedAnimated;
    }
    var __rest$D = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function filter(items) {
      return items.filter((item) => item);
    }
    function useLegacyItems(items, children) {
      if (items) {
        return items;
      }
      const childrenItems = toArray$5(children).map((node2) => {
        if (/* @__PURE__ */ reactExports.isValidElement(node2)) {
          const {
            key,
            props
          } = node2;
          const _a = props || {}, {
            tab
          } = _a, restProps = __rest$D(_a, ["tab"]);
          const item = Object.assign(Object.assign({
            key: String(key)
          }, restProps), {
            label: tab
          });
          return item;
        }
        return null;
      });
      return filter(childrenItems);
    }
    const genMotionStyle = (token2) => {
      const {
        componentCls,
        motionDurationSlow
      } = token2;
      return [
        {
          [componentCls]: {
            [`${componentCls}-switch`]: {
              "&-appear, &-enter": {
                transition: "none",
                "&-start": {
                  opacity: 0
                },
                "&-active": {
                  opacity: 1,
                  transition: `opacity ${motionDurationSlow}`
                }
              },
              "&-leave": {
                position: "absolute",
                transition: "none",
                inset: 0,
                "&-start": {
                  opacity: 1
                },
                "&-active": {
                  opacity: 0,
                  transition: `opacity ${motionDurationSlow}`
                }
              }
            }
          }
        },
        // Follow code may reuse in other components
        [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down")]
      ];
    };
    const genCardStyle = (token2) => {
      const {
        componentCls,
        tabsCardPadding,
        cardBg,
        cardGutter,
        colorBorderSecondary,
        itemSelectedColor
      } = token2;
      return {
        [`${componentCls}-card`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              margin: 0,
              padding: tabsCardPadding,
              background: cardBg,
              border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
              transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
            },
            [`${componentCls}-tab-active`]: {
              color: itemSelectedColor,
              background: token2.colorBgContainer
            },
            [`${componentCls}-tab-focus`]: Object.assign({}, genFocusOutline(token2, -3)),
            [`${componentCls}-ink-bar`]: {
              visibility: "hidden"
            },
            [`& ${componentCls}-tab${componentCls}-tab-focus ${componentCls}-tab-btn`]: {
              outline: "none"
            }
          },
          // ========================== Top & Bottom ==========================
          [`&${componentCls}-top, &${componentCls}-bottom`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab + ${componentCls}-tab`]: {
                marginLeft: {
                  _skip_check_: true,
                  value: unit$1(cardGutter)
                }
              }
            }
          },
          [`&${componentCls}-top`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                borderRadius: `${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0 0`
              },
              [`${componentCls}-tab-active`]: {
                borderBottomColor: token2.colorBgContainer
              }
            }
          },
          [`&${componentCls}-bottom`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                borderRadius: `0 0 ${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)}`
              },
              [`${componentCls}-tab-active`]: {
                borderTopColor: token2.colorBgContainer
              }
            }
          },
          // ========================== Left & Right ==========================
          [`&${componentCls}-left, &${componentCls}-right`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab + ${componentCls}-tab`]: {
                marginTop: unit$1(cardGutter)
              }
            }
          },
          [`&${componentCls}-left`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                borderRadius: {
                  _skip_check_: true,
                  value: `${unit$1(token2.borderRadiusLG)} 0 0 ${unit$1(token2.borderRadiusLG)}`
                }
              },
              [`${componentCls}-tab-active`]: {
                borderRightColor: {
                  _skip_check_: true,
                  value: token2.colorBgContainer
                }
              }
            }
          },
          [`&${componentCls}-right`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                borderRadius: {
                  _skip_check_: true,
                  value: `0 ${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0`
                }
              },
              [`${componentCls}-tab-active`]: {
                borderLeftColor: {
                  _skip_check_: true,
                  value: token2.colorBgContainer
                }
              }
            }
          }
        }
      };
    };
    const genDropdownStyle = (token2) => {
      const {
        componentCls,
        itemHoverColor,
        dropdownEdgeChildVerticalPadding
      } = token2;
      return {
        [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "absolute",
          top: -9999,
          left: {
            _skip_check_: true,
            value: -9999
          },
          zIndex: token2.zIndexPopup,
          display: "block",
          "&-hidden": {
            display: "none"
          },
          [`${componentCls}-dropdown-menu`]: {
            maxHeight: token2.tabsDropdownHeight,
            margin: 0,
            padding: `${unit$1(dropdownEdgeChildVerticalPadding)} 0`,
            overflowX: "hidden",
            overflowY: "auto",
            textAlign: {
              _skip_check_: true,
              value: "left"
            },
            listStyleType: "none",
            backgroundColor: token2.colorBgContainer,
            backgroundClip: "padding-box",
            borderRadius: token2.borderRadiusLG,
            outline: "none",
            boxShadow: token2.boxShadowSecondary,
            "&-item": Object.assign(Object.assign({}, textEllipsis), {
              display: "flex",
              alignItems: "center",
              minWidth: token2.tabsDropdownWidth,
              margin: 0,
              padding: `${unit$1(token2.paddingXXS)} ${unit$1(token2.paddingSM)}`,
              color: token2.colorText,
              fontWeight: "normal",
              fontSize: token2.fontSize,
              lineHeight: token2.lineHeight,
              cursor: "pointer",
              transition: `all ${token2.motionDurationSlow}`,
              "> span": {
                flex: 1,
                whiteSpace: "nowrap"
              },
              "&-remove": {
                flex: "none",
                marginLeft: {
                  _skip_check_: true,
                  value: token2.marginSM
                },
                color: token2.colorTextDescription,
                fontSize: token2.fontSizeSM,
                background: "transparent",
                border: 0,
                cursor: "pointer",
                "&:hover": {
                  color: itemHoverColor
                }
              },
              "&:hover": {
                background: token2.controlItemBgHover
              },
              "&-disabled": {
                "&, &:hover": {
                  color: token2.colorTextDisabled,
                  background: "transparent",
                  cursor: "not-allowed"
                }
              }
            })
          }
        })
      };
    };
    const genPositionStyle = (token2) => {
      const {
        componentCls,
        margin,
        colorBorderSecondary,
        horizontalMargin,
        verticalItemPadding,
        verticalItemMargin,
        calc
      } = token2;
      return {
        // ========================== Top & Bottom ==========================
        [`${componentCls}-top, ${componentCls}-bottom`]: {
          flexDirection: "column",
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            margin: horizontalMargin,
            "&::before": {
              position: "absolute",
              right: {
                _skip_check_: true,
                value: 0
              },
              left: {
                _skip_check_: true,
                value: 0
              },
              borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
              content: "''"
            },
            [`${componentCls}-ink-bar`]: {
              height: token2.lineWidthBold,
              "&-animated": {
                transition: `width ${token2.motionDurationSlow}, left ${token2.motionDurationSlow},
            right ${token2.motionDurationSlow}`
              }
            },
            [`${componentCls}-nav-wrap`]: {
              "&::before, &::after": {
                top: 0,
                bottom: 0,
                width: token2.controlHeight
              },
              "&::before": {
                left: {
                  _skip_check_: true,
                  value: 0
                },
                boxShadow: token2.boxShadowTabsOverflowLeft
              },
              "&::after": {
                right: {
                  _skip_check_: true,
                  value: 0
                },
                boxShadow: token2.boxShadowTabsOverflowRight
              },
              [`&${componentCls}-nav-wrap-ping-left::before`]: {
                opacity: 1
              },
              [`&${componentCls}-nav-wrap-ping-right::after`]: {
                opacity: 1
              }
            }
          }
        },
        [`${componentCls}-top`]: {
          [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
            "&::before": {
              bottom: 0
            },
            [`${componentCls}-ink-bar`]: {
              bottom: 0
            }
          }
        },
        [`${componentCls}-bottom`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            order: 1,
            marginTop: margin,
            marginBottom: 0,
            "&::before": {
              top: 0
            },
            [`${componentCls}-ink-bar`]: {
              top: 0
            }
          },
          [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
            order: 0
          }
        },
        // ========================== Left & Right ==========================
        [`${componentCls}-left, ${componentCls}-right`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            flexDirection: "column",
            minWidth: calc(token2.controlHeight).mul(1.25).equal(),
            // >>>>>>>>>>> Tab
            [`${componentCls}-tab`]: {
              padding: verticalItemPadding,
              textAlign: "center"
            },
            [`${componentCls}-tab + ${componentCls}-tab`]: {
              margin: verticalItemMargin
            },
            // >>>>>>>>>>> Nav
            [`${componentCls}-nav-wrap`]: {
              flexDirection: "column",
              "&::before, &::after": {
                right: {
                  _skip_check_: true,
                  value: 0
                },
                left: {
                  _skip_check_: true,
                  value: 0
                },
                height: token2.controlHeight
              },
              "&::before": {
                top: 0,
                boxShadow: token2.boxShadowTabsOverflowTop
              },
              "&::after": {
                bottom: 0,
                boxShadow: token2.boxShadowTabsOverflowBottom
              },
              [`&${componentCls}-nav-wrap-ping-top::before`]: {
                opacity: 1
              },
              [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
                opacity: 1
              }
            },
            // >>>>>>>>>>> Ink Bar
            [`${componentCls}-ink-bar`]: {
              width: token2.lineWidthBold,
              "&-animated": {
                transition: `height ${token2.motionDurationSlow}, top ${token2.motionDurationSlow}`
              }
            },
            [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
              flex: "1 0 auto",
              // fix safari scroll problem
              flexDirection: "column"
            }
          }
        },
        [`${componentCls}-left`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-ink-bar`]: {
              right: {
                _skip_check_: true,
                value: 0
              }
            }
          },
          [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
            marginLeft: {
              _skip_check_: true,
              value: unit$1(calc(token2.lineWidth).mul(-1).equal())
            },
            borderLeft: {
              _skip_check_: true,
              value: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
            },
            [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
              paddingLeft: {
                _skip_check_: true,
                value: token2.paddingLG
              }
            }
          }
        },
        [`${componentCls}-right`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            order: 1,
            [`${componentCls}-ink-bar`]: {
              left: {
                _skip_check_: true,
                value: 0
              }
            }
          },
          [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
            order: 0,
            marginRight: {
              _skip_check_: true,
              value: calc(token2.lineWidth).mul(-1).equal()
            },
            borderRight: {
              _skip_check_: true,
              value: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
            },
            [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
              paddingRight: {
                _skip_check_: true,
                value: token2.paddingLG
              }
            }
          }
        }
      };
    };
    const genSizeStyle = (token2) => {
      const {
        componentCls,
        cardPaddingSM,
        cardPaddingLG,
        horizontalItemPaddingSM,
        horizontalItemPaddingLG
      } = token2;
      return {
        [componentCls]: {
          "&-small": {
            [`> ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                padding: horizontalItemPaddingSM,
                fontSize: token2.titleFontSizeSM
              }
            }
          },
          "&-large": {
            [`> ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                padding: horizontalItemPaddingLG,
                fontSize: token2.titleFontSizeLG
              }
            }
          }
        },
        [`${componentCls}-card`]: {
          [`&${componentCls}-small`]: {
            [`> ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                padding: cardPaddingSM
              }
            },
            [`&${componentCls}-bottom`]: {
              [`> ${componentCls}-nav ${componentCls}-tab`]: {
                borderRadius: `0 0 ${unit$1(token2.borderRadius)} ${unit$1(token2.borderRadius)}`
              }
            },
            [`&${componentCls}-top`]: {
              [`> ${componentCls}-nav ${componentCls}-tab`]: {
                borderRadius: `${unit$1(token2.borderRadius)} ${unit$1(token2.borderRadius)} 0 0`
              }
            },
            [`&${componentCls}-right`]: {
              [`> ${componentCls}-nav ${componentCls}-tab`]: {
                borderRadius: {
                  _skip_check_: true,
                  value: `0 ${unit$1(token2.borderRadius)} ${unit$1(token2.borderRadius)} 0`
                }
              }
            },
            [`&${componentCls}-left`]: {
              [`> ${componentCls}-nav ${componentCls}-tab`]: {
                borderRadius: {
                  _skip_check_: true,
                  value: `${unit$1(token2.borderRadius)} 0 0 ${unit$1(token2.borderRadius)}`
                }
              }
            }
          },
          [`&${componentCls}-large`]: {
            [`> ${componentCls}-nav`]: {
              [`${componentCls}-tab`]: {
                padding: cardPaddingLG
              }
            }
          }
        }
      };
    };
    const genTabStyle = (token2) => {
      const {
        componentCls,
        itemActiveColor,
        itemHoverColor,
        iconCls,
        tabsHorizontalItemMargin,
        horizontalItemPadding,
        itemSelectedColor,
        itemColor
      } = token2;
      const tabCls = `${componentCls}-tab`;
      return {
        [tabCls]: {
          position: "relative",
          WebkitTouchCallout: "none",
          WebkitTapHighlightColor: "transparent",
          display: "inline-flex",
          alignItems: "center",
          padding: horizontalItemPadding,
          fontSize: token2.titleFontSize,
          background: "transparent",
          border: 0,
          outline: "none",
          cursor: "pointer",
          color: itemColor,
          "&-btn, &-remove": {
            "&:focus:not(:focus-visible), &:active": {
              color: itemActiveColor
            }
          },
          "&-btn": {
            outline: "none",
            transition: `all ${token2.motionDurationSlow}`,
            [`${tabCls}-icon:not(:last-child)`]: {
              marginInlineEnd: token2.marginSM
            }
          },
          "&-remove": Object.assign({
            flex: "none",
            marginRight: {
              _skip_check_: true,
              value: token2.calc(token2.marginXXS).mul(-1).equal()
            },
            marginLeft: {
              _skip_check_: true,
              value: token2.marginXS
            },
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            background: "transparent",
            border: "none",
            outline: "none",
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`,
            "&:hover": {
              color: token2.colorTextHeading
            }
          }, genFocusStyle(token2)),
          "&:hover": {
            color: itemHoverColor
          },
          [`&${tabCls}-active ${tabCls}-btn`]: {
            color: itemSelectedColor,
            textShadow: token2.tabsActiveTextShadow
          },
          [`&${tabCls}-focus ${tabCls}-btn`]: Object.assign({}, genFocusOutline(token2)),
          [`&${tabCls}-disabled`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed"
          },
          [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
            "&:focus, &:active": {
              color: token2.colorTextDisabled
            }
          },
          [`& ${tabCls}-remove ${iconCls}`]: {
            margin: 0
          },
          [`${iconCls}:not(:last-child)`]: {
            marginRight: {
              _skip_check_: true,
              value: token2.marginSM
            }
          }
        },
        [`${tabCls} + ${tabCls}`]: {
          margin: {
            _skip_check_: true,
            value: tabsHorizontalItemMargin
          }
        }
      };
    };
    const genRtlStyle$1 = (token2) => {
      const {
        componentCls,
        tabsHorizontalItemMarginRTL,
        iconCls,
        cardGutter,
        calc
      } = token2;
      const rtlCls = `${componentCls}-rtl`;
      return {
        [rtlCls]: {
          direction: "rtl",
          [`${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              margin: {
                _skip_check_: true,
                value: tabsHorizontalItemMarginRTL
              },
              [`${componentCls}-tab:last-of-type`]: {
                marginLeft: {
                  _skip_check_: true,
                  value: 0
                }
              },
              [iconCls]: {
                marginRight: {
                  _skip_check_: true,
                  value: 0
                },
                marginLeft: {
                  _skip_check_: true,
                  value: unit$1(token2.marginSM)
                }
              },
              [`${componentCls}-tab-remove`]: {
                marginRight: {
                  _skip_check_: true,
                  value: unit$1(token2.marginXS)
                },
                marginLeft: {
                  _skip_check_: true,
                  value: unit$1(calc(token2.marginXXS).mul(-1).equal())
                },
                [iconCls]: {
                  margin: 0
                }
              }
            }
          },
          [`&${componentCls}-left`]: {
            [`> ${componentCls}-nav`]: {
              order: 1
            },
            [`> ${componentCls}-content-holder`]: {
              order: 0
            }
          },
          [`&${componentCls}-right`]: {
            [`> ${componentCls}-nav`]: {
              order: 0
            },
            [`> ${componentCls}-content-holder`]: {
              order: 1
            }
          },
          // ====================== Card ======================
          [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
            [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
              [`${componentCls}-tab + ${componentCls}-tab`]: {
                marginRight: {
                  _skip_check_: true,
                  value: cardGutter
                },
                marginLeft: {
                  _skip_check_: true,
                  value: 0
                }
              }
            }
          }
        },
        [`${componentCls}-dropdown-rtl`]: {
          direction: "rtl"
        },
        [`${componentCls}-menu-item`]: {
          [`${componentCls}-dropdown-rtl`]: {
            textAlign: {
              _skip_check_: true,
              value: "right"
            }
          }
        }
      };
    };
    const genTabsStyle = (token2) => {
      const {
        componentCls,
        tabsCardPadding,
        cardHeight,
        cardGutter,
        itemHoverColor,
        itemActiveColor,
        colorBorderSecondary
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
          display: "flex",
          // ========================== Navigation ==========================
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            position: "relative",
            display: "flex",
            flex: "none",
            alignItems: "center",
            [`${componentCls}-nav-wrap`]: {
              position: "relative",
              display: "flex",
              flex: "auto",
              alignSelf: "stretch",
              overflow: "hidden",
              whiteSpace: "nowrap",
              transform: "translate(0)",
              // Fix chrome render bug
              // >>>>> Ping shadow
              "&::before, &::after": {
                position: "absolute",
                zIndex: 1,
                opacity: 0,
                transition: `opacity ${token2.motionDurationSlow}`,
                content: "''",
                pointerEvents: "none"
              }
            },
            [`${componentCls}-nav-list`]: {
              position: "relative",
              display: "flex",
              transition: `opacity ${token2.motionDurationSlow}`
            },
            // >>>>>>>> Operations
            [`${componentCls}-nav-operations`]: {
              display: "flex",
              alignSelf: "stretch"
            },
            [`${componentCls}-nav-operations-hidden`]: {
              position: "absolute",
              visibility: "hidden",
              pointerEvents: "none"
            },
            [`${componentCls}-nav-more`]: {
              position: "relative",
              padding: tabsCardPadding,
              background: "transparent",
              border: 0,
              color: token2.colorText,
              "&::after": {
                position: "absolute",
                right: {
                  _skip_check_: true,
                  value: 0
                },
                bottom: 0,
                left: {
                  _skip_check_: true,
                  value: 0
                },
                height: token2.calc(token2.controlHeightLG).div(8).equal(),
                transform: "translateY(100%)",
                content: "''"
              }
            },
            [`${componentCls}-nav-add`]: Object.assign({
              minWidth: cardHeight,
              marginLeft: {
                _skip_check_: true,
                value: cardGutter
              },
              padding: unit$1(token2.paddingXS),
              background: "transparent",
              border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
              borderRadius: `${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0 0`,
              outline: "none",
              cursor: "pointer",
              color: token2.colorText,
              transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
              "&:hover": {
                color: itemHoverColor
              },
              "&:active, &:focus:not(:focus-visible)": {
                color: itemActiveColor
              }
            }, genFocusStyle(token2, -3))
          },
          [`${componentCls}-extra-content`]: {
            flex: "none"
          },
          // ============================ InkBar ============================
          [`${componentCls}-ink-bar`]: {
            position: "absolute",
            background: token2.inkBarColor,
            pointerEvents: "none"
          }
        }), genTabStyle(token2)), {
          // =========================== TabPanes ===========================
          [`${componentCls}-content`]: {
            position: "relative",
            width: "100%"
          },
          [`${componentCls}-content-holder`]: {
            flex: "auto",
            minWidth: 0,
            minHeight: 0
          },
          [`${componentCls}-tabpane`]: Object.assign(Object.assign({}, genFocusStyle(token2)), {
            "&-hidden": {
              display: "none"
            }
          })
        }),
        [`${componentCls}-centered`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-nav-wrap`]: {
              [`&:not([class*='${componentCls}-nav-wrap-ping']) > ${componentCls}-nav-list`]: {
                margin: "auto"
              }
            }
          }
        }
      };
    };
    const prepareComponentToken$c = (token2) => {
      const cardHeight = token2.controlHeightLG;
      return {
        zIndexPopup: token2.zIndexPopupBase + 50,
        cardBg: token2.colorFillAlter,
        cardHeight,
        // Initialize with empty string, because cardPadding will be calculated with cardHeight by default.
        cardPadding: `${(cardHeight - Math.round(token2.fontSize * token2.lineHeight)) / 2 - token2.lineWidth}px ${token2.padding}px`,
        cardPaddingSM: `${token2.paddingXXS * 1.5}px ${token2.padding}px`,
        cardPaddingLG: `${token2.paddingXS}px ${token2.padding}px ${token2.paddingXXS * 1.5}px`,
        titleFontSize: token2.fontSize,
        titleFontSizeLG: token2.fontSizeLG,
        titleFontSizeSM: token2.fontSize,
        inkBarColor: token2.colorPrimary,
        horizontalMargin: `0 0 ${token2.margin}px 0`,
        horizontalItemGutter: 32,
        // Fixed Value
        // Initialize with empty string, because horizontalItemMargin will be calculated with horizontalItemGutter by default.
        horizontalItemMargin: ``,
        horizontalItemMarginRTL: ``,
        horizontalItemPadding: `${token2.paddingSM}px 0`,
        horizontalItemPaddingSM: `${token2.paddingXS}px 0`,
        horizontalItemPaddingLG: `${token2.padding}px 0`,
        verticalItemPadding: `${token2.paddingXS}px ${token2.paddingLG}px`,
        verticalItemMargin: `${token2.margin}px 0 0 0`,
        itemColor: token2.colorText,
        itemSelectedColor: token2.colorPrimary,
        itemHoverColor: token2.colorPrimaryHover,
        itemActiveColor: token2.colorPrimaryActive,
        cardGutter: token2.marginXXS / 2
      };
    };
    const useStyle$f = genStyleHooks("Tabs", (token2) => {
      const tabsToken = merge(token2, {
        // `cardPadding` is empty by default, so we could calculate with dynamic `cardHeight`
        tabsCardPadding: token2.cardPadding,
        dropdownEdgeChildVerticalPadding: token2.paddingXXS,
        tabsActiveTextShadow: "0 0 0.25px currentcolor",
        tabsDropdownHeight: 200,
        tabsDropdownWidth: 120,
        tabsHorizontalItemMargin: `0 0 0 ${unit$1(token2.horizontalItemGutter)}`,
        tabsHorizontalItemMarginRTL: `0 0 0 ${unit$1(token2.horizontalItemGutter)}`
      });
      return [genSizeStyle(tabsToken), genRtlStyle$1(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle(tabsToken), genTabsStyle(tabsToken), genMotionStyle(tabsToken)];
    }, prepareComponentToken$c);
    const TabPane = () => null;
    var __rest$C = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const Tabs = (props) => {
      var _a, _b, _c, _d, _e2, _f, _g, _h, _j, _k, _l;
      const {
        type: type2,
        className,
        rootClassName,
        size: customSize,
        onEdit,
        hideAdd,
        centered,
        addIcon,
        removeIcon,
        moreIcon,
        more,
        popupClassName,
        children,
        items,
        animated,
        style: style2,
        indicatorSize,
        indicator
      } = props, otherProps = __rest$C(props, ["type", "className", "rootClassName", "size", "onEdit", "hideAdd", "centered", "addIcon", "removeIcon", "moreIcon", "more", "popupClassName", "children", "items", "animated", "style", "indicatorSize", "indicator"]);
      const {
        prefixCls: customizePrefixCls
      } = otherProps;
      const {
        direction,
        tabs,
        getPrefixCls,
        getPopupContainer
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("tabs", customizePrefixCls);
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$f(prefixCls, rootCls);
      let editable;
      if (type2 === "editable-card") {
        editable = {
          onEdit: (editType, _ref) => {
            let {
              key,
              event
            } = _ref;
            onEdit === null || onEdit === void 0 ? void 0 : onEdit(editType === "add" ? event : key, editType);
          },
          removeIcon: (_a = removeIcon !== null && removeIcon !== void 0 ? removeIcon : tabs === null || tabs === void 0 ? void 0 : tabs.removeIcon) !== null && _a !== void 0 ? _a : /* @__PURE__ */ reactExports.createElement(RefIcon$A, null),
          addIcon: (addIcon !== null && addIcon !== void 0 ? addIcon : tabs === null || tabs === void 0 ? void 0 : tabs.addIcon) || /* @__PURE__ */ reactExports.createElement(RefIcon$p, null),
          showAdd: hideAdd !== true
        };
      }
      const rootPrefixCls = getPrefixCls();
      const size = useSize(customSize);
      const mergedItems = useLegacyItems(items, children);
      const mergedAnimated = useAnimateConfig(prefixCls, animated);
      const mergedStyle = Object.assign(Object.assign({}, tabs === null || tabs === void 0 ? void 0 : tabs.style), style2);
      const mergedIndicator = {
        align: (_b = indicator === null || indicator === void 0 ? void 0 : indicator.align) !== null && _b !== void 0 ? _b : (_c = tabs === null || tabs === void 0 ? void 0 : tabs.indicator) === null || _c === void 0 ? void 0 : _c.align,
        size: (_g = (_e2 = (_d = indicator === null || indicator === void 0 ? void 0 : indicator.size) !== null && _d !== void 0 ? _d : indicatorSize) !== null && _e2 !== void 0 ? _e2 : (_f = tabs === null || tabs === void 0 ? void 0 : tabs.indicator) === null || _f === void 0 ? void 0 : _f.size) !== null && _g !== void 0 ? _g : tabs === null || tabs === void 0 ? void 0 : tabs.indicatorSize
      };
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(Tabs$1, Object.assign({
        direction,
        getPopupContainer
      }, otherProps, {
        items: mergedItems,
        className: classNames({
          [`${prefixCls}-${size}`]: size,
          [`${prefixCls}-card`]: ["card", "editable-card"].includes(type2),
          [`${prefixCls}-editable-card`]: type2 === "editable-card",
          [`${prefixCls}-centered`]: centered
        }, tabs === null || tabs === void 0 ? void 0 : tabs.className, className, rootClassName, hashId, cssVarCls, rootCls),
        popupClassName: classNames(popupClassName, hashId, cssVarCls, rootCls),
        style: mergedStyle,
        editable,
        more: Object.assign({
          icon: (_l = (_k = (_j = (_h = tabs === null || tabs === void 0 ? void 0 : tabs.more) === null || _h === void 0 ? void 0 : _h.icon) !== null && _j !== void 0 ? _j : tabs === null || tabs === void 0 ? void 0 : tabs.moreIcon) !== null && _k !== void 0 ? _k : moreIcon) !== null && _l !== void 0 ? _l : /* @__PURE__ */ reactExports.createElement(RefIcon$q, null),
          transitionName: `${rootPrefixCls}-slide-up`
        }, more),
        prefixCls,
        animated: mergedAnimated,
        indicator: mergedIndicator
      })));
    };
    Tabs.TabPane = TabPane;
    function throttle(delay, callback, options2) {
      var _ref = options2 || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
      var timeoutID;
      var cancelled = false;
      var lastExec = 0;
      function clearExistingTimeout() {
        if (timeoutID) {
          clearTimeout(timeoutID);
        }
      }
      function cancel(options3) {
        var _ref2 = options3 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
        clearExistingTimeout();
        cancelled = !upcomingOnly;
      }
      function wrapper() {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
          arguments_[_key] = arguments[_key];
        }
        var self2 = this;
        var elapsed = Date.now() - lastExec;
        if (cancelled) {
          return;
        }
        function exec2() {
          lastExec = Date.now();
          callback.apply(self2, arguments_);
        }
        function clear() {
          timeoutID = void 0;
        }
        if (!noLeading && debounceMode && !timeoutID) {
          exec2();
        }
        clearExistingTimeout();
        if (debounceMode === void 0 && elapsed > delay) {
          if (noLeading) {
            lastExec = Date.now();
            if (!noTrailing) {
              timeoutID = setTimeout(debounceMode ? clear : exec2, delay);
            }
          } else {
            exec2();
          }
        } else if (noTrailing !== true) {
          timeoutID = setTimeout(debounceMode ? clear : exec2, debounceMode === void 0 ? delay - elapsed : delay);
        }
      }
      wrapper.cancel = cancel;
      return wrapper;
    }
    function debounce$1(delay, callback, options2) {
      var _ref = {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
      return throttle(delay, callback, {
        debounceMode: atBegin !== false
      });
    }
    const genCheckboxStyle = (token2) => {
      const {
        checkboxCls
      } = token2;
      const wrapperCls = `${checkboxCls}-wrapper`;
      return [
        // ===================== Basic =====================
        {
          // Group
          [`${checkboxCls}-group`]: Object.assign(Object.assign({}, resetComponent(token2)), {
            display: "inline-flex",
            flexWrap: "wrap",
            columnGap: token2.marginXS,
            // Group > Grid
            [`> ${token2.antCls}-row`]: {
              flex: 1
            }
          }),
          // Wrapper
          [wrapperCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
            display: "inline-flex",
            alignItems: "baseline",
            cursor: "pointer",
            // Fix checkbox & radio in flex align #30260
            "&:after": {
              display: "inline-block",
              width: 0,
              overflow: "hidden",
              content: "'\\a0'"
            },
            // Checkbox near checkbox
            [`& + ${wrapperCls}`]: {
              marginInlineStart: 0
            },
            [`&${wrapperCls}-in-form-item`]: {
              'input[type="checkbox"]': {
                width: 14,
                // FIXME: magic
                height: 14
                // FIXME: magic
              }
            }
          }),
          // Wrapper > Checkbox
          [checkboxCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
            position: "relative",
            whiteSpace: "nowrap",
            lineHeight: 1,
            cursor: "pointer",
            borderRadius: token2.borderRadiusSM,
            // To make alignment right when `controlHeight` is changed
            // Ref: https://github.com/ant-design/ant-design/issues/41564
            alignSelf: "center",
            // Wrapper > Checkbox > input
            [`${checkboxCls}-input`]: {
              position: "absolute",
              // Since baseline align will get additional space offset,
              // we need to move input to top to make it align with text.
              // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
              inset: 0,
              zIndex: 1,
              cursor: "pointer",
              opacity: 0,
              margin: 0,
              [`&:focus-visible + ${checkboxCls}-inner`]: Object.assign({}, genFocusOutline(token2))
            },
            // Wrapper > Checkbox > inner
            [`${checkboxCls}-inner`]: {
              boxSizing: "border-box",
              display: "block",
              width: token2.checkboxSize,
              height: token2.checkboxSize,
              direction: "ltr",
              backgroundColor: token2.colorBgContainer,
              border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
              borderRadius: token2.borderRadiusSM,
              borderCollapse: "separate",
              transition: `all ${token2.motionDurationSlow}`,
              "&:after": {
                boxSizing: "border-box",
                position: "absolute",
                top: "50%",
                insetInlineStart: "25%",
                display: "table",
                width: token2.calc(token2.checkboxSize).div(14).mul(5).equal(),
                height: token2.calc(token2.checkboxSize).div(14).mul(8).equal(),
                border: `${unit$1(token2.lineWidthBold)} solid ${token2.colorWhite}`,
                borderTop: 0,
                borderInlineStart: 0,
                transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
                opacity: 0,
                content: '""',
                transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
              }
            },
            // Wrapper > Checkbox + Text
            "& + span": {
              paddingInlineStart: token2.paddingXS,
              paddingInlineEnd: token2.paddingXS
            }
          })
        },
        // ===================== Hover =====================
        {
          // Wrapper & Wrapper > Checkbox
          [`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
            [`&:hover ${checkboxCls}-inner`]: {
              borderColor: token2.colorPrimary
            }
          },
          [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
            [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
              backgroundColor: token2.colorPrimaryHover,
              borderColor: "transparent"
            },
            [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: {
              borderColor: token2.colorPrimaryHover
            }
          }
        },
        // ==================== Checked ====================
        {
          // Wrapper > Checkbox
          [`${checkboxCls}-checked`]: {
            [`${checkboxCls}-inner`]: {
              backgroundColor: token2.colorPrimary,
              borderColor: token2.colorPrimary,
              "&:after": {
                opacity: 1,
                transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
                transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
              }
            }
          },
          [`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: {
            [`&:hover ${checkboxCls}-inner`]: {
              backgroundColor: token2.colorPrimaryHover,
              borderColor: "transparent"
            }
          }
        },
        // ================= Indeterminate =================
        {
          [checkboxCls]: {
            "&-indeterminate": {
              // Wrapper > Checkbox > inner
              [`${checkboxCls}-inner`]: {
                backgroundColor: `${token2.colorBgContainer} !important`,
                borderColor: `${token2.colorBorder} !important`,
                "&:after": {
                  top: "50%",
                  insetInlineStart: "50%",
                  width: token2.calc(token2.fontSizeLG).div(2).equal(),
                  height: token2.calc(token2.fontSizeLG).div(2).equal(),
                  backgroundColor: token2.colorPrimary,
                  border: 0,
                  transform: "translate(-50%, -50%) scale(1)",
                  opacity: 1,
                  content: '""'
                }
              },
              // https://github.com/ant-design/ant-design/issues/50074
              [`&:hover ${checkboxCls}-inner`]: {
                backgroundColor: `${token2.colorBgContainer} !important`,
                borderColor: `${token2.colorPrimary} !important`
              }
            }
          }
        },
        // ==================== Disable ====================
        {
          // Wrapper
          [`${wrapperCls}-disabled`]: {
            cursor: "not-allowed"
          },
          // Wrapper > Checkbox
          [`${checkboxCls}-disabled`]: {
            // Wrapper > Checkbox > input
            [`&, ${checkboxCls}-input`]: {
              cursor: "not-allowed",
              // Disabled for native input to enable Tooltip event handler
              // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
              pointerEvents: "none"
            },
            // Wrapper > Checkbox > inner
            [`${checkboxCls}-inner`]: {
              background: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              "&:after": {
                borderColor: token2.colorTextDisabled
              }
            },
            "&:after": {
              display: "none"
            },
            "& + span": {
              color: token2.colorTextDisabled
            },
            [`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: {
              background: token2.colorTextDisabled
            }
          }
        }
      ];
    };
    function getStyle(prefixCls, token2) {
      const checkboxToken = merge(token2, {
        checkboxCls: `.${prefixCls}`,
        checkboxSize: token2.controlInteractiveSize
      });
      return [genCheckboxStyle(checkboxToken)];
    }
    const useStyle$e = genStyleHooks("Checkbox", (token2, _ref) => {
      let {
        prefixCls
      } = _ref;
      return [getStyle(prefixCls, token2)];
    });
    const GroupContext = /* @__PURE__ */ i.createContext(null);
    var __rest$B = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const InternalCheckbox = (props, ref) => {
      var _a;
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        children,
        indeterminate = false,
        style: style2,
        onMouseEnter,
        onMouseLeave,
        skipGroup = false,
        disabled
      } = props, restProps = __rest$B(props, ["prefixCls", "className", "rootClassName", "children", "indeterminate", "style", "onMouseEnter", "onMouseLeave", "skipGroup", "disabled"]);
      const {
        getPrefixCls,
        direction,
        checkbox
      } = reactExports.useContext(ConfigContext);
      const checkboxGroup = reactExports.useContext(GroupContext);
      const {
        isFormItemInput
      } = reactExports.useContext(FormItemInputContext);
      const contextDisabled = reactExports.useContext(DisabledContext);
      const mergedDisabled = (_a = (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.disabled) || disabled) !== null && _a !== void 0 ? _a : contextDisabled;
      const prevValue = reactExports.useRef(restProps.value);
      const checkboxRef = reactExports.useRef(null);
      const mergedRef = composeRef(ref, checkboxRef);
      reactExports.useEffect(() => {
        checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
      }, []);
      reactExports.useEffect(() => {
        if (skipGroup) {
          return;
        }
        if (restProps.value !== prevValue.current) {
          checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(prevValue.current);
          checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
          prevValue.current = restProps.value;
        }
        return () => checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(restProps.value);
      }, [restProps.value]);
      reactExports.useEffect(() => {
        var _a2;
        if ((_a2 = checkboxRef.current) === null || _a2 === void 0 ? void 0 : _a2.input) {
          checkboxRef.current.input.indeterminate = indeterminate;
        }
      }, [indeterminate]);
      const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$e(prefixCls, rootCls);
      const checkboxProps = Object.assign({}, restProps);
      if (checkboxGroup && !skipGroup) {
        checkboxProps.onChange = function() {
          if (restProps.onChange) {
            restProps.onChange.apply(restProps, arguments);
          }
          if (checkboxGroup.toggleOption) {
            checkboxGroup.toggleOption({
              label: children,
              value: restProps.value
            });
          }
        };
        checkboxProps.name = checkboxGroup.name;
        checkboxProps.checked = checkboxGroup.value.includes(restProps.value);
      }
      const classString = classNames(`${prefixCls}-wrapper`, {
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-wrapper-checked`]: checkboxProps.checked,
        [`${prefixCls}-wrapper-disabled`]: mergedDisabled,
        [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
      }, checkbox === null || checkbox === void 0 ? void 0 : checkbox.className, className, rootClassName, cssVarCls, rootCls, hashId);
      const checkboxClass = classNames({
        [`${prefixCls}-indeterminate`]: indeterminate
      }, TARGET_CLS, hashId);
      const [onLabelClick, onInputClick] = useBubbleLock(checkboxProps.onClick);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(Wave, {
        component: "Checkbox",
        disabled: mergedDisabled
      }, /* @__PURE__ */ reactExports.createElement("label", {
        className: classString,
        style: Object.assign(Object.assign({}, checkbox === null || checkbox === void 0 ? void 0 : checkbox.style), style2),
        onMouseEnter,
        onMouseLeave,
        onClick: onLabelClick
      }, /* @__PURE__ */ reactExports.createElement(Checkbox$2, Object.assign({}, checkboxProps, {
        onClick: onInputClick,
        prefixCls,
        className: checkboxClass,
        disabled: mergedDisabled,
        ref: mergedRef
      })), children !== void 0 && /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-label`
      }, children))));
    };
    const Checkbox$1 = /* @__PURE__ */ reactExports.forwardRef(InternalCheckbox);
    var __rest$A = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const CheckboxGroup$1 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        defaultValue,
        children,
        options: options2 = [],
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        style: style2,
        onChange
      } = props, restProps = __rest$A(props, ["defaultValue", "children", "options", "prefixCls", "className", "rootClassName", "style", "onChange"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const [value, setValue] = reactExports.useState(restProps.value || defaultValue || []);
      const [registeredValues, setRegisteredValues] = reactExports.useState([]);
      reactExports.useEffect(() => {
        if ("value" in restProps) {
          setValue(restProps.value || []);
        }
      }, [restProps.value]);
      const memoizedOptions = reactExports.useMemo(() => options2.map((option) => {
        if (typeof option === "string" || typeof option === "number") {
          return {
            label: option,
            value: option
          };
        }
        return option;
      }), [options2]);
      const cancelValue = (val) => {
        setRegisteredValues((prevValues) => prevValues.filter((v2) => v2 !== val));
      };
      const registerValue = (val) => {
        setRegisteredValues((prevValues) => [].concat(_toConsumableArray(prevValues), [val]));
      };
      const toggleOption = (option) => {
        const optionIndex = value.indexOf(option.value);
        const newValue = _toConsumableArray(value);
        if (optionIndex === -1) {
          newValue.push(option.value);
        } else {
          newValue.splice(optionIndex, 1);
        }
        if (!("value" in restProps)) {
          setValue(newValue);
        }
        onChange === null || onChange === void 0 ? void 0 : onChange(newValue.filter((val) => registeredValues.includes(val)).sort((a, b2) => {
          const indexA = memoizedOptions.findIndex((opt) => opt.value === a);
          const indexB = memoizedOptions.findIndex((opt) => opt.value === b2);
          return indexA - indexB;
        }));
      };
      const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
      const groupPrefixCls = `${prefixCls}-group`;
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$e(prefixCls, rootCls);
      const domProps = omit(restProps, ["value", "disabled"]);
      const childrenNode = options2.length ? memoizedOptions.map((option) => /* @__PURE__ */ reactExports.createElement(Checkbox$1, {
        prefixCls,
        key: option.value.toString(),
        disabled: "disabled" in option ? option.disabled : restProps.disabled,
        value: option.value,
        checked: value.includes(option.value),
        onChange: option.onChange,
        className: `${groupPrefixCls}-item`,
        style: option.style,
        title: option.title,
        id: option.id,
        required: option.required
      }, option.label)) : children;
      const context = {
        toggleOption,
        value,
        disabled: restProps.disabled,
        name: restProps.name,
        // https://github.com/ant-design/ant-design/issues/16376
        registerValue,
        cancelValue
      };
      const classString = classNames(groupPrefixCls, {
        [`${groupPrefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, cssVarCls, rootCls, hashId);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: classString,
        style: style2
      }, domProps, {
        ref
      }), /* @__PURE__ */ reactExports.createElement(GroupContext.Provider, {
        value: context
      }, childrenNode)));
    });
    const Checkbox = Checkbox$1;
    Checkbox.Group = CheckboxGroup$1;
    Checkbox.__ANT_CHECKBOX = true;
    const RowContext = /* @__PURE__ */ reactExports.createContext({});
    var __rest$z = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function parseFlex(flex) {
      if (typeof flex === "number") {
        return `${flex} ${flex} auto`;
      }
      if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
        return `0 0 ${flex}`;
      }
      return flex;
    }
    const sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
    const Col = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        gutter,
        wrap
      } = reactExports.useContext(RowContext);
      const {
        prefixCls: customizePrefixCls,
        span,
        order,
        offset: offset2,
        push: push2,
        pull,
        className,
        children,
        flex,
        style: style2
      } = props, others = __rest$z(props, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]);
      const prefixCls = getPrefixCls("col", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useColStyle(prefixCls);
      const sizeStyle = {};
      let sizeClassObj = {};
      sizes.forEach((size) => {
        let sizeProps = {};
        const propSize = props[size];
        if (typeof propSize === "number") {
          sizeProps.span = propSize;
        } else if (typeof propSize === "object") {
          sizeProps = propSize || {};
        }
        delete others[size];
        sizeClassObj = Object.assign(Object.assign({}, sizeClassObj), {
          [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
          [`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
          [`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
          [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
          [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
          [`${prefixCls}-rtl`]: direction === "rtl"
        });
        if (sizeProps.flex) {
          sizeClassObj[`${prefixCls}-${size}-flex`] = true;
          sizeStyle[`--${prefixCls}-${size}-flex`] = parseFlex(sizeProps.flex);
        }
      });
      const classes = classNames(prefixCls, {
        [`${prefixCls}-${span}`]: span !== void 0,
        [`${prefixCls}-order-${order}`]: order,
        [`${prefixCls}-offset-${offset2}`]: offset2,
        [`${prefixCls}-push-${push2}`]: push2,
        [`${prefixCls}-pull-${pull}`]: pull
      }, className, sizeClassObj, hashId, cssVarCls);
      const mergedStyle = {};
      if (gutter && gutter[0] > 0) {
        const horizontalGutter = gutter[0] / 2;
        mergedStyle.paddingLeft = horizontalGutter;
        mergedStyle.paddingRight = horizontalGutter;
      }
      if (flex) {
        mergedStyle.flex = parseFlex(flex);
        if (wrap === false && !mergedStyle.minWidth) {
          mergedStyle.minWidth = 0;
        }
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({}, others, {
        style: Object.assign(Object.assign(Object.assign({}, mergedStyle), style2), sizeStyle),
        className: classes,
        ref
      }), children));
    });
    function useGutter(gutter, screens) {
      const results = [void 0, void 0];
      const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
      const mergedScreens = screens || {
        xs: true,
        sm: true,
        md: true,
        lg: true,
        xl: true,
        xxl: true
      };
      normalizedGutter.forEach((g2, index2) => {
        if (typeof g2 === "object" && g2 !== null) {
          for (let i2 = 0; i2 < responsiveArray.length; i2++) {
            const breakpoint = responsiveArray[i2];
            if (mergedScreens[breakpoint] && g2[breakpoint] !== void 0) {
              results[index2] = g2[breakpoint];
              break;
            }
          }
        } else {
          results[index2] = g2;
        }
      });
      return results;
    }
    var __rest$y = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function useMergedPropByScreen(oriProp, screen) {
      const [prop, setProp2] = reactExports.useState(typeof oriProp === "string" ? oriProp : "");
      const calcMergedAlignOrJustify = () => {
        if (typeof oriProp === "string") {
          setProp2(oriProp);
        }
        if (typeof oriProp !== "object") {
          return;
        }
        for (let i2 = 0; i2 < responsiveArray.length; i2++) {
          const breakpoint = responsiveArray[i2];
          if (!screen || !screen[breakpoint]) {
            continue;
          }
          const curVal = oriProp[breakpoint];
          if (curVal !== void 0) {
            setProp2(curVal);
            return;
          }
        }
      };
      reactExports.useEffect(() => {
        calcMergedAlignOrJustify();
      }, [JSON.stringify(oriProp), screen]);
      return prop;
    }
    const Row = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        justify,
        align,
        className,
        style: style2,
        children,
        gutter = 0,
        wrap
      } = props, others = __rest$y(props, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const screens = useBreakpoint(true, null);
      const mergedAlign = useMergedPropByScreen(align, screens);
      const mergedJustify = useMergedPropByScreen(justify, screens);
      const prefixCls = getPrefixCls("row", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useRowStyle(prefixCls);
      const gutters = useGutter(gutter, screens);
      const classes = classNames(prefixCls, {
        [`${prefixCls}-no-wrap`]: wrap === false,
        [`${prefixCls}-${mergedJustify}`]: mergedJustify,
        [`${prefixCls}-${mergedAlign}`]: mergedAlign,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, hashId, cssVarCls);
      const rowStyle = {};
      const horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : void 0;
      if (horizontalGutter) {
        rowStyle.marginLeft = horizontalGutter;
        rowStyle.marginRight = horizontalGutter;
      }
      const [gutterH, gutterV] = gutters;
      rowStyle.rowGap = gutterV;
      const rowContext = reactExports.useMemo(() => ({
        gutter: [gutterH, gutterV],
        wrap
      }), [gutterH, gutterV, wrap]);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(RowContext.Provider, {
        value: rowContext
      }, /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, others, {
        className: classes,
        style: Object.assign(Object.assign({}, rowStyle), style2),
        ref
      }), children)));
    });
    const genSharedDividerStyle = (token2) => {
      const {
        componentCls,
        sizePaddingEdgeHorizontal,
        colorSplit,
        lineWidth,
        textPaddingInline,
        orientationMargin,
        verticalMarginInline
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          borderBlockStart: `${unit$1(lineWidth)} solid ${colorSplit}`,
          // vertical
          "&-vertical": {
            position: "relative",
            top: "-0.06em",
            display: "inline-block",
            height: "0.9em",
            marginInline: verticalMarginInline,
            marginBlock: 0,
            verticalAlign: "middle",
            borderTop: 0,
            borderInlineStart: `${unit$1(lineWidth)} solid ${colorSplit}`
          },
          "&-horizontal": {
            display: "flex",
            clear: "both",
            width: "100%",
            minWidth: "100%",
            // Fix https://github.com/ant-design/ant-design/issues/10914
            margin: `${unit$1(token2.dividerHorizontalGutterMargin)} 0`
          },
          [`&-horizontal${componentCls}-with-text`]: {
            display: "flex",
            alignItems: "center",
            margin: `${unit$1(token2.dividerHorizontalWithTextGutterMargin)} 0`,
            color: token2.colorTextHeading,
            fontWeight: 500,
            fontSize: token2.fontSizeLG,
            whiteSpace: "nowrap",
            textAlign: "center",
            borderBlockStart: `0 ${colorSplit}`,
            "&::before, &::after": {
              position: "relative",
              width: "50%",
              borderBlockStart: `${unit$1(lineWidth)} solid transparent`,
              // Chrome not accept `inherit` in `border-top`
              borderBlockStartColor: "inherit",
              borderBlockEnd: 0,
              transform: "translateY(50%)",
              content: "''"
            }
          },
          [`&-horizontal${componentCls}-with-text-start`]: {
            "&::before": {
              width: `calc(${orientationMargin} * 100%)`
            },
            "&::after": {
              width: `calc(100% - ${orientationMargin} * 100%)`
            }
          },
          [`&-horizontal${componentCls}-with-text-end`]: {
            "&::before": {
              width: `calc(100% - ${orientationMargin} * 100%)`
            },
            "&::after": {
              width: `calc(${orientationMargin} * 100%)`
            }
          },
          [`${componentCls}-inner-text`]: {
            display: "inline-block",
            paddingBlock: 0,
            paddingInline: textPaddingInline
          },
          "&-dashed": {
            background: "none",
            borderColor: colorSplit,
            borderStyle: "dashed",
            borderWidth: `${unit$1(lineWidth)} 0 0`
          },
          [`&-horizontal${componentCls}-with-text${componentCls}-dashed`]: {
            "&::before, &::after": {
              borderStyle: "dashed none none"
            }
          },
          [`&-vertical${componentCls}-dashed`]: {
            borderInlineStartWidth: lineWidth,
            borderInlineEnd: 0,
            borderBlockStart: 0,
            borderBlockEnd: 0
          },
          "&-dotted": {
            background: "none",
            borderColor: colorSplit,
            borderStyle: "dotted",
            borderWidth: `${unit$1(lineWidth)} 0 0`
          },
          [`&-horizontal${componentCls}-with-text${componentCls}-dotted`]: {
            "&::before, &::after": {
              borderStyle: "dotted none none"
            }
          },
          [`&-vertical${componentCls}-dotted`]: {
            borderInlineStartWidth: lineWidth,
            borderInlineEnd: 0,
            borderBlockStart: 0,
            borderBlockEnd: 0
          },
          [`&-plain${componentCls}-with-text`]: {
            color: token2.colorText,
            fontWeight: "normal",
            fontSize: token2.fontSize
          },
          [`&-horizontal${componentCls}-with-text-start${componentCls}-no-default-orientation-margin-start`]: {
            "&::before": {
              width: 0
            },
            "&::after": {
              width: "100%"
            },
            [`${componentCls}-inner-text`]: {
              paddingInlineStart: sizePaddingEdgeHorizontal
            }
          },
          [`&-horizontal${componentCls}-with-text-end${componentCls}-no-default-orientation-margin-end`]: {
            "&::before": {
              width: "100%"
            },
            "&::after": {
              width: 0
            },
            [`${componentCls}-inner-text`]: {
              paddingInlineEnd: sizePaddingEdgeHorizontal
            }
          }
        })
      };
    };
    const prepareComponentToken$b = (token2) => ({
      textPaddingInline: "1em",
      orientationMargin: 0.05,
      verticalMarginInline: token2.marginXS
    });
    const useStyle$d = genStyleHooks("Divider", (token2) => {
      const dividerToken = merge(token2, {
        dividerHorizontalWithTextGutterMargin: token2.margin,
        dividerHorizontalGutterMargin: token2.marginLG,
        sizePaddingEdgeHorizontal: 0
      });
      return [genSharedDividerStyle(dividerToken)];
    }, prepareComponentToken$b, {
      unitless: {
        orientationMargin: true
      }
    });
    var __rest$x = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const Divider$1 = (props) => {
      const {
        getPrefixCls,
        direction,
        className: dividerClassName,
        style: dividerStyle
      } = useComponentConfig("divider");
      const {
        prefixCls: customizePrefixCls,
        type: type2 = "horizontal",
        orientation = "center",
        orientationMargin,
        className,
        rootClassName,
        children,
        dashed,
        variant = "solid",
        plain,
        style: style2
      } = props, restProps = __rest$x(props, ["prefixCls", "type", "orientation", "orientationMargin", "className", "rootClassName", "children", "dashed", "variant", "plain", "style"]);
      const prefixCls = getPrefixCls("divider", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$d(prefixCls);
      const hasChildren = !!children;
      const mergedOrientation = reactExports.useMemo(() => {
        if (orientation === "left") {
          return direction === "rtl" ? "end" : "start";
        }
        if (orientation === "right") {
          return direction === "rtl" ? "start" : "end";
        }
        return orientation;
      }, [direction, orientation]);
      const hasMarginStart = mergedOrientation === "start" && orientationMargin != null;
      const hasMarginEnd = mergedOrientation === "end" && orientationMargin != null;
      const classString = classNames(prefixCls, dividerClassName, hashId, cssVarCls, `${prefixCls}-${type2}`, {
        [`${prefixCls}-with-text`]: hasChildren,
        [`${prefixCls}-with-text-${mergedOrientation}`]: hasChildren,
        [`${prefixCls}-dashed`]: !!dashed,
        [`${prefixCls}-${variant}`]: variant !== "solid",
        [`${prefixCls}-plain`]: !!plain,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-no-default-orientation-margin-start`]: hasMarginStart,
        [`${prefixCls}-no-default-orientation-margin-end`]: hasMarginEnd
      }, className, rootClassName);
      const memoizedOrientationMargin = reactExports.useMemo(() => {
        if (typeof orientationMargin === "number") {
          return orientationMargin;
        }
        if (/^\d+$/.test(orientationMargin)) {
          return Number(orientationMargin);
        }
        return orientationMargin;
      }, [orientationMargin]);
      const innerStyle = {
        marginInlineStart: hasMarginStart ? memoizedOrientationMargin : void 0,
        marginInlineEnd: hasMarginEnd ? memoizedOrientationMargin : void 0
      };
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: classString,
        style: Object.assign(Object.assign({}, dividerStyle), style2)
      }, restProps, {
        role: "separator"
      }), children && type2 !== "vertical" && /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-inner-text`,
        style: innerStyle
      }, children)));
    };
    var UpOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, "name": "up", "theme": "outlined" };
    var UpOutlined = function UpOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: UpOutlined$1
      }));
    };
    var RefIcon$o = /* @__PURE__ */ reactExports.forwardRef(UpOutlined);
    function supportBigInt() {
      return typeof BigInt === "function";
    }
    function isEmpty(value) {
      return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
    }
    function trimNumber(numStr) {
      var str = numStr.trim();
      var negative = str.startsWith("-");
      if (negative) {
        str = str.slice(1);
      }
      str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
      if (str.startsWith(".")) {
        str = "0".concat(str);
      }
      var trimStr = str || "0";
      var splitNumber = trimStr.split(".");
      var integerStr = splitNumber[0] || "0";
      var decimalStr = splitNumber[1] || "0";
      if (integerStr === "0" && decimalStr === "0") {
        negative = false;
      }
      var negativeStr = negative ? "-" : "";
      return {
        negative,
        negativeStr,
        trimStr,
        integerStr,
        decimalStr,
        fullStr: "".concat(negativeStr).concat(trimStr)
      };
    }
    function isE(number2) {
      var str = String(number2);
      return !Number.isNaN(Number(str)) && str.includes("e");
    }
    function getNumberPrecision(number2) {
      var numStr = String(number2);
      if (isE(number2)) {
        var precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
        var decimalMatch = numStr.match(/\.(\d+)/);
        if (decimalMatch !== null && decimalMatch !== void 0 && decimalMatch[1]) {
          precision += decimalMatch[1].length;
        }
        return precision;
      }
      return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
    }
    function num2str(number2) {
      var numStr = String(number2);
      if (isE(number2)) {
        if (number2 > Number.MAX_SAFE_INTEGER) {
          return String(supportBigInt() ? BigInt(number2).toString() : Number.MAX_SAFE_INTEGER);
        }
        if (number2 < Number.MIN_SAFE_INTEGER) {
          return String(supportBigInt() ? BigInt(number2).toString() : Number.MIN_SAFE_INTEGER);
        }
        numStr = number2.toFixed(getNumberPrecision(numStr));
      }
      return trimNumber(numStr).fullStr;
    }
    function validateNumber(num) {
      if (typeof num === "number") {
        return !Number.isNaN(num);
      }
      if (!num) {
        return false;
      }
      return (
        // Normal type: 11.28
        /^\s*-?\d+(\.\d+)?\s*$/.test(num) || // Pre-number: 1.
        /^\s*-?\d+\.\s*$/.test(num) || // Post-number: .1
        /^\s*-?\.\d+\s*$/.test(num)
      );
    }
    var BigIntDecimal = /* @__PURE__ */ function() {
      function BigIntDecimal2(value) {
        _classCallCheck(this, BigIntDecimal2);
        _defineProperty(this, "origin", "");
        _defineProperty(this, "negative", void 0);
        _defineProperty(this, "integer", void 0);
        _defineProperty(this, "decimal", void 0);
        _defineProperty(this, "decimalLen", void 0);
        _defineProperty(this, "empty", void 0);
        _defineProperty(this, "nan", void 0);
        if (isEmpty(value)) {
          this.empty = true;
          return;
        }
        this.origin = String(value);
        if (value === "-" || Number.isNaN(value)) {
          this.nan = true;
          return;
        }
        var mergedValue = value;
        if (isE(mergedValue)) {
          mergedValue = Number(mergedValue);
        }
        mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
        if (validateNumber(mergedValue)) {
          var trimRet = trimNumber(mergedValue);
          this.negative = trimRet.negative;
          var numbers = trimRet.trimStr.split(".");
          this.integer = BigInt(numbers[0]);
          var decimalStr = numbers[1] || "0";
          this.decimal = BigInt(decimalStr);
          this.decimalLen = decimalStr.length;
        } else {
          this.nan = true;
        }
      }
      _createClass(BigIntDecimal2, [{
        key: "getMark",
        value: function getMark2() {
          return this.negative ? "-" : "";
        }
      }, {
        key: "getIntegerStr",
        value: function getIntegerStr() {
          return this.integer.toString();
        }
        /**
         * @private get decimal string
         */
      }, {
        key: "getDecimalStr",
        value: function getDecimalStr() {
          return this.decimal.toString().padStart(this.decimalLen, "0");
        }
        /**
         * @private Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
         * This is used for add function only.
         */
      }, {
        key: "alignDecimal",
        value: function alignDecimal(decimalLength) {
          var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
          return BigInt(str);
        }
      }, {
        key: "negate",
        value: function negate() {
          var clone2 = new BigIntDecimal2(this.toString());
          clone2.negative = !clone2.negative;
          return clone2;
        }
      }, {
        key: "cal",
        value: function cal(offset2, calculator, calDecimalLen) {
          var maxDecimalLength = Math.max(this.getDecimalStr().length, offset2.getDecimalStr().length);
          var myAlignedDecimal = this.alignDecimal(maxDecimalLength);
          var offsetAlignedDecimal = offset2.alignDecimal(maxDecimalLength);
          var valueStr = calculator(myAlignedDecimal, offsetAlignedDecimal).toString();
          var nextDecimalLength = calDecimalLen(maxDecimalLength);
          var _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr;
          var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(nextDecimalLength + 1, "0"));
          return new BigIntDecimal2("".concat(hydrateValueStr.slice(0, -nextDecimalLength), ".").concat(hydrateValueStr.slice(-nextDecimalLength)));
        }
      }, {
        key: "add",
        value: function add(value) {
          if (this.isInvalidate()) {
            return new BigIntDecimal2(value);
          }
          var offset2 = new BigIntDecimal2(value);
          if (offset2.isInvalidate()) {
            return this;
          }
          return this.cal(offset2, function(num1, num2) {
            return num1 + num2;
          }, function(len) {
            return len;
          });
        }
      }, {
        key: "multi",
        value: function multi(value) {
          var target = new BigIntDecimal2(value);
          if (this.isInvalidate() || target.isInvalidate()) {
            return new BigIntDecimal2(NaN);
          }
          return this.cal(target, function(num1, num2) {
            return num1 * num2;
          }, function(len) {
            return len * 2;
          });
        }
      }, {
        key: "isEmpty",
        value: function isEmpty2() {
          return this.empty;
        }
      }, {
        key: "isNaN",
        value: function isNaN2() {
          return this.nan;
        }
      }, {
        key: "isInvalidate",
        value: function isInvalidate() {
          return this.isEmpty() || this.isNaN();
        }
      }, {
        key: "equals",
        value: function equals(target) {
          return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
        }
      }, {
        key: "lessEquals",
        value: function lessEquals(target) {
          return this.add(target.negate().toString()).toNumber() <= 0;
        }
      }, {
        key: "toNumber",
        value: function toNumber2() {
          if (this.isNaN()) {
            return NaN;
          }
          return Number(this.toString());
        }
      }, {
        key: "toString",
        value: function toString2() {
          var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          if (!safe) {
            return this.origin;
          }
          if (this.isInvalidate()) {
            return "";
          }
          return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
        }
      }]);
      return BigIntDecimal2;
    }();
    var NumberDecimal = /* @__PURE__ */ function() {
      function NumberDecimal2(value) {
        _classCallCheck(this, NumberDecimal2);
        _defineProperty(this, "origin", "");
        _defineProperty(this, "number", void 0);
        _defineProperty(this, "empty", void 0);
        if (isEmpty(value)) {
          this.empty = true;
          return;
        }
        this.origin = String(value);
        this.number = Number(value);
      }
      _createClass(NumberDecimal2, [{
        key: "negate",
        value: function negate() {
          return new NumberDecimal2(-this.toNumber());
        }
      }, {
        key: "add",
        value: function add(value) {
          if (this.isInvalidate()) {
            return new NumberDecimal2(value);
          }
          var target = Number(value);
          if (Number.isNaN(target)) {
            return this;
          }
          var number2 = this.number + target;
          if (number2 > Number.MAX_SAFE_INTEGER) {
            return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
          }
          if (number2 < Number.MIN_SAFE_INTEGER) {
            return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
          }
          var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
          return new NumberDecimal2(number2.toFixed(maxPrecision));
        }
      }, {
        key: "multi",
        value: function multi(value) {
          var target = Number(value);
          if (this.isInvalidate() || Number.isNaN(target)) {
            return new NumberDecimal2(NaN);
          }
          var number2 = this.number * target;
          if (number2 > Number.MAX_SAFE_INTEGER) {
            return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
          }
          if (number2 < Number.MIN_SAFE_INTEGER) {
            return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
          }
          var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
          return new NumberDecimal2(number2.toFixed(maxPrecision));
        }
      }, {
        key: "isEmpty",
        value: function isEmpty2() {
          return this.empty;
        }
      }, {
        key: "isNaN",
        value: function isNaN2() {
          return Number.isNaN(this.number);
        }
      }, {
        key: "isInvalidate",
        value: function isInvalidate() {
          return this.isEmpty() || this.isNaN();
        }
      }, {
        key: "equals",
        value: function equals(target) {
          return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
        }
      }, {
        key: "lessEquals",
        value: function lessEquals(target) {
          return this.add(target.negate().toString()).toNumber() <= 0;
        }
      }, {
        key: "toNumber",
        value: function toNumber2() {
          return this.number;
        }
      }, {
        key: "toString",
        value: function toString2() {
          var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          if (!safe) {
            return this.origin;
          }
          if (this.isInvalidate()) {
            return "";
          }
          return num2str(this.number);
        }
      }]);
      return NumberDecimal2;
    }();
    function getMiniDecimal(value) {
      if (supportBigInt()) {
        return new BigIntDecimal(value);
      }
      return new NumberDecimal(value);
    }
    function toFixed(numStr, separatorStr, precision) {
      var cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (numStr === "") {
        return "";
      }
      var _trimNumber = trimNumber(numStr), negativeStr = _trimNumber.negativeStr, integerStr = _trimNumber.integerStr, decimalStr = _trimNumber.decimalStr;
      var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
      var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
      if (precision >= 0) {
        var advancedNum = Number(decimalStr[precision]);
        if (advancedNum >= 5 && !cutOnly) {
          var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision)).concat(10 - advancedNum));
          return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);
        }
        if (precision === 0) {
          return numberWithoutDecimal;
        }
        return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, "0").slice(0, precision));
      }
      if (precisionDecimalStr === ".0") {
        return numberWithoutDecimal;
      }
      return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
    }
    function hasAddon(props) {
      return !!(props.addonBefore || props.addonAfter);
    }
    function hasPrefixSuffix$1(props) {
      return !!(props.prefix || props.suffix || props.allowClear);
    }
    function cloneEvent(event, target, value) {
      var currentTarget = target.cloneNode(true);
      var newEvent = Object.create(event, {
        target: {
          value: currentTarget
        },
        currentTarget: {
          value: currentTarget
        }
      });
      currentTarget.value = value;
      if (typeof target.selectionStart === "number" && typeof target.selectionEnd === "number") {
        currentTarget.selectionStart = target.selectionStart;
        currentTarget.selectionEnd = target.selectionEnd;
      }
      currentTarget.setSelectionRange = function() {
        target.setSelectionRange.apply(target, arguments);
      };
      return newEvent;
    }
    function resolveOnChange(target, e2, onChange, targetValue) {
      if (!onChange) {
        return;
      }
      var event = e2;
      if (e2.type === "click") {
        event = cloneEvent(e2, target, "");
        onChange(event);
        return;
      }
      if (target.type !== "file" && targetValue !== void 0) {
        event = cloneEvent(e2, target, targetValue);
        onChange(event);
        return;
      }
      onChange(event);
    }
    function triggerFocus(element, option) {
      if (!element) return;
      element.focus(option);
      var _ref = option || {}, cursor = _ref.cursor;
      if (cursor) {
        var len = element.value.length;
        switch (cursor) {
          case "start":
            element.setSelectionRange(0, 0);
            break;
          case "end":
            element.setSelectionRange(len, len);
            break;
          default:
            element.setSelectionRange(0, len);
        }
      }
    }
    var BaseInput = /* @__PURE__ */ i.forwardRef(function(props, ref) {
      var _props, _props2, _props3;
      var inputEl = props.inputElement, children = props.children, prefixCls = props.prefixCls, prefix2 = props.prefix, suffix2 = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style2 = props.style, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value = props.value, handleReset = props.handleReset, hidden = props.hidden, classes = props.classes, classNames$1 = props.classNames, dataAttrs = props.dataAttrs, styles = props.styles, components = props.components, onClear = props.onClear;
      var inputElement = children !== null && children !== void 0 ? children : inputEl;
      var AffixWrapperComponent = (components === null || components === void 0 ? void 0 : components.affixWrapper) || "span";
      var GroupWrapperComponent = (components === null || components === void 0 ? void 0 : components.groupWrapper) || "span";
      var WrapperComponent = (components === null || components === void 0 ? void 0 : components.wrapper) || "span";
      var GroupAddonComponent = (components === null || components === void 0 ? void 0 : components.groupAddon) || "span";
      var containerRef = reactExports.useRef(null);
      var onInputClick = function onInputClick2(e2) {
        var _containerRef$current;
        if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e2.target)) {
          triggerFocus2 === null || triggerFocus2 === void 0 || triggerFocus2();
        }
      };
      var hasAffix = hasPrefixSuffix$1(props);
      var element = /* @__PURE__ */ reactExports.cloneElement(inputElement, {
        value,
        className: classNames((_props = inputElement.props) === null || _props === void 0 ? void 0 : _props.className, !hasAffix && (classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.variant)) || null
      });
      var groupRef = reactExports.useRef(null);
      i.useImperativeHandle(ref, function() {
        return {
          nativeElement: groupRef.current || containerRef.current
        };
      });
      if (hasAffix) {
        var clearIcon = null;
        if (allowClear) {
          var needClear = !disabled && !readOnly && value;
          var clearIconCls = "".concat(prefixCls, "-clear-icon");
          var iconNode = _typeof$1(allowClear) === "object" && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : "";
          clearIcon = /* @__PURE__ */ i.createElement("button", {
            type: "button",
            tabIndex: -1,
            onClick: function onClick(event) {
              handleReset === null || handleReset === void 0 || handleReset(event);
              onClear === null || onClear === void 0 || onClear();
            },
            onMouseDown: function onMouseDown(e2) {
              return e2.preventDefault();
            },
            className: classNames(clearIconCls, _defineProperty(_defineProperty({}, "".concat(clearIconCls, "-hidden"), !needClear), "".concat(clearIconCls, "-has-suffix"), !!suffix2))
          }, iconNode);
        }
        var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
        var affixWrapperCls = classNames(affixWrapperPrefixCls, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-disabled"), disabled), "".concat(affixWrapperPrefixCls, "-disabled"), disabled), "".concat(affixWrapperPrefixCls, "-focused"), focused), "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix2 && allowClear && value), classes === null || classes === void 0 ? void 0 : classes.affixWrapper, classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.affixWrapper, classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.variant);
        var suffixNode = (suffix2 || allowClear) && /* @__PURE__ */ i.createElement("span", {
          className: classNames("".concat(prefixCls, "-suffix"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.suffix),
          style: styles === null || styles === void 0 ? void 0 : styles.suffix
        }, clearIcon, suffix2);
        element = /* @__PURE__ */ i.createElement(AffixWrapperComponent, _extends$2({
          className: affixWrapperCls,
          style: styles === null || styles === void 0 ? void 0 : styles.affixWrapper,
          onClick: onInputClick
        }, dataAttrs === null || dataAttrs === void 0 ? void 0 : dataAttrs.affixWrapper, {
          ref: containerRef
        }), prefix2 && /* @__PURE__ */ i.createElement("span", {
          className: classNames("".concat(prefixCls, "-prefix"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.prefix),
          style: styles === null || styles === void 0 ? void 0 : styles.prefix
        }, prefix2), element, suffixNode);
      }
      if (hasAddon(props)) {
        var wrapperCls = "".concat(prefixCls, "-group");
        var addonCls = "".concat(wrapperCls, "-addon");
        var groupWrapperCls = "".concat(wrapperCls, "-wrapper");
        var mergedWrapperClassName = classNames("".concat(prefixCls, "-wrapper"), wrapperCls, classes === null || classes === void 0 ? void 0 : classes.wrapper, classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.wrapper);
        var mergedGroupClassName = classNames(groupWrapperCls, _defineProperty({}, "".concat(groupWrapperCls, "-disabled"), disabled), classes === null || classes === void 0 ? void 0 : classes.group, classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.groupWrapper);
        element = /* @__PURE__ */ i.createElement(GroupWrapperComponent, {
          className: mergedGroupClassName,
          ref: groupRef
        }, /* @__PURE__ */ i.createElement(WrapperComponent, {
          className: mergedWrapperClassName
        }, addonBefore && /* @__PURE__ */ i.createElement(GroupAddonComponent, {
          className: addonCls
        }, addonBefore), element, addonAfter && /* @__PURE__ */ i.createElement(GroupAddonComponent, {
          className: addonCls
        }, addonAfter)));
      }
      return /* @__PURE__ */ i.cloneElement(element, {
        className: classNames((_props2 = element.props) === null || _props2 === void 0 ? void 0 : _props2.className, className) || null,
        style: _objectSpread2$3(_objectSpread2$3({}, (_props3 = element.props) === null || _props3 === void 0 ? void 0 : _props3.style), style2),
        hidden
      });
    });
    var _excluded$8 = ["show"];
    function useCount(count, showCount) {
      return reactExports.useMemo(function() {
        var mergedConfig = {};
        if (showCount) {
          mergedConfig.show = _typeof$1(showCount) === "object" && showCount.formatter ? showCount.formatter : !!showCount;
        }
        mergedConfig = _objectSpread2$3(_objectSpread2$3({}, mergedConfig), count);
        var _ref = mergedConfig, show = _ref.show, rest = _objectWithoutProperties(_ref, _excluded$8);
        return _objectSpread2$3(_objectSpread2$3({}, rest), {}, {
          show: !!show,
          showFormatter: typeof show === "function" ? show : void 0,
          strategy: rest.strategy || function(value) {
            return value.length;
          }
        });
      }, [count, showCount]);
    }
    var _excluded$7 = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "onKeyUp", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "count", "type", "classes", "classNames", "styles", "onCompositionStart", "onCompositionEnd"];
    var Input$3 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var autoComplete = props.autoComplete, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input" : _props$prefixCls, disabled = props.disabled, htmlSize = props.htmlSize, className = props.className, maxLength = props.maxLength, suffix2 = props.suffix, showCount = props.showCount, count = props.count, _props$type = props.type, type2 = _props$type === void 0 ? "text" : _props$type, classes = props.classes, classNames$1 = props.classNames, styles = props.styles, _onCompositionStart = props.onCompositionStart, onCompositionEnd = props.onCompositionEnd, rest = _objectWithoutProperties(props, _excluded$7);
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), focused = _useState2[0], setFocused = _useState2[1];
      var compositionRef = reactExports.useRef(false);
      var keyLockRef = reactExports.useRef(false);
      var inputRef = reactExports.useRef(null);
      var holderRef = reactExports.useRef(null);
      var focus = function focus2(option) {
        if (inputRef.current) {
          triggerFocus(inputRef.current, option);
        }
      };
      var _useMergedState = useMergedState(props.defaultValue, {
        value: props.value
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
      var formatValue2 = value === void 0 || value === null ? "" : String(value);
      var _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), selection = _useState4[0], setSelection = _useState4[1];
      var countConfig = useCount(count, showCount);
      var mergedMax = countConfig.max || maxLength;
      var valueLength = countConfig.strategy(formatValue2);
      var isOutOfRange = !!mergedMax && valueLength > mergedMax;
      reactExports.useImperativeHandle(ref, function() {
        var _holderRef$current;
        return {
          focus,
          blur: function blur() {
            var _inputRef$current;
            (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.blur();
          },
          setSelectionRange: function setSelectionRange(start, end, direction) {
            var _inputRef$current2;
            (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.setSelectionRange(start, end, direction);
          },
          select: function select() {
            var _inputRef$current3;
            (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 || _inputRef$current3.select();
          },
          input: inputRef.current,
          nativeElement: ((_holderRef$current = holderRef.current) === null || _holderRef$current === void 0 ? void 0 : _holderRef$current.nativeElement) || inputRef.current
        };
      });
      reactExports.useEffect(function() {
        if (keyLockRef.current) {
          keyLockRef.current = false;
        }
        setFocused(function(prev2) {
          return prev2 && disabled ? false : prev2;
        });
      }, [disabled]);
      var triggerChange = function triggerChange2(e2, currentValue, info) {
        var cutValue = currentValue;
        if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
          cutValue = countConfig.exceedFormatter(currentValue, {
            max: countConfig.max
          });
          if (currentValue !== cutValue) {
            var _inputRef$current4, _inputRef$current5;
            setSelection([((_inputRef$current4 = inputRef.current) === null || _inputRef$current4 === void 0 ? void 0 : _inputRef$current4.selectionStart) || 0, ((_inputRef$current5 = inputRef.current) === null || _inputRef$current5 === void 0 ? void 0 : _inputRef$current5.selectionEnd) || 0]);
          }
        } else if (info.source === "compositionEnd") {
          return;
        }
        setValue(cutValue);
        if (inputRef.current) {
          resolveOnChange(inputRef.current, e2, onChange, cutValue);
        }
      };
      reactExports.useEffect(function() {
        if (selection) {
          var _inputRef$current6;
          (_inputRef$current6 = inputRef.current) === null || _inputRef$current6 === void 0 || _inputRef$current6.setSelectionRange.apply(_inputRef$current6, _toConsumableArray(selection));
        }
      }, [selection]);
      var onInternalChange = function onInternalChange2(e2) {
        triggerChange(e2, e2.target.value, {
          source: "change"
        });
      };
      var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {
        compositionRef.current = false;
        triggerChange(e2, e2.currentTarget.value, {
          source: "compositionEnd"
        });
        onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e2);
      };
      var handleKeyDown = function handleKeyDown2(e2) {
        if (onPressEnter && e2.key === "Enter" && !keyLockRef.current) {
          keyLockRef.current = true;
          onPressEnter(e2);
        }
        onKeyDown === null || onKeyDown === void 0 || onKeyDown(e2);
      };
      var handleKeyUp = function handleKeyUp2(e2) {
        if (e2.key === "Enter") {
          keyLockRef.current = false;
        }
        onKeyUp === null || onKeyUp === void 0 || onKeyUp(e2);
      };
      var handleFocus = function handleFocus2(e2) {
        setFocused(true);
        onFocus === null || onFocus === void 0 || onFocus(e2);
      };
      var handleBlur = function handleBlur2(e2) {
        if (keyLockRef.current) {
          keyLockRef.current = false;
        }
        setFocused(false);
        onBlur === null || onBlur === void 0 || onBlur(e2);
      };
      var handleReset = function handleReset2(e2) {
        setValue("");
        focus();
        if (inputRef.current) {
          resolveOnChange(inputRef.current, e2, onChange);
        }
      };
      var outOfRangeCls = isOutOfRange && "".concat(prefixCls, "-out-of-range");
      var getInputElement = function getInputElement2() {
        var otherProps = omit(props, [
          "prefixCls",
          "onPressEnter",
          "addonBefore",
          "addonAfter",
          "prefix",
          "suffix",
          "allowClear",
          // Input elements must be either controlled or uncontrolled,
          // specify either the value prop, or the defaultValue prop, but not both.
          "defaultValue",
          "showCount",
          "count",
          "classes",
          "htmlSize",
          "styles",
          "classNames",
          "onClear"
        ]);
        return /* @__PURE__ */ i.createElement("input", _extends$2({
          autoComplete
        }, otherProps, {
          onChange: onInternalChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onKeyDown: handleKeyDown,
          onKeyUp: handleKeyUp,
          className: classNames(prefixCls, _defineProperty({}, "".concat(prefixCls, "-disabled"), disabled), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.input),
          style: styles === null || styles === void 0 ? void 0 : styles.input,
          ref: inputRef,
          size: htmlSize,
          type: type2,
          onCompositionStart: function onCompositionStart(e2) {
            compositionRef.current = true;
            _onCompositionStart === null || _onCompositionStart === void 0 || _onCompositionStart(e2);
          },
          onCompositionEnd: onInternalCompositionEnd
        }));
      };
      var getSuffix = function getSuffix2() {
        var hasMaxLength = Number(mergedMax) > 0;
        if (suffix2 || countConfig.show) {
          var dataCount = countConfig.showFormatter ? countConfig.showFormatter({
            value: formatValue2,
            count: valueLength,
            maxLength: mergedMax
          }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : "");
          return /* @__PURE__ */ i.createElement(i.Fragment, null, countConfig.show && /* @__PURE__ */ i.createElement("span", {
            className: classNames("".concat(prefixCls, "-show-count-suffix"), _defineProperty({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix2), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.count),
            style: _objectSpread2$3({}, styles === null || styles === void 0 ? void 0 : styles.count)
          }, dataCount), suffix2);
        }
        return null;
      };
      return /* @__PURE__ */ i.createElement(BaseInput, _extends$2({}, rest, {
        prefixCls,
        className: classNames(className, outOfRangeCls),
        handleReset,
        value: formatValue2,
        focused,
        triggerFocus: focus,
        suffix: getSuffix(),
        disabled,
        classes,
        classNames: classNames$1,
        styles
      }), getInputElement());
    });
    function proxyObject(obj, extendProps) {
      if (typeof Proxy !== "undefined" && obj) {
        return new Proxy(obj, {
          get: function get2(target, prop) {
            if (extendProps[prop]) {
              return extendProps[prop];
            }
            var originProp = target[prop];
            return typeof originProp === "function" ? originProp.bind(target) : originProp;
          }
        });
      }
      return obj;
    }
    function useCursor(input, focused) {
      var selectionRef = reactExports.useRef(null);
      function recordCursor() {
        try {
          var start = input.selectionStart, end = input.selectionEnd, value = input.value;
          var beforeTxt = value.substring(0, start);
          var afterTxt = value.substring(end);
          selectionRef.current = {
            start,
            end,
            value,
            beforeTxt,
            afterTxt
          };
        } catch (e2) {
        }
      }
      function restoreCursor() {
        if (input && selectionRef.current && focused) {
          try {
            var value = input.value;
            var _selectionRef$current = selectionRef.current, beforeTxt = _selectionRef$current.beforeTxt, afterTxt = _selectionRef$current.afterTxt, start = _selectionRef$current.start;
            var startPos = value.length;
            if (value.startsWith(beforeTxt)) {
              startPos = beforeTxt.length;
            } else if (value.endsWith(afterTxt)) {
              startPos = value.length - selectionRef.current.afterTxt.length;
            } else {
              var beforeLastChar = beforeTxt[start - 1];
              var newIndex = value.indexOf(beforeLastChar, start - 1);
              if (newIndex !== -1) {
                startPos = newIndex + 1;
              }
            }
            input.setSelectionRange(startPos, startPos);
          } catch (e2) {
            warningOnce$1(false, "Something warning of cursor restore. Please fire issue about this: ".concat(e2.message));
          }
        }
      }
      return [recordCursor, restoreCursor];
    }
    var useMobile = function useMobile2() {
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
      useLayoutEffect$1(function() {
        setMobile(isMobile());
      }, []);
      return mobile;
    };
    var STEP_INTERVAL = 200;
    var STEP_DELAY = 600;
    function StepHandler(_ref) {
      var prefixCls = _ref.prefixCls, upNode = _ref.upNode, downNode = _ref.downNode, upDisabled = _ref.upDisabled, downDisabled = _ref.downDisabled, onStep = _ref.onStep;
      var stepTimeoutRef = reactExports.useRef();
      var frameIds = reactExports.useRef([]);
      var onStepRef = reactExports.useRef();
      onStepRef.current = onStep;
      var onStopStep = function onStopStep2() {
        clearTimeout(stepTimeoutRef.current);
      };
      var onStepMouseDown = function onStepMouseDown2(e2, up) {
        e2.preventDefault();
        onStopStep();
        onStepRef.current(up);
        function loopStep() {
          onStepRef.current(up);
          stepTimeoutRef.current = setTimeout(loopStep, STEP_INTERVAL);
        }
        stepTimeoutRef.current = setTimeout(loopStep, STEP_DELAY);
      };
      reactExports.useEffect(function() {
        return function() {
          onStopStep();
          frameIds.current.forEach(function(id) {
            return wrapperRaf.cancel(id);
          });
        };
      }, []);
      var isMobile2 = useMobile();
      if (isMobile2) {
        return null;
      }
      var handlerClassName = "".concat(prefixCls, "-handler");
      var upClassName = classNames(handlerClassName, "".concat(handlerClassName, "-up"), _defineProperty({}, "".concat(handlerClassName, "-up-disabled"), upDisabled));
      var downClassName = classNames(handlerClassName, "".concat(handlerClassName, "-down"), _defineProperty({}, "".concat(handlerClassName, "-down-disabled"), downDisabled));
      var safeOnStopStep = function safeOnStopStep2() {
        return frameIds.current.push(wrapperRaf(onStopStep));
      };
      var sharedHandlerProps = {
        unselectable: "on",
        role: "button",
        onMouseUp: safeOnStopStep,
        onMouseLeave: safeOnStopStep
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(handlerClassName, "-wrap")
      }, /* @__PURE__ */ reactExports.createElement("span", _extends$2({}, sharedHandlerProps, {
        onMouseDown: function onMouseDown(e2) {
          onStepMouseDown(e2, true);
        },
        "aria-label": "Increase Value",
        "aria-disabled": upDisabled,
        className: upClassName
      }), upNode || /* @__PURE__ */ reactExports.createElement("span", {
        unselectable: "on",
        className: "".concat(prefixCls, "-handler-up-inner")
      })), /* @__PURE__ */ reactExports.createElement("span", _extends$2({}, sharedHandlerProps, {
        onMouseDown: function onMouseDown(e2) {
          onStepMouseDown(e2, false);
        },
        "aria-label": "Decrease Value",
        "aria-disabled": downDisabled,
        className: downClassName
      }), downNode || /* @__PURE__ */ reactExports.createElement("span", {
        unselectable: "on",
        className: "".concat(prefixCls, "-handler-down-inner")
      })));
    }
    function getDecupleSteps(step) {
      var stepStr = typeof step === "number" ? num2str(step) : trimNumber(step).fullStr;
      var hasPoint = stepStr.includes(".");
      if (!hasPoint) {
        return step + "0";
      }
      return trimNumber(stepStr.replace(/(\d)\.(\d)/g, "$1$2.")).fullStr;
    }
    const useFrame = function() {
      var idRef = reactExports.useRef(0);
      var cleanUp = function cleanUp2() {
        wrapperRaf.cancel(idRef.current);
      };
      reactExports.useEffect(function() {
        return cleanUp;
      }, []);
      return function(callback) {
        cleanUp();
        idRef.current = wrapperRaf(function() {
          callback();
        });
      };
    };
    var _excluded$6 = ["prefixCls", "className", "style", "min", "max", "step", "defaultValue", "value", "disabled", "readOnly", "upHandler", "downHandler", "keyboard", "changeOnWheel", "controls", "classNames", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep", "changeOnBlur", "domRef"], _excluded2 = ["disabled", "style", "prefixCls", "value", "prefix", "suffix", "addonBefore", "addonAfter", "className", "classNames"];
    var getDecimalValue = function getDecimalValue2(stringMode, decimalValue) {
      if (stringMode || decimalValue.isEmpty()) {
        return decimalValue.toString();
      }
      return decimalValue.toNumber();
    };
    var getDecimalIfValidate = function getDecimalIfValidate2(value) {
      var decimal = getMiniDecimal(value);
      return decimal.isInvalidate() ? null : decimal;
    };
    var InternalInputNumber = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, className = props.className, style2 = props.style, min = props.min, max = props.max, _props$step = props.step, step = _props$step === void 0 ? 1 : _props$step, defaultValue = props.defaultValue, value = props.value, disabled = props.disabled, readOnly = props.readOnly, upHandler = props.upHandler, downHandler = props.downHandler, keyboard = props.keyboard, _props$changeOnWheel = props.changeOnWheel, changeOnWheel = _props$changeOnWheel === void 0 ? false : _props$changeOnWheel, _props$controls = props.controls, controls = _props$controls === void 0 ? true : _props$controls;
      props.classNames;
      var stringMode = props.stringMode, parser = props.parser, formatter = props.formatter, precision = props.precision, decimalSeparator = props.decimalSeparator, onChange = props.onChange, onInput = props.onInput, onPressEnter = props.onPressEnter, onStep = props.onStep, _props$changeOnBlur = props.changeOnBlur, changeOnBlur = _props$changeOnBlur === void 0 ? true : _props$changeOnBlur, domRef = props.domRef, inputProps = _objectWithoutProperties(props, _excluded$6);
      var inputClassName = "".concat(prefixCls, "-input");
      var inputRef = reactExports.useRef(null);
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focus = _React$useState2[0], setFocus = _React$useState2[1];
      var userTypingRef = reactExports.useRef(false);
      var compositionRef = reactExports.useRef(false);
      var shiftKeyRef = reactExports.useRef(false);
      var _React$useState3 = reactExports.useState(function() {
        return getMiniDecimal(value !== null && value !== void 0 ? value : defaultValue);
      }), _React$useState4 = _slicedToArray(_React$useState3, 2), decimalValue = _React$useState4[0], setDecimalValue = _React$useState4[1];
      function setUncontrolledDecimalValue(newDecimal) {
        if (value === void 0) {
          setDecimalValue(newDecimal);
        }
      }
      var getPrecision = reactExports.useCallback(function(numStr, userTyping) {
        if (userTyping) {
          return void 0;
        }
        if (precision >= 0) {
          return precision;
        }
        return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));
      }, [precision, step]);
      var mergedParser = reactExports.useCallback(function(num) {
        var numStr = String(num);
        if (parser) {
          return parser(numStr);
        }
        var parsedStr = numStr;
        if (decimalSeparator) {
          parsedStr = parsedStr.replace(decimalSeparator, ".");
        }
        return parsedStr.replace(/[^\w.-]+/g, "");
      }, [parser, decimalSeparator]);
      var inputValueRef = reactExports.useRef("");
      var mergedFormatter = reactExports.useCallback(function(number2, userTyping) {
        if (formatter) {
          return formatter(number2, {
            userTyping,
            input: String(inputValueRef.current)
          });
        }
        var str = typeof number2 === "number" ? num2str(number2) : number2;
        if (!userTyping) {
          var mergedPrecision = getPrecision(str, userTyping);
          if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) {
            var separatorStr = decimalSeparator || ".";
            str = toFixed(str, separatorStr, mergedPrecision);
          }
        }
        return str;
      }, [formatter, getPrecision, decimalSeparator]);
      var _React$useState5 = reactExports.useState(function() {
        var initValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : value;
        if (decimalValue.isInvalidate() && ["string", "number"].includes(_typeof$1(initValue))) {
          return Number.isNaN(initValue) ? "" : initValue;
        }
        return mergedFormatter(decimalValue.toString(), false);
      }), _React$useState6 = _slicedToArray(_React$useState5, 2), inputValue = _React$useState6[0], setInternalInputValue = _React$useState6[1];
      inputValueRef.current = inputValue;
      function setInputValue(newValue, userTyping) {
        setInternalInputValue(mergedFormatter(
          // Invalidate number is sometime passed by external control, we should let it go
          // Otherwise is controlled by internal interactive logic which check by userTyping
          // You can ref 'show limited value when input is not focused' test for more info.
          newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping),
          userTyping
        ));
      }
      var maxDecimal = reactExports.useMemo(function() {
        return getDecimalIfValidate(max);
      }, [max, precision]);
      var minDecimal = reactExports.useMemo(function() {
        return getDecimalIfValidate(min);
      }, [min, precision]);
      var upDisabled = reactExports.useMemo(function() {
        if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) {
          return false;
        }
        return maxDecimal.lessEquals(decimalValue);
      }, [maxDecimal, decimalValue]);
      var downDisabled = reactExports.useMemo(function() {
        if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) {
          return false;
        }
        return decimalValue.lessEquals(minDecimal);
      }, [minDecimal, decimalValue]);
      var _useCursor = useCursor(inputRef.current, focus), _useCursor2 = _slicedToArray(_useCursor, 2), recordCursor = _useCursor2[0], restoreCursor = _useCursor2[1];
      var getRangeValue = function getRangeValue2(target) {
        if (maxDecimal && !target.lessEquals(maxDecimal)) {
          return maxDecimal;
        }
        if (minDecimal && !minDecimal.lessEquals(target)) {
          return minDecimal;
        }
        return null;
      };
      var isInRange2 = function isInRange22(target) {
        return !getRangeValue(target);
      };
      var triggerValueUpdate = function triggerValueUpdate2(newValue, userTyping) {
        var updateValue = newValue;
        var isRangeValidate = isInRange2(updateValue) || updateValue.isEmpty();
        if (!updateValue.isEmpty() && !userTyping) {
          updateValue = getRangeValue(updateValue) || updateValue;
          isRangeValidate = true;
        }
        if (!readOnly && !disabled && isRangeValidate) {
          var numStr = updateValue.toString();
          var mergedPrecision = getPrecision(numStr, userTyping);
          if (mergedPrecision >= 0) {
            updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision));
            if (!isInRange2(updateValue)) {
              updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision, true));
            }
          }
          if (!updateValue.equals(decimalValue)) {
            setUncontrolledDecimalValue(updateValue);
            onChange === null || onChange === void 0 || onChange(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));
            if (value === void 0) {
              setInputValue(updateValue, userTyping);
            }
          }
          return updateValue;
        }
        return decimalValue;
      };
      var onNextPromise = useFrame();
      var collectInputValue = function collectInputValue2(inputStr) {
        recordCursor();
        inputValueRef.current = inputStr;
        setInternalInputValue(inputStr);
        if (!compositionRef.current) {
          var finalValue = mergedParser(inputStr);
          var finalDecimal = getMiniDecimal(finalValue);
          if (!finalDecimal.isNaN()) {
            triggerValueUpdate(finalDecimal, true);
          }
        }
        onInput === null || onInput === void 0 || onInput(inputStr);
        onNextPromise(function() {
          var nextInputStr = inputStr;
          if (!parser) {
            nextInputStr = inputStr.replace(//g, ".");
          }
          if (nextInputStr !== inputStr) {
            collectInputValue2(nextInputStr);
          }
        });
      };
      var onCompositionStart = function onCompositionStart2() {
        compositionRef.current = true;
      };
      var onCompositionEnd = function onCompositionEnd2() {
        compositionRef.current = false;
        collectInputValue(inputRef.current.value);
      };
      var onInternalInput = function onInternalInput2(e2) {
        collectInputValue(e2.target.value);
      };
      var onInternalStep = function onInternalStep2(up) {
        var _inputRef$current;
        if (up && upDisabled || !up && downDisabled) {
          return;
        }
        userTypingRef.current = false;
        var stepDecimal = getMiniDecimal(shiftKeyRef.current ? getDecupleSteps(step) : step);
        if (!up) {
          stepDecimal = stepDecimal.negate();
        }
        var target = (decimalValue || getMiniDecimal(0)).add(stepDecimal.toString());
        var updatedValue = triggerValueUpdate(target, false);
        onStep === null || onStep === void 0 || onStep(getDecimalValue(stringMode, updatedValue), {
          offset: shiftKeyRef.current ? getDecupleSteps(step) : step,
          type: up ? "up" : "down"
        });
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus();
      };
      var flushInputValue = function flushInputValue2(userTyping) {
        var parsedValue = getMiniDecimal(mergedParser(inputValue));
        var formatValue2;
        if (!parsedValue.isNaN()) {
          formatValue2 = triggerValueUpdate(parsedValue, userTyping);
        } else {
          formatValue2 = triggerValueUpdate(decimalValue, userTyping);
        }
        if (value !== void 0) {
          setInputValue(decimalValue, false);
        } else if (!formatValue2.isNaN()) {
          setInputValue(formatValue2, false);
        }
      };
      var onBeforeInput = function onBeforeInput2() {
        userTypingRef.current = true;
      };
      var onKeyDown = function onKeyDown2(event) {
        var key = event.key, shiftKey = event.shiftKey;
        userTypingRef.current = true;
        shiftKeyRef.current = shiftKey;
        if (key === "Enter") {
          if (!compositionRef.current) {
            userTypingRef.current = false;
          }
          flushInputValue(false);
          onPressEnter === null || onPressEnter === void 0 || onPressEnter(event);
        }
        if (keyboard === false) {
          return;
        }
        if (!compositionRef.current && ["Up", "ArrowUp", "Down", "ArrowDown"].includes(key)) {
          onInternalStep(key === "Up" || key === "ArrowUp");
          event.preventDefault();
        }
      };
      var onKeyUp = function onKeyUp2() {
        userTypingRef.current = false;
        shiftKeyRef.current = false;
      };
      reactExports.useEffect(function() {
        if (changeOnWheel && focus) {
          var onWheel = function onWheel2(event) {
            onInternalStep(event.deltaY < 0);
            event.preventDefault();
          };
          var input = inputRef.current;
          if (input) {
            input.addEventListener("wheel", onWheel, {
              passive: false
            });
            return function() {
              return input.removeEventListener("wheel", onWheel);
            };
          }
        }
      });
      var onBlur = function onBlur2() {
        if (changeOnBlur) {
          flushInputValue(false);
        }
        setFocus(false);
        userTypingRef.current = false;
      };
      useLayoutUpdateEffect(function() {
        if (!decimalValue.isInvalidate()) {
          setInputValue(decimalValue, false);
        }
      }, [precision, formatter]);
      useLayoutUpdateEffect(function() {
        var newValue = getMiniDecimal(value);
        setDecimalValue(newValue);
        var currentParsedValue = getMiniDecimal(mergedParser(inputValue));
        if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) {
          setInputValue(newValue, userTypingRef.current);
        }
      }, [value]);
      useLayoutUpdateEffect(function() {
        if (formatter) {
          restoreCursor();
        }
      }, [inputValue]);
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: domRef,
        className: classNames(prefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-focused"), focus), "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-readonly"), readOnly), "".concat(prefixCls, "-not-a-number"), decimalValue.isNaN()), "".concat(prefixCls, "-out-of-range"), !decimalValue.isInvalidate() && !isInRange2(decimalValue))),
        style: style2,
        onFocus: function onFocus() {
          setFocus(true);
        },
        onBlur,
        onKeyDown,
        onKeyUp,
        onCompositionStart,
        onCompositionEnd,
        onBeforeInput
      }, controls && /* @__PURE__ */ reactExports.createElement(StepHandler, {
        prefixCls,
        upNode: upHandler,
        downNode: downHandler,
        upDisabled,
        downDisabled,
        onStep: onInternalStep
      }), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(inputClassName, "-wrap")
      }, /* @__PURE__ */ reactExports.createElement("input", _extends$2({
        autoComplete: "off",
        role: "spinbutton",
        "aria-valuemin": min,
        "aria-valuemax": max,
        "aria-valuenow": decimalValue.isInvalidate() ? null : decimalValue.toString(),
        step
      }, inputProps, {
        ref: composeRef(inputRef, ref),
        className: inputClassName,
        value: inputValue,
        onChange: onInternalInput,
        disabled,
        readOnly
      }))));
    });
    var InputNumber$1 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var disabled = props.disabled, style2 = props.style, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input-number" : _props$prefixCls, value = props.value, prefix2 = props.prefix, suffix2 = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, classNames2 = props.classNames, rest = _objectWithoutProperties(props, _excluded2);
      var holderRef = reactExports.useRef(null);
      var inputNumberDomRef = reactExports.useRef(null);
      var inputFocusRef = reactExports.useRef(null);
      var focus = function focus2(option) {
        if (inputFocusRef.current) {
          triggerFocus(inputFocusRef.current, option);
        }
      };
      reactExports.useImperativeHandle(ref, function() {
        return proxyObject(inputFocusRef.current, {
          focus,
          nativeElement: holderRef.current.nativeElement || inputNumberDomRef.current
        });
      });
      return /* @__PURE__ */ reactExports.createElement(BaseInput, {
        className,
        triggerFocus: focus,
        prefixCls,
        value,
        disabled,
        style: style2,
        prefix: prefix2,
        suffix: suffix2,
        addonAfter,
        addonBefore,
        classNames: classNames2,
        components: {
          affixWrapper: "div",
          groupWrapper: "div",
          wrapper: "div",
          groupAddon: "div"
        },
        ref: holderRef
      }, /* @__PURE__ */ reactExports.createElement(InternalInputNumber, _extends$2({
        prefixCls,
        disabled,
        ref: inputFocusRef,
        domRef: inputNumberDomRef,
        className: classNames2 === null || classNames2 === void 0 ? void 0 : classNames2.input
      }, rest)));
    });
    const prepareComponentToken$a = (token2) => {
      var _a;
      const handleVisible = (_a = token2.handleVisible) !== null && _a !== void 0 ? _a : "auto";
      const handleWidth = token2.controlHeightSM - token2.lineWidth * 2;
      return Object.assign(Object.assign({}, initComponentToken(token2)), {
        controlWidth: 90,
        handleWidth,
        handleFontSize: token2.fontSize / 2,
        handleVisible,
        handleActiveBg: token2.colorFillAlter,
        handleBg: token2.colorBgContainer,
        filledHandleBg: new FastColor(token2.colorFillSecondary).onBackground(token2.colorBgContainer).toHexString(),
        handleHoverColor: token2.colorPrimary,
        handleBorderColor: token2.colorBorder,
        handleOpacity: handleVisible === true ? 1 : 0,
        handleVisibleWidth: handleVisible === true ? handleWidth : 0
      });
    };
    const genRadiusStyle = (_ref, size) => {
      let {
        componentCls,
        borderRadiusSM,
        borderRadiusLG
      } = _ref;
      const borderRadius = size === "lg" ? borderRadiusLG : borderRadiusSM;
      return {
        [`&-${size}`]: {
          [`${componentCls}-handler-wrap`]: {
            borderStartEndRadius: borderRadius,
            borderEndEndRadius: borderRadius
          },
          [`${componentCls}-handler-up`]: {
            borderStartEndRadius: borderRadius
          },
          [`${componentCls}-handler-down`]: {
            borderEndEndRadius: borderRadius
          }
        }
      };
    };
    const genInputNumberStyles = (token2) => {
      const {
        componentCls,
        lineWidth,
        lineType,
        borderRadius,
        inputFontSizeSM,
        inputFontSizeLG,
        controlHeightLG,
        controlHeightSM,
        colorError,
        paddingInlineSM,
        paddingBlockSM,
        paddingBlockLG,
        paddingInlineLG,
        colorTextDescription,
        motionDurationMid,
        handleHoverColor,
        handleOpacity,
        paddingInline,
        paddingBlock,
        handleBg,
        handleActiveBg,
        colorTextDisabled,
        borderRadiusSM,
        borderRadiusLG,
        controlWidth,
        handleBorderColor,
        filledHandleBg,
        lineHeightLG,
        calc
      } = token2;
      return [
        {
          [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genBasicInputStyle(token2)), {
            display: "inline-block",
            width: controlWidth,
            margin: 0,
            padding: 0,
            borderRadius
          }), genOutlinedStyle(token2, {
            [`${componentCls}-handler-wrap`]: {
              background: handleBg,
              [`${componentCls}-handler-down`]: {
                borderBlockStart: `${unit$1(lineWidth)} ${lineType} ${handleBorderColor}`
              }
            }
          })), genFilledStyle(token2, {
            [`${componentCls}-handler-wrap`]: {
              background: filledHandleBg,
              [`${componentCls}-handler-down`]: {
                borderBlockStart: `${unit$1(lineWidth)} ${lineType} ${handleBorderColor}`
              }
            },
            "&:focus-within": {
              [`${componentCls}-handler-wrap`]: {
                background: handleBg
              }
            }
          })), genUnderlinedStyle(token2, {
            [`${componentCls}-handler-wrap`]: {
              background: handleBg,
              [`${componentCls}-handler-down`]: {
                borderBlockStart: `${unit$1(lineWidth)} ${lineType} ${handleBorderColor}`
              }
            }
          })), genBorderlessStyle(token2)), {
            "&-rtl": {
              direction: "rtl",
              [`${componentCls}-input`]: {
                direction: "rtl"
              }
            },
            "&-lg": {
              padding: 0,
              fontSize: inputFontSizeLG,
              lineHeight: lineHeightLG,
              borderRadius: borderRadiusLG,
              [`input${componentCls}-input`]: {
                height: calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal(),
                padding: `${unit$1(paddingBlockLG)} ${unit$1(paddingInlineLG)}`
              }
            },
            "&-sm": {
              padding: 0,
              fontSize: inputFontSizeSM,
              borderRadius: borderRadiusSM,
              [`input${componentCls}-input`]: {
                height: calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal(),
                padding: `${unit$1(paddingBlockSM)} ${unit$1(paddingInlineSM)}`
              }
            },
            // ===================== Out Of Range =====================
            "&-out-of-range": {
              [`${componentCls}-input-wrap`]: {
                input: {
                  color: colorError
                }
              }
            },
            // Style for input-group: input with label, with button or dropdown...
            "&-group": Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genInputGroupStyle(token2)), {
              "&-wrapper": Object.assign(Object.assign(Object.assign({
                display: "inline-block",
                textAlign: "start",
                verticalAlign: "top",
                [`${componentCls}-affix-wrapper`]: {
                  width: "100%"
                },
                // Size
                "&-lg": {
                  [`${componentCls}-group-addon`]: {
                    borderRadius: borderRadiusLG,
                    fontSize: token2.fontSizeLG
                  }
                },
                "&-sm": {
                  [`${componentCls}-group-addon`]: {
                    borderRadius: borderRadiusSM
                  }
                }
              }, genOutlinedGroupStyle(token2)), genFilledGroupStyle(token2)), {
                // Fix the issue of using icons in Space Compact mode
                // https://github.com/ant-design/ant-design/issues/45764
                [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
                  [`${componentCls}, ${componentCls}-group-addon`]: {
                    borderRadius: 0
                  }
                },
                [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
                  [`${componentCls}, ${componentCls}-group-addon`]: {
                    borderStartEndRadius: 0,
                    borderEndEndRadius: 0
                  }
                },
                [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
                  [`${componentCls}, ${componentCls}-group-addon`]: {
                    borderStartStartRadius: 0,
                    borderEndStartRadius: 0
                  }
                }
              })
            }),
            [`&-disabled ${componentCls}-input`]: {
              cursor: "not-allowed"
            },
            [componentCls]: {
              "&-input": Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
                width: "100%",
                padding: `${unit$1(paddingBlock)} ${unit$1(paddingInline)}`,
                textAlign: "start",
                backgroundColor: "transparent",
                border: 0,
                borderRadius,
                outline: 0,
                transition: `all ${motionDurationMid} linear`,
                appearance: "textfield",
                fontSize: "inherit"
              }), genPlaceholderStyle(token2.colorTextPlaceholder)), {
                '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
                  margin: 0,
                  appearance: "none"
                }
              })
            },
            [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
              width: token2.handleWidth,
              opacity: 1
            }
          })
        },
        // Handler
        {
          [componentCls]: Object.assign(Object.assign(Object.assign({
            [`${componentCls}-handler-wrap`]: {
              position: "absolute",
              insetBlockStart: 0,
              insetInlineEnd: 0,
              width: token2.handleVisibleWidth,
              opacity: handleOpacity,
              height: "100%",
              borderStartStartRadius: 0,
              borderStartEndRadius: borderRadius,
              borderEndEndRadius: borderRadius,
              borderEndStartRadius: 0,
              display: "flex",
              flexDirection: "column",
              alignItems: "stretch",
              transition: `all ${motionDurationMid}`,
              overflow: "hidden",
              // Fix input number inside Menu makes icon too large
              // We arise the selector priority by nest selector here
              // https://github.com/ant-design/ant-design/issues/14367
              [`${componentCls}-handler`]: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                flex: "auto",
                height: "40%",
                [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
                  marginInlineEnd: 0,
                  fontSize: token2.handleFontSize
                }
              }
            },
            [`${componentCls}-handler`]: {
              height: "50%",
              overflow: "hidden",
              color: colorTextDescription,
              fontWeight: "bold",
              lineHeight: 0,
              textAlign: "center",
              cursor: "pointer",
              borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${handleBorderColor}`,
              transition: `all ${motionDurationMid} linear`,
              "&:active": {
                background: handleActiveBg
              },
              // Hover
              "&:hover": {
                height: `60%`,
                [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
                  color: handleHoverColor
                }
              },
              "&-up-inner, &-down-inner": Object.assign(Object.assign({}, resetIcon()), {
                color: colorTextDescription,
                transition: `all ${motionDurationMid} linear`,
                userSelect: "none"
              })
            },
            [`${componentCls}-handler-up`]: {
              borderStartEndRadius: borderRadius
            },
            [`${componentCls}-handler-down`]: {
              borderEndEndRadius: borderRadius
            }
          }, genRadiusStyle(token2, "lg")), genRadiusStyle(token2, "sm")), {
            // Disabled
            "&-disabled, &-readonly": {
              [`${componentCls}-handler-wrap`]: {
                display: "none"
              },
              [`${componentCls}-input`]: {
                color: "inherit"
              }
            },
            [`
          ${componentCls}-handler-up-disabled,
          ${componentCls}-handler-down-disabled
        `]: {
              cursor: "not-allowed"
            },
            [`
          ${componentCls}-handler-up-disabled:hover &-handler-up-inner,
          ${componentCls}-handler-down-disabled:hover &-handler-down-inner
        `]: {
              color: colorTextDisabled
            }
          })
        }
      ];
    };
    const genAffixWrapperStyles = (token2) => {
      const {
        componentCls,
        paddingBlock,
        paddingInline,
        inputAffixPadding,
        controlWidth,
        borderRadiusLG,
        borderRadiusSM,
        paddingInlineLG,
        paddingInlineSM,
        paddingBlockLG,
        paddingBlockSM,
        motionDurationMid
      } = token2;
      return {
        [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign({
          [`input${componentCls}-input`]: {
            padding: `${unit$1(paddingBlock)} 0`
          }
        }, genBasicInputStyle(token2)), {
          // or number handler will cover form status
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          width: controlWidth,
          padding: 0,
          paddingInlineStart: paddingInline,
          "&-lg": {
            borderRadius: borderRadiusLG,
            paddingInlineStart: paddingInlineLG,
            [`input${componentCls}-input`]: {
              padding: `${unit$1(paddingBlockLG)} 0`
            }
          },
          "&-sm": {
            borderRadius: borderRadiusSM,
            paddingInlineStart: paddingInlineSM,
            [`input${componentCls}-input`]: {
              padding: `${unit$1(paddingBlockSM)} 0`
            }
          },
          [`&:not(${componentCls}-disabled):hover`]: {
            zIndex: 1
          },
          "&-focused, &:focus": {
            zIndex: 1
          },
          [`&-disabled > ${componentCls}-disabled`]: {
            background: "transparent"
          },
          [`> div${componentCls}`]: {
            width: "100%",
            border: "none",
            outline: "none",
            [`&${componentCls}-focused`]: {
              boxShadow: "none !important"
            }
          },
          "&::before": {
            display: "inline-block",
            width: 0,
            visibility: "hidden",
            content: '"\\a0"'
          },
          [`${componentCls}-handler-wrap`]: {
            zIndex: 2
          },
          [componentCls]: {
            position: "static",
            color: "inherit",
            "&-prefix, &-suffix": {
              display: "flex",
              flex: "none",
              alignItems: "center",
              pointerEvents: "none"
            },
            "&-prefix": {
              marginInlineEnd: inputAffixPadding
            },
            "&-suffix": {
              insetBlockStart: 0,
              insetInlineEnd: 0,
              height: "100%",
              marginInlineEnd: paddingInline,
              marginInlineStart: inputAffixPadding,
              transition: `margin ${motionDurationMid}`
            }
          },
          [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
            width: token2.handleWidth,
            opacity: 1
          },
          [`&:not(${componentCls}-affix-wrapper-without-controls):hover ${componentCls}-suffix`]: {
            marginInlineEnd: token2.calc(token2.handleWidth).add(paddingInline).equal()
          }
        })
      };
    };
    const useStyle$c = genStyleHooks("InputNumber", (token2) => {
      const inputNumberToken = merge(token2, initInputToken(token2));
      return [
        genInputNumberStyles(inputNumberToken),
        genAffixWrapperStyles(inputNumberToken),
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        genCompactItemStyle(inputNumberToken)
      ];
    }, prepareComponentToken$a, {
      unitless: {
        handleOpacity: true
      }
    });
    var __rest$w = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const InputNumber = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const inputRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, () => inputRef.current);
      const {
        className,
        rootClassName,
        size: customizeSize,
        disabled: customDisabled,
        prefixCls: customizePrefixCls,
        addonBefore,
        addonAfter,
        prefix: prefix2,
        suffix: suffix2,
        bordered,
        readOnly,
        status: customStatus,
        controls,
        variant: customVariant
      } = props, others = __rest$w(props, ["className", "rootClassName", "size", "disabled", "prefixCls", "addonBefore", "addonAfter", "prefix", "suffix", "bordered", "readOnly", "status", "controls", "variant"]);
      const prefixCls = getPrefixCls("input-number", customizePrefixCls);
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$c(prefixCls, rootCls);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      let upIcon = /* @__PURE__ */ reactExports.createElement(RefIcon$o, {
        className: `${prefixCls}-handler-up-inner`
      });
      let downIcon = /* @__PURE__ */ reactExports.createElement(RefIcon$u, {
        className: `${prefixCls}-handler-down-inner`
      });
      const controlsTemp = typeof controls === "boolean" ? controls : void 0;
      if (typeof controls === "object") {
        upIcon = typeof controls.upIcon === "undefined" ? upIcon : /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-handler-up-inner`
        }, controls.upIcon);
        downIcon = typeof controls.downIcon === "undefined" ? downIcon : /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-handler-down-inner`
        }, controls.downIcon);
      }
      const {
        hasFeedback,
        status: contextStatus,
        isFormItemInput,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      const mergedSize = useSize((ctx) => {
        var _a;
        return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
      });
      const disabled = reactExports.useContext(DisabledContext);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const [variant, enableVariantCls] = useVariant("inputNumber", customVariant, bordered);
      const suffixNode = hasFeedback && /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, feedbackIcon);
      const inputNumberClass = classNames({
        [`${prefixCls}-lg`]: mergedSize === "large",
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-in-form-item`]: isFormItemInput
      }, hashId);
      const wrapperClassName = `${prefixCls}-group`;
      const element = /* @__PURE__ */ reactExports.createElement(InputNumber$1, Object.assign({
        ref: inputRef,
        disabled: mergedDisabled,
        className: classNames(cssVarCls, rootCls, className, rootClassName, compactItemClassnames),
        upHandler: upIcon,
        downHandler: downIcon,
        prefixCls,
        readOnly,
        controls: controlsTemp,
        prefix: prefix2,
        suffix: suffixNode || suffix2,
        addonBefore: addonBefore && /* @__PURE__ */ reactExports.createElement(ContextIsolator, {
          form: true,
          space: true
        }, addonBefore),
        addonAfter: addonAfter && /* @__PURE__ */ reactExports.createElement(ContextIsolator, {
          form: true,
          space: true
        }, addonAfter),
        classNames: {
          input: inputNumberClass,
          variant: classNames({
            [`${prefixCls}-${variant}`]: enableVariantCls
          }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback)),
          affixWrapper: classNames({
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-affix-wrapper-without-controls`]: controls === false || mergedDisabled
          }, hashId),
          wrapper: classNames({
            [`${wrapperClassName}-rtl`]: direction === "rtl"
          }, hashId),
          groupWrapper: classNames({
            [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
          }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
        }
      }, others));
      return wrapCSSVar(element);
    });
    const TypedInputNumber = InputNumber;
    const PureInputNumber = (props) => /* @__PURE__ */ reactExports.createElement(ConfigProvider, {
      theme: {
        components: {
          InputNumber: {
            handleVisible: true
          }
        }
      }
    }, /* @__PURE__ */ reactExports.createElement(InputNumber, Object.assign({}, props)));
    TypedInputNumber._InternalPanelDoNotUseOrYouWillBeFired = PureInputNumber;
    const getAllowClear = (allowClear) => {
      let mergedAllowClear;
      if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
        mergedAllowClear = allowClear;
      } else if (allowClear) {
        mergedAllowClear = {
          clearIcon: /* @__PURE__ */ i.createElement(RefIcon$B, null)
        };
      }
      return mergedAllowClear;
    };
    function useRemovePasswordTimeout(inputRef, triggerOnMount) {
      const removePasswordTimeoutRef = reactExports.useRef([]);
      const removePasswordTimeout = () => {
        removePasswordTimeoutRef.current.push(setTimeout(() => {
          var _a, _b, _c, _d;
          if (((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) {
            (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
          }
        }));
      };
      reactExports.useEffect(() => {
        if (triggerOnMount) {
          removePasswordTimeout();
        }
        return () => removePasswordTimeoutRef.current.forEach((timer) => {
          if (timer) {
            clearTimeout(timer);
          }
        });
      }, []);
      return removePasswordTimeout;
    }
    function hasPrefixSuffix(props) {
      return !!(props.prefix || props.suffix || props.allowClear || props.showCount);
    }
    var __rest$v = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const Input$2 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        bordered = true,
        status: customStatus,
        size: customSize,
        disabled: customDisabled,
        onBlur,
        onFocus,
        suffix: suffix2,
        allowClear,
        addonAfter,
        addonBefore,
        className,
        style: style2,
        styles,
        rootClassName,
        onChange,
        classNames: classes,
        variant: customVariant
      } = props, rest = __rest$v(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "style", "styles", "rootClassName", "onChange", "classNames", "variant"]);
      const {
        getPrefixCls,
        direction,
        allowClear: contextAllowClear,
        autoComplete: contextAutoComplete,
        className: contextClassName,
        style: contextStyle,
        classNames: contextClassNames,
        styles: contextStyles
      } = useComponentConfig("input");
      const prefixCls = getPrefixCls("input", customizePrefixCls);
      const inputRef = reactExports.useRef(null);
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapSharedCSSVar, hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
      const [wrapCSSVar] = useStyle$h(prefixCls, rootCls);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const mergedSize = useSize((ctx) => {
        var _a;
        return (_a = customSize !== null && customSize !== void 0 ? customSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
      });
      const disabled = i.useContext(DisabledContext);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const {
        status: contextStatus,
        hasFeedback,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      const inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
      reactExports.useRef(inputHasPrefixSuffix);
      const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
      const handleBlur = (e2) => {
        removePasswordTimeout();
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
      };
      const handleFocus = (e2) => {
        removePasswordTimeout();
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
      };
      const handleChange = (e2) => {
        removePasswordTimeout();
        onChange === null || onChange === void 0 ? void 0 : onChange(e2);
      };
      const suffixNode = (hasFeedback || suffix2) && /* @__PURE__ */ i.createElement(i.Fragment, null, suffix2, hasFeedback && feedbackIcon);
      const mergedAllowClear = getAllowClear(allowClear !== null && allowClear !== void 0 ? allowClear : contextAllowClear);
      const [variant, enableVariantCls] = useVariant("input", customVariant, bordered);
      return wrapSharedCSSVar(wrapCSSVar(/* @__PURE__ */ i.createElement(Input$3, Object.assign({
        ref: composeRef(ref, inputRef),
        prefixCls,
        autoComplete: contextAutoComplete
      }, rest, {
        disabled: mergedDisabled,
        onBlur: handleBlur,
        onFocus: handleFocus,
        style: Object.assign(Object.assign({}, contextStyle), style2),
        styles: Object.assign(Object.assign({}, contextStyles), styles),
        suffix: suffixNode,
        allowClear: mergedAllowClear,
        className: classNames(className, rootClassName, cssVarCls, rootCls, compactItemClassnames, contextClassName),
        onChange: handleChange,
        addonBefore: addonBefore && /* @__PURE__ */ i.createElement(ContextIsolator, {
          form: true,
          space: true
        }, addonBefore),
        addonAfter: addonAfter && /* @__PURE__ */ i.createElement(ContextIsolator, {
          form: true,
          space: true
        }, addonAfter),
        classNames: Object.assign(Object.assign(Object.assign({}, classes), contextClassNames), {
          input: classNames({
            [`${prefixCls}-sm`]: mergedSize === "small",
            [`${prefixCls}-lg`]: mergedSize === "large",
            [`${prefixCls}-rtl`]: direction === "rtl"
          }, classes === null || classes === void 0 ? void 0 : classes.input, contextClassNames.input, hashId),
          variant: classNames({
            [`${prefixCls}-${variant}`]: enableVariantCls
          }, getStatusClassNames(prefixCls, mergedStatus)),
          affixWrapper: classNames({
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl"
          }, hashId),
          wrapper: classNames({
            [`${prefixCls}-group-rtl`]: direction === "rtl"
          }, hashId),
          groupWrapper: classNames({
            [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
          }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
        })
      }))));
    });
    var CalendarOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" } }] }, "name": "calendar", "theme": "outlined" };
    var CalendarOutlined = function CalendarOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: CalendarOutlined$1
      }));
    };
    var RefIcon$n = /* @__PURE__ */ reactExports.forwardRef(CalendarOutlined);
    var ClockCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] }, "name": "clock-circle", "theme": "outlined" };
    var ClockCircleOutlined = function ClockCircleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: ClockCircleOutlined$1
      }));
    };
    var RefIcon$m = /* @__PURE__ */ reactExports.forwardRef(ClockCircleOutlined);
    var SwapRightOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" } }] }, "name": "swap-right", "theme": "outlined" };
    var SwapRightOutlined = function SwapRightOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: SwapRightOutlined$1
      }));
    };
    var RefIcon$l = /* @__PURE__ */ reactExports.forwardRef(SwapRightOutlined);
    function getPlaceholder(locale2, picker, customizePlaceholder) {
      if (customizePlaceholder !== void 0) {
        return customizePlaceholder;
      }
      if (picker === "year" && locale2.lang.yearPlaceholder) {
        return locale2.lang.yearPlaceholder;
      }
      if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
        return locale2.lang.quarterPlaceholder;
      }
      if (picker === "month" && locale2.lang.monthPlaceholder) {
        return locale2.lang.monthPlaceholder;
      }
      if (picker === "week" && locale2.lang.weekPlaceholder) {
        return locale2.lang.weekPlaceholder;
      }
      if (picker === "time" && locale2.timePickerLocale.placeholder) {
        return locale2.timePickerLocale.placeholder;
      }
      return locale2.lang.placeholder;
    }
    function getRangePlaceholder(locale2, picker, customizePlaceholder) {
      if (customizePlaceholder !== void 0) {
        return customizePlaceholder;
      }
      if (picker === "year" && locale2.lang.yearPlaceholder) {
        return locale2.lang.rangeYearPlaceholder;
      }
      if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
        return locale2.lang.rangeQuarterPlaceholder;
      }
      if (picker === "month" && locale2.lang.monthPlaceholder) {
        return locale2.lang.rangeMonthPlaceholder;
      }
      if (picker === "week" && locale2.lang.weekPlaceholder) {
        return locale2.lang.rangeWeekPlaceholder;
      }
      if (picker === "time" && locale2.timePickerLocale.placeholder) {
        return locale2.timePickerLocale.rangePlaceholder;
      }
      return locale2.lang.rangePlaceholder;
    }
    function useIcons(props, prefixCls) {
      const {
        allowClear = true
      } = props;
      const {
        clearIcon,
        removeIcon
      } = useIcons$1(Object.assign(Object.assign({}, props), {
        prefixCls,
        componentName: "DatePicker"
      }));
      const mergedAllowClear = reactExports.useMemo(() => {
        if (allowClear === false) {
          return false;
        }
        const allowClearConfig = allowClear === true ? {} : allowClear;
        return Object.assign({
          clearIcon
        }, allowClearConfig);
      }, [allowClear, clearIcon]);
      return [mergedAllowClear, removeIcon];
    }
    const [WEEK, WEEKPICKER] = ["week", "WeekPicker"];
    const [MONTH, MONTHPICKER] = ["month", "MonthPicker"];
    const [YEAR, YEARPICKER] = ["year", "YearPicker"];
    const [QUARTER, QUARTERPICKER] = ["quarter", "QuarterPicker"];
    const [TIME, TIMEPICKER] = ["time", "TimePicker"];
    const PickerButton = (props) => /* @__PURE__ */ reactExports.createElement(Button$1, Object.assign({
      size: "small",
      type: "primary"
    }, props));
    function useComponents(components) {
      return reactExports.useMemo(() => Object.assign({
        button: PickerButton
      }, components), [components]);
    }
    var __rest$u = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const generateRangePicker = (generateConfig2) => {
      const RangePicker2 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
        var _a;
        const {
          prefixCls: customizePrefixCls,
          getPopupContainer: customGetPopupContainer,
          components,
          className,
          style: style2,
          placement,
          size: customizeSize,
          disabled: customDisabled,
          bordered = true,
          placeholder,
          popupClassName,
          dropdownClassName,
          status: customStatus,
          rootClassName,
          variant: customVariant,
          picker
        } = props, restProps = __rest$u(props, ["prefixCls", "getPopupContainer", "components", "className", "style", "placement", "size", "disabled", "bordered", "placeholder", "popupClassName", "dropdownClassName", "status", "rootClassName", "variant", "picker"]);
        const innerRef = reactExports.useRef(null);
        const {
          getPrefixCls,
          direction,
          getPopupContainer,
          rangePicker
        } = reactExports.useContext(ConfigContext);
        const prefixCls = getPrefixCls("picker", customizePrefixCls);
        const {
          compactSize,
          compactItemClassnames
        } = useCompactItemContext(prefixCls, direction);
        const rootPrefixCls = getPrefixCls();
        const [variant, enableVariantCls] = useVariant("rangePicker", customVariant, bordered);
        const rootCls = useCSSVarCls(prefixCls);
        const [wrapCSSVar, hashId, cssVarCls] = useStyle$g(prefixCls, rootCls);
        const [mergedAllowClear] = useIcons(props, prefixCls);
        const mergedComponents = useComponents(components);
        const mergedSize = useSize((ctx) => {
          var _a2;
          return (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
        });
        const disabled = reactExports.useContext(DisabledContext);
        const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
        const formItemContext = reactExports.useContext(FormItemInputContext);
        const {
          hasFeedback,
          status: contextStatus,
          feedbackIcon
        } = formItemContext;
        const suffixNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, picker === TIME ? /* @__PURE__ */ reactExports.createElement(RefIcon$m, null) : /* @__PURE__ */ reactExports.createElement(RefIcon$n, null), hasFeedback && feedbackIcon);
        reactExports.useImperativeHandle(ref, () => innerRef.current);
        const [contextLocale] = useLocale$1("Calendar", locale$1);
        const locale2 = Object.assign(Object.assign({}, contextLocale), props.locale);
        const [zIndex] = useZIndex("DatePicker", (_a = props.popupStyle) === null || _a === void 0 ? void 0 : _a.zIndex);
        return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(ContextIsolator, {
          space: true
        }, /* @__PURE__ */ reactExports.createElement(RefRangePicker, Object.assign({
          separator: /* @__PURE__ */ reactExports.createElement("span", {
            "aria-label": "to",
            className: `${prefixCls}-separator`
          }, /* @__PURE__ */ reactExports.createElement(RefIcon$l, null)),
          disabled: mergedDisabled,
          ref: innerRef,
          placement,
          placeholder: getRangePlaceholder(locale2, picker, placeholder),
          suffixIcon: suffixNode,
          prevIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-prev-icon`
          }),
          nextIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-next-icon`
          }),
          superPrevIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-super-prev-icon`
          }),
          superNextIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-super-next-icon`
          }),
          transitionName: `${rootPrefixCls}-slide-up`,
          picker
        }, restProps, {
          className: classNames({
            [`${prefixCls}-${mergedSize}`]: mergedSize,
            [`${prefixCls}-${variant}`]: enableVariantCls
          }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), hashId, compactItemClassnames, className, rangePicker === null || rangePicker === void 0 ? void 0 : rangePicker.className, cssVarCls, rootCls, rootClassName),
          style: Object.assign(Object.assign({}, rangePicker === null || rangePicker === void 0 ? void 0 : rangePicker.style), style2),
          locale: locale2.lang,
          prefixCls,
          getPopupContainer: customGetPopupContainer || getPopupContainer,
          generateConfig: generateConfig2,
          components: mergedComponents,
          direction,
          classNames: {
            popup: classNames(hashId, popupClassName || dropdownClassName, cssVarCls, rootCls, rootClassName)
          },
          styles: {
            popup: Object.assign(Object.assign({}, props.popupStyle), {
              zIndex
            })
          },
          allowClear: mergedAllowClear
        }))));
      });
      return RangePicker2;
    };
    var __rest$t = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const generatePicker$1 = (generateConfig2) => {
      const getPicker = (picker, displayName) => {
        const consumerName = displayName === TIMEPICKER ? "timePicker" : "datePicker";
        const Picker2 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
          var _a;
          const {
            prefixCls: customizePrefixCls,
            getPopupContainer: customizeGetPopupContainer,
            components,
            style: style2,
            className,
            rootClassName,
            size: customizeSize,
            bordered,
            placement,
            placeholder,
            popupClassName,
            dropdownClassName,
            disabled: customDisabled,
            status: customStatus,
            variant: customVariant,
            onCalendarChange
          } = props, restProps = __rest$t(props, ["prefixCls", "getPopupContainer", "components", "style", "className", "rootClassName", "size", "bordered", "placement", "placeholder", "popupClassName", "dropdownClassName", "disabled", "status", "variant", "onCalendarChange"]);
          const {
            getPrefixCls,
            direction,
            getPopupContainer,
            // Consume different styles according to different names
            [consumerName]: consumerStyle
          } = reactExports.useContext(ConfigContext);
          const prefixCls = getPrefixCls("picker", customizePrefixCls);
          const {
            compactSize,
            compactItemClassnames
          } = useCompactItemContext(prefixCls, direction);
          const innerRef = reactExports.useRef(null);
          const [variant, enableVariantCls] = useVariant("datePicker", customVariant, bordered);
          const rootCls = useCSSVarCls(prefixCls);
          const [wrapCSSVar, hashId, cssVarCls] = useStyle$g(prefixCls, rootCls);
          reactExports.useImperativeHandle(ref, () => innerRef.current);
          const additionalProps = {
            showToday: true
          };
          const mergedPicker = picker || props.picker;
          const rootPrefixCls = getPrefixCls();
          const {
            onSelect,
            multiple
          } = restProps;
          const hasLegacyOnSelect = onSelect && picker === "time" && !multiple;
          const onInternalCalendarChange = (date2, dateStr, info) => {
            onCalendarChange === null || onCalendarChange === void 0 ? void 0 : onCalendarChange(date2, dateStr, info);
            if (hasLegacyOnSelect) {
              onSelect(date2);
            }
          };
          const [mergedAllowClear, removeIcon] = useIcons(props, prefixCls);
          const mergedComponents = useComponents(components);
          const mergedSize = useSize((ctx) => {
            var _a2;
            return (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
          });
          const disabled = reactExports.useContext(DisabledContext);
          const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
          const formItemContext = reactExports.useContext(FormItemInputContext);
          const {
            hasFeedback,
            status: contextStatus,
            feedbackIcon
          } = formItemContext;
          const suffixNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, mergedPicker === "time" ? /* @__PURE__ */ reactExports.createElement(RefIcon$m, null) : /* @__PURE__ */ reactExports.createElement(RefIcon$n, null), hasFeedback && feedbackIcon);
          const [contextLocale] = useLocale$1("DatePicker", locale$1);
          const locale2 = Object.assign(Object.assign({}, contextLocale), props.locale);
          const [zIndex] = useZIndex("DatePicker", (_a = props.popupStyle) === null || _a === void 0 ? void 0 : _a.zIndex);
          return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(ContextIsolator, {
            space: true
          }, /* @__PURE__ */ reactExports.createElement(RefPicker, Object.assign({
            ref: innerRef,
            placeholder: getPlaceholder(locale2, mergedPicker, placeholder),
            suffixIcon: suffixNode,
            placement,
            prevIcon: /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-prev-icon`
            }),
            nextIcon: /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-next-icon`
            }),
            superPrevIcon: /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-super-prev-icon`
            }),
            superNextIcon: /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-super-next-icon`
            }),
            transitionName: `${rootPrefixCls}-slide-up`,
            picker,
            onCalendarChange: onInternalCalendarChange
          }, additionalProps, restProps, {
            locale: locale2.lang,
            className: classNames({
              [`${prefixCls}-${mergedSize}`]: mergedSize,
              [`${prefixCls}-${variant}`]: enableVariantCls
            }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), hashId, compactItemClassnames, consumerStyle === null || consumerStyle === void 0 ? void 0 : consumerStyle.className, className, cssVarCls, rootCls, rootClassName),
            style: Object.assign(Object.assign({}, consumerStyle === null || consumerStyle === void 0 ? void 0 : consumerStyle.style), style2),
            prefixCls,
            getPopupContainer: customizeGetPopupContainer || getPopupContainer,
            generateConfig: generateConfig2,
            components: mergedComponents,
            direction,
            disabled: mergedDisabled,
            classNames: {
              popup: classNames(hashId, cssVarCls, rootCls, rootClassName, popupClassName || dropdownClassName)
            },
            styles: {
              popup: Object.assign(Object.assign({}, props.popupStyle), {
                zIndex
              })
            },
            allowClear: mergedAllowClear,
            removeIcon
          }))));
        });
        return Picker2;
      };
      const DatePicker2 = getPicker();
      const WeekPicker = getPicker(WEEK, WEEKPICKER);
      const MonthPicker = getPicker(MONTH, MONTHPICKER);
      const YearPicker = getPicker(YEAR, YEARPICKER);
      const QuarterPicker = getPicker(QUARTER, QUARTERPICKER);
      const TimePicker2 = getPicker(TIME, TIMEPICKER);
      return {
        DatePicker: DatePicker2,
        WeekPicker,
        MonthPicker,
        YearPicker,
        TimePicker: TimePicker2,
        QuarterPicker
      };
    };
    const generatePicker = (generateConfig2) => {
      const {
        DatePicker: DatePicker2,
        WeekPicker,
        MonthPicker,
        YearPicker,
        TimePicker: TimePicker2,
        QuarterPicker
      } = generatePicker$1(generateConfig2);
      const RangePicker2 = generateRangePicker(generateConfig2);
      const MergedDatePicker = DatePicker2;
      MergedDatePicker.WeekPicker = WeekPicker;
      MergedDatePicker.MonthPicker = MonthPicker;
      MergedDatePicker.YearPicker = YearPicker;
      MergedDatePicker.RangePicker = RangePicker2;
      MergedDatePicker.TimePicker = TimePicker2;
      MergedDatePicker.QuarterPicker = QuarterPicker;
      return MergedDatePicker;
    };
    const DatePicker = generatePicker(generateConfig);
    const PurePanel$3 = genPurePanel(DatePicker, "popupAlign", void 0, "picker");
    DatePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$3;
    const PureRangePanel = genPurePanel(DatePicker.RangePicker, "popupAlign", void 0, "picker");
    DatePicker._InternalRangePanelDoNotUseOrYouWillBeFired = PureRangePanel;
    DatePicker.generatePicker = generatePicker;
    function isPresetSize(size) {
      return ["small", "middle", "large"].includes(size);
    }
    function isValidGapNumber(size) {
      if (!size) {
        return false;
      }
      return typeof size === "number" && !Number.isNaN(size);
    }
    const SpaceContext = /* @__PURE__ */ i.createContext({
      latestIndex: 0
    });
    const SpaceContextProvider = SpaceContext.Provider;
    const Item$1 = (_ref) => {
      let {
        className,
        index: index2,
        children,
        split: split2,
        style: style2
      } = _ref;
      const {
        latestIndex
      } = reactExports.useContext(SpaceContext);
      if (children === null || children === void 0) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("div", {
        className,
        style: style2
      }, children), index2 < latestIndex && split2 && /* @__PURE__ */ reactExports.createElement("span", {
        className: `${className}-split`
      }, split2));
    };
    var __rest$s = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const InternalSpace = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a;
      const {
        getPrefixCls,
        direction: directionConfig,
        size: contextSize,
        className: contextClassName,
        style: contextStyle,
        classNames: contextClassNames,
        styles: contextStyles
      } = useComponentConfig("space");
      const {
        size = contextSize !== null && contextSize !== void 0 ? contextSize : "small",
        align,
        className,
        rootClassName,
        children,
        direction = "horizontal",
        prefixCls: customizePrefixCls,
        split: split2,
        style: style2,
        wrap = false,
        classNames: customClassNames,
        styles
      } = props, otherProps = __rest$s(props, ["size", "align", "className", "rootClassName", "children", "direction", "prefixCls", "split", "style", "wrap", "classNames", "styles"]);
      const [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size];
      const isPresetVerticalSize = isPresetSize(verticalSize);
      const isPresetHorizontalSize = isPresetSize(horizontalSize);
      const isValidVerticalSize = isValidGapNumber(verticalSize);
      const isValidHorizontalSize = isValidGapNumber(horizontalSize);
      const childNodes = toArray$5(children, {
        keepEmpty: true
      });
      const mergedAlign = align === void 0 && direction === "horizontal" ? "center" : align;
      const prefixCls = getPrefixCls("space", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$p(prefixCls);
      const cls = classNames(prefixCls, contextClassName, hashId, `${prefixCls}-${direction}`, {
        [`${prefixCls}-rtl`]: directionConfig === "rtl",
        [`${prefixCls}-align-${mergedAlign}`]: mergedAlign,
        [`${prefixCls}-gap-row-${verticalSize}`]: isPresetVerticalSize,
        [`${prefixCls}-gap-col-${horizontalSize}`]: isPresetHorizontalSize
      }, className, rootClassName, cssVarCls);
      const itemClassName = classNames(`${prefixCls}-item`, (_a = customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.item) !== null && _a !== void 0 ? _a : contextClassNames.item);
      let latestIndex = 0;
      const nodes = childNodes.map((child, i2) => {
        var _a2;
        if (child !== null && child !== void 0) {
          latestIndex = i2;
        }
        const key = (child === null || child === void 0 ? void 0 : child.key) || `${itemClassName}-${i2}`;
        return /* @__PURE__ */ reactExports.createElement(Item$1, {
          className: itemClassName,
          key,
          index: i2,
          split: split2,
          style: (_a2 = styles === null || styles === void 0 ? void 0 : styles.item) !== null && _a2 !== void 0 ? _a2 : contextStyles.item
        }, child);
      });
      const spaceContext = reactExports.useMemo(() => ({
        latestIndex
      }), [latestIndex]);
      if (childNodes.length === 0) {
        return null;
      }
      const gapStyle = {};
      if (wrap) {
        gapStyle.flexWrap = "wrap";
      }
      if (!isPresetHorizontalSize && isValidHorizontalSize) {
        gapStyle.columnGap = horizontalSize;
      }
      if (!isPresetVerticalSize && isValidVerticalSize) {
        gapStyle.rowGap = verticalSize;
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        ref,
        className: cls,
        style: Object.assign(Object.assign(Object.assign({}, gapStyle), contextStyle), style2)
      }, otherProps), /* @__PURE__ */ reactExports.createElement(SpaceContextProvider, {
        value: spaceContext
      }, nodes)));
    });
    const Space = InternalSpace;
    Space.Compact = Compact$1;
    const flexWrapValues = ["wrap", "nowrap", "wrap-reverse"];
    const justifyContentValues = ["flex-start", "flex-end", "start", "end", "center", "space-between", "space-around", "space-evenly", "stretch", "normal", "left", "right"];
    const alignItemsValues = ["center", "start", "end", "flex-start", "flex-end", "self-start", "self-end", "baseline", "normal", "stretch"];
    const genClsWrap = (prefixCls, props) => {
      const wrap = props.wrap === true ? "wrap" : props.wrap;
      return {
        [`${prefixCls}-wrap-${wrap}`]: wrap && flexWrapValues.includes(wrap)
      };
    };
    const genClsAlign = (prefixCls, props) => {
      const alignCls = {};
      alignItemsValues.forEach((cssKey) => {
        alignCls[`${prefixCls}-align-${cssKey}`] = props.align === cssKey;
      });
      alignCls[`${prefixCls}-align-stretch`] = !props.align && !!props.vertical;
      return alignCls;
    };
    const genClsJustify = (prefixCls, props) => {
      const justifyCls = {};
      justifyContentValues.forEach((cssKey) => {
        justifyCls[`${prefixCls}-justify-${cssKey}`] = props.justify === cssKey;
      });
      return justifyCls;
    };
    function createFlexClassNames(prefixCls, props) {
      return classNames(Object.assign(Object.assign(Object.assign({}, genClsWrap(prefixCls, props)), genClsAlign(prefixCls, props)), genClsJustify(prefixCls, props)));
    }
    const genFlexStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          display: "flex",
          margin: 0,
          padding: 0,
          "&-vertical": {
            flexDirection: "column"
          },
          "&-rtl": {
            direction: "rtl"
          },
          "&:empty": {
            display: "none"
          }
        }
      };
    };
    const genFlexGapStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          "&-gap-small": {
            gap: token2.flexGapSM
          },
          "&-gap-middle": {
            gap: token2.flexGap
          },
          "&-gap-large": {
            gap: token2.flexGapLG
          }
        }
      };
    };
    const genFlexWrapStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const wrapStyle = {};
      flexWrapValues.forEach((value) => {
        wrapStyle[`${componentCls}-wrap-${value}`] = {
          flexWrap: value
        };
      });
      return wrapStyle;
    };
    const genAlignItemsStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const alignStyle = {};
      alignItemsValues.forEach((value) => {
        alignStyle[`${componentCls}-align-${value}`] = {
          alignItems: value
        };
      });
      return alignStyle;
    };
    const genJustifyContentStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const justifyStyle = {};
      justifyContentValues.forEach((value) => {
        justifyStyle[`${componentCls}-justify-${value}`] = {
          justifyContent: value
        };
      });
      return justifyStyle;
    };
    const prepareComponentToken$9 = () => ({});
    const useStyle$b = genStyleHooks("Flex", (token2) => {
      const {
        paddingXS,
        padding,
        paddingLG
      } = token2;
      const flexToken = merge(token2, {
        flexGapSM: paddingXS,
        flexGap: padding,
        flexGapLG: paddingLG
      });
      return [genFlexStyle(flexToken), genFlexGapStyle(flexToken), genFlexWrapStyle(flexToken), genAlignItemsStyle(flexToken), genJustifyContentStyle(flexToken)];
    }, prepareComponentToken$9, {
      // Flex component don't apply extra font style
      // https://github.com/ant-design/ant-design/issues/46403
      resetStyle: false
    });
    var __rest$r = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const Flex = /* @__PURE__ */ i.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        rootClassName,
        className,
        style: style2,
        flex,
        gap,
        children,
        vertical = false,
        component: Component2 = "div"
      } = props, othersProps = __rest$r(props, ["prefixCls", "rootClassName", "className", "style", "flex", "gap", "children", "vertical", "component"]);
      const {
        flex: ctxFlex,
        direction: ctxDirection,
        getPrefixCls
      } = i.useContext(ConfigContext);
      const prefixCls = getPrefixCls("flex", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$b(prefixCls);
      const mergedVertical = vertical !== null && vertical !== void 0 ? vertical : ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.vertical;
      const mergedCls = classNames(className, rootClassName, ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.className, prefixCls, hashId, cssVarCls, createFlexClassNames(prefixCls, props), {
        [`${prefixCls}-rtl`]: ctxDirection === "rtl",
        [`${prefixCls}-gap-${gap}`]: isPresetSize(gap),
        [`${prefixCls}-vertical`]: mergedVertical
      });
      const mergedStyle = Object.assign(Object.assign({}, ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.style), style2);
      if (flex) {
        mergedStyle.flex = flex;
      }
      if (gap && !isPresetSize(gap)) {
        mergedStyle.gap = gap;
      }
      return wrapCSSVar(/* @__PURE__ */ i.createElement(Component2, Object.assign({
        ref,
        className: mergedCls,
        style: mergedStyle
      }, omit(othersProps, ["justify", "wrap", "align"])), children));
    });
    function useDebounce(value) {
      const [cacheValue, setCacheValue] = reactExports.useState(value);
      reactExports.useEffect(() => {
        const timeout = setTimeout(() => {
          setCacheValue(value);
        }, value.length ? 0 : 10);
        return () => {
          clearTimeout(timeout);
        };
      }, [value]);
      return cacheValue;
    }
    const genFormValidateMotionStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const helpCls = `${componentCls}-show-help`;
      const helpItemCls = `${componentCls}-show-help-item`;
      return {
        [helpCls]: {
          // Explain holder
          transition: `opacity ${token2.motionDurationFast} ${token2.motionEaseInOut}`,
          "&-appear, &-enter": {
            opacity: 0,
            "&-active": {
              opacity: 1
            }
          },
          "&-leave": {
            opacity: 1,
            "&-active": {
              opacity: 0
            }
          },
          // Explain
          [helpItemCls]: {
            overflow: "hidden",
            transition: `height ${token2.motionDurationFast} ${token2.motionEaseInOut},
                     opacity ${token2.motionDurationFast} ${token2.motionEaseInOut},
                     transform ${token2.motionDurationFast} ${token2.motionEaseInOut} !important`,
            [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
              transform: `translateY(-5px)`,
              opacity: 0,
              "&-active": {
                transform: "translateY(0)",
                opacity: 1
              }
            },
            [`&${helpItemCls}-leave-active`]: {
              transform: `translateY(-5px)`
            }
          }
        }
      };
    };
    const resetForm = (token2) => ({
      legend: {
        display: "block",
        width: "100%",
        marginBottom: token2.marginLG,
        padding: 0,
        color: token2.colorTextDescription,
        fontSize: token2.fontSizeLG,
        lineHeight: "inherit",
        border: 0,
        borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
      },
      'input[type="search"]': {
        boxSizing: "border-box"
      },
      // Position radios and checkboxes better
      'input[type="radio"], input[type="checkbox"]': {
        lineHeight: "normal"
      },
      'input[type="file"]': {
        display: "block"
      },
      // Make range inputs behave like textual form controls
      'input[type="range"]': {
        display: "block",
        width: "100%"
      },
      // Make multiple select elements height not fixed
      "select[multiple], select[size]": {
        height: "auto"
      },
      // Focus for file, radio, and checkbox
      [`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
        outline: 0,
        boxShadow: `0 0 0 ${unit$1(token2.controlOutlineWidth)} ${token2.controlOutline}`
      },
      // Adjust output element
      output: {
        display: "block",
        paddingTop: 15,
        color: token2.colorText,
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight
      }
    });
    const genFormSize = (token2, height) => {
      const {
        formItemCls
      } = token2;
      return {
        [formItemCls]: {
          [`${formItemCls}-label > label`]: {
            height
          },
          [`${formItemCls}-control-input`]: {
            minHeight: height
          }
        }
      };
    };
    const genFormStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [token2.componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), resetForm(token2)), {
          [`${componentCls}-text`]: {
            display: "inline-block",
            paddingInlineEnd: token2.paddingSM
          },
          // ================================================================
          // =                             Size                             =
          // ================================================================
          "&-small": Object.assign({}, genFormSize(token2, token2.controlHeightSM)),
          "&-large": Object.assign({}, genFormSize(token2, token2.controlHeightLG))
        })
      };
    };
    const genFormItemStyle = (token2) => {
      const {
        formItemCls,
        iconCls,
        rootPrefixCls,
        antCls,
        labelRequiredMarkColor,
        labelColor,
        labelFontSize,
        labelHeight,
        labelColonMarginInlineStart,
        labelColonMarginInlineEnd,
        itemMarginBottom
      } = token2;
      return {
        [formItemCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          marginBottom: itemMarginBottom,
          verticalAlign: "top",
          "&-with-help": {
            transition: "none"
          },
          [`&-hidden,
        &-hidden${antCls}-row`]: {
            // https://github.com/ant-design/ant-design/issues/26141
            display: "none"
          },
          "&-has-warning": {
            [`${formItemCls}-split`]: {
              color: token2.colorError
            }
          },
          "&-has-error": {
            [`${formItemCls}-split`]: {
              color: token2.colorWarning
            }
          },
          // ==============================================================
          // =                            Label                           =
          // ==============================================================
          [`${formItemCls}-label`]: {
            flexGrow: 0,
            overflow: "hidden",
            whiteSpace: "nowrap",
            textAlign: "end",
            verticalAlign: "middle",
            "&-left": {
              textAlign: "start"
            },
            "&-wrap": {
              overflow: "unset",
              lineHeight: token2.lineHeight,
              whiteSpace: "unset"
            },
            "> label": {
              position: "relative",
              display: "inline-flex",
              alignItems: "center",
              maxWidth: "100%",
              height: labelHeight,
              color: labelColor,
              fontSize: labelFontSize,
              [`> ${iconCls}`]: {
                fontSize: token2.fontSize,
                verticalAlign: "top"
              },
              [`&${formItemCls}-required`]: {
                "&::before": {
                  display: "inline-block",
                  marginInlineEnd: token2.marginXXS,
                  color: labelRequiredMarkColor,
                  fontSize: token2.fontSize,
                  fontFamily: "SimSun, sans-serif",
                  lineHeight: 1,
                  content: '"*"'
                },
                [`&${formItemCls}-required-mark-hidden, &${formItemCls}-required-mark-optional`]: {
                  "&::before": {
                    display: "none"
                  }
                }
              },
              // Optional mark
              [`${formItemCls}-optional`]: {
                display: "inline-block",
                marginInlineStart: token2.marginXXS,
                color: token2.colorTextDescription,
                [`&${formItemCls}-required-mark-hidden`]: {
                  display: "none"
                }
              },
              // Optional mark
              [`${formItemCls}-tooltip`]: {
                color: token2.colorTextDescription,
                cursor: "help",
                writingMode: "horizontal-tb",
                marginInlineStart: token2.marginXXS
              },
              "&::after": {
                content: '":"',
                position: "relative",
                marginBlock: 0,
                marginInlineStart: labelColonMarginInlineStart,
                marginInlineEnd: labelColonMarginInlineEnd
              },
              [`&${formItemCls}-no-colon::after`]: {
                content: '"\\a0"'
              }
            }
          },
          // ==============================================================
          // =                            Input                           =
          // ==============================================================
          [`${formItemCls}-control`]: {
            ["--ant-display"]: "flex",
            flexDirection: "column",
            flexGrow: 1,
            [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
              width: "100%"
            },
            "&-input": {
              position: "relative",
              display: "flex",
              alignItems: "center",
              minHeight: token2.controlHeight,
              "&-content": {
                flex: "auto",
                maxWidth: "100%"
              }
            }
          },
          // ==============================================================
          // =                           Explain                          =
          // ==============================================================
          [formItemCls]: {
            "&-additional": {
              display: "flex",
              flexDirection: "column"
            },
            "&-explain, &-extra": {
              clear: "both",
              color: token2.colorTextDescription,
              fontSize: token2.fontSize,
              lineHeight: token2.lineHeight
            },
            "&-explain-connected": {
              width: "100%"
            },
            "&-extra": {
              minHeight: token2.controlHeightSM,
              transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
              // sync input color transition
            },
            "&-explain": {
              "&-error": {
                color: token2.colorError
              },
              "&-warning": {
                color: token2.colorWarning
              }
            }
          },
          [`&-with-help ${formItemCls}-explain`]: {
            height: "auto",
            opacity: 1
          },
          // ==============================================================
          // =                        Feedback Icon                       =
          // ==============================================================
          [`${formItemCls}-feedback-icon`]: {
            fontSize: token2.fontSize,
            textAlign: "center",
            visibility: "visible",
            animationName: zoomIn,
            animationDuration: token2.motionDurationMid,
            animationTimingFunction: token2.motionEaseOutBack,
            pointerEvents: "none",
            "&-success": {
              color: token2.colorSuccess
            },
            "&-error": {
              color: token2.colorError
            },
            "&-warning": {
              color: token2.colorWarning
            },
            "&-validating": {
              color: token2.colorPrimary
            }
          }
        })
      };
    };
    const genHorizontalStyle = (token2, className) => {
      const {
        formItemCls
      } = token2;
      return {
        [`${className}-horizontal`]: {
          [`${formItemCls}-label`]: {
            flexGrow: 0
          },
          [`${formItemCls}-control`]: {
            flex: "1 1 0",
            // https://github.com/ant-design/ant-design/issues/32777
            // https://github.com/ant-design/ant-design/issues/33773
            minWidth: 0
          },
          // Do not change this to `ant-col-24`! `-24` match all the responsive rules
          // https://github.com/ant-design/ant-design/issues/32980
          // https://github.com/ant-design/ant-design/issues/34903
          // https://github.com/ant-design/ant-design/issues/44538
          [`${formItemCls}-label[class$='-24'], ${formItemCls}-label[class*='-24 ']`]: {
            [`& + ${formItemCls}-control`]: {
              minWidth: "unset"
            }
          }
        }
      };
    };
    const genInlineStyle = (token2) => {
      const {
        componentCls,
        formItemCls,
        inlineItemMarginBottom
      } = token2;
      return {
        [`${componentCls}-inline`]: {
          display: "flex",
          flexWrap: "wrap",
          [formItemCls]: {
            flex: "none",
            marginInlineEnd: token2.margin,
            marginBottom: inlineItemMarginBottom,
            "&-row": {
              flexWrap: "nowrap"
            },
            [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
              display: "inline-block",
              verticalAlign: "top"
            },
            [`> ${formItemCls}-label`]: {
              flex: "none"
            },
            [`${componentCls}-text`]: {
              display: "inline-block"
            },
            [`${formItemCls}-has-feedback`]: {
              display: "inline-block"
            }
          }
        }
      };
    };
    const makeVerticalLayoutLabel = (token2) => ({
      padding: token2.verticalLabelPadding,
      margin: token2.verticalLabelMargin,
      whiteSpace: "initial",
      textAlign: "start",
      "> label": {
        margin: 0,
        "&::after": {
          // https://github.com/ant-design/ant-design/issues/43538
          visibility: "hidden"
        }
      }
    });
    const makeVerticalLayout = (token2) => {
      const {
        componentCls,
        formItemCls,
        rootPrefixCls
      } = token2;
      return {
        [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
        // ref: https://github.com/ant-design/ant-design/issues/45122
        [`${componentCls}:not(${componentCls}-inline)`]: {
          [formItemCls]: {
            flexWrap: "wrap",
            [`${formItemCls}-label, ${formItemCls}-control`]: {
              // When developer pass `xs: { span }`,
              // It should follow the `xs` screen config
              // ref: https://github.com/ant-design/ant-design/issues/44386
              [`&:not([class*=" ${rootPrefixCls}-col-xs"])`]: {
                flex: "0 0 100%",
                maxWidth: "100%"
              }
            }
          }
        }
      };
    };
    const genVerticalStyle = (token2) => {
      const {
        componentCls,
        formItemCls,
        antCls
      } = token2;
      return {
        [`${componentCls}-vertical`]: {
          [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
            [`${formItemCls}-row`]: {
              flexDirection: "column"
            },
            [`${formItemCls}-label > label`]: {
              height: "auto"
            },
            [`${formItemCls}-control`]: {
              width: "100%"
            },
            [`${formItemCls}-label,
        ${antCls}-col-24${formItemCls}-label,
        ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        },
        [`@media (max-width: ${unit$1(token2.screenXSMax)})`]: [makeVerticalLayout(token2), {
          [componentCls]: {
            [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
              [`${antCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
            }
          }
        }],
        [`@media (max-width: ${unit$1(token2.screenSMMax)})`]: {
          [componentCls]: {
            [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
              [`${antCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
            }
          }
        },
        [`@media (max-width: ${unit$1(token2.screenMDMax)})`]: {
          [componentCls]: {
            [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
              [`${antCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
            }
          }
        },
        [`@media (max-width: ${unit$1(token2.screenLGMax)})`]: {
          [componentCls]: {
            [`${formItemCls}:not(${formItemCls}-horizontal)`]: {
              [`${antCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
            }
          }
        }
      };
    };
    const genItemVerticalStyle = (token2) => {
      const {
        formItemCls,
        antCls
      } = token2;
      return {
        [`${formItemCls}-vertical`]: {
          [`${formItemCls}-row`]: {
            flexDirection: "column"
          },
          [`${formItemCls}-label > label`]: {
            height: "auto"
          },
          [`${formItemCls}-control`]: {
            width: "100%"
          }
        },
        [`${formItemCls}-vertical ${formItemCls}-label,
      ${antCls}-col-24${formItemCls}-label,
      ${antCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
        [`@media (max-width: ${unit$1(token2.screenXSMax)})`]: [makeVerticalLayout(token2), {
          [formItemCls]: {
            [`${antCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        }],
        [`@media (max-width: ${unit$1(token2.screenSMMax)})`]: {
          [formItemCls]: {
            [`${antCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        },
        [`@media (max-width: ${unit$1(token2.screenMDMax)})`]: {
          [formItemCls]: {
            [`${antCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        },
        [`@media (max-width: ${unit$1(token2.screenLGMax)})`]: {
          [formItemCls]: {
            [`${antCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        }
      };
    };
    const prepareComponentToken$8 = (token2) => ({
      labelRequiredMarkColor: token2.colorError,
      labelColor: token2.colorTextHeading,
      labelFontSize: token2.fontSize,
      labelHeight: token2.controlHeight,
      labelColonMarginInlineStart: token2.marginXXS / 2,
      labelColonMarginInlineEnd: token2.marginXS,
      itemMarginBottom: token2.marginLG,
      verticalLabelPadding: `0 0 ${token2.paddingXS}px`,
      verticalLabelMargin: 0,
      inlineItemMarginBottom: 0
    });
    const prepareToken$2 = (token2, rootPrefixCls) => {
      const formToken = merge(token2, {
        formItemCls: `${token2.componentCls}-item`,
        rootPrefixCls
      });
      return formToken;
    };
    const useStyle$a = genStyleHooks("Form", (token2, _ref) => {
      let {
        rootPrefixCls
      } = _ref;
      const formToken = prepareToken$2(token2, rootPrefixCls);
      return [genFormStyle(formToken), genFormItemStyle(formToken), genFormValidateMotionStyle(formToken), genHorizontalStyle(formToken, formToken.componentCls), genHorizontalStyle(formToken, formToken.formItemCls), genInlineStyle(formToken), genVerticalStyle(formToken), genItemVerticalStyle(formToken), genCollapseMotion(formToken), zoomIn];
    }, prepareComponentToken$8, {
      // Let From style before the Grid
      // ref https://github.com/ant-design/ant-design/issues/44386
      order: -1e3
    });
    const EMPTY_LIST = [];
    function toErrorEntity(error, prefix2, errorStatus) {
      let index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      return {
        key: typeof error === "string" ? error : `${prefix2}-${index2}`,
        error,
        errorStatus
      };
    }
    const ErrorList = (_ref) => {
      let {
        help,
        helpStatus,
        errors = EMPTY_LIST,
        warnings = EMPTY_LIST,
        className: rootClassName,
        fieldId,
        onVisibleChanged
      } = _ref;
      const {
        prefixCls
      } = reactExports.useContext(FormItemPrefixContext);
      const baseClassName = `${prefixCls}-item-explain`;
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$a(prefixCls, rootCls);
      const collapseMotion = reactExports.useMemo(() => initCollapseMotion(prefixCls), [prefixCls]);
      const debounceErrors = useDebounce(errors);
      const debounceWarnings = useDebounce(warnings);
      const fullKeyList = reactExports.useMemo(() => {
        if (help !== void 0 && help !== null) {
          return [toErrorEntity(help, "help", helpStatus)];
        }
        return [].concat(_toConsumableArray(debounceErrors.map((error, index2) => toErrorEntity(error, "error", "error", index2))), _toConsumableArray(debounceWarnings.map((warning2, index2) => toErrorEntity(warning2, "warning", "warning", index2))));
      }, [help, helpStatus, debounceErrors, debounceWarnings]);
      const filledKeyFullKeyList = reactExports.useMemo(() => {
        const keysCount = {};
        fullKeyList.forEach((_ref2) => {
          let {
            key
          } = _ref2;
          keysCount[key] = (keysCount[key] || 0) + 1;
        });
        return fullKeyList.map((entity, index2) => Object.assign(Object.assign({}, entity), {
          key: keysCount[entity.key] > 1 ? `${entity.key}-fallback-${index2}` : entity.key
        }));
      }, [fullKeyList]);
      const helpProps = {};
      if (fieldId) {
        helpProps.id = `${fieldId}_help`;
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(CSSMotion, {
        motionDeadline: collapseMotion.motionDeadline,
        motionName: `${prefixCls}-show-help`,
        visible: !!filledKeyFullKeyList.length,
        onVisibleChanged
      }, (holderProps) => {
        const {
          className: holderClassName,
          style: holderStyle
        } = holderProps;
        return /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, helpProps, {
          className: classNames(baseClassName, holderClassName, cssVarCls, rootCls, rootClassName, hashId),
          style: holderStyle
        }), /* @__PURE__ */ reactExports.createElement(CSSMotionList, Object.assign({
          keys: filledKeyFullKeyList
        }, initCollapseMotion(prefixCls), {
          motionName: `${prefixCls}-show-help-item`,
          component: false
        }), (itemProps) => {
          const {
            key,
            error,
            errorStatus,
            className: itemClassName,
            style: itemStyle
          } = itemProps;
          return /* @__PURE__ */ reactExports.createElement("div", {
            key,
            className: classNames(itemClassName, {
              [`${baseClassName}-${errorStatus}`]: errorStatus
            }),
            style: itemStyle
          }, error);
        }));
      }));
    };
    const formItemNameBlackList = ["parentNode"];
    const defaultItemNamePrefixCls = "form_item";
    function toArray(candidate) {
      if (candidate === void 0 || candidate === false) return [];
      return Array.isArray(candidate) ? candidate : [candidate];
    }
    function getFieldId(namePath, formName) {
      if (!namePath.length) {
        return void 0;
      }
      const mergedId = namePath.join("_");
      if (formName) {
        return `${formName}_${mergedId}`;
      }
      const isIllegalName = formItemNameBlackList.includes(mergedId);
      return isIllegalName ? `${defaultItemNamePrefixCls}_${mergedId}` : mergedId;
    }
    function getStatus(errors, warnings, meta, defaultValidateStatus, hasFeedback, validateStatus) {
      let status = defaultValidateStatus;
      if (validateStatus !== void 0) {
        status = validateStatus;
      } else if (meta.validating) {
        status = "validating";
      } else if (errors.length) {
        status = "error";
      } else if (warnings.length) {
        status = "warning";
      } else if (meta.touched || hasFeedback && meta.validated) {
        status = "success";
      }
      return status;
    }
    var __rest$q = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function toNamePathStr(name) {
      const namePath = toArray(name);
      return namePath.join("_");
    }
    function getFieldDOMNode(name, wrapForm) {
      const field = wrapForm.getFieldInstance(name);
      const fieldDom = getDOM(field);
      if (fieldDom) {
        return fieldDom;
      }
      const fieldId = getFieldId(toArray(name), wrapForm.__INTERNAL__.name);
      if (fieldId) {
        return document.getElementById(fieldId);
      }
    }
    function useForm(form) {
      const [rcForm] = useForm$1();
      const itemsRef = reactExports.useRef({});
      const wrapForm = reactExports.useMemo(() => form !== null && form !== void 0 ? form : Object.assign(Object.assign({}, rcForm), {
        __INTERNAL__: {
          itemRef: (name) => (node2) => {
            const namePathStr = toNamePathStr(name);
            if (node2) {
              itemsRef.current[namePathStr] = node2;
            } else {
              delete itemsRef.current[namePathStr];
            }
          }
        },
        scrollToField: function(name) {
          let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const {
            focus
          } = options2, restOpt = __rest$q(options2, ["focus"]);
          const node2 = getFieldDOMNode(name, wrapForm);
          if (node2) {
            e$1(node2, Object.assign({
              scrollMode: "if-needed",
              block: "nearest"
            }, restOpt));
            if (focus) {
              wrapForm.focusField(name);
            }
          }
        },
        focusField: (name) => {
          var _a, _b;
          const itemRef = wrapForm.getFieldInstance(name);
          if (typeof (itemRef === null || itemRef === void 0 ? void 0 : itemRef.focus) === "function") {
            itemRef.focus();
          } else {
            (_b = (_a = getFieldDOMNode(name, wrapForm)) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);
          }
        },
        getFieldInstance: (name) => {
          const namePathStr = toNamePathStr(name);
          return itemsRef.current[namePathStr];
        }
      }), [form, rcForm]);
      return [wrapForm];
    }
    var __rest$p = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const InternalForm = (props, ref) => {
      const contextDisabled = reactExports.useContext(DisabledContext);
      const {
        getPrefixCls,
        direction,
        requiredMark: contextRequiredMark,
        colon: contextColon,
        scrollToFirstError: contextScrollToFirstError,
        className: contextClassName,
        style: contextStyle
      } = useComponentConfig("form");
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        size,
        disabled = contextDisabled,
        form,
        colon,
        labelAlign,
        labelWrap,
        labelCol,
        wrapperCol,
        hideRequiredMark,
        layout = "horizontal",
        scrollToFirstError,
        requiredMark,
        onFinishFailed,
        name,
        style: style2,
        feedbackIcons,
        variant
      } = props, restFormProps = __rest$p(props, ["prefixCls", "className", "rootClassName", "size", "disabled", "form", "colon", "labelAlign", "labelWrap", "labelCol", "wrapperCol", "hideRequiredMark", "layout", "scrollToFirstError", "requiredMark", "onFinishFailed", "name", "style", "feedbackIcons", "variant"]);
      const mergedSize = useSize(size);
      const contextValidateMessages = reactExports.useContext(ValidateMessagesContext);
      const mergedRequiredMark = reactExports.useMemo(() => {
        if (requiredMark !== void 0) {
          return requiredMark;
        }
        if (hideRequiredMark) {
          return false;
        }
        if (contextRequiredMark !== void 0) {
          return contextRequiredMark;
        }
        return true;
      }, [hideRequiredMark, requiredMark, contextRequiredMark]);
      const mergedColon = colon !== null && colon !== void 0 ? colon : contextColon;
      const prefixCls = getPrefixCls("form", customizePrefixCls);
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$a(prefixCls, rootCls);
      const formClassName = classNames(prefixCls, `${prefixCls}-${layout}`, {
        [`${prefixCls}-hide-required-mark`]: mergedRequiredMark === false,
        // todo: remove in next major version
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-${mergedSize}`]: mergedSize
      }, cssVarCls, rootCls, hashId, contextClassName, className, rootClassName);
      const [wrapForm] = useForm(form);
      const {
        __INTERNAL__
      } = wrapForm;
      __INTERNAL__.name = name;
      const formContextValue = reactExports.useMemo(() => ({
        name,
        labelAlign,
        labelCol,
        labelWrap,
        wrapperCol,
        vertical: layout === "vertical",
        colon: mergedColon,
        requiredMark: mergedRequiredMark,
        itemRef: __INTERNAL__.itemRef,
        form: wrapForm,
        feedbackIcons
      }), [name, labelAlign, labelCol, wrapperCol, layout, mergedColon, mergedRequiredMark, wrapForm, feedbackIcons]);
      const nativeElementRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, () => {
        var _a;
        return Object.assign(Object.assign({}, wrapForm), {
          nativeElement: (_a = nativeElementRef.current) === null || _a === void 0 ? void 0 : _a.nativeElement
        });
      });
      const scrollToField = (options2, fieldName) => {
        if (options2) {
          let defaultScrollToFirstError = {
            block: "nearest"
          };
          if (typeof options2 === "object") {
            defaultScrollToFirstError = Object.assign(Object.assign({}, defaultScrollToFirstError), options2);
          }
          wrapForm.scrollToField(fieldName, defaultScrollToFirstError);
        }
      };
      const onInternalFinishFailed = (errorInfo) => {
        onFinishFailed === null || onFinishFailed === void 0 ? void 0 : onFinishFailed(errorInfo);
        if (errorInfo.errorFields.length) {
          const fieldName = errorInfo.errorFields[0].name;
          if (scrollToFirstError !== void 0) {
            scrollToField(scrollToFirstError, fieldName);
            return;
          }
          if (contextScrollToFirstError !== void 0) {
            scrollToField(contextScrollToFirstError, fieldName);
          }
        }
      };
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(VariantContext.Provider, {
        value: variant
      }, /* @__PURE__ */ reactExports.createElement(DisabledContextProvider, {
        disabled
      }, /* @__PURE__ */ reactExports.createElement(SizeContext.Provider, {
        value: mergedSize
      }, /* @__PURE__ */ reactExports.createElement(FormProvider, {
        // This is not list in API, we pass with spread
        validateMessages: contextValidateMessages
      }, /* @__PURE__ */ reactExports.createElement(FormContext.Provider, {
        value: formContextValue
      }, /* @__PURE__ */ reactExports.createElement(RefForm, Object.assign({
        id: name
      }, restFormProps, {
        name,
        onFinishFailed: onInternalFinishFailed,
        form: wrapForm,
        ref: nativeElementRef,
        style: Object.assign(Object.assign({}, contextStyle), style2),
        className: formClassName
      }))))))));
    };
    const Form$2 = /* @__PURE__ */ reactExports.forwardRef(InternalForm);
    function useChildren(children) {
      if (typeof children === "function") {
        return children;
      }
      const childList = toArray$5(children);
      return childList.length <= 1 ? childList[0] : childList;
    }
    const useFormItemStatus = () => {
      const {
        status,
        errors = [],
        warnings = []
      } = reactExports.useContext(FormItemInputContext);
      return {
        status,
        errors,
        warnings
      };
    };
    useFormItemStatus.Context = FormItemInputContext;
    function useFrameState(defaultValue) {
      const [value, setValue] = reactExports.useState(defaultValue);
      const frameRef = reactExports.useRef(null);
      const batchRef = reactExports.useRef([]);
      const destroyRef = reactExports.useRef(false);
      reactExports.useEffect(() => {
        destroyRef.current = false;
        return () => {
          destroyRef.current = true;
          wrapperRaf.cancel(frameRef.current);
          frameRef.current = null;
        };
      }, []);
      function setFrameValue(updater) {
        if (destroyRef.current) {
          return;
        }
        if (frameRef.current === null) {
          batchRef.current = [];
          frameRef.current = wrapperRaf(() => {
            frameRef.current = null;
            setValue((prevValue) => {
              let current = prevValue;
              batchRef.current.forEach((func) => {
                current = func(current);
              });
              return current;
            });
          });
        }
        batchRef.current.push(updater);
      }
      return [value, setFrameValue];
    }
    function useItemRef() {
      const {
        itemRef
      } = reactExports.useContext(FormContext);
      const cacheRef = reactExports.useRef({});
      function getRef(name, children) {
        const childrenRef = children && typeof children === "object" && getNodeRef(children);
        const nameStr = name.join("_");
        if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
          cacheRef.current.name = nameStr;
          cacheRef.current.originRef = childrenRef;
          cacheRef.current.ref = composeRef(itemRef(name), childrenRef);
        }
        return cacheRef.current.ref;
      }
      return getRef;
    }
    const genFallbackStyle = (token2) => {
      const {
        formItemCls
      } = token2;
      return {
        "@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)": {
          // Fallback for IE, safe to remove we not support it anymore
          [`${formItemCls}-control`]: {
            display: "flex"
          }
        }
      };
    };
    const FallbackCmp = genSubStyleComponent(["Form", "item-item"], (token2, _ref) => {
      let {
        rootPrefixCls
      } = _ref;
      const formToken = prepareToken$2(token2, rootPrefixCls);
      return [genFallbackStyle(formToken)];
    });
    var __rest$o = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const GRID_MAX = 24;
    const FormItemInput = (props) => {
      const {
        prefixCls,
        status,
        labelCol,
        wrapperCol,
        children,
        errors,
        warnings,
        _internalItemRender: formItemRender,
        extra,
        help,
        fieldId,
        marginBottom,
        onErrorVisibleChanged,
        label
      } = props;
      const baseClassName = `${prefixCls}-item`;
      const formContext = reactExports.useContext(FormContext);
      const mergedWrapperCol = reactExports.useMemo(() => {
        let mergedWrapper = Object.assign({}, wrapperCol || formContext.wrapperCol || {});
        if (label === null && !labelCol && !wrapperCol && formContext.labelCol) {
          const list = [void 0, "xs", "sm", "md", "lg", "xl", "xxl"];
          list.forEach((size) => {
            const _size = size ? [size] : [];
            const formLabel = get(formContext.labelCol, _size);
            const formLabelObj = typeof formLabel === "object" ? formLabel : {};
            const wrapper = get(mergedWrapper, _size);
            const wrapperObj = typeof wrapper === "object" ? wrapper : {};
            if ("span" in formLabelObj && !("offset" in wrapperObj) && formLabelObj.span < GRID_MAX) {
              mergedWrapper = set(mergedWrapper, [].concat(_size, ["offset"]), formLabelObj.span);
            }
          });
        }
        return mergedWrapper;
      }, [wrapperCol, formContext]);
      const className = classNames(`${baseClassName}-control`, mergedWrapperCol.className);
      const subFormContext = reactExports.useMemo(() => {
        const {
          labelCol: labelCol2,
          wrapperCol: wrapperCol2
        } = formContext, rest = __rest$o(formContext, ["labelCol", "wrapperCol"]);
        return rest;
      }, [formContext]);
      const extraRef = reactExports.useRef(null);
      const [extraHeight, setExtraHeight] = reactExports.useState(0);
      useLayoutEffect$1(() => {
        if (extra && extraRef.current) {
          setExtraHeight(extraRef.current.clientHeight);
        } else {
          setExtraHeight(0);
        }
      }, [extra]);
      const inputDom = /* @__PURE__ */ reactExports.createElement("div", {
        className: `${baseClassName}-control-input`
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${baseClassName}-control-input-content`
      }, children));
      const formItemContext = reactExports.useMemo(() => ({
        prefixCls,
        status
      }), [prefixCls, status]);
      const errorListDom = marginBottom !== null || errors.length || warnings.length ? /* @__PURE__ */ reactExports.createElement(FormItemPrefixContext.Provider, {
        value: formItemContext
      }, /* @__PURE__ */ reactExports.createElement(ErrorList, {
        fieldId,
        errors,
        warnings,
        help,
        helpStatus: status,
        className: `${baseClassName}-explain-connected`,
        onVisibleChanged: onErrorVisibleChanged
      })) : null;
      const extraProps = {};
      if (fieldId) {
        extraProps.id = `${fieldId}_extra`;
      }
      const extraDom = extra ? /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, extraProps, {
        className: `${baseClassName}-extra`,
        ref: extraRef
      }), extra) : null;
      const additionalDom = errorListDom || extraDom ? /* @__PURE__ */ reactExports.createElement("div", {
        className: `${baseClassName}-additional`,
        style: marginBottom ? {
          minHeight: marginBottom + extraHeight
        } : {}
      }, errorListDom, extraDom) : null;
      const dom = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, {
        input: inputDom,
        errorList: errorListDom,
        extra: extraDom
      }) : /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, inputDom, additionalDom);
      return /* @__PURE__ */ reactExports.createElement(FormContext.Provider, {
        value: subFormContext
      }, /* @__PURE__ */ reactExports.createElement(Col, Object.assign({}, mergedWrapperCol, {
        className
      }), dom), /* @__PURE__ */ reactExports.createElement(FallbackCmp, {
        prefixCls
      }));
    };
    var QuestionCircleOutlined$7 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
    var QuestionCircleOutlined$6 = function QuestionCircleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: QuestionCircleOutlined$7
      }));
    };
    var RefIcon$k = /* @__PURE__ */ reactExports.forwardRef(QuestionCircleOutlined$6);
    var __rest$n = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function toTooltipProps(tooltip) {
      if (!tooltip) {
        return null;
      }
      if (typeof tooltip === "object" && !/* @__PURE__ */ reactExports.isValidElement(tooltip)) {
        return tooltip;
      }
      return {
        title: tooltip
      };
    }
    const FormItemLabel = (_ref) => {
      let {
        prefixCls,
        label,
        htmlFor,
        labelCol,
        labelAlign,
        colon,
        required: required2,
        requiredMark,
        tooltip,
        vertical
      } = _ref;
      var _a;
      const [formLocale] = useLocale$1("Form");
      const {
        labelAlign: contextLabelAlign,
        labelCol: contextLabelCol,
        labelWrap,
        colon: contextColon
      } = reactExports.useContext(FormContext);
      if (!label) {
        return null;
      }
      const mergedLabelCol = labelCol || contextLabelCol || {};
      const mergedLabelAlign = labelAlign || contextLabelAlign;
      const labelClsBasic = `${prefixCls}-item-label`;
      const labelColClassName = classNames(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.className, {
        [`${labelClsBasic}-wrap`]: !!labelWrap
      });
      let labelChildren = label;
      const computedColon = colon === true || contextColon !== false && colon !== false;
      const haveColon = computedColon && !vertical;
      if (haveColon && typeof label === "string" && label.trim()) {
        labelChildren = label.replace(/[:|]\s*$/, "");
      }
      const tooltipProps = toTooltipProps(tooltip);
      if (tooltipProps) {
        const {
          icon = /* @__PURE__ */ reactExports.createElement(RefIcon$k, null)
        } = tooltipProps, restTooltipProps = __rest$n(tooltipProps, ["icon"]);
        const tooltipNode = /* @__PURE__ */ reactExports.createElement(Tooltip, Object.assign({}, restTooltipProps), /* @__PURE__ */ reactExports.cloneElement(icon, {
          className: `${prefixCls}-item-tooltip`,
          title: "",
          onClick: (e2) => {
            e2.preventDefault();
          },
          tabIndex: null
        }));
        labelChildren = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, labelChildren, tooltipNode);
      }
      const isOptionalMark = requiredMark === "optional";
      const isRenderMark = typeof requiredMark === "function";
      const hideRequiredMark = requiredMark === false;
      if (isRenderMark) {
        labelChildren = requiredMark(labelChildren, {
          required: !!required2
        });
      } else if (isOptionalMark && !required2) {
        labelChildren = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, labelChildren, /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-item-optional`,
          title: ""
        }, (formLocale === null || formLocale === void 0 ? void 0 : formLocale.optional) || ((_a = localeValues.Form) === null || _a === void 0 ? void 0 : _a.optional)));
      }
      let markType;
      if (hideRequiredMark) {
        markType = "hidden";
      } else if (isOptionalMark || isRenderMark) {
        markType = "optional";
      }
      const labelClassName = classNames({
        [`${prefixCls}-item-required`]: required2,
        [`${prefixCls}-item-required-mark-${markType}`]: markType,
        [`${prefixCls}-item-no-colon`]: !computedColon
      });
      return /* @__PURE__ */ reactExports.createElement(Col, Object.assign({}, mergedLabelCol, {
        className: labelColClassName
      }), /* @__PURE__ */ reactExports.createElement("label", {
        htmlFor,
        className: labelClassName,
        title: typeof label === "string" ? label : ""
      }, labelChildren));
    };
    const iconMap = {
      success: RefIcon$C,
      warning: RefIcon$z,
      error: RefIcon$B,
      validating: RefIcon$x
    };
    function StatusProvider(_ref) {
      let {
        children,
        errors,
        warnings,
        hasFeedback,
        validateStatus,
        prefixCls,
        meta,
        noStyle
      } = _ref;
      const itemPrefixCls = `${prefixCls}-item`;
      const {
        feedbackIcons
      } = reactExports.useContext(FormContext);
      const mergedValidateStatus = getStatus(errors, warnings, meta, null, !!hasFeedback, validateStatus);
      const {
        isFormItemInput: parentIsFormItemInput,
        status: parentStatus,
        hasFeedback: parentHasFeedback,
        feedbackIcon: parentFeedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const formItemStatusContext = reactExports.useMemo(() => {
        var _a;
        let feedbackIcon;
        if (hasFeedback) {
          const customIcons = hasFeedback !== true && hasFeedback.icons || feedbackIcons;
          const customIconNode = mergedValidateStatus && ((_a = customIcons === null || customIcons === void 0 ? void 0 : customIcons({
            status: mergedValidateStatus,
            errors,
            warnings
          })) === null || _a === void 0 ? void 0 : _a[mergedValidateStatus]);
          const IconNode = mergedValidateStatus && iconMap[mergedValidateStatus];
          feedbackIcon = customIconNode !== false && IconNode ? /* @__PURE__ */ reactExports.createElement("span", {
            className: classNames(`${itemPrefixCls}-feedback-icon`, `${itemPrefixCls}-feedback-icon-${mergedValidateStatus}`)
          }, customIconNode || /* @__PURE__ */ reactExports.createElement(IconNode, null)) : null;
        }
        const context = {
          status: mergedValidateStatus || "",
          errors,
          warnings,
          hasFeedback: !!hasFeedback,
          feedbackIcon,
          isFormItemInput: true
        };
        if (noStyle) {
          context.status = (mergedValidateStatus !== null && mergedValidateStatus !== void 0 ? mergedValidateStatus : parentStatus) || "";
          context.isFormItemInput = parentIsFormItemInput;
          context.hasFeedback = !!(hasFeedback !== null && hasFeedback !== void 0 ? hasFeedback : parentHasFeedback);
          context.feedbackIcon = hasFeedback !== void 0 ? context.feedbackIcon : parentFeedbackIcon;
        }
        return context;
      }, [mergedValidateStatus, hasFeedback, noStyle, parentIsFormItemInput, parentStatus]);
      return /* @__PURE__ */ reactExports.createElement(FormItemInputContext.Provider, {
        value: formItemStatusContext
      }, children);
    }
    var __rest$m = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function ItemHolder(props) {
      const {
        prefixCls,
        className,
        rootClassName,
        style: style2,
        help,
        errors,
        warnings,
        validateStatus,
        meta,
        hasFeedback,
        hidden,
        children,
        fieldId,
        required: required2,
        isRequired: isRequired2,
        onSubItemMetaChange,
        layout
      } = props, restProps = __rest$m(props, ["prefixCls", "className", "rootClassName", "style", "help", "errors", "warnings", "validateStatus", "meta", "hasFeedback", "hidden", "children", "fieldId", "required", "isRequired", "onSubItemMetaChange", "layout"]);
      const itemPrefixCls = `${prefixCls}-item`;
      const {
        requiredMark,
        vertical: formVertical
      } = reactExports.useContext(FormContext);
      const vertical = formVertical || layout === "vertical";
      const itemRef = reactExports.useRef(null);
      const debounceErrors = useDebounce(errors);
      const debounceWarnings = useDebounce(warnings);
      const hasHelp = help !== void 0 && help !== null;
      const hasError = !!(hasHelp || errors.length || warnings.length);
      const isOnScreen = !!itemRef.current && isVisible(itemRef.current);
      const [marginBottom, setMarginBottom] = reactExports.useState(null);
      useLayoutEffect$1(() => {
        if (hasError && itemRef.current) {
          const itemStyle = getComputedStyle(itemRef.current);
          setMarginBottom(parseInt(itemStyle.marginBottom, 10));
        }
      }, [hasError, isOnScreen]);
      const onErrorVisibleChanged = (nextVisible) => {
        if (!nextVisible) {
          setMarginBottom(null);
        }
      };
      const getValidateState = function() {
        let isDebounce = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        const _errors = isDebounce ? debounceErrors : meta.errors;
        const _warnings = isDebounce ? debounceWarnings : meta.warnings;
        return getStatus(_errors, _warnings, meta, "", !!hasFeedback, validateStatus);
      };
      const mergedValidateStatus = getValidateState();
      const itemClassName = classNames(itemPrefixCls, className, rootClassName, {
        [`${itemPrefixCls}-with-help`]: hasHelp || debounceErrors.length || debounceWarnings.length,
        // Status
        [`${itemPrefixCls}-has-feedback`]: mergedValidateStatus && hasFeedback,
        [`${itemPrefixCls}-has-success`]: mergedValidateStatus === "success",
        [`${itemPrefixCls}-has-warning`]: mergedValidateStatus === "warning",
        [`${itemPrefixCls}-has-error`]: mergedValidateStatus === "error",
        [`${itemPrefixCls}-is-validating`]: mergedValidateStatus === "validating",
        [`${itemPrefixCls}-hidden`]: hidden,
        // Layout
        [`${itemPrefixCls}-${layout}`]: layout
      });
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: itemClassName,
        style: style2,
        ref: itemRef
      }, /* @__PURE__ */ reactExports.createElement(Row, Object.assign({
        className: `${itemPrefixCls}-row`
      }, omit(restProps, [
        "_internalItemRender",
        "colon",
        "dependencies",
        "extra",
        "fieldKey",
        "getValueFromEvent",
        "getValueProps",
        "htmlFor",
        "id",
        // It is deprecated because `htmlFor` is its replacement.
        "initialValue",
        "isListField",
        "label",
        "labelAlign",
        "labelCol",
        "labelWrap",
        "messageVariables",
        "name",
        "normalize",
        "noStyle",
        "preserve",
        "requiredMark",
        "rules",
        "shouldUpdate",
        "trigger",
        "tooltip",
        "validateFirst",
        "validateTrigger",
        "valuePropName",
        "wrapperCol",
        "validateDebounce"
      ])), /* @__PURE__ */ reactExports.createElement(FormItemLabel, Object.assign({
        htmlFor: fieldId
      }, props, {
        requiredMark,
        required: required2 !== null && required2 !== void 0 ? required2 : isRequired2,
        prefixCls,
        vertical
      })), /* @__PURE__ */ reactExports.createElement(FormItemInput, Object.assign({}, props, meta, {
        errors: debounceErrors,
        warnings: debounceWarnings,
        prefixCls,
        status: mergedValidateStatus,
        help,
        marginBottom,
        onErrorVisibleChanged
      }), /* @__PURE__ */ reactExports.createElement(NoStyleItemContext.Provider, {
        value: onSubItemMetaChange
      }, /* @__PURE__ */ reactExports.createElement(StatusProvider, {
        prefixCls,
        meta,
        errors: meta.errors,
        warnings: meta.warnings,
        hasFeedback,
        // Already calculated
        validateStatus: mergedValidateStatus
      }, children)))), !!marginBottom && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${itemPrefixCls}-margin-offset`,
        style: {
          marginBottom: -marginBottom
        }
      }));
    }
    const NAME_SPLIT = "__SPLIT__";
    function isSimilarControl(a, b2) {
      const keysA = Object.keys(a);
      const keysB = Object.keys(b2);
      return keysA.length === keysB.length && keysA.every((key) => {
        const propValueA = a[key];
        const propValueB = b2[key];
        return propValueA === propValueB || typeof propValueA === "function" || typeof propValueB === "function";
      });
    }
    const MemoInput = /* @__PURE__ */ reactExports.memo((_ref) => {
      let {
        children
      } = _ref;
      return children;
    }, (prev2, next2) => isSimilarControl(prev2.control, next2.control) && prev2.update === next2.update && prev2.childProps.length === next2.childProps.length && prev2.childProps.every((value, index2) => value === next2.childProps[index2]));
    function genEmptyMeta() {
      return {
        errors: [],
        warnings: [],
        touched: false,
        validating: false,
        name: [],
        validated: false
      };
    }
    function InternalFormItem(props) {
      const {
        name,
        noStyle,
        className,
        dependencies,
        prefixCls: customizePrefixCls,
        shouldUpdate,
        rules: rules2,
        children,
        required: required2,
        label,
        messageVariables,
        trigger = "onChange",
        validateTrigger,
        hidden,
        help,
        layout
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const {
        name: formName
      } = reactExports.useContext(FormContext);
      const mergedChildren = useChildren(children);
      const isRenderProps = typeof mergedChildren === "function";
      const notifyParentMetaChange = reactExports.useContext(NoStyleItemContext);
      const {
        validateTrigger: contextValidateTrigger
      } = reactExports.useContext(Context$1);
      const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : contextValidateTrigger;
      const hasName = !(name === void 0 || name === null);
      const prefixCls = getPrefixCls("form", customizePrefixCls);
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$a(prefixCls, rootCls);
      devUseWarning();
      const listContext = reactExports.useContext(ListContext$1);
      const fieldKeyPathRef = reactExports.useRef(null);
      const [subFieldErrors, setSubFieldErrors] = useFrameState({});
      const [meta, setMeta] = useSafeState(() => genEmptyMeta());
      const onMetaChange = (nextMeta) => {
        const keyInfo = listContext === null || listContext === void 0 ? void 0 : listContext.getKey(nextMeta.name);
        setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
        if (noStyle && help !== false && notifyParentMetaChange) {
          let namePath = nextMeta.name;
          if (!nextMeta.destroy) {
            if (keyInfo !== void 0) {
              const [fieldKey, restPath] = keyInfo;
              namePath = [fieldKey].concat(_toConsumableArray(restPath));
              fieldKeyPathRef.current = namePath;
            }
          } else {
            namePath = fieldKeyPathRef.current || namePath;
          }
          notifyParentMetaChange(nextMeta, namePath);
        }
      };
      const onSubItemMetaChange = (subMeta, uniqueKeys) => {
        setSubFieldErrors((prevSubFieldErrors) => {
          const clone2 = Object.assign({}, prevSubFieldErrors);
          const mergedNamePath = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys));
          const mergedNameKey = mergedNamePath.join(NAME_SPLIT);
          if (subMeta.destroy) {
            delete clone2[mergedNameKey];
          } else {
            clone2[mergedNameKey] = subMeta;
          }
          return clone2;
        });
      };
      const [mergedErrors, mergedWarnings] = reactExports.useMemo(() => {
        const errorList = _toConsumableArray(meta.errors);
        const warningList = _toConsumableArray(meta.warnings);
        Object.values(subFieldErrors).forEach((subFieldError) => {
          errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || []));
          warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
        });
        return [errorList, warningList];
      }, [subFieldErrors, meta.errors, meta.warnings]);
      const getItemRef = useItemRef();
      function renderLayout(baseChildren, fieldId, isRequired2) {
        if (noStyle && !hidden) {
          return /* @__PURE__ */ reactExports.createElement(StatusProvider, {
            prefixCls,
            hasFeedback: props.hasFeedback,
            validateStatus: props.validateStatus,
            meta,
            errors: mergedErrors,
            warnings: mergedWarnings,
            noStyle: true
          }, baseChildren);
        }
        return /* @__PURE__ */ reactExports.createElement(ItemHolder, Object.assign({
          key: "row"
        }, props, {
          className: classNames(className, cssVarCls, rootCls, hashId),
          prefixCls,
          fieldId,
          isRequired: isRequired2,
          errors: mergedErrors,
          warnings: mergedWarnings,
          meta,
          onSubItemMetaChange,
          layout
        }), baseChildren);
      }
      if (!hasName && !isRenderProps && !dependencies) {
        return wrapCSSVar(renderLayout(mergedChildren));
      }
      let variables = {};
      if (typeof label === "string") {
        variables.label = label;
      } else if (name) {
        variables.label = String(name);
      }
      if (messageVariables) {
        variables = Object.assign(Object.assign({}, variables), messageVariables);
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(WrapperField, Object.assign({}, props, {
        messageVariables: variables,
        trigger,
        validateTrigger: mergedValidateTrigger,
        onMetaChange
      }), (control, renderMeta, context) => {
        const mergedName = toArray(name).length && renderMeta ? renderMeta.name : [];
        const fieldId = getFieldId(mergedName, formName);
        const isRequired2 = required2 !== void 0 ? required2 : !!(rules2 === null || rules2 === void 0 ? void 0 : rules2.some((rule) => {
          if (rule && typeof rule === "object" && rule.required && !rule.warningOnly) {
            return true;
          }
          if (typeof rule === "function") {
            const ruleEntity = rule(context);
            return (ruleEntity === null || ruleEntity === void 0 ? void 0 : ruleEntity.required) && !(ruleEntity === null || ruleEntity === void 0 ? void 0 : ruleEntity.warningOnly);
          }
          return false;
        }));
        const mergedControl = Object.assign({}, control);
        let childNode = null;
        if (Array.isArray(mergedChildren) && hasName) {
          childNode = mergedChildren;
        } else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName)) ;
        else if (dependencies && !isRenderProps && !hasName) ;
        else if (/* @__PURE__ */ reactExports.isValidElement(mergedChildren)) {
          const childProps = Object.assign(Object.assign({}, mergedChildren.props), mergedControl);
          if (!childProps.id) {
            childProps.id = fieldId;
          }
          if (help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
            const describedbyArr = [];
            if (help || mergedErrors.length > 0) {
              describedbyArr.push(`${fieldId}_help`);
            }
            if (props.extra) {
              describedbyArr.push(`${fieldId}_extra`);
            }
            childProps["aria-describedby"] = describedbyArr.join(" ");
          }
          if (mergedErrors.length > 0) {
            childProps["aria-invalid"] = "true";
          }
          if (isRequired2) {
            childProps["aria-required"] = "true";
          }
          if (supportRef(mergedChildren)) {
            childProps.ref = getItemRef(mergedName, mergedChildren);
          }
          const triggers = new Set([].concat(_toConsumableArray(toArray(trigger)), _toConsumableArray(toArray(mergedValidateTrigger))));
          triggers.forEach((eventName) => {
            childProps[eventName] = function() {
              var _a2, _c2;
              var _a, _b, _c;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              (_a = mergedControl[eventName]) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [mergedControl].concat(args));
              (_c = (_b = mergedChildren.props)[eventName]) === null || _c === void 0 ? void 0 : (_c2 = _c).call.apply(_c2, [_b].concat(args));
            };
          });
          const watchingChildProps = [childProps["aria-required"], childProps["aria-invalid"], childProps["aria-describedby"]];
          childNode = /* @__PURE__ */ reactExports.createElement(MemoInput, {
            control: mergedControl,
            update: mergedChildren,
            childProps: watchingChildProps
          }, cloneElement(mergedChildren, childProps));
        } else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) {
          childNode = mergedChildren(context);
        } else {
          childNode = mergedChildren;
        }
        return renderLayout(childNode, fieldId, isRequired2);
      }));
    }
    const FormItem = InternalFormItem;
    FormItem.useStatus = useFormItemStatus;
    var __rest$l = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const FormList = (_a) => {
      var {
        prefixCls: customizePrefixCls,
        children
      } = _a, props = __rest$l(_a, ["prefixCls", "children"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("form", customizePrefixCls);
      const contextValue = reactExports.useMemo(() => ({
        prefixCls,
        status: "error"
      }), [prefixCls]);
      return /* @__PURE__ */ reactExports.createElement(List$2, Object.assign({}, props), (fields, operation, meta) => /* @__PURE__ */ reactExports.createElement(FormItemPrefixContext.Provider, {
        value: contextValue
      }, children(fields.map((field) => Object.assign(Object.assign({}, field), {
        fieldKey: field.key
      })), operation, {
        errors: meta.errors,
        warnings: meta.warnings
      })));
    };
    function useFormInstance() {
      const {
        form
      } = reactExports.useContext(FormContext);
      return form;
    }
    const Form$1 = Form$2;
    Form$1.Item = FormItem;
    Form$1.List = FormList;
    Form$1.ErrorList = ErrorList;
    Form$1.useForm = useForm;
    Form$1.useFormInstance = useFormInstance;
    Form$1.useWatch = useWatch$1;
    Form$1.Provider = FormProvider;
    Form$1.create = () => {
    };
    var EyeOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
    var EyeOutlined = function EyeOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: EyeOutlined$1
      }));
    };
    var RefIcon$j = /* @__PURE__ */ reactExports.forwardRef(EyeOutlined);
    const Group = (props) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        className
      } = props;
      const prefixCls = getPrefixCls("input-group", customizePrefixCls);
      const inputPrefixCls = getPrefixCls("input");
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$h(inputPrefixCls);
      const cls = classNames(prefixCls, cssVarCls, {
        [`${prefixCls}-lg`]: props.size === "large",
        [`${prefixCls}-sm`]: props.size === "small",
        [`${prefixCls}-compact`]: props.compact,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, hashId, className);
      const formItemContext = reactExports.useContext(FormItemInputContext);
      const groupFormItemContext = reactExports.useMemo(() => Object.assign(Object.assign({}, formItemContext), {
        isFormItemInput: false
      }), [formItemContext]);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("span", {
        className: cls,
        style: props.style,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        onFocus: props.onFocus,
        onBlur: props.onBlur
      }, /* @__PURE__ */ reactExports.createElement(FormItemInputContext.Provider, {
        value: groupFormItemContext
      }, props.children)));
    };
    const genOTPStyle = (token2) => {
      const {
        componentCls,
        paddingXS
      } = token2;
      return {
        [componentCls]: {
          display: "inline-flex",
          alignItems: "center",
          flexWrap: "nowrap",
          columnGap: paddingXS,
          "&-rtl": {
            direction: "rtl"
          },
          [`${componentCls}-input`]: {
            textAlign: "center",
            paddingInline: token2.paddingXXS
          },
          // ================= Size =================
          [`&${componentCls}-sm ${componentCls}-input`]: {
            paddingInline: token2.calc(token2.paddingXXS).div(2).equal()
          },
          [`&${componentCls}-lg ${componentCls}-input`]: {
            paddingInline: token2.paddingXS
          }
        }
      };
    };
    const useStyle$9 = genStyleHooks(["Input", "OTP"], (token2) => {
      const inputToken = merge(token2, initInputToken(token2));
      return [genOTPStyle(inputToken)];
    }, initComponentToken);
    var __rest$k = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const OTPInput = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        value,
        onChange,
        onActiveChange,
        index: index2,
        mask
      } = props, restProps = __rest$k(props, ["value", "onChange", "onActiveChange", "index", "mask"]);
      const internalValue = value && typeof mask === "string" ? mask : value;
      const onInternalChange = (e2) => {
        onChange(index2, e2.target.value);
      };
      const inputRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, () => inputRef.current);
      const syncSelection = () => {
        wrapperRaf(() => {
          var _a;
          const inputEle = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input;
          if (document.activeElement === inputEle && inputEle) {
            inputEle.select();
          }
        });
      };
      const onInternalKeyDown = (event) => {
        const {
          key,
          ctrlKey,
          metaKey
        } = event;
        if (key === "ArrowLeft") {
          onActiveChange(index2 - 1);
        } else if (key === "ArrowRight") {
          onActiveChange(index2 + 1);
        } else if (key === "z" && (ctrlKey || metaKey)) {
          event.preventDefault();
        }
        syncSelection();
      };
      const onInternalKeyUp = (e2) => {
        if (e2.key === "Backspace" && !value) {
          onActiveChange(index2 - 1);
        }
        syncSelection();
      };
      return /* @__PURE__ */ reactExports.createElement(Input$2, Object.assign({
        type: mask === true ? "password" : "text"
      }, restProps, {
        ref: inputRef,
        value: internalValue,
        onInput: onInternalChange,
        onFocus: syncSelection,
        onKeyDown: onInternalKeyDown,
        onKeyUp: onInternalKeyUp,
        onMouseDown: syncSelection,
        onMouseUp: syncSelection
      }));
    });
    var __rest$j = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function strToArr(str) {
      return (str || "").split("");
    }
    const Separator = (props) => {
      const {
        index: index2,
        prefixCls,
        separator
      } = props;
      const separatorNode = typeof separator === "function" ? separator(index2) : separator;
      if (!separatorNode) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-separator`
      }, separatorNode);
    };
    const OTP = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        length: length2 = 6,
        size: customSize,
        defaultValue,
        value,
        onChange,
        formatter,
        separator,
        variant,
        disabled,
        status: customStatus,
        autoFocus,
        mask,
        type: type2,
        onInput,
        inputMode
      } = props, restProps = __rest$j(props, ["prefixCls", "length", "size", "defaultValue", "value", "onChange", "formatter", "separator", "variant", "disabled", "status", "autoFocus", "mask", "type", "onInput", "inputMode"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("otp", customizePrefixCls);
      const domAttrs = pickAttrs(restProps, {
        aria: true,
        data: true,
        attr: true
      });
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$9(prefixCls);
      const mergedSize = useSize((ctx) => customSize !== null && customSize !== void 0 ? customSize : ctx);
      const formContext = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(formContext.status, customStatus);
      const proxyFormContext = reactExports.useMemo(() => Object.assign(Object.assign({}, formContext), {
        status: mergedStatus,
        hasFeedback: false,
        feedbackIcon: null
      }), [formContext, mergedStatus]);
      const containerRef = reactExports.useRef(null);
      const refs = reactExports.useRef({});
      reactExports.useImperativeHandle(ref, () => ({
        focus: () => {
          var _a;
          (_a = refs.current[0]) === null || _a === void 0 ? void 0 : _a.focus();
        },
        blur: () => {
          var _a;
          for (let i2 = 0; i2 < length2; i2 += 1) {
            (_a = refs.current[i2]) === null || _a === void 0 ? void 0 : _a.blur();
          }
        },
        nativeElement: containerRef.current
      }));
      const internalFormatter = (txt) => formatter ? formatter(txt) : txt;
      const [valueCells, setValueCells] = reactExports.useState(() => strToArr(internalFormatter(defaultValue || "")));
      reactExports.useEffect(() => {
        if (value !== void 0) {
          setValueCells(strToArr(value));
        }
      }, [value]);
      const triggerValueCellsChange = useEvent((nextValueCells) => {
        setValueCells(nextValueCells);
        if (onInput) {
          onInput(nextValueCells);
        }
        if (onChange && nextValueCells.length === length2 && nextValueCells.every((c2) => c2) && nextValueCells.some((c2, index2) => valueCells[index2] !== c2)) {
          onChange(nextValueCells.join(""));
        }
      });
      const patchValue = useEvent((index2, txt) => {
        let nextCells = _toConsumableArray(valueCells);
        for (let i2 = 0; i2 < index2; i2 += 1) {
          if (!nextCells[i2]) {
            nextCells[i2] = "";
          }
        }
        if (txt.length <= 1) {
          nextCells[index2] = txt;
        } else {
          nextCells = nextCells.slice(0, index2).concat(strToArr(txt));
        }
        nextCells = nextCells.slice(0, length2);
        for (let i2 = nextCells.length - 1; i2 >= 0; i2 -= 1) {
          if (nextCells[i2]) {
            break;
          }
          nextCells.pop();
        }
        const formattedValue = internalFormatter(nextCells.map((c2) => c2 || " ").join(""));
        nextCells = strToArr(formattedValue).map((c2, i2) => {
          if (c2 === " " && !nextCells[i2]) {
            return nextCells[i2];
          }
          return c2;
        });
        return nextCells;
      });
      const onInputChange = (index2, txt) => {
        var _a;
        const nextCells = patchValue(index2, txt);
        const nextIndex = Math.min(index2 + txt.length, length2 - 1);
        if (nextIndex !== index2 && nextCells[index2] !== void 0) {
          (_a = refs.current[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();
        }
        triggerValueCellsChange(nextCells);
      };
      const onInputActiveChange = (nextIndex) => {
        var _a;
        (_a = refs.current[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();
      };
      const inputSharedProps = {
        variant,
        disabled,
        status: mergedStatus,
        mask,
        type: type2,
        inputMode
      };
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({}, domAttrs, {
        ref: containerRef,
        className: classNames(prefixCls, {
          [`${prefixCls}-sm`]: mergedSize === "small",
          [`${prefixCls}-lg`]: mergedSize === "large",
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, cssVarCls, hashId)
      }), /* @__PURE__ */ reactExports.createElement(FormItemInputContext.Provider, {
        value: proxyFormContext
      }, Array.from({
        length: length2
      }).map((_2, index2) => {
        const key = `otp-${index2}`;
        const singleValue = valueCells[index2] || "";
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, {
          key
        }, /* @__PURE__ */ reactExports.createElement(OTPInput, Object.assign({
          ref: (inputEle) => {
            refs.current[index2] = inputEle;
          },
          index: index2,
          size: mergedSize,
          htmlSize: 1,
          className: `${prefixCls}-input`,
          onChange: onInputChange,
          value: singleValue,
          onActiveChange: onInputActiveChange,
          autoFocus: index2 === 0 && autoFocus
        }, inputSharedProps)), index2 < length2 - 1 && /* @__PURE__ */ reactExports.createElement(Separator, {
          separator,
          index: index2,
          prefixCls
        }));
      }))));
    });
    var EyeInvisibleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
    var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: EyeInvisibleOutlined$1
      }));
    };
    var RefIcon$i = /* @__PURE__ */ reactExports.forwardRef(EyeInvisibleOutlined);
    var __rest$i = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const defaultIconRender = (visible) => visible ? /* @__PURE__ */ reactExports.createElement(RefIcon$j, null) : /* @__PURE__ */ reactExports.createElement(RefIcon$i, null);
    const actionMap = {
      click: "onClick",
      hover: "onMouseOver"
    };
    const Password = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        disabled: customDisabled,
        action = "click",
        visibilityToggle = true,
        iconRender = defaultIconRender
      } = props;
      const disabled = reactExports.useContext(DisabledContext);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
      const [visible, setVisible] = reactExports.useState(() => visibilityControlled ? visibilityToggle.visible : false);
      const inputRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (visibilityControlled) {
          setVisible(visibilityToggle.visible);
        }
      }, [visibilityControlled, visibilityToggle]);
      const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
      const onVisibleChange = () => {
        var _a;
        if (mergedDisabled) {
          return;
        }
        if (visible) {
          removePasswordTimeout();
        }
        const nextVisible = !visible;
        setVisible(nextVisible);
        if (typeof visibilityToggle === "object") {
          (_a = visibilityToggle.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(visibilityToggle, nextVisible);
        }
      };
      const getIcon = (prefixCls2) => {
        const iconTrigger = actionMap[action] || "";
        const icon = iconRender(visible);
        const iconProps = {
          [iconTrigger]: onVisibleChange,
          className: `${prefixCls2}-icon`,
          key: "passwordIcon",
          onMouseDown: (e2) => {
            e2.preventDefault();
          },
          onMouseUp: (e2) => {
            e2.preventDefault();
          }
        };
        return /* @__PURE__ */ reactExports.cloneElement(/* @__PURE__ */ reactExports.isValidElement(icon) ? icon : /* @__PURE__ */ reactExports.createElement("span", null, icon), iconProps);
      };
      const {
        className,
        prefixCls: customizePrefixCls,
        inputPrefixCls: customizeInputPrefixCls,
        size
      } = props, restProps = __rest$i(props, ["className", "prefixCls", "inputPrefixCls", "size"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
      const prefixCls = getPrefixCls("input-password", customizePrefixCls);
      const suffixIcon = visibilityToggle && getIcon(prefixCls);
      const inputClassName = classNames(prefixCls, className, {
        [`${prefixCls}-${size}`]: !!size
      });
      const omittedProps = Object.assign(Object.assign({}, omit(restProps, ["suffix", "iconRender", "visibilityToggle"])), {
        type: visible ? "text" : "password",
        className: inputClassName,
        prefixCls: inputPrefixCls,
        suffix: suffixIcon
      });
      if (size) {
        omittedProps.size = size;
      }
      return /* @__PURE__ */ reactExports.createElement(Input$2, Object.assign({
        ref: composeRef(ref, inputRef)
      }, omittedProps));
    });
    var __rest$h = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const Search = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        inputPrefixCls: customizeInputPrefixCls,
        className,
        size: customizeSize,
        suffix: suffix2,
        enterButton = false,
        addonAfter,
        loading,
        disabled,
        onSearch: customOnSearch,
        onChange: customOnChange,
        onCompositionStart,
        onCompositionEnd
      } = props, restProps = __rest$h(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const composedRef = reactExports.useRef(false);
      const prefixCls = getPrefixCls("input-search", customizePrefixCls);
      const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
      const {
        compactSize
      } = useCompactItemContext(prefixCls, direction);
      const size = useSize((ctx) => {
        var _a;
        return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
      });
      const inputRef = reactExports.useRef(null);
      const onChange = (e2) => {
        if ((e2 === null || e2 === void 0 ? void 0 : e2.target) && e2.type === "click" && customOnSearch) {
          customOnSearch(e2.target.value, e2, {
            source: "clear"
          });
        }
        customOnChange === null || customOnChange === void 0 ? void 0 : customOnChange(e2);
      };
      const onMouseDown = (e2) => {
        var _a;
        if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) {
          e2.preventDefault();
        }
      };
      const onSearch = (e2) => {
        var _a, _b;
        if (customOnSearch) {
          customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e2, {
            source: "input"
          });
        }
      };
      const onPressEnter = (e2) => {
        if (composedRef.current || loading) {
          return;
        }
        onSearch(e2);
      };
      const searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ reactExports.createElement(RefIcon$t, null) : null;
      const btnClassName = `${prefixCls}-button`;
      let button;
      const enterButtonAsElement = enterButton || {};
      const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
      if (isAntdButton || enterButtonAsElement.type === "button") {
        button = cloneElement(enterButtonAsElement, Object.assign({
          onMouseDown,
          onClick: (e2) => {
            var _a, _b;
            (_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e2);
            onSearch(e2);
          },
          key: "enterButton"
        }, isAntdButton ? {
          className: btnClassName,
          size
        } : {}));
      } else {
        button = /* @__PURE__ */ reactExports.createElement(Button$1, {
          className: btnClassName,
          type: enterButton ? "primary" : void 0,
          size,
          disabled,
          key: "enterButton",
          onMouseDown,
          onClick: onSearch,
          loading,
          icon: searchIcon
        }, enterButton);
      }
      if (addonAfter) {
        button = [button, cloneElement(addonAfter, {
          key: "addonAfter"
        })];
      }
      const cls = classNames(prefixCls, {
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-${size}`]: !!size,
        [`${prefixCls}-with-button`]: !!enterButton
      }, className);
      const newProps = Object.assign(Object.assign({}, restProps), {
        className: cls,
        prefixCls: inputPrefixCls,
        type: "search"
      });
      const handleOnCompositionStart = (e2) => {
        composedRef.current = true;
        onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
      };
      const handleOnCompositionEnd = (e2) => {
        composedRef.current = false;
        onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
      };
      return /* @__PURE__ */ reactExports.createElement(Input$2, Object.assign({
        ref: composeRef(inputRef, ref),
        onPressEnter
      }, newProps, {
        size,
        onCompositionStart: handleOnCompositionStart,
        onCompositionEnd: handleOnCompositionEnd,
        addonAfter: button,
        suffix: suffix2,
        onChange,
        disabled
      }));
    });
    var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n";
    var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
    var computedStyleCache = {};
    var hiddenTextarea;
    function calculateNodeStyling(node2) {
      var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
      if (useCache2 && computedStyleCache[nodeRef]) {
        return computedStyleCache[nodeRef];
      }
      var style2 = window.getComputedStyle(node2);
      var boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
      var paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
      var borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
      var sizingStyle = SIZING_STYLE.map(function(name) {
        return "".concat(name, ":").concat(style2.getPropertyValue(name));
      }).join(";");
      var nodeInfo = {
        sizingStyle,
        paddingSize,
        borderSize,
        boxSizing
      };
      if (useCache2 && nodeRef) {
        computedStyleCache[nodeRef] = nodeInfo;
      }
      return nodeInfo;
    }
    function calculateAutoSizeStyle(uiTextNode) {
      var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      if (!hiddenTextarea) {
        hiddenTextarea = document.createElement("textarea");
        hiddenTextarea.setAttribute("tab-index", "-1");
        hiddenTextarea.setAttribute("aria-hidden", "true");
        hiddenTextarea.setAttribute("name", "hiddenTextarea");
        document.body.appendChild(hiddenTextarea);
      }
      if (uiTextNode.getAttribute("wrap")) {
        hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
      } else {
        hiddenTextarea.removeAttribute("wrap");
      }
      var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache2), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
      hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
      hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
      var minHeight = void 0;
      var maxHeight = void 0;
      var overflowY;
      var height = hiddenTextarea.scrollHeight;
      if (boxSizing === "border-box") {
        height += borderSize;
      } else if (boxSizing === "content-box") {
        height -= paddingSize;
      }
      if (minRows !== null || maxRows !== null) {
        hiddenTextarea.value = " ";
        var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (minRows !== null) {
          minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
        }
        if (maxRows !== null) {
          maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          overflowY = height > maxHeight ? "" : "hidden";
          height = Math.min(maxHeight, height);
        }
      }
      var style2 = {
        height,
        overflowY,
        resize: "none"
      };
      if (minHeight) {
        style2.minHeight = minHeight;
      }
      if (maxHeight) {
        style2.maxHeight = maxHeight;
      }
      return style2;
    }
    var _excluded$5 = ["prefixCls", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"];
    var RESIZE_START = 0;
    var RESIZE_MEASURING = 1;
    var RESIZE_STABLE = 2;
    var ResizableTextArea = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _ref = props, prefixCls = _ref.prefixCls, defaultValue = _ref.defaultValue, value = _ref.value, autoSize = _ref.autoSize, onResize2 = _ref.onResize, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, onChange = _ref.onChange;
      _ref.onInternalAutoSize;
      var restProps = _objectWithoutProperties(_ref, _excluded$5);
      var _useMergedState = useMergedState(defaultValue, {
        value,
        postState: function postState(val) {
          return val !== null && val !== void 0 ? val : "";
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setMergedValue = _useMergedState2[1];
      var onInternalChange = function onInternalChange2(event) {
        setMergedValue(event.target.value);
        onChange === null || onChange === void 0 || onChange(event);
      };
      var textareaRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function() {
        return {
          textArea: textareaRef.current
        };
      });
      var _React$useMemo = reactExports.useMemo(function() {
        if (autoSize && _typeof$1(autoSize) === "object") {
          return [autoSize.minRows, autoSize.maxRows];
        }
        return [];
      }, [autoSize]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), minRows = _React$useMemo2[0], maxRows = _React$useMemo2[1];
      var needAutoSize = !!autoSize;
      var fixFirefoxAutoScroll = function fixFirefoxAutoScroll2() {
        try {
          if (document.activeElement === textareaRef.current) {
            var _textareaRef$current = textareaRef.current, selectionStart = _textareaRef$current.selectionStart, selectionEnd = _textareaRef$current.selectionEnd, scrollTop = _textareaRef$current.scrollTop;
            textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
            textareaRef.current.scrollTop = scrollTop;
          }
        } catch (e2) {
        }
      };
      var _React$useState = reactExports.useState(RESIZE_STABLE), _React$useState2 = _slicedToArray(_React$useState, 2), resizeState = _React$useState2[0], setResizeState = _React$useState2[1];
      var _React$useState3 = reactExports.useState(), _React$useState4 = _slicedToArray(_React$useState3, 2), autoSizeStyle = _React$useState4[0], setAutoSizeStyle = _React$useState4[1];
      var startResize = function startResize2() {
        setResizeState(RESIZE_START);
      };
      useLayoutEffect$1(function() {
        if (needAutoSize) {
          startResize();
        }
      }, [value, minRows, maxRows, needAutoSize]);
      useLayoutEffect$1(function() {
        if (resizeState === RESIZE_START) {
          setResizeState(RESIZE_MEASURING);
        } else if (resizeState === RESIZE_MEASURING) {
          var textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
          setResizeState(RESIZE_STABLE);
          setAutoSizeStyle(textareaStyles);
        } else {
          fixFirefoxAutoScroll();
        }
      }, [resizeState]);
      var resizeRafRef = reactExports.useRef();
      var cleanRaf = function cleanRaf2() {
        wrapperRaf.cancel(resizeRafRef.current);
      };
      var onInternalResize = function onInternalResize2(size) {
        if (resizeState === RESIZE_STABLE) {
          onResize2 === null || onResize2 === void 0 || onResize2(size);
          if (autoSize) {
            cleanRaf();
            resizeRafRef.current = wrapperRaf(function() {
              startResize();
            });
          }
        }
      };
      reactExports.useEffect(function() {
        return cleanRaf;
      }, []);
      var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
      var mergedStyle = _objectSpread2$3(_objectSpread2$3({}, style2), mergedAutoSizeStyle);
      if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
        mergedStyle.overflowY = "hidden";
        mergedStyle.overflowX = "hidden";
      }
      return /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onInternalResize,
        disabled: !(autoSize || onResize2)
      }, /* @__PURE__ */ reactExports.createElement("textarea", _extends$2({}, restProps, {
        ref: textareaRef,
        style: mergedStyle,
        className: classNames(prefixCls, className, _defineProperty({}, "".concat(prefixCls, "-disabled"), disabled)),
        disabled,
        value: mergedValue,
        onChange: onInternalChange
      })));
    });
    var _excluded$4 = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "showCount", "count", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize", "onClear", "onPressEnter", "readOnly", "autoSize", "onKeyDown"];
    var TextArea$1 = /* @__PURE__ */ i.forwardRef(function(_ref, ref) {
      var _countConfig$max;
      var defaultValue = _ref.defaultValue, customValue = _ref.value, onFocus = _ref.onFocus, onBlur = _ref.onBlur, onChange = _ref.onChange, allowClear = _ref.allowClear, maxLength = _ref.maxLength, onCompositionStart = _ref.onCompositionStart, onCompositionEnd = _ref.onCompositionEnd, suffix2 = _ref.suffix, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-textarea" : _ref$prefixCls, showCount = _ref.showCount, count = _ref.count, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, hidden = _ref.hidden, classNames$1 = _ref.classNames, styles = _ref.styles, onResize2 = _ref.onResize, onClear = _ref.onClear, onPressEnter = _ref.onPressEnter, readOnly = _ref.readOnly, autoSize = _ref.autoSize, onKeyDown = _ref.onKeyDown, rest = _objectWithoutProperties(_ref, _excluded$4);
      var _useMergedState = useMergedState(defaultValue, {
        value: customValue,
        defaultValue
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
      var formatValue2 = value === void 0 || value === null ? "" : String(value);
      var _React$useState = i.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
      var compositionRef = i.useRef(false);
      var _React$useState3 = i.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), textareaResized = _React$useState4[0], setTextareaResized = _React$useState4[1];
      var holderRef = reactExports.useRef(null);
      var resizableTextAreaRef = reactExports.useRef(null);
      var getTextArea = function getTextArea2() {
        var _resizableTextAreaRef;
        return (_resizableTextAreaRef = resizableTextAreaRef.current) === null || _resizableTextAreaRef === void 0 ? void 0 : _resizableTextAreaRef.textArea;
      };
      var focus = function focus2() {
        getTextArea().focus();
      };
      reactExports.useImperativeHandle(ref, function() {
        var _holderRef$current;
        return {
          resizableTextArea: resizableTextAreaRef.current,
          focus,
          blur: function blur() {
            getTextArea().blur();
          },
          nativeElement: ((_holderRef$current = holderRef.current) === null || _holderRef$current === void 0 ? void 0 : _holderRef$current.nativeElement) || getTextArea()
        };
      });
      reactExports.useEffect(function() {
        setFocused(function(prev2) {
          return !disabled && prev2;
        });
      }, [disabled]);
      var _React$useState5 = i.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), selection = _React$useState6[0], setSelection = _React$useState6[1];
      i.useEffect(function() {
        if (selection) {
          var _getTextArea;
          (_getTextArea = getTextArea()).setSelectionRange.apply(_getTextArea, _toConsumableArray(selection));
        }
      }, [selection]);
      var countConfig = useCount(count, showCount);
      var mergedMax = (_countConfig$max = countConfig.max) !== null && _countConfig$max !== void 0 ? _countConfig$max : maxLength;
      var hasMaxLength = Number(mergedMax) > 0;
      var valueLength = countConfig.strategy(formatValue2);
      var isOutOfRange = !!mergedMax && valueLength > mergedMax;
      var triggerChange = function triggerChange2(e2, currentValue) {
        var cutValue = currentValue;
        if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
          cutValue = countConfig.exceedFormatter(currentValue, {
            max: countConfig.max
          });
          if (currentValue !== cutValue) {
            setSelection([getTextArea().selectionStart || 0, getTextArea().selectionEnd || 0]);
          }
        }
        setValue(cutValue);
        resolveOnChange(e2.currentTarget, e2, onChange, cutValue);
      };
      var onInternalCompositionStart = function onInternalCompositionStart2(e2) {
        compositionRef.current = true;
        onCompositionStart === null || onCompositionStart === void 0 || onCompositionStart(e2);
      };
      var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {
        compositionRef.current = false;
        triggerChange(e2, e2.currentTarget.value);
        onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e2);
      };
      var onInternalChange = function onInternalChange2(e2) {
        triggerChange(e2, e2.target.value);
      };
      var handleKeyDown = function handleKeyDown2(e2) {
        if (e2.key === "Enter" && onPressEnter) {
          onPressEnter(e2);
        }
        onKeyDown === null || onKeyDown === void 0 || onKeyDown(e2);
      };
      var handleFocus = function handleFocus2(e2) {
        setFocused(true);
        onFocus === null || onFocus === void 0 || onFocus(e2);
      };
      var handleBlur = function handleBlur2(e2) {
        setFocused(false);
        onBlur === null || onBlur === void 0 || onBlur(e2);
      };
      var handleReset = function handleReset2(e2) {
        setValue("");
        focus();
        resolveOnChange(getTextArea(), e2, onChange);
      };
      var suffixNode = suffix2;
      var dataCount;
      if (countConfig.show) {
        if (countConfig.showFormatter) {
          dataCount = countConfig.showFormatter({
            value: formatValue2,
            count: valueLength,
            maxLength: mergedMax
          });
        } else {
          dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : "");
        }
        suffixNode = /* @__PURE__ */ i.createElement(i.Fragment, null, suffixNode, /* @__PURE__ */ i.createElement("span", {
          className: classNames("".concat(prefixCls, "-data-count"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.count),
          style: styles === null || styles === void 0 ? void 0 : styles.count
        }, dataCount));
      }
      var handleResize = function handleResize2(size) {
        var _getTextArea2;
        onResize2 === null || onResize2 === void 0 || onResize2(size);
        if ((_getTextArea2 = getTextArea()) !== null && _getTextArea2 !== void 0 && _getTextArea2.style.height) {
          setTextareaResized(true);
        }
      };
      var isPureTextArea = !autoSize && !showCount && !allowClear;
      return /* @__PURE__ */ i.createElement(BaseInput, {
        ref: holderRef,
        value: formatValue2,
        allowClear,
        handleReset,
        suffix: suffixNode,
        prefixCls,
        classNames: _objectSpread2$3(_objectSpread2$3({}, classNames$1), {}, {
          affixWrapper: classNames(classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.affixWrapper, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-show-count"), showCount), "".concat(prefixCls, "-textarea-allow-clear"), allowClear))
        }),
        disabled,
        focused,
        className: classNames(className, isOutOfRange && "".concat(prefixCls, "-out-of-range")),
        style: _objectSpread2$3(_objectSpread2$3({}, style2), textareaResized && !isPureTextArea ? {
          height: "auto"
        } : {}),
        dataAttrs: {
          affixWrapper: {
            "data-count": typeof dataCount === "string" ? dataCount : void 0
          }
        },
        hidden,
        readOnly,
        onClear
      }, /* @__PURE__ */ i.createElement(ResizableTextArea, _extends$2({}, rest, {
        autoSize,
        maxLength,
        onKeyDown: handleKeyDown,
        onChange: onInternalChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onCompositionStart: onInternalCompositionStart,
        onCompositionEnd: onInternalCompositionEnd,
        className: classNames(classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.textarea),
        style: _objectSpread2$3(_objectSpread2$3({}, styles === null || styles === void 0 ? void 0 : styles.textarea), {}, {
          resize: style2 === null || style2 === void 0 ? void 0 : style2.resize
        }),
        disabled,
        prefixCls,
        onResize: handleResize,
        ref: resizableTextAreaRef,
        readOnly
      })));
    });
    const genTextAreaStyle = (token2) => {
      const {
        componentCls,
        paddingLG
      } = token2;
      const textareaPrefixCls = `${componentCls}-textarea`;
      return {
        // Raw Textarea
        [`textarea${componentCls}`]: {
          maxWidth: "100%",
          // prevent textarea resize from coming out of its container
          height: "auto",
          minHeight: token2.controlHeight,
          lineHeight: token2.lineHeight,
          verticalAlign: "bottom",
          transition: `all ${token2.motionDurationSlow}`,
          resize: "vertical",
          [`&${componentCls}-mouse-active`]: {
            transition: `all ${token2.motionDurationSlow}, height 0s, width 0s`
          }
        },
        // Wrapper for resize
        [`${componentCls}-textarea-affix-wrapper-resize-dirty`]: {
          width: "auto"
        },
        [textareaPrefixCls]: {
          position: "relative",
          "&-show-count": {
            // https://github.com/ant-design/ant-design/issues/33049
            [`> ${componentCls}`]: {
              height: "100%"
            },
            [`${componentCls}-data-count`]: {
              position: "absolute",
              bottom: token2.calc(token2.fontSize).mul(token2.lineHeight).mul(-1).equal(),
              insetInlineEnd: 0,
              color: token2.colorTextDescription,
              whiteSpace: "nowrap",
              pointerEvents: "none"
            }
          },
          [`
        &-allow-clear > ${componentCls},
        &-affix-wrapper${textareaPrefixCls}-has-feedback ${componentCls}
      `]: {
            paddingInlineEnd: paddingLG
          },
          [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
            padding: 0,
            [`> textarea${componentCls}`]: {
              fontSize: "inherit",
              border: "none",
              outline: "none",
              background: "transparent",
              minHeight: token2.calc(token2.controlHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal(),
              "&:focus": {
                boxShadow: "none !important"
              }
            },
            [`${componentCls}-suffix`]: {
              margin: 0,
              "> *:not(:last-child)": {
                marginInline: 0
              },
              // Clear Icon
              [`${componentCls}-clear-icon`]: {
                position: "absolute",
                insetInlineEnd: token2.paddingInline,
                insetBlockStart: token2.paddingXS
              },
              // Feedback Icon
              [`${textareaPrefixCls}-suffix`]: {
                position: "absolute",
                top: 0,
                insetInlineEnd: token2.paddingInline,
                bottom: 0,
                zIndex: 1,
                display: "inline-flex",
                alignItems: "center",
                margin: "auto",
                pointerEvents: "none"
              }
            }
          },
          [`&-affix-wrapper${componentCls}-affix-wrapper-sm`]: {
            [`${componentCls}-suffix`]: {
              [`${componentCls}-clear-icon`]: {
                insetInlineEnd: token2.paddingInlineSM
              }
            }
          }
        }
      };
    };
    const useStyle$8 = genStyleHooks(["Input", "TextArea"], (token2) => {
      const inputToken = merge(token2, initInputToken(token2));
      return [genTextAreaStyle(inputToken)];
    }, initComponentToken, {
      resetFont: false
    });
    var __rest$g = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const TextArea = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a;
      const {
        prefixCls: customizePrefixCls,
        bordered = true,
        size: customizeSize,
        disabled: customDisabled,
        status: customStatus,
        allowClear,
        classNames: classes,
        rootClassName,
        className,
        style: style2,
        styles,
        variant: customVariant,
        showCount,
        onMouseDown,
        onResize: onResize2
      } = props, rest = __rest$g(props, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className", "style", "styles", "variant", "showCount", "onMouseDown", "onResize"]);
      const {
        getPrefixCls,
        direction,
        allowClear: contextAllowClear,
        autoComplete: contextAutoComplete,
        className: contextClassName,
        style: contextStyle,
        classNames: contextClassNames,
        styles: contextStyles
      } = useComponentConfig("textArea");
      const disabled = reactExports.useContext(DisabledContext);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const {
        status: contextStatus,
        hasFeedback,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      const innerRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, () => {
        var _a2;
        return {
          resizableTextArea: (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea,
          focus: (option) => {
            var _a3, _b;
            triggerFocus((_b = (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
          },
          blur: () => {
            var _a3;
            return (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.blur();
          }
        };
      });
      const prefixCls = getPrefixCls("input", customizePrefixCls);
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapSharedCSSVar, hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
      const [wrapCSSVar] = useStyle$8(prefixCls, rootCls);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const mergedSize = useSize((ctx) => {
        var _a2;
        return (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
      });
      const [variant, enableVariantCls] = useVariant("textArea", customVariant, bordered);
      const mergedAllowClear = getAllowClear(allowClear !== null && allowClear !== void 0 ? allowClear : contextAllowClear);
      const [isMouseDown, setIsMouseDown] = reactExports.useState(false);
      const [resizeDirty, setResizeDirty] = reactExports.useState(false);
      const onInternalMouseDown = (e2) => {
        setIsMouseDown(true);
        onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(e2);
        const onMouseUp = () => {
          setIsMouseDown(false);
          document.removeEventListener("mouseup", onMouseUp);
        };
        document.addEventListener("mouseup", onMouseUp);
      };
      const onInternalResize = (size) => {
        var _a2, _b;
        onResize2 === null || onResize2 === void 0 ? void 0 : onResize2(size);
        if (isMouseDown && typeof getComputedStyle === "function") {
          const ele = (_b = (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.nativeElement) === null || _b === void 0 ? void 0 : _b.querySelector("textarea");
          if (ele && getComputedStyle(ele).resize === "both") {
            setResizeDirty(true);
          }
        }
      };
      return wrapSharedCSSVar(wrapCSSVar(/* @__PURE__ */ reactExports.createElement(TextArea$1, Object.assign({
        autoComplete: contextAutoComplete
      }, rest, {
        style: Object.assign(Object.assign({}, contextStyle), style2),
        styles: Object.assign(Object.assign({}, contextStyles), styles),
        disabled: mergedDisabled,
        allowClear: mergedAllowClear,
        className: classNames(
          cssVarCls,
          rootCls,
          className,
          rootClassName,
          compactItemClassnames,
          contextClassName,
          // Only for wrapper
          resizeDirty && `${prefixCls}-textarea-affix-wrapper-resize-dirty`
        ),
        classNames: Object.assign(Object.assign(Object.assign({}, classes), contextClassNames), {
          textarea: classNames({
            [`${prefixCls}-sm`]: mergedSize === "small",
            [`${prefixCls}-lg`]: mergedSize === "large"
          }, hashId, classes === null || classes === void 0 ? void 0 : classes.textarea, contextClassNames.textarea, isMouseDown && `${prefixCls}-mouse-active`),
          variant: classNames({
            [`${prefixCls}-${variant}`]: enableVariantCls
          }, getStatusClassNames(prefixCls, mergedStatus)),
          affixWrapper: classNames(`${prefixCls}-textarea-affix-wrapper`, {
            [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-textarea-show-count`]: showCount || ((_a = props.count) === null || _a === void 0 ? void 0 : _a.show)
          }, hashId)
        }),
        prefixCls,
        suffix: hasFeedback && /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-textarea-suffix`
        }, feedbackIcon),
        showCount,
        ref: innerRef,
        onResize: onInternalResize,
        onMouseDown: onInternalMouseDown
      }))));
    });
    const Input$1 = Input$2;
    Input$1.Group = Group;
    Input$1.Search = Search;
    Input$1.TextArea = TextArea;
    Input$1.Password = Password;
    Input$1.OTP = OTP;
    const extendsObject = function() {
      const result = Object.assign({}, arguments.length <= 0 ? void 0 : arguments[0]);
      for (let i2 = 1; i2 < arguments.length; i2++) {
        const obj = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
        if (obj) {
          Object.keys(obj).forEach((key) => {
            const val = obj[key];
            if (val !== void 0) {
              result[key] = val;
            }
          });
        }
      }
      return result;
    };
    var DoubleLeftOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
    var DoubleLeftOutlined = function DoubleLeftOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: DoubleLeftOutlined$1
      }));
    };
    var RefIcon$h = /* @__PURE__ */ reactExports.forwardRef(DoubleLeftOutlined);
    var DoubleRightOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
    var DoubleRightOutlined = function DoubleRightOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: DoubleRightOutlined$1
      }));
    };
    var RefIcon$g = /* @__PURE__ */ reactExports.forwardRef(DoubleRightOutlined);
    var locale = {
      // Options
      items_per_page: "/",
      jump_to: "",
      jump_to_confirm: "",
      page: "",
      // Pagination
      prev_page: "",
      next_page: "",
      prev_5: " 5 ",
      next_5: " 5 ",
      prev_3: " 3 ",
      next_3: " 3 ",
      page_size: ""
    };
    var defaultPageSizeOptions = [10, 20, 50, 100];
    var Options = function Options2(props) {
      var _props$pageSizeOption = props.pageSizeOptions, pageSizeOptions = _props$pageSizeOption === void 0 ? defaultPageSizeOptions : _props$pageSizeOption, locale2 = props.locale, changeSize = props.changeSize, pageSize = props.pageSize, goButton = props.goButton, quickGo = props.quickGo, rootPrefixCls = props.rootPrefixCls, disabled = props.disabled, buildOptionText = props.buildOptionText, showSizeChanger = props.showSizeChanger, sizeChangerRender = props.sizeChangerRender;
      var _React$useState = i.useState(""), _React$useState2 = _slicedToArray(_React$useState, 2), goInputText = _React$useState2[0], setGoInputText = _React$useState2[1];
      var getValidValue = function getValidValue2() {
        return !goInputText || Number.isNaN(goInputText) ? void 0 : Number(goInputText);
      };
      var mergeBuildOptionText = typeof buildOptionText === "function" ? buildOptionText : function(value) {
        return "".concat(value, " ").concat(locale2.items_per_page);
      };
      var handleChange = function handleChange2(e2) {
        setGoInputText(e2.target.value);
      };
      var handleBlur = function handleBlur2(e2) {
        if (goButton || goInputText === "") {
          return;
        }
        setGoInputText("");
        if (e2.relatedTarget && (e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item-link")) >= 0 || e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item")) >= 0)) {
          return;
        }
        quickGo === null || quickGo === void 0 || quickGo(getValidValue());
      };
      var go = function go2(e2) {
        if (goInputText === "") {
          return;
        }
        if (e2.keyCode === KeyCode.ENTER || e2.type === "click") {
          setGoInputText("");
          quickGo === null || quickGo === void 0 || quickGo(getValidValue());
        }
      };
      var getPageSizeOptions = function getPageSizeOptions2() {
        if (pageSizeOptions.some(function(option) {
          return option.toString() === pageSize.toString();
        })) {
          return pageSizeOptions;
        }
        return pageSizeOptions.concat([pageSize]).sort(function(a, b2) {
          var numberA = Number.isNaN(Number(a)) ? 0 : Number(a);
          var numberB = Number.isNaN(Number(b2)) ? 0 : Number(b2);
          return numberA - numberB;
        });
      };
      var prefixCls = "".concat(rootPrefixCls, "-options");
      if (!showSizeChanger && !quickGo) {
        return null;
      }
      var changeSelect = null;
      var goInput = null;
      var gotoButton = null;
      if (showSizeChanger && sizeChangerRender) {
        changeSelect = sizeChangerRender({
          disabled,
          size: pageSize,
          onSizeChange: function onSizeChange(nextValue) {
            changeSize === null || changeSize === void 0 || changeSize(Number(nextValue));
          },
          "aria-label": locale2.page_size,
          className: "".concat(prefixCls, "-size-changer"),
          options: getPageSizeOptions().map(function(opt) {
            return {
              label: mergeBuildOptionText(opt),
              value: opt
            };
          })
        });
      }
      if (quickGo) {
        if (goButton) {
          gotoButton = typeof goButton === "boolean" ? /* @__PURE__ */ i.createElement("button", {
            type: "button",
            onClick: go,
            onKeyUp: go,
            disabled,
            className: "".concat(prefixCls, "-quick-jumper-button")
          }, locale2.jump_to_confirm) : /* @__PURE__ */ i.createElement("span", {
            onClick: go,
            onKeyUp: go
          }, goButton);
        }
        goInput = /* @__PURE__ */ i.createElement("div", {
          className: "".concat(prefixCls, "-quick-jumper")
        }, locale2.jump_to, /* @__PURE__ */ i.createElement("input", {
          disabled,
          type: "text",
          value: goInputText,
          onChange: handleChange,
          onKeyUp: go,
          onBlur: handleBlur,
          "aria-label": locale2.page
        }), locale2.page, gotoButton);
      }
      return /* @__PURE__ */ i.createElement("li", {
        className: prefixCls
      }, changeSelect, goInput);
    };
    var Pager = function Pager2(props) {
      var rootPrefixCls = props.rootPrefixCls, page = props.page, active = props.active, className = props.className, showTitle = props.showTitle, onClick = props.onClick, onKeyPress = props.onKeyPress, itemRender = props.itemRender;
      var prefixCls = "".concat(rootPrefixCls, "-item");
      var cls = classNames(prefixCls, "".concat(prefixCls, "-").concat(page), _defineProperty(_defineProperty({}, "".concat(prefixCls, "-active"), active), "".concat(prefixCls, "-disabled"), !page), className);
      var handleClick = function handleClick2() {
        onClick(page);
      };
      var handleKeyPress = function handleKeyPress2(e2) {
        onKeyPress(e2, onClick, page);
      };
      var pager = itemRender(page, "page", /* @__PURE__ */ i.createElement("a", {
        rel: "nofollow"
      }, page));
      return pager ? /* @__PURE__ */ i.createElement("li", {
        title: showTitle ? String(page) : null,
        className: cls,
        onClick: handleClick,
        onKeyDown: handleKeyPress,
        tabIndex: 0
      }, pager) : null;
    };
    var defaultItemRender = function defaultItemRender2(page, type2, element) {
      return element;
    };
    function noop() {
    }
    function isInteger$1(v2) {
      var value = Number(v2);
      return typeof value === "number" && !Number.isNaN(value) && isFinite(value) && Math.floor(value) === value;
    }
    function calculatePage(p2, pageSize, total) {
      var _pageSize = typeof p2 === "undefined" ? pageSize : p2;
      return Math.floor((total - 1) / _pageSize) + 1;
    }
    var Pagination$1 = function Pagination2(props) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-pagination" : _props$prefixCls, _props$selectPrefixCl = props.selectPrefixCls, selectPrefixCls = _props$selectPrefixCl === void 0 ? "rc-select" : _props$selectPrefixCl, className = props.className, currentProp = props.current, _props$defaultCurrent = props.defaultCurrent, defaultCurrent = _props$defaultCurrent === void 0 ? 1 : _props$defaultCurrent, _props$total = props.total, total = _props$total === void 0 ? 0 : _props$total, pageSizeProp = props.pageSize, _props$defaultPageSiz = props.defaultPageSize, defaultPageSize = _props$defaultPageSiz === void 0 ? 10 : _props$defaultPageSiz, _props$onChange = props.onChange, onChange = _props$onChange === void 0 ? noop : _props$onChange, hideOnSinglePage = props.hideOnSinglePage, align = props.align, _props$showPrevNextJu = props.showPrevNextJumpers, showPrevNextJumpers = _props$showPrevNextJu === void 0 ? true : _props$showPrevNextJu, showQuickJumper = props.showQuickJumper, showLessItems = props.showLessItems, _props$showTitle = props.showTitle, showTitle = _props$showTitle === void 0 ? true : _props$showTitle, _props$onShowSizeChan = props.onShowSizeChange, onShowSizeChange = _props$onShowSizeChan === void 0 ? noop : _props$onShowSizeChan, _props$locale = props.locale, locale$12 = _props$locale === void 0 ? locale : _props$locale, style2 = props.style, _props$totalBoundaryS = props.totalBoundaryShowSizeChanger, totalBoundaryShowSizeChanger = _props$totalBoundaryS === void 0 ? 50 : _props$totalBoundaryS, disabled = props.disabled, simple = props.simple, showTotal = props.showTotal, _props$showSizeChange = props.showSizeChanger, showSizeChanger = _props$showSizeChange === void 0 ? total > totalBoundaryShowSizeChanger : _props$showSizeChange, sizeChangerRender = props.sizeChangerRender, pageSizeOptions = props.pageSizeOptions, _props$itemRender = props.itemRender, itemRender = _props$itemRender === void 0 ? defaultItemRender : _props$itemRender, jumpPrevIcon = props.jumpPrevIcon, jumpNextIcon = props.jumpNextIcon, prevIcon = props.prevIcon, nextIcon = props.nextIcon;
      var paginationRef = i.useRef(null);
      var _useMergedState = useMergedState(10, {
        value: pageSizeProp,
        defaultValue: defaultPageSize
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), pageSize = _useMergedState2[0], setPageSize = _useMergedState2[1];
      var _useMergedState3 = useMergedState(1, {
        value: currentProp,
        defaultValue: defaultCurrent,
        postState: function postState(c2) {
          return Math.max(1, Math.min(c2, calculatePage(void 0, pageSize, total)));
        }
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), current = _useMergedState4[0], setCurrent = _useMergedState4[1];
      var _React$useState = i.useState(current), _React$useState2 = _slicedToArray(_React$useState, 2), internalInputVal = _React$useState2[0], setInternalInputVal = _React$useState2[1];
      reactExports.useEffect(function() {
        setInternalInputVal(current);
      }, [current]);
      var jumpPrevPage = Math.max(1, current - (showLessItems ? 3 : 5));
      var jumpNextPage = Math.min(calculatePage(void 0, pageSize, total), current + (showLessItems ? 3 : 5));
      function getItemIcon(icon, label) {
        var iconNode = icon || /* @__PURE__ */ i.createElement("button", {
          type: "button",
          "aria-label": label,
          className: "".concat(prefixCls, "-item-link")
        });
        if (typeof icon === "function") {
          iconNode = /* @__PURE__ */ i.createElement(icon, _objectSpread2$3({}, props));
        }
        return iconNode;
      }
      function getValidValue(e2) {
        var inputValue = e2.target.value;
        var allPages2 = calculatePage(void 0, pageSize, total);
        var value;
        if (inputValue === "") {
          value = inputValue;
        } else if (Number.isNaN(Number(inputValue))) {
          value = internalInputVal;
        } else if (inputValue >= allPages2) {
          value = allPages2;
        } else {
          value = Number(inputValue);
        }
        return value;
      }
      function isValid(page) {
        return isInteger$1(page) && page !== current && isInteger$1(total) && total > 0;
      }
      var shouldDisplayQuickJumper = total > pageSize ? showQuickJumper : false;
      function handleKeyDown(event) {
        if (event.keyCode === KeyCode.UP || event.keyCode === KeyCode.DOWN) {
          event.preventDefault();
        }
      }
      function handleKeyUp(event) {
        var value = getValidValue(event);
        if (value !== internalInputVal) {
          setInternalInputVal(value);
        }
        switch (event.keyCode) {
          case KeyCode.ENTER:
            handleChange(value);
            break;
          case KeyCode.UP:
            handleChange(value - 1);
            break;
          case KeyCode.DOWN:
            handleChange(value + 1);
            break;
        }
      }
      function handleBlur(event) {
        handleChange(getValidValue(event));
      }
      function changePageSize(size) {
        var newCurrent = calculatePage(size, pageSize, total);
        var nextCurrent = current > newCurrent && newCurrent !== 0 ? newCurrent : current;
        setPageSize(size);
        setInternalInputVal(nextCurrent);
        onShowSizeChange === null || onShowSizeChange === void 0 || onShowSizeChange(current, size);
        setCurrent(nextCurrent);
        onChange === null || onChange === void 0 || onChange(nextCurrent, size);
      }
      function handleChange(page) {
        if (isValid(page) && !disabled) {
          var currentPage = calculatePage(void 0, pageSize, total);
          var newPage = page;
          if (page > currentPage) {
            newPage = currentPage;
          } else if (page < 1) {
            newPage = 1;
          }
          if (newPage !== internalInputVal) {
            setInternalInputVal(newPage);
          }
          setCurrent(newPage);
          onChange === null || onChange === void 0 || onChange(newPage, pageSize);
          return newPage;
        }
        return current;
      }
      var hasPrev = current > 1;
      var hasNext = current < calculatePage(void 0, pageSize, total);
      function prevHandle() {
        if (hasPrev) handleChange(current - 1);
      }
      function nextHandle() {
        if (hasNext) handleChange(current + 1);
      }
      function jumpPrevHandle() {
        handleChange(jumpPrevPage);
      }
      function jumpNextHandle() {
        handleChange(jumpNextPage);
      }
      function runIfEnter(event, callback) {
        if (event.key === "Enter" || event.charCode === KeyCode.ENTER || event.keyCode === KeyCode.ENTER) {
          for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            restParams[_key - 2] = arguments[_key];
          }
          callback.apply(void 0, restParams);
        }
      }
      function runIfEnterPrev(event) {
        runIfEnter(event, prevHandle);
      }
      function runIfEnterNext(event) {
        runIfEnter(event, nextHandle);
      }
      function runIfEnterJumpPrev(event) {
        runIfEnter(event, jumpPrevHandle);
      }
      function runIfEnterJumpNext(event) {
        runIfEnter(event, jumpNextHandle);
      }
      function renderPrev(prevPage2) {
        var prevButton = itemRender(prevPage2, "prev", getItemIcon(prevIcon, "prev page"));
        return /* @__PURE__ */ i.isValidElement(prevButton) ? /* @__PURE__ */ i.cloneElement(prevButton, {
          disabled: !hasPrev
        }) : prevButton;
      }
      function renderNext(nextPage2) {
        var nextButton = itemRender(nextPage2, "next", getItemIcon(nextIcon, "next page"));
        return /* @__PURE__ */ i.isValidElement(nextButton) ? /* @__PURE__ */ i.cloneElement(nextButton, {
          disabled: !hasNext
        }) : nextButton;
      }
      function handleGoTO(event) {
        if (event.type === "click" || event.keyCode === KeyCode.ENTER) {
          handleChange(internalInputVal);
        }
      }
      var jumpPrev = null;
      var dataOrAriaAttributeProps = pickAttrs(props, {
        aria: true,
        data: true
      });
      var totalText = showTotal && /* @__PURE__ */ i.createElement("li", {
        className: "".concat(prefixCls, "-total-text")
      }, showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize]));
      var jumpNext = null;
      var allPages = calculatePage(void 0, pageSize, total);
      if (hideOnSinglePage && total <= pageSize) {
        return null;
      }
      var pagerList = [];
      var pagerProps = {
        rootPrefixCls: prefixCls,
        onClick: handleChange,
        onKeyPress: runIfEnter,
        showTitle,
        itemRender,
        page: -1
      };
      var prevPage = current - 1 > 0 ? current - 1 : 0;
      var nextPage = current + 1 < allPages ? current + 1 : allPages;
      var goButton = showQuickJumper && showQuickJumper.goButton;
      var isReadOnly = _typeof$1(simple) === "object" ? simple.readOnly : !simple;
      var gotoButton = goButton;
      var simplePager = null;
      if (simple) {
        if (goButton) {
          if (typeof goButton === "boolean") {
            gotoButton = /* @__PURE__ */ i.createElement("button", {
              type: "button",
              onClick: handleGoTO,
              onKeyUp: handleGoTO
            }, locale$12.jump_to_confirm);
          } else {
            gotoButton = /* @__PURE__ */ i.createElement("span", {
              onClick: handleGoTO,
              onKeyUp: handleGoTO
            }, goButton);
          }
          gotoButton = /* @__PURE__ */ i.createElement("li", {
            title: showTitle ? "".concat(locale$12.jump_to).concat(current, "/").concat(allPages) : null,
            className: "".concat(prefixCls, "-simple-pager")
          }, gotoButton);
        }
        simplePager = /* @__PURE__ */ i.createElement("li", {
          title: showTitle ? "".concat(current, "/").concat(allPages) : null,
          className: "".concat(prefixCls, "-simple-pager")
        }, isReadOnly ? internalInputVal : /* @__PURE__ */ i.createElement("input", {
          type: "text",
          "aria-label": locale$12.jump_to,
          value: internalInputVal,
          disabled,
          onKeyDown: handleKeyDown,
          onKeyUp: handleKeyUp,
          onChange: handleKeyUp,
          onBlur: handleBlur,
          size: 3
        }), /* @__PURE__ */ i.createElement("span", {
          className: "".concat(prefixCls, "-slash")
        }, "/"), allPages);
      }
      var pageBufferSize = showLessItems ? 1 : 2;
      if (allPages <= 3 + pageBufferSize * 2) {
        if (!allPages) {
          pagerList.push(/* @__PURE__ */ i.createElement(Pager, _extends$2({}, pagerProps, {
            key: "noPager",
            page: 1,
            className: "".concat(prefixCls, "-item-disabled")
          })));
        }
        for (var i$1 = 1; i$1 <= allPages; i$1 += 1) {
          pagerList.push(/* @__PURE__ */ i.createElement(Pager, _extends$2({}, pagerProps, {
            key: i$1,
            page: i$1,
            active: current === i$1
          })));
        }
      } else {
        var prevItemTitle = showLessItems ? locale$12.prev_3 : locale$12.prev_5;
        var nextItemTitle = showLessItems ? locale$12.next_3 : locale$12.next_5;
        var jumpPrevContent = itemRender(jumpPrevPage, "jump-prev", getItemIcon(jumpPrevIcon, "prev page"));
        var jumpNextContent = itemRender(jumpNextPage, "jump-next", getItemIcon(jumpNextIcon, "next page"));
        if (showPrevNextJumpers) {
          jumpPrev = jumpPrevContent ? /* @__PURE__ */ i.createElement("li", {
            title: showTitle ? prevItemTitle : null,
            key: "prev",
            onClick: jumpPrevHandle,
            tabIndex: 0,
            onKeyDown: runIfEnterJumpPrev,
            className: classNames("".concat(prefixCls, "-jump-prev"), _defineProperty({}, "".concat(prefixCls, "-jump-prev-custom-icon"), !!jumpPrevIcon))
          }, jumpPrevContent) : null;
          jumpNext = jumpNextContent ? /* @__PURE__ */ i.createElement("li", {
            title: showTitle ? nextItemTitle : null,
            key: "next",
            onClick: jumpNextHandle,
            tabIndex: 0,
            onKeyDown: runIfEnterJumpNext,
            className: classNames("".concat(prefixCls, "-jump-next"), _defineProperty({}, "".concat(prefixCls, "-jump-next-custom-icon"), !!jumpNextIcon))
          }, jumpNextContent) : null;
        }
        var left = Math.max(1, current - pageBufferSize);
        var right = Math.min(current + pageBufferSize, allPages);
        if (current - 1 <= pageBufferSize) {
          right = 1 + pageBufferSize * 2;
        }
        if (allPages - current <= pageBufferSize) {
          left = allPages - pageBufferSize * 2;
        }
        for (var _i = left; _i <= right; _i += 1) {
          pagerList.push(/* @__PURE__ */ i.createElement(Pager, _extends$2({}, pagerProps, {
            key: _i,
            page: _i,
            active: current === _i
          })));
        }
        if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
          pagerList[0] = /* @__PURE__ */ i.cloneElement(pagerList[0], {
            className: classNames("".concat(prefixCls, "-item-after-jump-prev"), pagerList[0].props.className)
          });
          pagerList.unshift(jumpPrev);
        }
        if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
          var lastOne = pagerList[pagerList.length - 1];
          pagerList[pagerList.length - 1] = /* @__PURE__ */ i.cloneElement(lastOne, {
            className: classNames("".concat(prefixCls, "-item-before-jump-next"), lastOne.props.className)
          });
          pagerList.push(jumpNext);
        }
        if (left !== 1) {
          pagerList.unshift(/* @__PURE__ */ i.createElement(Pager, _extends$2({}, pagerProps, {
            key: 1,
            page: 1
          })));
        }
        if (right !== allPages) {
          pagerList.push(/* @__PURE__ */ i.createElement(Pager, _extends$2({}, pagerProps, {
            key: allPages,
            page: allPages
          })));
        }
      }
      var prev2 = renderPrev(prevPage);
      if (prev2) {
        var prevDisabled = !hasPrev || !allPages;
        prev2 = /* @__PURE__ */ i.createElement("li", {
          title: showTitle ? locale$12.prev_page : null,
          onClick: prevHandle,
          tabIndex: prevDisabled ? null : 0,
          onKeyDown: runIfEnterPrev,
          className: classNames("".concat(prefixCls, "-prev"), _defineProperty({}, "".concat(prefixCls, "-disabled"), prevDisabled)),
          "aria-disabled": prevDisabled
        }, prev2);
      }
      var next2 = renderNext(nextPage);
      if (next2) {
        var nextDisabled, nextTabIndex;
        if (simple) {
          nextDisabled = !hasNext;
          nextTabIndex = hasPrev ? 0 : null;
        } else {
          nextDisabled = !hasNext || !allPages;
          nextTabIndex = nextDisabled ? null : 0;
        }
        next2 = /* @__PURE__ */ i.createElement("li", {
          title: showTitle ? locale$12.next_page : null,
          onClick: nextHandle,
          tabIndex: nextTabIndex,
          onKeyDown: runIfEnterNext,
          className: classNames("".concat(prefixCls, "-next"), _defineProperty({}, "".concat(prefixCls, "-disabled"), nextDisabled)),
          "aria-disabled": nextDisabled
        }, next2);
      }
      var cls = classNames(prefixCls, className, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-start"), align === "start"), "".concat(prefixCls, "-center"), align === "center"), "".concat(prefixCls, "-end"), align === "end"), "".concat(prefixCls, "-simple"), simple), "".concat(prefixCls, "-disabled"), disabled));
      return /* @__PURE__ */ i.createElement("ul", _extends$2({
        className: cls,
        style: style2,
        ref: paginationRef
      }, dataOrAriaAttributeProps), totalText, prev2, simple ? simplePager : pagerList, next2, /* @__PURE__ */ i.createElement(Options, {
        locale: locale$12,
        rootPrefixCls: prefixCls,
        disabled,
        selectPrefixCls,
        changeSize: changePageSize,
        pageSize,
        pageSizeOptions,
        quickGo: shouldDisplayQuickJumper ? handleChange : null,
        goButton: gotoButton,
        showSizeChanger,
        sizeChangerRender
      }));
    };
    const genPaginationDisabledStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-disabled`]: {
          "&, &:hover": {
            cursor: "not-allowed",
            [`${componentCls}-item-link`]: {
              color: token2.colorTextDisabled,
              cursor: "not-allowed"
            }
          },
          "&:focus-visible": {
            cursor: "not-allowed",
            [`${componentCls}-item-link`]: {
              color: token2.colorTextDisabled,
              cursor: "not-allowed"
            }
          }
        },
        [`&${componentCls}-disabled`]: {
          cursor: "not-allowed",
          [`${componentCls}-item`]: {
            cursor: "not-allowed",
            "&:hover, &:active": {
              backgroundColor: "transparent"
            },
            a: {
              color: token2.colorTextDisabled,
              backgroundColor: "transparent",
              border: "none",
              cursor: "not-allowed"
            },
            "&-active": {
              borderColor: token2.colorBorder,
              backgroundColor: token2.itemActiveBgDisabled,
              "&:hover, &:active": {
                backgroundColor: token2.itemActiveBgDisabled
              },
              a: {
                color: token2.itemActiveColorDisabled
              }
            }
          },
          [`${componentCls}-item-link`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            "&:hover, &:active": {
              backgroundColor: "transparent"
            },
            [`${componentCls}-simple&`]: {
              backgroundColor: "transparent",
              "&:hover, &:active": {
                backgroundColor: "transparent"
              }
            }
          },
          [`${componentCls}-simple-pager`]: {
            color: token2.colorTextDisabled
          },
          [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
            [`${componentCls}-item-link-icon`]: {
              opacity: 0
            },
            [`${componentCls}-item-ellipsis`]: {
              opacity: 1
            }
          }
        },
        [`&${componentCls}-simple`]: {
          [`${componentCls}-prev, ${componentCls}-next`]: {
            [`&${componentCls}-disabled ${componentCls}-item-link`]: {
              "&:hover, &:active": {
                backgroundColor: "transparent"
              }
            }
          }
        }
      };
    };
    const genPaginationMiniStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
          height: token2.itemSizeSM,
          lineHeight: unit$1(token2.itemSizeSM)
        },
        [`&${componentCls}-mini ${componentCls}-item`]: {
          minWidth: token2.itemSizeSM,
          height: token2.itemSizeSM,
          margin: 0,
          lineHeight: unit$1(token2.calc(token2.itemSizeSM).sub(2).equal())
        },
        [`&${componentCls}-mini:not(${componentCls}-disabled) ${componentCls}-item:not(${componentCls}-item-active)`]: {
          backgroundColor: "transparent",
          borderColor: "transparent",
          "&:hover": {
            backgroundColor: token2.colorBgTextHover
          },
          "&:active": {
            backgroundColor: token2.colorBgTextActive
          }
        },
        [`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
          minWidth: token2.itemSizeSM,
          height: token2.itemSizeSM,
          margin: 0,
          lineHeight: unit$1(token2.itemSizeSM)
        },
        [`&${componentCls}-mini:not(${componentCls}-disabled)`]: {
          [`${componentCls}-prev, ${componentCls}-next`]: {
            [`&:hover ${componentCls}-item-link`]: {
              backgroundColor: token2.colorBgTextHover
            },
            [`&:active ${componentCls}-item-link`]: {
              backgroundColor: token2.colorBgTextActive
            },
            [`&${componentCls}-disabled:hover ${componentCls}-item-link`]: {
              backgroundColor: "transparent"
            }
          }
        },
        [`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
          backgroundColor: "transparent",
          borderColor: "transparent",
          "&::after": {
            height: token2.itemSizeSM,
            lineHeight: unit$1(token2.itemSizeSM)
          }
        },
        [`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
          height: token2.itemSizeSM,
          marginInlineEnd: 0,
          lineHeight: unit$1(token2.itemSizeSM)
        },
        [`&${componentCls}-mini ${componentCls}-options`]: {
          marginInlineStart: token2.paginationMiniOptionsMarginInlineStart,
          "&-size-changer": {
            top: token2.miniOptionsSizeChangerTop
          },
          "&-quick-jumper": {
            height: token2.itemSizeSM,
            lineHeight: unit$1(token2.itemSizeSM),
            input: Object.assign(Object.assign({}, genInputSmallStyle(token2)), {
              width: token2.paginationMiniQuickJumperInputWidth,
              height: token2.controlHeightSM
            })
          }
        }
      };
    };
    const genPaginationSimpleStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`
    &${componentCls}-simple ${componentCls}-prev,
    &${componentCls}-simple ${componentCls}-next
    `]: {
          height: token2.itemSizeSM,
          lineHeight: unit$1(token2.itemSizeSM),
          verticalAlign: "top",
          [`${componentCls}-item-link`]: {
            height: token2.itemSizeSM,
            backgroundColor: "transparent",
            border: 0,
            "&:hover": {
              backgroundColor: token2.colorBgTextHover
            },
            "&:active": {
              backgroundColor: token2.colorBgTextActive
            },
            "&::after": {
              height: token2.itemSizeSM,
              lineHeight: unit$1(token2.itemSizeSM)
            }
          }
        },
        [`&${componentCls}-simple ${componentCls}-simple-pager`]: {
          display: "inline-block",
          height: token2.itemSizeSM,
          marginInlineEnd: token2.marginXS,
          input: {
            boxSizing: "border-box",
            height: "100%",
            padding: `0 ${unit$1(token2.paginationItemPaddingInline)}`,
            textAlign: "center",
            backgroundColor: token2.itemInputBg,
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderRadius: token2.borderRadius,
            outline: "none",
            transition: `border-color ${token2.motionDurationMid}`,
            color: "inherit",
            "&:hover": {
              borderColor: token2.colorPrimary
            },
            "&:focus": {
              borderColor: token2.colorPrimaryHover,
              boxShadow: `${unit$1(token2.inputOutlineOffset)} 0 ${unit$1(token2.controlOutlineWidth)} ${token2.controlOutline}`
            },
            "&[disabled]": {
              color: token2.colorTextDisabled,
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              cursor: "not-allowed"
            }
          }
        }
      };
    };
    const genPaginationJumpStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
          outline: 0,
          [`${componentCls}-item-container`]: {
            position: "relative",
            [`${componentCls}-item-link-icon`]: {
              color: token2.colorPrimary,
              fontSize: token2.fontSizeSM,
              opacity: 0,
              transition: `all ${token2.motionDurationMid}`,
              "&-svg": {
                top: 0,
                insetInlineEnd: 0,
                bottom: 0,
                insetInlineStart: 0,
                margin: "auto"
              }
            },
            [`${componentCls}-item-ellipsis`]: {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: 0,
              insetInlineStart: 0,
              display: "block",
              margin: "auto",
              color: token2.colorTextDisabled,
              letterSpacing: token2.paginationEllipsisLetterSpacing,
              textAlign: "center",
              textIndent: token2.paginationEllipsisTextIndent,
              opacity: 1,
              transition: `all ${token2.motionDurationMid}`
            }
          },
          "&:hover": {
            [`${componentCls}-item-link-icon`]: {
              opacity: 1
            },
            [`${componentCls}-item-ellipsis`]: {
              opacity: 0
            }
          }
        },
        [`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
          marginInlineEnd: token2.marginXS
        },
        [`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
          display: "inline-block",
          minWidth: token2.itemSize,
          height: token2.itemSize,
          color: token2.colorText,
          fontFamily: token2.fontFamily,
          lineHeight: unit$1(token2.itemSize),
          textAlign: "center",
          verticalAlign: "middle",
          listStyle: "none",
          borderRadius: token2.borderRadius,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid}`
        },
        [`${componentCls}-prev, ${componentCls}-next`]: {
          outline: 0,
          button: {
            color: token2.colorText,
            cursor: "pointer",
            userSelect: "none"
          },
          [`${componentCls}-item-link`]: {
            display: "block",
            width: "100%",
            height: "100%",
            padding: 0,
            fontSize: token2.fontSizeSM,
            textAlign: "center",
            backgroundColor: "transparent",
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
            borderRadius: token2.borderRadius,
            outline: "none",
            transition: `all ${token2.motionDurationMid}`
          },
          [`&:hover ${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgTextHover
          },
          [`&:active ${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgTextActive
          },
          [`&${componentCls}-disabled:hover`]: {
            [`${componentCls}-item-link`]: {
              backgroundColor: "transparent"
            }
          }
        },
        [`${componentCls}-slash`]: {
          marginInlineEnd: token2.paginationSlashMarginInlineEnd,
          marginInlineStart: token2.paginationSlashMarginInlineStart
        },
        [`${componentCls}-options`]: {
          display: "inline-block",
          marginInlineStart: token2.margin,
          verticalAlign: "middle",
          "&-size-changer": {
            display: "inline-block",
            width: "auto"
          },
          "&-quick-jumper": {
            display: "inline-block",
            height: token2.controlHeight,
            marginInlineStart: token2.marginXS,
            lineHeight: unit$1(token2.controlHeight),
            verticalAlign: "top",
            input: Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), genBaseOutlinedStyle(token2, {
              borderColor: token2.colorBorder,
              hoverBorderColor: token2.colorPrimaryHover,
              activeBorderColor: token2.colorPrimary,
              activeShadow: token2.activeShadow
            })), {
              "&[disabled]": Object.assign({}, genDisabledStyle(token2)),
              width: token2.calc(token2.controlHeightLG).mul(1.25).equal(),
              height: token2.controlHeight,
              boxSizing: "border-box",
              margin: 0,
              marginInlineStart: token2.marginXS,
              marginInlineEnd: token2.marginXS
            })
          }
        }
      };
    };
    const genPaginationItemStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-item`]: {
          display: "inline-block",
          minWidth: token2.itemSize,
          height: token2.itemSize,
          marginInlineEnd: token2.marginXS,
          fontFamily: token2.fontFamily,
          lineHeight: unit$1(token2.calc(token2.itemSize).sub(2).equal()),
          textAlign: "center",
          verticalAlign: "middle",
          listStyle: "none",
          backgroundColor: token2.itemBg,
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
          borderRadius: token2.borderRadius,
          outline: 0,
          cursor: "pointer",
          userSelect: "none",
          a: {
            display: "block",
            padding: `0 ${unit$1(token2.paginationItemPaddingInline)}`,
            color: token2.colorText,
            "&:hover": {
              textDecoration: "none"
            }
          },
          [`&:not(${componentCls}-item-active)`]: {
            "&:hover": {
              transition: `all ${token2.motionDurationMid}`,
              backgroundColor: token2.colorBgTextHover
            },
            "&:active": {
              backgroundColor: token2.colorBgTextActive
            }
          },
          "&-active": {
            fontWeight: token2.fontWeightStrong,
            backgroundColor: token2.itemActiveBg,
            borderColor: token2.colorPrimary,
            a: {
              color: token2.colorPrimary
            },
            "&:hover": {
              borderColor: token2.colorPrimaryHover
            },
            "&:hover a": {
              color: token2.colorPrimaryHover
            }
          }
        }
      };
    };
    const genPaginationStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
          display: "flex",
          "&-start": {
            justifyContent: "start"
          },
          "&-center": {
            justifyContent: "center"
          },
          "&-end": {
            justifyContent: "end"
          },
          "ul, ol": {
            margin: 0,
            padding: 0,
            listStyle: "none"
          },
          "&::after": {
            display: "block",
            clear: "both",
            height: 0,
            overflow: "hidden",
            visibility: "hidden",
            content: '""'
          },
          [`${componentCls}-total-text`]: {
            display: "inline-block",
            height: token2.itemSize,
            marginInlineEnd: token2.marginXS,
            lineHeight: unit$1(token2.calc(token2.itemSize).sub(2).equal()),
            verticalAlign: "middle"
          }
        }), genPaginationItemStyle(token2)), genPaginationJumpStyle(token2)), genPaginationSimpleStyle(token2)), genPaginationMiniStyle(token2)), genPaginationDisabledStyle(token2)), {
          // media query style
          [`@media only screen and (max-width: ${token2.screenLG}px)`]: {
            [`${componentCls}-item`]: {
              "&-after-jump-prev, &-before-jump-next": {
                display: "none"
              }
            }
          },
          [`@media only screen and (max-width: ${token2.screenSM}px)`]: {
            [`${componentCls}-options`]: {
              display: "none"
            }
          }
        }),
        // rtl style
        [`&${token2.componentCls}-rtl`]: {
          direction: "rtl"
        }
      };
    };
    const genPaginationFocusStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}:not(${componentCls}-disabled)`]: {
          [`${componentCls}-item`]: Object.assign({}, genFocusStyle(token2)),
          [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
            "&:focus-visible": Object.assign({
              [`${componentCls}-item-link-icon`]: {
                opacity: 1
              },
              [`${componentCls}-item-ellipsis`]: {
                opacity: 0
              }
            }, genFocusOutline(token2))
          },
          [`${componentCls}-prev, ${componentCls}-next`]: {
            [`&:focus-visible ${componentCls}-item-link`]: Object.assign({}, genFocusOutline(token2))
          }
        }
      };
    };
    const prepareComponentToken$7 = (token2) => Object.assign({
      itemBg: token2.colorBgContainer,
      itemSize: token2.controlHeight,
      itemSizeSM: token2.controlHeightSM,
      itemActiveBg: token2.colorBgContainer,
      itemLinkBg: token2.colorBgContainer,
      itemActiveColorDisabled: token2.colorTextDisabled,
      itemActiveBgDisabled: token2.controlItemBgActiveDisabled,
      itemInputBg: token2.colorBgContainer,
      miniOptionsSizeChangerTop: 0
    }, initComponentToken(token2));
    const prepareToken$1 = (token2) => merge(token2, {
      inputOutlineOffset: 0,
      paginationMiniOptionsMarginInlineStart: token2.calc(token2.marginXXS).div(2).equal(),
      paginationMiniQuickJumperInputWidth: token2.calc(token2.controlHeightLG).mul(1.1).equal(),
      paginationItemPaddingInline: token2.calc(token2.marginXXS).mul(1.5).equal(),
      paginationEllipsisLetterSpacing: token2.calc(token2.marginXXS).div(2).equal(),
      paginationSlashMarginInlineStart: token2.marginSM,
      paginationSlashMarginInlineEnd: token2.marginSM,
      paginationEllipsisTextIndent: "0.13em"
      // magic for ui experience
    }, initInputToken(token2));
    const useStyle$7 = genStyleHooks("Pagination", (token2) => {
      const paginationToken = prepareToken$1(token2);
      return [genPaginationStyle(paginationToken), genPaginationFocusStyle(paginationToken)];
    }, prepareComponentToken$7);
    const genBorderedStyle$1 = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}${componentCls}-bordered${componentCls}-disabled:not(${componentCls}-mini)`]: {
          "&, &:hover": {
            [`${componentCls}-item-link`]: {
              borderColor: token2.colorBorder
            }
          },
          "&:focus-visible": {
            [`${componentCls}-item-link`]: {
              borderColor: token2.colorBorder
            }
          },
          [`${componentCls}-item, ${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            [`&:hover:not(${componentCls}-item-active)`]: {
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              a: {
                color: token2.colorTextDisabled
              }
            },
            [`&${componentCls}-item-active`]: {
              backgroundColor: token2.itemActiveBgDisabled
            }
          },
          [`${componentCls}-prev, ${componentCls}-next`]: {
            "&:hover button": {
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              color: token2.colorTextDisabled
            },
            [`${componentCls}-item-link`]: {
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder
            }
          }
        },
        [`${componentCls}${componentCls}-bordered:not(${componentCls}-mini)`]: {
          [`${componentCls}-prev, ${componentCls}-next`]: {
            "&:hover button": {
              borderColor: token2.colorPrimaryHover,
              backgroundColor: token2.itemBg
            },
            [`${componentCls}-item-link`]: {
              backgroundColor: token2.itemLinkBg,
              borderColor: token2.colorBorder
            },
            [`&:hover ${componentCls}-item-link`]: {
              borderColor: token2.colorPrimary,
              backgroundColor: token2.itemBg,
              color: token2.colorPrimary
            },
            [`&${componentCls}-disabled`]: {
              [`${componentCls}-item-link`]: {
                borderColor: token2.colorBorder,
                color: token2.colorTextDisabled
              }
            }
          },
          [`${componentCls}-item`]: {
            backgroundColor: token2.itemBg,
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            [`&:hover:not(${componentCls}-item-active)`]: {
              borderColor: token2.colorPrimary,
              backgroundColor: token2.itemBg,
              a: {
                color: token2.colorPrimary
              }
            },
            "&-active": {
              borderColor: token2.colorPrimary
            }
          }
        }
      };
    };
    const BorderedStyle = genSubStyleComponent(["Pagination", "bordered"], (token2) => {
      const paginationToken = prepareToken$1(token2);
      return [genBorderedStyle$1(paginationToken)];
    }, prepareComponentToken$7);
    function useShowSizeChanger(showSizeChanger) {
      return reactExports.useMemo(() => {
        if (typeof showSizeChanger === "boolean") {
          return [showSizeChanger, {}];
        }
        if (showSizeChanger && typeof showSizeChanger === "object") {
          return [true, showSizeChanger];
        }
        return [void 0, void 0];
      }, [showSizeChanger]);
    }
    var __rest$f = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const Pagination = (props) => {
      const {
        align,
        prefixCls: customizePrefixCls,
        selectPrefixCls: customizeSelectPrefixCls,
        className,
        rootClassName,
        style: style2,
        size: customizeSize,
        locale: customLocale,
        responsive,
        showSizeChanger,
        selectComponentClass,
        pageSizeOptions
      } = props, restProps = __rest$f(props, ["align", "prefixCls", "selectPrefixCls", "className", "rootClassName", "style", "size", "locale", "responsive", "showSizeChanger", "selectComponentClass", "pageSizeOptions"]);
      const {
        xs
      } = useBreakpoint(responsive);
      const [, token2] = useToken();
      const {
        getPrefixCls,
        direction,
        showSizeChanger: contextShowSizeChangerConfig,
        className: contextClassName,
        style: contextStyle
      } = useComponentConfig("pagination");
      const prefixCls = getPrefixCls("pagination", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$7(prefixCls);
      const mergedSize = useSize(customizeSize);
      const isSmall = mergedSize === "small" || !!(xs && !mergedSize && responsive);
      const [contextLocale] = useLocale$1("Pagination", locale$4);
      const locale2 = Object.assign(Object.assign({}, contextLocale), customLocale);
      const [propShowSizeChanger, propSizeChangerSelectProps] = useShowSizeChanger(showSizeChanger);
      const [contextShowSizeChanger, contextSizeChangerSelectProps] = useShowSizeChanger(contextShowSizeChangerConfig);
      const mergedShowSizeChanger = propShowSizeChanger !== null && propShowSizeChanger !== void 0 ? propShowSizeChanger : contextShowSizeChanger;
      const mergedShowSizeChangerSelectProps = propSizeChangerSelectProps !== null && propSizeChangerSelectProps !== void 0 ? propSizeChangerSelectProps : contextSizeChangerSelectProps;
      const SizeChanger = selectComponentClass || Select$1;
      const mergedPageSizeOptions = reactExports.useMemo(() => {
        return pageSizeOptions ? pageSizeOptions.map((option) => Number(option)) : void 0;
      }, [pageSizeOptions]);
      const sizeChangerRender = (info) => {
        var _a;
        const {
          disabled,
          size: pageSize,
          onSizeChange,
          "aria-label": ariaLabel,
          className: sizeChangerClassName,
          options: options2
        } = info;
        const {
          className: propSizeChangerClassName,
          onChange: propSizeChangerOnChange
        } = mergedShowSizeChangerSelectProps || {};
        const selectedValue = (_a = options2.find((option) => String(option.value) === String(pageSize))) === null || _a === void 0 ? void 0 : _a.value;
        return /* @__PURE__ */ reactExports.createElement(SizeChanger, Object.assign({
          disabled,
          showSearch: true,
          popupMatchSelectWidth: false,
          getPopupContainer: (triggerNode) => triggerNode.parentNode,
          "aria-label": ariaLabel,
          options: options2
        }, mergedShowSizeChangerSelectProps, {
          value: selectedValue,
          onChange: (nextSize, option) => {
            onSizeChange === null || onSizeChange === void 0 ? void 0 : onSizeChange(nextSize);
            propSizeChangerOnChange === null || propSizeChangerOnChange === void 0 ? void 0 : propSizeChangerOnChange(nextSize, option);
          },
          size: isSmall ? "small" : "middle",
          className: classNames(sizeChangerClassName, propSizeChangerClassName)
        }));
      };
      const iconsProps = reactExports.useMemo(() => {
        const ellipsis = /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-item-ellipsis`
        }, "");
        const prevIcon = /* @__PURE__ */ reactExports.createElement("button", {
          className: `${prefixCls}-item-link`,
          type: "button",
          tabIndex: -1
        }, direction === "rtl" ? /* @__PURE__ */ reactExports.createElement(RefIcon$w, null) : /* @__PURE__ */ reactExports.createElement(RefIcon$s, null));
        const nextIcon = /* @__PURE__ */ reactExports.createElement("button", {
          className: `${prefixCls}-item-link`,
          type: "button",
          tabIndex: -1
        }, direction === "rtl" ? /* @__PURE__ */ reactExports.createElement(RefIcon$s, null) : /* @__PURE__ */ reactExports.createElement(RefIcon$w, null));
        const jumpPrevIcon = (
          // biome-ignore lint/a11y/useValidAnchor: it is hard to refactor
          /* @__PURE__ */ reactExports.createElement("a", {
            className: `${prefixCls}-item-link`
          }, /* @__PURE__ */ reactExports.createElement("div", {
            className: `${prefixCls}-item-container`
          }, direction === "rtl" ? /* @__PURE__ */ reactExports.createElement(RefIcon$g, {
            className: `${prefixCls}-item-link-icon`
          }) : /* @__PURE__ */ reactExports.createElement(RefIcon$h, {
            className: `${prefixCls}-item-link-icon`
          }), ellipsis))
        );
        const jumpNextIcon = (
          // biome-ignore lint/a11y/useValidAnchor: it is hard to refactor
          /* @__PURE__ */ reactExports.createElement("a", {
            className: `${prefixCls}-item-link`
          }, /* @__PURE__ */ reactExports.createElement("div", {
            className: `${prefixCls}-item-container`
          }, direction === "rtl" ? /* @__PURE__ */ reactExports.createElement(RefIcon$h, {
            className: `${prefixCls}-item-link-icon`
          }) : /* @__PURE__ */ reactExports.createElement(RefIcon$g, {
            className: `${prefixCls}-item-link-icon`
          }), ellipsis))
        );
        return {
          prevIcon,
          nextIcon,
          jumpPrevIcon,
          jumpNextIcon
        };
      }, [direction, prefixCls]);
      const selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
      const extendedClassName = classNames({
        [`${prefixCls}-${align}`]: !!align,
        [`${prefixCls}-mini`]: isSmall,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-bordered`]: token2.wireframe
      }, contextClassName, className, rootClassName, hashId, cssVarCls);
      const mergedStyle = Object.assign(Object.assign({}, contextStyle), style2);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, token2.wireframe && /* @__PURE__ */ reactExports.createElement(BorderedStyle, {
        prefixCls
      }), /* @__PURE__ */ reactExports.createElement(Pagination$1, Object.assign({}, iconsProps, restProps, {
        style: mergedStyle,
        prefixCls,
        selectPrefixCls,
        className: extendedClassName,
        locale: locale2,
        pageSizeOptions: mergedPageSizeOptions,
        showSizeChanger: mergedShowSizeChanger,
        sizeChangerRender
      }))));
    };
    const viewSize = 100;
    const borderWidth = viewSize / 5;
    const radius = viewSize / 2 - borderWidth / 2;
    const circumference = radius * 2 * Math.PI;
    const position = 50;
    const CustomCircle = (props) => {
      const {
        dotClassName,
        style: style2,
        hasCircleCls
      } = props;
      return /* @__PURE__ */ reactExports.createElement("circle", {
        className: classNames(`${dotClassName}-circle`, {
          [`${dotClassName}-circle-bg`]: hasCircleCls
        }),
        r: radius,
        cx: position,
        cy: position,
        strokeWidth: borderWidth,
        style: style2
      });
    };
    const Progress = (_ref) => {
      let {
        percent,
        prefixCls
      } = _ref;
      const dotClassName = `${prefixCls}-dot`;
      const holderClassName = `${dotClassName}-holder`;
      const hideClassName = `${holderClassName}-hidden`;
      const [render2, setRender] = reactExports.useState(false);
      useLayoutEffect$1(() => {
        if (percent !== 0) {
          setRender(true);
        }
      }, [percent !== 0]);
      const safePtg = Math.max(Math.min(percent, 100), 0);
      if (!render2) {
        return null;
      }
      const circleStyle = {
        strokeDashoffset: `${circumference / 4}`,
        strokeDasharray: `${circumference * safePtg / 100} ${circumference * (100 - safePtg) / 100}`
      };
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(holderClassName, `${dotClassName}-progress`, safePtg <= 0 && hideClassName)
      }, /* @__PURE__ */ reactExports.createElement("svg", {
        viewBox: `0 0 ${viewSize} ${viewSize}`,
        // biome-ignore lint/a11y/noNoninteractiveElementToInteractiveRole: progressbar could be readonly
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": safePtg
      }, /* @__PURE__ */ reactExports.createElement(CustomCircle, {
        dotClassName,
        hasCircleCls: true
      }), /* @__PURE__ */ reactExports.createElement(CustomCircle, {
        dotClassName,
        style: circleStyle
      })));
    };
    function Looper(props) {
      const {
        prefixCls,
        percent = 0
      } = props;
      const dotClassName = `${prefixCls}-dot`;
      const holderClassName = `${dotClassName}-holder`;
      const hideClassName = `${holderClassName}-hidden`;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(holderClassName, percent > 0 && hideClassName)
      }, /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(dotClassName, `${prefixCls}-dot-spin`)
      }, [1, 2, 3, 4].map((i2) => /* @__PURE__ */ reactExports.createElement("i", {
        className: `${prefixCls}-dot-item`,
        key: i2
      })))), /* @__PURE__ */ reactExports.createElement(Progress, {
        prefixCls,
        percent
      }));
    }
    function Indicator(props) {
      const {
        prefixCls,
        indicator,
        percent
      } = props;
      const dotClassName = `${prefixCls}-dot`;
      if (indicator && /* @__PURE__ */ reactExports.isValidElement(indicator)) {
        return cloneElement(indicator, {
          className: classNames(indicator.props.className, dotClassName),
          percent
        });
      }
      return /* @__PURE__ */ reactExports.createElement(Looper, {
        prefixCls,
        percent
      });
    }
    const antSpinMove = new Keyframe("antSpinMove", {
      to: {
        opacity: 1
      }
    });
    const antRotate = new Keyframe("antRotate", {
      to: {
        transform: "rotate(405deg)"
      }
    });
    const genSpinStyle = (token2) => {
      const {
        componentCls,
        calc
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "absolute",
          display: "none",
          color: token2.colorPrimary,
          fontSize: 0,
          textAlign: "center",
          verticalAlign: "middle",
          opacity: 0,
          transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
          "&-spinning": {
            position: "relative",
            display: "inline-block",
            opacity: 1
          },
          [`${componentCls}-text`]: {
            fontSize: token2.fontSize,
            paddingTop: calc(calc(token2.dotSize).sub(token2.fontSize)).div(2).add(2).equal()
          },
          "&-fullscreen": {
            position: "fixed",
            width: "100vw",
            height: "100vh",
            backgroundColor: token2.colorBgMask,
            zIndex: token2.zIndexPopupBase,
            inset: 0,
            display: "flex",
            alignItems: "center",
            flexDirection: "column",
            justifyContent: "center",
            opacity: 0,
            visibility: "hidden",
            transition: `all ${token2.motionDurationMid}`,
            "&-show": {
              opacity: 1,
              visibility: "visible"
            },
            [componentCls]: {
              [`${componentCls}-dot-holder`]: {
                color: token2.colorWhite
              },
              [`${componentCls}-text`]: {
                color: token2.colorTextLightSolid
              }
            }
          },
          "&-nested-loading": {
            position: "relative",
            [`> div > ${componentCls}`]: {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              zIndex: 4,
              display: "block",
              width: "100%",
              height: "100%",
              maxHeight: token2.contentHeight,
              [`${componentCls}-dot`]: {
                position: "absolute",
                top: "50%",
                insetInlineStart: "50%",
                margin: calc(token2.dotSize).mul(-1).div(2).equal()
              },
              [`${componentCls}-text`]: {
                position: "absolute",
                top: "50%",
                width: "100%",
                textShadow: `0 1px 2px ${token2.colorBgContainer}`
                // FIXME: shadow
              },
              [`&${componentCls}-show-text ${componentCls}-dot`]: {
                marginTop: calc(token2.dotSize).div(2).mul(-1).sub(10).equal()
              },
              "&-sm": {
                [`${componentCls}-dot`]: {
                  margin: calc(token2.dotSizeSM).mul(-1).div(2).equal()
                },
                [`${componentCls}-text`]: {
                  paddingTop: calc(calc(token2.dotSizeSM).sub(token2.fontSize)).div(2).add(2).equal()
                },
                [`&${componentCls}-show-text ${componentCls}-dot`]: {
                  marginTop: calc(token2.dotSizeSM).div(2).mul(-1).sub(10).equal()
                }
              },
              "&-lg": {
                [`${componentCls}-dot`]: {
                  margin: calc(token2.dotSizeLG).mul(-1).div(2).equal()
                },
                [`${componentCls}-text`]: {
                  paddingTop: calc(calc(token2.dotSizeLG).sub(token2.fontSize)).div(2).add(2).equal()
                },
                [`&${componentCls}-show-text ${componentCls}-dot`]: {
                  marginTop: calc(token2.dotSizeLG).div(2).mul(-1).sub(10).equal()
                }
              }
            },
            [`${componentCls}-container`]: {
              position: "relative",
              transition: `opacity ${token2.motionDurationSlow}`,
              "&::after": {
                position: "absolute",
                top: 0,
                insetInlineEnd: 0,
                bottom: 0,
                insetInlineStart: 0,
                zIndex: 10,
                width: "100%",
                height: "100%",
                background: token2.colorBgContainer,
                opacity: 0,
                transition: `all ${token2.motionDurationSlow}`,
                content: '""',
                pointerEvents: "none"
              }
            },
            [`${componentCls}-blur`]: {
              clear: "both",
              opacity: 0.5,
              userSelect: "none",
              pointerEvents: "none",
              "&::after": {
                opacity: 0.4,
                pointerEvents: "auto"
              }
            }
          },
          // tip
          // ------------------------------
          "&-tip": {
            color: token2.spinDotDefault
          },
          // holder
          // ------------------------------
          [`${componentCls}-dot-holder`]: {
            width: "1em",
            height: "1em",
            fontSize: token2.dotSize,
            display: "inline-block",
            transition: `transform ${token2.motionDurationSlow} ease, opacity ${token2.motionDurationSlow} ease`,
            transformOrigin: "50% 50%",
            lineHeight: 1,
            color: token2.colorPrimary,
            "&-hidden": {
              transform: "scale(0.3)",
              opacity: 0
            }
          },
          // progress
          // ------------------------------
          [`${componentCls}-dot-progress`]: {
            position: "absolute",
            inset: 0
          },
          // dots
          // ------------------------------
          [`${componentCls}-dot`]: {
            position: "relative",
            display: "inline-block",
            fontSize: token2.dotSize,
            width: "1em",
            height: "1em",
            "&-item": {
              position: "absolute",
              display: "block",
              width: calc(token2.dotSize).sub(calc(token2.marginXXS).div(2)).div(2).equal(),
              height: calc(token2.dotSize).sub(calc(token2.marginXXS).div(2)).div(2).equal(),
              background: "currentColor",
              borderRadius: "100%",
              transform: "scale(0.75)",
              transformOrigin: "50% 50%",
              opacity: 0.3,
              animationName: antSpinMove,
              animationDuration: "1s",
              animationIterationCount: "infinite",
              animationTimingFunction: "linear",
              animationDirection: "alternate",
              "&:nth-child(1)": {
                top: 0,
                insetInlineStart: 0,
                animationDelay: "0s"
              },
              "&:nth-child(2)": {
                top: 0,
                insetInlineEnd: 0,
                animationDelay: "0.4s"
              },
              "&:nth-child(3)": {
                insetInlineEnd: 0,
                bottom: 0,
                animationDelay: "0.8s"
              },
              "&:nth-child(4)": {
                bottom: 0,
                insetInlineStart: 0,
                animationDelay: "1.2s"
              }
            },
            "&-spin": {
              transform: "rotate(45deg)",
              animationName: antRotate,
              animationDuration: "1.2s",
              animationIterationCount: "infinite",
              animationTimingFunction: "linear"
            },
            "&-circle": {
              strokeLinecap: "round",
              transition: ["stroke-dashoffset", "stroke-dasharray", "stroke", "stroke-width", "opacity"].map((item) => `${item} ${token2.motionDurationSlow} ease`).join(","),
              fillOpacity: 0,
              stroke: "currentcolor"
            },
            "&-circle-bg": {
              stroke: token2.colorFillSecondary
            }
          },
          // small
          [`&-sm ${componentCls}-dot`]: {
            "&, &-holder": {
              fontSize: token2.dotSizeSM
            }
          },
          [`&-sm ${componentCls}-dot-holder`]: {
            i: {
              width: calc(calc(token2.dotSizeSM).sub(calc(token2.marginXXS).div(2))).div(2).equal(),
              height: calc(calc(token2.dotSizeSM).sub(calc(token2.marginXXS).div(2))).div(2).equal()
            }
          },
          // large
          [`&-lg ${componentCls}-dot`]: {
            "&, &-holder": {
              fontSize: token2.dotSizeLG
            }
          },
          [`&-lg ${componentCls}-dot-holder`]: {
            i: {
              width: calc(calc(token2.dotSizeLG).sub(token2.marginXXS)).div(2).equal(),
              height: calc(calc(token2.dotSizeLG).sub(token2.marginXXS)).div(2).equal()
            }
          },
          [`&${componentCls}-show-text ${componentCls}-text`]: {
            display: "block"
          }
        })
      };
    };
    const prepareComponentToken$6 = (token2) => {
      const {
        controlHeightLG,
        controlHeight
      } = token2;
      return {
        contentHeight: 400,
        dotSize: controlHeightLG / 2,
        dotSizeSM: controlHeightLG * 0.35,
        dotSizeLG: controlHeight
      };
    };
    const useStyle$6 = genStyleHooks("Spin", (token2) => {
      const spinToken = merge(token2, {
        spinDotDefault: token2.colorTextDescription
      });
      return [genSpinStyle(spinToken)];
    }, prepareComponentToken$6);
    const AUTO_INTERVAL = 200;
    const STEP_BUCKETS = [[30, 0.05], [70, 0.03], [96, 0.01]];
    function usePercent(spinning, percent) {
      const [mockPercent, setMockPercent] = reactExports.useState(0);
      const mockIntervalRef = reactExports.useRef(null);
      const isAuto = percent === "auto";
      reactExports.useEffect(() => {
        if (isAuto && spinning) {
          setMockPercent(0);
          mockIntervalRef.current = setInterval(() => {
            setMockPercent((prev2) => {
              const restPTG = 100 - prev2;
              for (let i2 = 0; i2 < STEP_BUCKETS.length; i2 += 1) {
                const [limit, stepPtg] = STEP_BUCKETS[i2];
                if (prev2 <= limit) {
                  return prev2 + restPTG * stepPtg;
                }
              }
              return prev2;
            });
          }, AUTO_INTERVAL);
        }
        return () => {
          clearInterval(mockIntervalRef.current);
        };
      }, [isAuto, spinning]);
      return isAuto ? mockPercent : percent;
    }
    var __rest$e = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    let defaultIndicator;
    function shouldDelay(spinning, delay) {
      return !!spinning && !!delay && !Number.isNaN(Number(delay));
    }
    const Spin = (props) => {
      var _a;
      const {
        prefixCls: customizePrefixCls,
        spinning: customSpinning = true,
        delay = 0,
        className,
        rootClassName,
        size = "default",
        tip,
        wrapperClassName,
        style: style2,
        children,
        fullscreen = false,
        indicator,
        percent
      } = props, restProps = __rest$e(props, ["prefixCls", "spinning", "delay", "className", "rootClassName", "size", "tip", "wrapperClassName", "style", "children", "fullscreen", "indicator", "percent"]);
      const {
        getPrefixCls,
        direction,
        className: contextClassName,
        style: contextStyle,
        indicator: contextIndicator
      } = useComponentConfig("spin");
      const prefixCls = getPrefixCls("spin", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$6(prefixCls);
      const [spinning, setSpinning] = reactExports.useState(() => customSpinning && !shouldDelay(customSpinning, delay));
      const mergedPercent = usePercent(spinning, percent);
      reactExports.useEffect(() => {
        if (customSpinning) {
          const showSpinning = debounce$1(delay, () => {
            setSpinning(true);
          });
          showSpinning();
          return () => {
            var _a2;
            (_a2 = showSpinning === null || showSpinning === void 0 ? void 0 : showSpinning.cancel) === null || _a2 === void 0 ? void 0 : _a2.call(showSpinning);
          };
        }
        setSpinning(false);
      }, [delay, customSpinning]);
      const isNestedPattern = reactExports.useMemo(() => typeof children !== "undefined" && !fullscreen, [children, fullscreen]);
      const spinClassName = classNames(prefixCls, contextClassName, {
        [`${prefixCls}-sm`]: size === "small",
        [`${prefixCls}-lg`]: size === "large",
        [`${prefixCls}-spinning`]: spinning,
        [`${prefixCls}-show-text`]: !!tip,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, !fullscreen && rootClassName, hashId, cssVarCls);
      const containerClassName = classNames(`${prefixCls}-container`, {
        [`${prefixCls}-blur`]: spinning
      });
      const mergedIndicator = (_a = indicator !== null && indicator !== void 0 ? indicator : contextIndicator) !== null && _a !== void 0 ? _a : defaultIndicator;
      const mergedStyle = Object.assign(Object.assign({}, contextStyle), style2);
      const spinElement = /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, restProps, {
        style: mergedStyle,
        className: spinClassName,
        "aria-live": "polite",
        "aria-busy": spinning
      }), /* @__PURE__ */ reactExports.createElement(Indicator, {
        prefixCls,
        indicator: mergedIndicator,
        percent: mergedPercent
      }), tip && (isNestedPattern || fullscreen) ? /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-text`
      }, tip) : null);
      if (isNestedPattern) {
        return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({}, restProps, {
          className: classNames(`${prefixCls}-nested-loading`, wrapperClassName, hashId, cssVarCls)
        }), spinning && /* @__PURE__ */ reactExports.createElement("div", {
          key: "loading"
        }, spinElement), /* @__PURE__ */ reactExports.createElement("div", {
          className: containerClassName,
          key: "container"
        }, children)));
      }
      if (fullscreen) {
        return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
          className: classNames(`${prefixCls}-fullscreen`, {
            [`${prefixCls}-fullscreen-show`]: spinning
          }, rootClassName, hashId, cssVarCls)
        }, spinElement));
      }
      return wrapCSSVar(spinElement);
    };
    Spin.setDefaultIndicator = (indicator) => {
      defaultIndicator = indicator;
    };
    const ListContext = /* @__PURE__ */ i.createContext({});
    ListContext.Consumer;
    var __rest$d = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const Meta = (_a) => {
      var {
        prefixCls: customizePrefixCls,
        className,
        avatar,
        title,
        description
      } = _a, others = __rest$d(_a, ["prefixCls", "className", "avatar", "title", "description"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("list", customizePrefixCls);
      const classString = classNames(`${prefixCls}-item-meta`, className);
      const content = /* @__PURE__ */ i.createElement("div", {
        className: `${prefixCls}-item-meta-content`
      }, title && /* @__PURE__ */ i.createElement("h4", {
        className: `${prefixCls}-item-meta-title`
      }, title), description && /* @__PURE__ */ i.createElement("div", {
        className: `${prefixCls}-item-meta-description`
      }, description));
      return /* @__PURE__ */ i.createElement("div", Object.assign({}, others, {
        className: classString
      }), avatar && /* @__PURE__ */ i.createElement("div", {
        className: `${prefixCls}-item-meta-avatar`
      }, avatar), (title || description) && content);
    };
    const InternalItem = /* @__PURE__ */ i.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        children,
        actions,
        extra,
        styles,
        className,
        classNames: customizeClassNames,
        colStyle
      } = props, others = __rest$d(props, ["prefixCls", "children", "actions", "extra", "styles", "className", "classNames", "colStyle"]);
      const {
        grid,
        itemLayout
      } = reactExports.useContext(ListContext);
      const {
        getPrefixCls,
        list
      } = reactExports.useContext(ConfigContext);
      const moduleClass = (moduleName) => {
        var _a, _b;
        return classNames((_b = (_a = list === null || list === void 0 ? void 0 : list.item) === null || _a === void 0 ? void 0 : _a.classNames) === null || _b === void 0 ? void 0 : _b[moduleName], customizeClassNames === null || customizeClassNames === void 0 ? void 0 : customizeClassNames[moduleName]);
      };
      const moduleStyle = (moduleName) => {
        var _a, _b;
        return Object.assign(Object.assign({}, (_b = (_a = list === null || list === void 0 ? void 0 : list.item) === null || _a === void 0 ? void 0 : _a.styles) === null || _b === void 0 ? void 0 : _b[moduleName]), styles === null || styles === void 0 ? void 0 : styles[moduleName]);
      };
      const isItemContainsTextNodeAndNotSingular = () => {
        let result = false;
        reactExports.Children.forEach(children, (element) => {
          if (typeof element === "string") {
            result = true;
          }
        });
        return result && reactExports.Children.count(children) > 1;
      };
      const isFlexMode = () => {
        if (itemLayout === "vertical") {
          return !!extra;
        }
        return !isItemContainsTextNodeAndNotSingular();
      };
      const prefixCls = getPrefixCls("list", customizePrefixCls);
      const actionsContent = actions && actions.length > 0 && /* @__PURE__ */ i.createElement("ul", {
        className: classNames(`${prefixCls}-item-action`, moduleClass("actions")),
        key: "actions",
        style: moduleStyle("actions")
      }, actions.map((action, i$1) => (
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ i.createElement("li", {
          key: `${prefixCls}-item-action-${i$1}`
        }, action, i$1 !== actions.length - 1 && /* @__PURE__ */ i.createElement("em", {
          className: `${prefixCls}-item-action-split`
        }))
      )));
      const Element2 = grid ? "div" : "li";
      const itemChildren = /* @__PURE__ */ i.createElement(Element2, Object.assign({}, others, !grid ? {
        ref
      } : {}, {
        className: classNames(`${prefixCls}-item`, {
          [`${prefixCls}-item-no-flex`]: !isFlexMode()
        }, className)
      }), itemLayout === "vertical" && extra ? [/* @__PURE__ */ i.createElement("div", {
        className: `${prefixCls}-item-main`,
        key: "content"
      }, children, actionsContent), /* @__PURE__ */ i.createElement("div", {
        className: classNames(`${prefixCls}-item-extra`, moduleClass("extra")),
        key: "extra",
        style: moduleStyle("extra")
      }, extra)] : [children, actionsContent, cloneElement(extra, {
        key: "extra"
      })]);
      return grid ? /* @__PURE__ */ i.createElement(Col, {
        ref,
        flex: 1,
        style: colStyle
      }, itemChildren) : itemChildren;
    });
    const Item = InternalItem;
    Item.Meta = Meta;
    const genBorderedStyle = (token2) => {
      const {
        listBorderedCls,
        componentCls,
        paddingLG,
        margin,
        itemPaddingSM,
        itemPaddingLG,
        marginLG,
        borderRadiusLG
      } = token2;
      return {
        [listBorderedCls]: {
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: borderRadiusLG,
          [`${componentCls}-header,${componentCls}-footer,${componentCls}-item`]: {
            paddingInline: paddingLG
          },
          [`${componentCls}-pagination`]: {
            margin: `${unit$1(margin)} ${unit$1(marginLG)}`
          }
        },
        [`${listBorderedCls}${componentCls}-sm`]: {
          [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
            padding: itemPaddingSM
          }
        },
        [`${listBorderedCls}${componentCls}-lg`]: {
          [`${componentCls}-item,${componentCls}-header,${componentCls}-footer`]: {
            padding: itemPaddingLG
          }
        }
      };
    };
    const genResponsiveStyle = (token2) => {
      const {
        componentCls,
        screenSM,
        screenMD,
        marginLG,
        marginSM,
        margin
      } = token2;
      return {
        [`@media screen and (max-width:${screenMD}px)`]: {
          [componentCls]: {
            [`${componentCls}-item`]: {
              [`${componentCls}-item-action`]: {
                marginInlineStart: marginLG
              }
            }
          },
          [`${componentCls}-vertical`]: {
            [`${componentCls}-item`]: {
              [`${componentCls}-item-extra`]: {
                marginInlineStart: marginLG
              }
            }
          }
        },
        [`@media screen and (max-width: ${screenSM}px)`]: {
          [componentCls]: {
            [`${componentCls}-item`]: {
              flexWrap: "wrap",
              [`${componentCls}-action`]: {
                marginInlineStart: marginSM
              }
            }
          },
          [`${componentCls}-vertical`]: {
            [`${componentCls}-item`]: {
              flexWrap: "wrap-reverse",
              [`${componentCls}-item-main`]: {
                minWidth: token2.contentWidth
              },
              [`${componentCls}-item-extra`]: {
                margin: `auto auto ${unit$1(margin)}`
              }
            }
          }
        }
      };
    };
    const genBaseStyle$1 = (token2) => {
      const {
        componentCls,
        antCls,
        controlHeight,
        minHeight,
        paddingSM,
        marginLG,
        padding,
        itemPadding,
        colorPrimary,
        itemPaddingSM,
        itemPaddingLG,
        paddingXS,
        margin,
        colorText,
        colorTextDescription,
        motionDurationSlow,
        lineWidth,
        headerBg,
        footerBg,
        emptyTextPadding,
        metaMarginBottom,
        avatarMarginRight,
        titleMarginBottom,
        descriptionFontSize
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "relative",
          "*": {
            outline: "none"
          },
          [`${componentCls}-header`]: {
            background: headerBg
          },
          [`${componentCls}-footer`]: {
            background: footerBg
          },
          [`${componentCls}-header, ${componentCls}-footer`]: {
            paddingBlock: paddingSM
          },
          [`${componentCls}-pagination`]: {
            marginBlockStart: marginLG,
            // https://github.com/ant-design/ant-design/issues/20037
            [`${antCls}-pagination-options`]: {
              textAlign: "start"
            }
          },
          [`${componentCls}-spin`]: {
            minHeight,
            textAlign: "center"
          },
          [`${componentCls}-items`]: {
            margin: 0,
            padding: 0,
            listStyle: "none"
          },
          [`${componentCls}-item`]: {
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            padding: itemPadding,
            color: colorText,
            [`${componentCls}-item-meta`]: {
              display: "flex",
              flex: 1,
              alignItems: "flex-start",
              maxWidth: "100%",
              [`${componentCls}-item-meta-avatar`]: {
                marginInlineEnd: avatarMarginRight
              },
              [`${componentCls}-item-meta-content`]: {
                flex: "1 0",
                width: 0,
                color: colorText
              },
              [`${componentCls}-item-meta-title`]: {
                margin: `0 0 ${unit$1(token2.marginXXS)} 0`,
                color: colorText,
                fontSize: token2.fontSize,
                lineHeight: token2.lineHeight,
                "> a": {
                  color: colorText,
                  transition: `all ${motionDurationSlow}`,
                  "&:hover": {
                    color: colorPrimary
                  }
                }
              },
              [`${componentCls}-item-meta-description`]: {
                color: colorTextDescription,
                fontSize: descriptionFontSize,
                lineHeight: token2.lineHeight
              }
            },
            [`${componentCls}-item-action`]: {
              flex: "0 0 auto",
              marginInlineStart: token2.marginXXL,
              padding: 0,
              fontSize: 0,
              listStyle: "none",
              "& > li": {
                position: "relative",
                display: "inline-block",
                padding: `0 ${unit$1(paddingXS)}`,
                color: colorTextDescription,
                fontSize: token2.fontSize,
                lineHeight: token2.lineHeight,
                textAlign: "center",
                "&:first-child": {
                  paddingInlineStart: 0
                }
              },
              [`${componentCls}-item-action-split`]: {
                position: "absolute",
                insetBlockStart: "50%",
                insetInlineEnd: 0,
                width: lineWidth,
                height: token2.calc(token2.fontHeight).sub(token2.calc(token2.marginXXS).mul(2)).equal(),
                transform: "translateY(-50%)",
                backgroundColor: token2.colorSplit
              }
            }
          },
          [`${componentCls}-empty`]: {
            padding: `${unit$1(padding)} 0`,
            color: colorTextDescription,
            fontSize: token2.fontSizeSM,
            textAlign: "center"
          },
          [`${componentCls}-empty-text`]: {
            padding: emptyTextPadding,
            color: token2.colorTextDisabled,
            fontSize: token2.fontSize,
            textAlign: "center"
          },
          // ============================ without flex ============================
          [`${componentCls}-item-no-flex`]: {
            display: "block"
          }
        }),
        [`${componentCls}-grid ${antCls}-col > ${componentCls}-item`]: {
          display: "block",
          maxWidth: "100%",
          marginBlockEnd: margin,
          paddingBlock: 0,
          borderBlockEnd: "none"
        },
        [`${componentCls}-vertical ${componentCls}-item`]: {
          alignItems: "initial",
          [`${componentCls}-item-main`]: {
            display: "block",
            flex: 1
          },
          [`${componentCls}-item-extra`]: {
            marginInlineStart: marginLG
          },
          [`${componentCls}-item-meta`]: {
            marginBlockEnd: metaMarginBottom,
            [`${componentCls}-item-meta-title`]: {
              marginBlockStart: 0,
              marginBlockEnd: titleMarginBottom,
              color: colorText,
              fontSize: token2.fontSizeLG,
              lineHeight: token2.lineHeightLG
            }
          },
          [`${componentCls}-item-action`]: {
            marginBlockStart: padding,
            marginInlineStart: "auto",
            "> li": {
              padding: `0 ${unit$1(padding)}`,
              "&:first-child": {
                paddingInlineStart: 0
              }
            }
          }
        },
        [`${componentCls}-split ${componentCls}-item`]: {
          borderBlockEnd: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
          "&:last-child": {
            borderBlockEnd: "none"
          }
        },
        [`${componentCls}-split ${componentCls}-header`]: {
          borderBlockEnd: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
        },
        [`${componentCls}-split${componentCls}-empty ${componentCls}-footer`]: {
          borderTop: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
        },
        [`${componentCls}-loading ${componentCls}-spin-nested-loading`]: {
          minHeight: controlHeight
        },
        [`${componentCls}-split${componentCls}-something-after-last-item ${antCls}-spin-container > ${componentCls}-items > ${componentCls}-item:last-child`]: {
          borderBlockEnd: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`
        },
        [`${componentCls}-lg ${componentCls}-item`]: {
          padding: itemPaddingLG
        },
        [`${componentCls}-sm ${componentCls}-item`]: {
          padding: itemPaddingSM
        },
        // Horizontal
        [`${componentCls}:not(${componentCls}-vertical)`]: {
          [`${componentCls}-item-no-flex`]: {
            [`${componentCls}-item-action`]: {
              float: "right"
            }
          }
        }
      };
    };
    const prepareComponentToken$5 = (token2) => ({
      contentWidth: 220,
      itemPadding: `${unit$1(token2.paddingContentVertical)} 0`,
      itemPaddingSM: `${unit$1(token2.paddingContentVerticalSM)} ${unit$1(token2.paddingContentHorizontal)}`,
      itemPaddingLG: `${unit$1(token2.paddingContentVerticalLG)} ${unit$1(token2.paddingContentHorizontalLG)}`,
      headerBg: "transparent",
      footerBg: "transparent",
      emptyTextPadding: token2.padding,
      metaMarginBottom: token2.padding,
      avatarMarginRight: token2.padding,
      titleMarginBottom: token2.paddingSM,
      descriptionFontSize: token2.fontSize
    });
    const useStyle$5 = genStyleHooks("List", (token2) => {
      const listToken = merge(token2, {
        listBorderedCls: `${token2.componentCls}-bordered`,
        minHeight: token2.controlHeightLG
      });
      return [genBaseStyle$1(listToken), genBorderedStyle(listToken), genResponsiveStyle(listToken)];
    }, prepareComponentToken$5);
    var __rest$c = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function InternalList(_a, ref) {
      var {
        pagination = false,
        prefixCls: customizePrefixCls,
        bordered = false,
        split: split2 = true,
        className,
        rootClassName,
        style: style2,
        children,
        itemLayout,
        loadMore,
        grid,
        dataSource = [],
        size: customizeSize,
        header,
        footer,
        loading = false,
        rowKey,
        renderItem,
        locale: locale2
      } = _a, rest = __rest$c(_a, ["pagination", "prefixCls", "bordered", "split", "className", "rootClassName", "style", "children", "itemLayout", "loadMore", "grid", "dataSource", "size", "header", "footer", "loading", "rowKey", "renderItem", "locale"]);
      const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
      const [paginationCurrent, setPaginationCurrent] = reactExports.useState(paginationObj.defaultCurrent || 1);
      const [paginationSize, setPaginationSize] = reactExports.useState(paginationObj.defaultPageSize || 10);
      const {
        getPrefixCls,
        direction,
        className: contextClassName,
        style: contextStyle
      } = useComponentConfig("list");
      const {
        renderEmpty
      } = reactExports.useContext(ConfigContext);
      const defaultPaginationProps = {
        current: 1,
        total: 0
      };
      const triggerPaginationEvent = (eventName) => (page, pageSize) => {
        var _a2;
        setPaginationCurrent(page);
        setPaginationSize(pageSize);
        if (pagination) {
          (_a2 = pagination === null || pagination === void 0 ? void 0 : pagination[eventName]) === null || _a2 === void 0 ? void 0 : _a2.call(pagination, page, pageSize);
        }
      };
      const onPaginationChange = triggerPaginationEvent("onChange");
      const onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
      const renderInnerItem = (item, index2) => {
        if (!renderItem) return null;
        let key;
        if (typeof rowKey === "function") {
          key = rowKey(item);
        } else if (rowKey) {
          key = item[rowKey];
        } else {
          key = item.key;
        }
        if (!key) {
          key = `list-item-${index2}`;
        }
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, {
          key
        }, renderItem(item, index2));
      };
      const isSomethingAfterLastItem = () => !!(loadMore || pagination || footer);
      const prefixCls = getPrefixCls("list", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$5(prefixCls);
      let loadingProp = loading;
      if (typeof loadingProp === "boolean") {
        loadingProp = {
          spinning: loadingProp
        };
      }
      const isLoading = !!(loadingProp === null || loadingProp === void 0 ? void 0 : loadingProp.spinning);
      const mergedSize = useSize(customizeSize);
      let sizeCls = "";
      switch (mergedSize) {
        case "large":
          sizeCls = "lg";
          break;
        case "small":
          sizeCls = "sm";
          break;
      }
      const classString = classNames(prefixCls, {
        [`${prefixCls}-vertical`]: itemLayout === "vertical",
        [`${prefixCls}-${sizeCls}`]: sizeCls,
        [`${prefixCls}-split`]: split2,
        [`${prefixCls}-bordered`]: bordered,
        [`${prefixCls}-loading`]: isLoading,
        [`${prefixCls}-grid`]: !!grid,
        [`${prefixCls}-something-after-last-item`]: isSomethingAfterLastItem(),
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, contextClassName, className, rootClassName, hashId, cssVarCls);
      const paginationProps = extendsObject(defaultPaginationProps, {
        total: dataSource.length,
        current: paginationCurrent,
        pageSize: paginationSize
      }, pagination || {});
      const largestPage = Math.ceil(paginationProps.total / paginationProps.pageSize);
      if (paginationProps.current > largestPage) {
        paginationProps.current = largestPage;
      }
      const paginationContent = pagination && /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-pagination`)
      }, /* @__PURE__ */ reactExports.createElement(Pagination, Object.assign({
        align: "end"
      }, paginationProps, {
        onChange: onPaginationChange,
        onShowSizeChange: onPaginationShowSizeChange
      })));
      let splitDataSource = _toConsumableArray(dataSource);
      if (pagination) {
        if (dataSource.length > (paginationProps.current - 1) * paginationProps.pageSize) {
          splitDataSource = _toConsumableArray(dataSource).splice((paginationProps.current - 1) * paginationProps.pageSize, paginationProps.pageSize);
        }
      }
      const needResponsive = Object.keys(grid || {}).some((key) => ["xs", "sm", "md", "lg", "xl", "xxl"].includes(key));
      const screens = useBreakpoint(needResponsive);
      const currentBreakpoint = reactExports.useMemo(() => {
        for (let i2 = 0; i2 < responsiveArray.length; i2 += 1) {
          const breakpoint = responsiveArray[i2];
          if (screens[breakpoint]) {
            return breakpoint;
          }
        }
        return void 0;
      }, [screens]);
      const colStyle = reactExports.useMemo(() => {
        if (!grid) {
          return void 0;
        }
        const columnCount = currentBreakpoint && grid[currentBreakpoint] ? grid[currentBreakpoint] : grid.column;
        if (columnCount) {
          return {
            width: `${100 / columnCount}%`,
            maxWidth: `${100 / columnCount}%`
          };
        }
      }, [JSON.stringify(grid), currentBreakpoint]);
      let childrenContent = isLoading && /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          minHeight: 53
        }
      });
      if (splitDataSource.length > 0) {
        const items = splitDataSource.map((item, index2) => renderInnerItem(item, index2));
        childrenContent = grid ? /* @__PURE__ */ reactExports.createElement(Row, {
          gutter: grid.gutter
        }, reactExports.Children.map(items, (child) => /* @__PURE__ */ reactExports.createElement("div", {
          key: child === null || child === void 0 ? void 0 : child.key,
          style: colStyle
        }, child))) : /* @__PURE__ */ reactExports.createElement("ul", {
          className: `${prefixCls}-items`
        }, items);
      } else if (!children && !isLoading) {
        childrenContent = /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-empty-text`
        }, (locale2 === null || locale2 === void 0 ? void 0 : locale2.emptyText) || (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("List")) || /* @__PURE__ */ reactExports.createElement(DefaultRenderEmpty, {
          componentName: "List"
        }));
      }
      const paginationPosition = paginationProps.position || "bottom";
      const contextValue = reactExports.useMemo(() => ({
        grid,
        itemLayout
      }), [JSON.stringify(grid), itemLayout]);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(ListContext.Provider, {
        value: contextValue
      }, /* @__PURE__ */ reactExports.createElement("div", Object.assign({
        ref,
        style: Object.assign(Object.assign({}, contextStyle), style2),
        className: classString
      }, rest), (paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-header`
      }, header), /* @__PURE__ */ reactExports.createElement(Spin, Object.assign({}, loadingProp), childrenContent, children), footer && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-footer`
      }, footer), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent)));
    }
    const ListWithForwardRef = /* @__PURE__ */ reactExports.forwardRef(InternalList);
    const List = ListWithForwardRef;
    List.Item = Item;
    function toList$1(candidate) {
      let skipEmpty = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (skipEmpty && (candidate === void 0 || candidate === null)) return [];
      return Array.isArray(candidate) ? candidate : [candidate];
    }
    let message = null;
    let act = (callback) => callback();
    let taskQueue = [];
    let defaultGlobalConfig = {};
    function getGlobalContext() {
      const {
        getContainer: getContainer2,
        duration,
        rtl,
        maxCount,
        top
      } = defaultGlobalConfig;
      const mergedContainer = (getContainer2 === null || getContainer2 === void 0 ? void 0 : getContainer2()) || document.body;
      return {
        getContainer: () => mergedContainer,
        duration,
        rtl,
        maxCount,
        top
      };
    }
    const GlobalHolder = /* @__PURE__ */ i.forwardRef((props, ref) => {
      const {
        messageConfig,
        sync
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = defaultGlobalConfig.prefixCls || getPrefixCls("message");
      const appConfig = reactExports.useContext(AppConfigContext);
      const [api, holder] = useInternalMessage(Object.assign(Object.assign(Object.assign({}, messageConfig), {
        prefixCls
      }), appConfig.message));
      i.useImperativeHandle(ref, () => {
        const instance = Object.assign({}, api);
        Object.keys(instance).forEach((method2) => {
          instance[method2] = function() {
            sync();
            return api[method2].apply(api, arguments);
          };
        });
        return {
          instance,
          sync
        };
      });
      return holder;
    });
    const GlobalHolderWrapper = /* @__PURE__ */ i.forwardRef((_2, ref) => {
      const [messageConfig, setMessageConfig] = i.useState(getGlobalContext);
      const sync = () => {
        setMessageConfig(getGlobalContext);
      };
      i.useEffect(sync, []);
      const global2 = globalConfig();
      const rootPrefixCls = global2.getRootPrefixCls();
      const rootIconPrefixCls = global2.getIconPrefixCls();
      const theme = global2.getTheme();
      const dom = /* @__PURE__ */ i.createElement(GlobalHolder, {
        ref,
        sync,
        messageConfig
      });
      return /* @__PURE__ */ i.createElement(ConfigProvider, {
        prefixCls: rootPrefixCls,
        iconPrefixCls: rootIconPrefixCls,
        theme
      }, global2.holderRender ? global2.holderRender(dom) : dom);
    });
    function flushNotice() {
      if (!message) {
        const holderFragment = document.createDocumentFragment();
        const newMessage = {
          fragment: holderFragment
        };
        message = newMessage;
        act(() => {
          const reactRender2 = getReactRender();
          reactRender2(/* @__PURE__ */ i.createElement(GlobalHolderWrapper, {
            ref: (node2) => {
              const {
                instance,
                sync
              } = node2 || {};
              Promise.resolve().then(() => {
                if (!newMessage.instance && instance) {
                  newMessage.instance = instance;
                  newMessage.sync = sync;
                  flushNotice();
                }
              });
            }
          }), holderFragment);
        });
        return;
      }
      if (!message.instance) {
        return;
      }
      taskQueue.forEach((task) => {
        const {
          type: type2,
          skipped
        } = task;
        if (!skipped) {
          switch (type2) {
            case "open": {
              act(() => {
                const closeFn = message.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig), task.config));
                closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);
                task.setCloseFn(closeFn);
              });
              break;
            }
            case "destroy":
              act(() => {
                message === null || message === void 0 ? void 0 : message.instance.destroy(task.key);
              });
              break;
            default: {
              act(() => {
                var _message$instance;
                const closeFn = (_message$instance = message.instance)[type2].apply(_message$instance, _toConsumableArray(task.args));
                closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);
                task.setCloseFn(closeFn);
              });
            }
          }
        }
      });
      taskQueue = [];
    }
    function setMessageGlobalConfig(config) {
      defaultGlobalConfig = Object.assign(Object.assign({}, defaultGlobalConfig), config);
      act(() => {
        var _a;
        (_a = message === null || message === void 0 ? void 0 : message.sync) === null || _a === void 0 ? void 0 : _a.call(message);
      });
    }
    function open(config) {
      const result = wrapPromiseFn((resolve) => {
        let closeFn;
        const task = {
          type: "open",
          config,
          resolve,
          setCloseFn: (fn) => {
            closeFn = fn;
          }
        };
        taskQueue.push(task);
        return () => {
          if (closeFn) {
            act(() => {
              closeFn();
            });
          } else {
            task.skipped = true;
          }
        };
      });
      flushNotice();
      return result;
    }
    function typeOpen(type2, args) {
      const result = wrapPromiseFn((resolve) => {
        let closeFn;
        const task = {
          type: type2,
          args,
          resolve,
          setCloseFn: (fn) => {
            closeFn = fn;
          }
        };
        taskQueue.push(task);
        return () => {
          if (closeFn) {
            act(() => {
              closeFn();
            });
          } else {
            task.skipped = true;
          }
        };
      });
      flushNotice();
      return result;
    }
    const destroy = (key) => {
      taskQueue.push({
        type: "destroy",
        key
      });
      flushNotice();
    };
    const methods = ["success", "info", "warning", "error", "loading"];
    const baseStaticMethods = {
      open,
      destroy,
      config: setMessageGlobalConfig,
      useMessage,
      _InternalPanelDoNotUseOrYouWillBeFired: PurePanel$6
    };
    const staticMethods = baseStaticMethods;
    methods.forEach((type2) => {
      staticMethods[type2] = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return typeOpen(type2, args);
      };
    });
    var __rest$b = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const PurePanel$1 = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        closeIcon,
        closable,
        type: type2,
        title,
        children,
        footer
      } = props, restProps = __rest$b(props, ["prefixCls", "className", "closeIcon", "closable", "type", "title", "children", "footer"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const rootPrefixCls = getPrefixCls();
      const prefixCls = customizePrefixCls || getPrefixCls("modal");
      const rootCls = useCSSVarCls(rootPrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$m(prefixCls, rootCls);
      const confirmPrefixCls = `${prefixCls}-confirm`;
      let additionalProps = {};
      if (type2) {
        additionalProps = {
          closable: closable !== null && closable !== void 0 ? closable : false,
          title: "",
          footer: "",
          children: /* @__PURE__ */ reactExports.createElement(ConfirmContent, Object.assign({}, props, {
            prefixCls,
            confirmPrefixCls,
            rootPrefixCls,
            content: children
          }))
        };
      } else {
        additionalProps = {
          closable: closable !== null && closable !== void 0 ? closable : true,
          title,
          footer: footer !== null && /* @__PURE__ */ reactExports.createElement(Footer$1, Object.assign({}, props)),
          children
        };
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(Panel$1, Object.assign({
        prefixCls,
        className: classNames(hashId, `${prefixCls}-pure-panel`, type2 && confirmPrefixCls, type2 && `${confirmPrefixCls}-${type2}`, className, cssVarCls, rootCls)
      }, restProps, {
        closeIcon: renderCloseIcon(prefixCls, closeIcon),
        closable
      }, additionalProps)));
    };
    const PurePanel$2 = withPureRenderTheme(PurePanel$1);
    function modalWarn(props) {
      return confirm(withWarn(props));
    }
    const Modal = Modal$1;
    Modal.useModal = useModal;
    Modal.info = function infoFn(props) {
      return confirm(withInfo(props));
    };
    Modal.success = function successFn(props) {
      return confirm(withSuccess(props));
    };
    Modal.error = function errorFn(props) {
      return confirm(withError(props));
    };
    Modal.warning = modalWarn;
    Modal.warn = modalWarn;
    Modal.confirm = function confirmFn(props) {
      return confirm(withConfirm(props));
    };
    Modal.destroyAll = function destroyAllFn() {
      while (destroyFns.length) {
        const close = destroyFns.pop();
        if (close) {
          close();
        }
      }
    };
    Modal.config = modalGlobalConfig;
    Modal._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$2;
    var ArrowDownOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M862 465.3h-81c-4.6 0-9 2-12.1 5.5L550 723.1V160c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v563.1L255.1 470.8c-3-3.5-7.4-5.5-12.1-5.5h-81c-6.8 0-10.5 8.1-6 13.2L487.9 861a31.96 31.96 0 0048.3 0L868 478.5c4.5-5.2.8-13.2-6-13.2z" } }] }, "name": "arrow-down", "theme": "outlined" };
    var ArrowDownOutlined = function ArrowDownOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: ArrowDownOutlined$1
      }));
    };
    var RefIcon$f = /* @__PURE__ */ reactExports.forwardRef(ArrowDownOutlined);
    var ArrowUpOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M868 545.5L536.1 163a31.96 31.96 0 00-48.3 0L156 545.5a7.97 7.97 0 006 13.2h81c4.6 0 9-2 12.1-5.5L474 300.9V864c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V300.9l218.9 252.3c3 3.5 7.4 5.5 12.1 5.5h81c6.8 0 10.5-8 6-13.2z" } }] }, "name": "arrow-up", "theme": "outlined" };
    var ArrowUpOutlined = function ArrowUpOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: ArrowUpOutlined$1
      }));
    };
    var RefIcon$e = /* @__PURE__ */ reactExports.forwardRef(ArrowUpOutlined);
    var BorderOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "border", "theme": "outlined" };
    var BorderOutlined = function BorderOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: BorderOutlined$1
      }));
    };
    var RefIcon$d = /* @__PURE__ */ reactExports.forwardRef(BorderOutlined);
    var CheckCircleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z" } }, { "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "check-circle", "theme": "outlined" };
    var CheckCircleOutlined = function CheckCircleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: CheckCircleOutlined$1
      }));
    };
    var RefIcon$c = /* @__PURE__ */ reactExports.forwardRef(CheckCircleOutlined);
    var CheckSquareOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M433.1 657.7a31.8 31.8 0 0051.7 0l210.6-292c3.8-5.3 0-12.7-6.5-12.7H642c-10.2 0-19.9 4.9-25.9 13.3L459 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H315c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "check-square", "theme": "outlined" };
    var CheckSquareOutlined = function CheckSquareOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: CheckSquareOutlined$1
      }));
    };
    var RefIcon$b = /* @__PURE__ */ reactExports.forwardRef(CheckSquareOutlined);
    var CopyOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, "name": "copy", "theme": "outlined" };
    var CopyOutlined = function CopyOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: CopyOutlined$1
      }));
    };
    var RefIcon$a = /* @__PURE__ */ reactExports.forwardRef(CopyOutlined);
    var DeleteOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, "name": "delete", "theme": "outlined" };
    var DeleteOutlined = function DeleteOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: DeleteOutlined$1
      }));
    };
    var RefIcon$9 = /* @__PURE__ */ reactExports.forwardRef(DeleteOutlined);
    var EditOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, "name": "edit", "theme": "outlined" };
    var EditOutlined = function EditOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: EditOutlined$1
      }));
    };
    var RefIcon$8 = /* @__PURE__ */ reactExports.forwardRef(EditOutlined);
    var EnterOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, "name": "enter", "theme": "outlined" };
    var EnterOutlined = function EnterOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: EnterOutlined$1
      }));
    };
    var RefIcon$7 = /* @__PURE__ */ reactExports.forwardRef(EnterOutlined);
    var FontSizeOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M920 416H616c-4.4 0-8 3.6-8 8v112c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-56h60v320h-46c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h164c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8h-46V480h60v56c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V424c0-4.4-3.6-8-8-8zM656 296V168c0-4.4-3.6-8-8-8H104c-4.4 0-8 3.6-8 8v128c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-64h168v560h-92c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h264c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8h-92V232h168v64c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8z" } }] }, "name": "font-size", "theme": "outlined" };
    var FontSizeOutlined = function FontSizeOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: FontSizeOutlined$1
      }));
    };
    var RefIcon$6 = /* @__PURE__ */ reactExports.forwardRef(FontSizeOutlined);
    var FormOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M904 512h-56c-4.4 0-8 3.6-8 8v320H184V184h320c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V520c0-4.4-3.6-8-8-8z" } }, { "tag": "path", "attrs": { "d": "M355.9 534.9L354 653.8c-.1 8.9 7.1 16.2 16 16.2h.4l118-2.9c2-.1 4-.9 5.4-2.3l415.9-415c3.1-3.1 3.1-8.2 0-11.3L785.4 114.3c-1.6-1.6-3.6-2.3-5.7-2.3s-4.1.8-5.7 2.3l-415.8 415a8.3 8.3 0 00-2.3 5.6zm63.5 23.6L779.7 199l45.2 45.1-360.5 359.7-45.7 1.1.7-46.4z" } }] }, "name": "form", "theme": "outlined" };
    var FormOutlined = function FormOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: FormOutlined$1
      }));
    };
    var RefIcon$5 = /* @__PURE__ */ reactExports.forwardRef(FormOutlined);
    var LineOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M904 476H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8z" } }] }, "name": "line", "theme": "outlined" };
    var LineOutlined = function LineOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: LineOutlined$1
      }));
    };
    var RefIcon$4 = /* @__PURE__ */ reactExports.forwardRef(LineOutlined);
    var MenuOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z" } }] }, "name": "menu", "theme": "outlined" };
    var MenuOutlined = function MenuOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: MenuOutlined$1
      }));
    };
    var RefIcon$3 = /* @__PURE__ */ reactExports.forwardRef(MenuOutlined);
    var StarFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z" } }] }, "name": "star", "theme": "filled" };
    var StarFilled = function StarFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: StarFilled$1
      }));
    };
    var RefIcon$2 = /* @__PURE__ */ reactExports.forwardRef(StarFilled);
    var StarOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3zM664.8 561.6l36.1 210.3L512 672.7 323.1 772l36.1-210.3-152.8-149L417.6 382 512 190.7 606.4 382l211.2 30.7-152.8 148.9z" } }] }, "name": "star", "theme": "outlined" };
    var StarOutlined = function StarOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(Icon$3, _extends$2({}, props, {
        ref,
        icon: StarOutlined$1
      }));
    };
    var RefIcon$1 = /* @__PURE__ */ reactExports.forwardRef(StarOutlined);
    function Star(props, ref) {
      var disabled = props.disabled, prefixCls = props.prefixCls, character2 = props.character, characterRender = props.characterRender, index2 = props.index, count = props.count, value = props.value, allowHalf = props.allowHalf, focused = props.focused, onHover = props.onHover, onClick = props.onClick;
      var onInternalHover = function onInternalHover2(e2) {
        onHover(e2, index2);
      };
      var onInternalClick = function onInternalClick2(e2) {
        onClick(e2, index2);
      };
      var onInternalKeyDown = function onInternalKeyDown2(e2) {
        if (e2.keyCode === KeyCode.ENTER) {
          onClick(e2, index2);
        }
      };
      var starValue = index2 + 1;
      var classNameList = /* @__PURE__ */ new Set([prefixCls]);
      if (value === 0 && index2 === 0 && focused) {
        classNameList.add("".concat(prefixCls, "-focused"));
      } else if (allowHalf && value + 0.5 >= starValue && value < starValue) {
        classNameList.add("".concat(prefixCls, "-half"));
        classNameList.add("".concat(prefixCls, "-active"));
        if (focused) {
          classNameList.add("".concat(prefixCls, "-focused"));
        }
      } else {
        if (starValue <= value) {
          classNameList.add("".concat(prefixCls, "-full"));
        } else {
          classNameList.add("".concat(prefixCls, "-zero"));
        }
        if (starValue === value && focused) {
          classNameList.add("".concat(prefixCls, "-focused"));
        }
      }
      var characterNode = typeof character2 === "function" ? character2(props) : character2;
      var start = /* @__PURE__ */ i.createElement("li", {
        className: classNames(Array.from(classNameList)),
        ref
      }, /* @__PURE__ */ i.createElement("div", {
        onClick: disabled ? null : onInternalClick,
        onKeyDown: disabled ? null : onInternalKeyDown,
        onMouseMove: disabled ? null : onInternalHover,
        role: "radio",
        "aria-checked": value > index2 ? "true" : "false",
        "aria-posinset": index2 + 1,
        "aria-setsize": count,
        tabIndex: disabled ? -1 : 0
      }, /* @__PURE__ */ i.createElement("div", {
        className: "".concat(prefixCls, "-first")
      }, characterNode), /* @__PURE__ */ i.createElement("div", {
        className: "".concat(prefixCls, "-second")
      }, characterNode)));
      if (characterRender) {
        start = characterRender(start, props);
      }
      return start;
    }
    const Star$1 = /* @__PURE__ */ i.forwardRef(Star);
    function useRefs() {
      var nodeRef = reactExports.useRef({});
      function getRef(index2) {
        return nodeRef.current[index2];
      }
      function setRef(index2) {
        return function(node2) {
          nodeRef.current[index2] = node2;
        };
      }
      return [getRef, setRef];
    }
    function getScroll(w2) {
      var ret = w2.pageXOffset;
      var method2 = "scrollLeft";
      if (typeof ret !== "number") {
        var d2 = w2.document;
        ret = d2.documentElement[method2];
        if (typeof ret !== "number") {
          ret = d2.body[method2];
        }
      }
      return ret;
    }
    function getClientPosition(elem) {
      var x2;
      var y2;
      var doc = elem.ownerDocument;
      var body = doc.body;
      var docElem = doc && doc.documentElement;
      var box2 = elem.getBoundingClientRect();
      x2 = box2.left;
      y2 = box2.top;
      x2 -= docElem.clientLeft || body.clientLeft || 0;
      y2 -= docElem.clientTop || body.clientTop || 0;
      return {
        left: x2,
        top: y2
      };
    }
    function getOffsetLeft(el) {
      var pos = getClientPosition(el);
      var doc = el.ownerDocument;
      var w2 = doc.defaultView || doc.parentWindow;
      pos.left += getScroll(w2);
      return pos.left;
    }
    var _excluded$3 = ["prefixCls", "className", "defaultValue", "value", "count", "allowHalf", "allowClear", "keyboard", "character", "characterRender", "disabled", "direction", "tabIndex", "autoFocus", "onHoverChange", "onChange", "onFocus", "onBlur", "onKeyDown", "onMouseLeave"];
    function Rate$2(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-rate" : _props$prefixCls, className = props.className, defaultValue = props.defaultValue, propValue = props.value, _props$count = props.count, count = _props$count === void 0 ? 5 : _props$count, _props$allowHalf = props.allowHalf, allowHalf = _props$allowHalf === void 0 ? false : _props$allowHalf, _props$allowClear = props.allowClear, allowClear = _props$allowClear === void 0 ? true : _props$allowClear, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$character = props.character, character2 = _props$character === void 0 ? "" : _props$character, characterRender = props.characterRender, disabled = props.disabled, _props$direction = props.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, autoFocus = props.autoFocus, onHoverChange = props.onHoverChange, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onKeyDown = props.onKeyDown, onMouseLeave = props.onMouseLeave, restProps = _objectWithoutProperties(props, _excluded$3);
      var _useRefs = useRefs(), _useRefs2 = _slicedToArray(_useRefs, 2), getStarRef = _useRefs2[0], setStarRef = _useRefs2[1];
      var rateRef = i.useRef(null);
      var triggerFocus2 = function triggerFocus3() {
        if (!disabled) {
          var _rateRef$current;
          (_rateRef$current = rateRef.current) === null || _rateRef$current === void 0 || _rateRef$current.focus();
        }
      };
      i.useImperativeHandle(ref, function() {
        return {
          focus: triggerFocus2,
          blur: function blur() {
            if (!disabled) {
              var _rateRef$current2;
              (_rateRef$current2 = rateRef.current) === null || _rateRef$current2 === void 0 || _rateRef$current2.blur();
            }
          }
        };
      });
      var _useMergedState = useMergedState(defaultValue || 0, {
        value: propValue
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
      var _useMergedState3 = useMergedState(null), _useMergedState4 = _slicedToArray(_useMergedState3, 2), cleanedValue = _useMergedState4[0], setCleanedValue = _useMergedState4[1];
      var getStarValue = function getStarValue2(index2, x2) {
        var reverse = direction === "rtl";
        var starValue = index2 + 1;
        if (allowHalf) {
          var starEle = getStarRef(index2);
          var leftDis = getOffsetLeft(starEle);
          var width = starEle.clientWidth;
          if (reverse && x2 - leftDis > width / 2) {
            starValue -= 0.5;
          } else if (!reverse && x2 - leftDis < width / 2) {
            starValue -= 0.5;
          }
        }
        return starValue;
      };
      var changeValue = function changeValue2(nextValue) {
        setValue(nextValue);
        onChange === null || onChange === void 0 || onChange(nextValue);
      };
      var _React$useState = i.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
      var onInternalFocus = function onInternalFocus2() {
        setFocused(true);
        onFocus === null || onFocus === void 0 || onFocus();
      };
      var onInternalBlur = function onInternalBlur2() {
        setFocused(false);
        onBlur === null || onBlur === void 0 || onBlur();
      };
      var _React$useState3 = i.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), hoverValue = _React$useState4[0], setHoverValue = _React$useState4[1];
      var onHover = function onHover2(event, index2) {
        var nextHoverValue = getStarValue(index2, event.pageX);
        if (nextHoverValue !== cleanedValue) {
          setHoverValue(nextHoverValue);
          setCleanedValue(null);
        }
        onHoverChange === null || onHoverChange === void 0 || onHoverChange(nextHoverValue);
      };
      var onMouseLeaveCallback = function onMouseLeaveCallback2(event) {
        if (!disabled) {
          setHoverValue(null);
          setCleanedValue(null);
          onHoverChange === null || onHoverChange === void 0 || onHoverChange(void 0);
        }
        if (event) {
          onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave(event);
        }
      };
      var onClick = function onClick2(event, index2) {
        var newValue = getStarValue(index2, event.pageX);
        var isReset = false;
        if (allowClear) {
          isReset = newValue === value;
        }
        onMouseLeaveCallback();
        changeValue(isReset ? 0 : newValue);
        setCleanedValue(isReset ? newValue : null);
      };
      var onInternalKeyDown = function onInternalKeyDown2(event) {
        var keyCode = event.keyCode;
        var reverse = direction === "rtl";
        var step = allowHalf ? 0.5 : 1;
        if (keyboard) {
          if (keyCode === KeyCode.RIGHT && value < count && !reverse) {
            changeValue(value + step);
            event.preventDefault();
          } else if (keyCode === KeyCode.LEFT && value > 0 && !reverse) {
            changeValue(value - step);
            event.preventDefault();
          } else if (keyCode === KeyCode.RIGHT && value > 0 && reverse) {
            changeValue(value - step);
            event.preventDefault();
          } else if (keyCode === KeyCode.LEFT && value < count && reverse) {
            changeValue(value + step);
            event.preventDefault();
          }
        }
        onKeyDown === null || onKeyDown === void 0 || onKeyDown(event);
      };
      i.useEffect(function() {
        if (autoFocus && !disabled) {
          triggerFocus2();
        }
      }, []);
      var starNodes = new Array(count).fill(0).map(function(item, index2) {
        return /* @__PURE__ */ i.createElement(Star$1, {
          ref: setStarRef(index2),
          index: index2,
          count,
          disabled,
          prefixCls: "".concat(prefixCls, "-star"),
          allowHalf,
          value: hoverValue === null ? value : hoverValue,
          onClick,
          onHover,
          key: item || index2,
          character: character2,
          characterRender,
          focused
        });
      });
      var classString = classNames(prefixCls, className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-disabled"), disabled), "".concat(prefixCls, "-rtl"), direction === "rtl"));
      return /* @__PURE__ */ i.createElement("ul", _extends$2({
        className: classString,
        onMouseLeave: onMouseLeaveCallback,
        tabIndex: disabled ? -1 : tabIndex,
        onFocus: disabled ? null : onInternalFocus,
        onBlur: disabled ? null : onInternalBlur,
        onKeyDown: disabled ? null : onInternalKeyDown,
        ref: rateRef
      }, pickAttrs(restProps, {
        aria: true,
        data: true,
        attr: true
      })), starNodes);
    }
    const Rate$3 = /* @__PURE__ */ i.forwardRef(Rate$2);
    const genRateStarStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-star`]: {
          position: "relative",
          display: "inline-block",
          color: "inherit",
          cursor: "pointer",
          "&:not(:last-child)": {
            marginInlineEnd: token2.marginXS
          },
          "> div": {
            transition: `all ${token2.motionDurationMid}, outline 0s`,
            "&:hover": {
              transform: token2.starHoverScale
            },
            "&:focus": {
              outline: 0
            },
            "&:focus-visible": {
              outline: `${unit$1(token2.lineWidth)} dashed ${token2.starColor}`,
              transform: token2.starHoverScale
            }
          },
          "&-first, &-second": {
            color: token2.starBg,
            transition: `all ${token2.motionDurationMid}`,
            userSelect: "none"
          },
          "&-first": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: "50%",
            height: "100%",
            overflow: "hidden",
            opacity: 0
          },
          [`&-half ${componentCls}-star-first, &-half ${componentCls}-star-second`]: {
            opacity: 1
          },
          [`&-half ${componentCls}-star-first, &-full ${componentCls}-star-second`]: {
            color: "inherit"
          }
        }
      };
    };
    const genRateRtlStyle = (token2) => ({
      [`&-rtl${token2.componentCls}`]: {
        direction: "rtl"
      }
    });
    const genRateStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
          display: "inline-block",
          margin: 0,
          padding: 0,
          color: token2.starColor,
          fontSize: token2.starSize,
          lineHeight: 1,
          listStyle: "none",
          outline: "none",
          // disable styles
          [`&-disabled${componentCls} ${componentCls}-star`]: {
            cursor: "default",
            "> div:hover": {
              transform: "scale(1)"
            }
          }
        }), genRateStarStyle(token2)), genRateRtlStyle(token2))
      };
    };
    const prepareComponentToken$4 = (token2) => ({
      starColor: token2.yellow6,
      starSize: token2.controlHeightLG * 0.5,
      starHoverScale: "scale(1.1)",
      starBg: token2.colorFillContent
    });
    const useStyle$4 = genStyleHooks("Rate", (token2) => {
      const rateToken = merge(token2, {});
      return [genRateStyle(rateToken)];
    }, prepareComponentToken$4);
    var __rest$a = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const Rate$1 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls,
        className,
        rootClassName,
        style: style2,
        tooltips,
        character: character2 = /* @__PURE__ */ reactExports.createElement(RefIcon$2, null),
        disabled: customDisabled
      } = props, rest = __rest$a(props, ["prefixCls", "className", "rootClassName", "style", "tooltips", "character", "disabled"]);
      const characterRender = (node2, _ref) => {
        let {
          index: index2
        } = _ref;
        if (!tooltips) {
          return node2;
        }
        return /* @__PURE__ */ reactExports.createElement(Tooltip, {
          title: tooltips[index2]
        }, node2);
      };
      const {
        getPrefixCls,
        direction,
        rate
      } = reactExports.useContext(ConfigContext);
      const ratePrefixCls = getPrefixCls("rate", prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$4(ratePrefixCls);
      const mergedStyle = Object.assign(Object.assign({}, rate === null || rate === void 0 ? void 0 : rate.style), style2);
      const disabled = reactExports.useContext(DisabledContext);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(Rate$3, Object.assign({
        ref,
        character: character2,
        characterRender,
        disabled: mergedDisabled
      }, rest, {
        className: classNames(className, rootClassName, hashId, cssVarCls, rate === null || rate === void 0 ? void 0 : rate.className),
        style: mergedStyle,
        prefixCls: ratePrefixCls,
        direction
      })));
    });
    var _excluded$2 = ["prefixCls", "className", "checked", "defaultChecked", "disabled", "loadingIcon", "checkedChildren", "unCheckedChildren", "onClick", "onChange", "onKeyDown"];
    var Switch$2 = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref) {
      var _classNames;
      var _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-switch" : _ref$prefixCls, className = _ref.className, checked = _ref.checked, defaultChecked = _ref.defaultChecked, disabled = _ref.disabled, loadingIcon = _ref.loadingIcon, checkedChildren = _ref.checkedChildren, unCheckedChildren = _ref.unCheckedChildren, onClick = _ref.onClick, onChange = _ref.onChange, onKeyDown = _ref.onKeyDown, restProps = _objectWithoutProperties(_ref, _excluded$2);
      var _useMergedState = useMergedState(false, {
        value: checked,
        defaultValue: defaultChecked
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerChecked = _useMergedState2[0], setInnerChecked = _useMergedState2[1];
      function triggerChange(newChecked, event) {
        var mergedChecked = innerChecked;
        if (!disabled) {
          mergedChecked = newChecked;
          setInnerChecked(mergedChecked);
          onChange === null || onChange === void 0 ? void 0 : onChange(mergedChecked, event);
        }
        return mergedChecked;
      }
      function onInternalKeyDown(e2) {
        if (e2.which === KeyCode.LEFT) {
          triggerChange(false, e2);
        } else if (e2.which === KeyCode.RIGHT) {
          triggerChange(true, e2);
        }
        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e2);
      }
      function onInternalClick(e2) {
        var ret = triggerChange(!innerChecked, e2);
        onClick === null || onClick === void 0 ? void 0 : onClick(ret, e2);
      }
      var switchClassName = classNames(prefixCls, className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-checked"), innerChecked), _defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
      return /* @__PURE__ */ reactExports.createElement("button", _extends$2({}, restProps, {
        type: "button",
        role: "switch",
        "aria-checked": innerChecked,
        disabled,
        className: switchClassName,
        ref,
        onKeyDown: onInternalKeyDown,
        onClick: onInternalClick
      }), loadingIcon, /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-inner")
      }, /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-inner-checked")
      }, checkedChildren), /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-inner-unchecked")
      }, unCheckedChildren)));
    });
    Switch$2.displayName = "Switch";
    const genSwitchSmallStyle = (token2) => {
      const {
        componentCls,
        trackHeightSM,
        trackPadding,
        trackMinWidthSM,
        innerMinMarginSM,
        innerMaxMarginSM,
        handleSizeSM,
        calc
      } = token2;
      const switchInnerCls = `${componentCls}-inner`;
      const trackPaddingCalc = unit$1(calc(handleSizeSM).add(calc(trackPadding).mul(2)).equal());
      const innerMaxMarginCalc = unit$1(calc(innerMaxMarginSM).mul(2).equal());
      return {
        [componentCls]: {
          [`&${componentCls}-small`]: {
            minWidth: trackMinWidthSM,
            height: trackHeightSM,
            lineHeight: unit$1(trackHeightSM),
            [`${componentCls}-inner`]: {
              paddingInlineStart: innerMaxMarginSM,
              paddingInlineEnd: innerMinMarginSM,
              [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
                minHeight: trackHeightSM
              },
              [`${switchInnerCls}-checked`]: {
                marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
                marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
              },
              [`${switchInnerCls}-unchecked`]: {
                marginTop: calc(trackHeightSM).mul(-1).equal(),
                marginInlineStart: 0,
                marginInlineEnd: 0
              }
            },
            [`${componentCls}-handle`]: {
              width: handleSizeSM,
              height: handleSizeSM
            },
            [`${componentCls}-loading-icon`]: {
              top: calc(calc(handleSizeSM).sub(token2.switchLoadingIconSize)).div(2).equal(),
              fontSize: token2.switchLoadingIconSize
            },
            [`&${componentCls}-checked`]: {
              [`${componentCls}-inner`]: {
                paddingInlineStart: innerMinMarginSM,
                paddingInlineEnd: innerMaxMarginSM,
                [`${switchInnerCls}-checked`]: {
                  marginInlineStart: 0,
                  marginInlineEnd: 0
                },
                [`${switchInnerCls}-unchecked`]: {
                  marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
                  marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
                }
              },
              [`${componentCls}-handle`]: {
                insetInlineStart: `calc(100% - ${unit$1(calc(handleSizeSM).add(trackPadding).equal())})`
              }
            },
            [`&:not(${componentCls}-disabled):active`]: {
              [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
                [`${switchInnerCls}-unchecked`]: {
                  marginInlineStart: calc(token2.marginXXS).div(2).equal(),
                  marginInlineEnd: calc(token2.marginXXS).mul(-1).div(2).equal()
                }
              },
              [`&${componentCls}-checked ${switchInnerCls}`]: {
                [`${switchInnerCls}-checked`]: {
                  marginInlineStart: calc(token2.marginXXS).mul(-1).div(2).equal(),
                  marginInlineEnd: calc(token2.marginXXS).div(2).equal()
                }
              }
            }
          }
        }
      };
    };
    const genSwitchLoadingStyle = (token2) => {
      const {
        componentCls,
        handleSize,
        calc
      } = token2;
      return {
        [componentCls]: {
          [`${componentCls}-loading-icon${token2.iconCls}`]: {
            position: "relative",
            top: calc(calc(handleSize).sub(token2.fontSize)).div(2).equal(),
            color: token2.switchLoadingIconColor,
            verticalAlign: "top"
          },
          [`&${componentCls}-checked ${componentCls}-loading-icon`]: {
            color: token2.switchColor
          }
        }
      };
    };
    const genSwitchHandleStyle = (token2) => {
      const {
        componentCls,
        trackPadding,
        handleBg,
        handleShadow,
        handleSize,
        calc
      } = token2;
      const switchHandleCls = `${componentCls}-handle`;
      return {
        [componentCls]: {
          [switchHandleCls]: {
            position: "absolute",
            top: trackPadding,
            insetInlineStart: trackPadding,
            width: handleSize,
            height: handleSize,
            transition: `all ${token2.switchDuration} ease-in-out`,
            "&::before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: 0,
              insetInlineStart: 0,
              backgroundColor: handleBg,
              borderRadius: calc(handleSize).div(2).equal(),
              boxShadow: handleShadow,
              transition: `all ${token2.switchDuration} ease-in-out`,
              content: '""'
            }
          },
          [`&${componentCls}-checked ${switchHandleCls}`]: {
            insetInlineStart: `calc(100% - ${unit$1(calc(handleSize).add(trackPadding).equal())})`
          },
          [`&:not(${componentCls}-disabled):active`]: {
            [`${switchHandleCls}::before`]: {
              insetInlineEnd: token2.switchHandleActiveInset,
              insetInlineStart: 0
            },
            [`&${componentCls}-checked ${switchHandleCls}::before`]: {
              insetInlineEnd: 0,
              insetInlineStart: token2.switchHandleActiveInset
            }
          }
        }
      };
    };
    const genSwitchInnerStyle = (token2) => {
      const {
        componentCls,
        trackHeight,
        trackPadding,
        innerMinMargin,
        innerMaxMargin,
        handleSize,
        calc
      } = token2;
      const switchInnerCls = `${componentCls}-inner`;
      const trackPaddingCalc = unit$1(calc(handleSize).add(calc(trackPadding).mul(2)).equal());
      const innerMaxMarginCalc = unit$1(calc(innerMaxMargin).mul(2).equal());
      return {
        [componentCls]: {
          [switchInnerCls]: {
            display: "block",
            overflow: "hidden",
            borderRadius: 100,
            height: "100%",
            paddingInlineStart: innerMaxMargin,
            paddingInlineEnd: innerMinMargin,
            transition: `padding-inline-start ${token2.switchDuration} ease-in-out, padding-inline-end ${token2.switchDuration} ease-in-out`,
            [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
              display: "block",
              color: token2.colorTextLightSolid,
              fontSize: token2.fontSizeSM,
              transition: `margin-inline-start ${token2.switchDuration} ease-in-out, margin-inline-end ${token2.switchDuration} ease-in-out`,
              pointerEvents: "none",
              minHeight: trackHeight
            },
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
              marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
            },
            [`${switchInnerCls}-unchecked`]: {
              marginTop: calc(trackHeight).mul(-1).equal(),
              marginInlineStart: 0,
              marginInlineEnd: 0
            }
          },
          [`&${componentCls}-checked ${switchInnerCls}`]: {
            paddingInlineStart: innerMinMargin,
            paddingInlineEnd: innerMaxMargin,
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: 0,
              marginInlineEnd: 0
            },
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
              marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
            }
          },
          [`&:not(${componentCls}-disabled):active`]: {
            [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
              [`${switchInnerCls}-unchecked`]: {
                marginInlineStart: calc(trackPadding).mul(2).equal(),
                marginInlineEnd: calc(trackPadding).mul(-1).mul(2).equal()
              }
            },
            [`&${componentCls}-checked ${switchInnerCls}`]: {
              [`${switchInnerCls}-checked`]: {
                marginInlineStart: calc(trackPadding).mul(-1).mul(2).equal(),
                marginInlineEnd: calc(trackPadding).mul(2).equal()
              }
            }
          }
        }
      };
    };
    const genSwitchStyle = (token2) => {
      const {
        componentCls,
        trackHeight,
        trackMinWidth
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "relative",
          display: "inline-block",
          boxSizing: "border-box",
          minWidth: trackMinWidth,
          height: trackHeight,
          lineHeight: unit$1(trackHeight),
          verticalAlign: "middle",
          background: token2.colorTextQuaternary,
          border: "0",
          borderRadius: 100,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid}`,
          userSelect: "none",
          [`&:hover:not(${componentCls}-disabled)`]: {
            background: token2.colorTextTertiary
          }
        }), genFocusStyle(token2)), {
          [`&${componentCls}-checked`]: {
            background: token2.switchColor,
            [`&:hover:not(${componentCls}-disabled)`]: {
              background: token2.colorPrimaryHover
            }
          },
          [`&${componentCls}-loading, &${componentCls}-disabled`]: {
            cursor: "not-allowed",
            opacity: token2.switchDisabledOpacity,
            "*": {
              boxShadow: "none",
              cursor: "not-allowed"
            }
          },
          // rtl style
          [`&${componentCls}-rtl`]: {
            direction: "rtl"
          }
        })
      };
    };
    const prepareComponentToken$3 = (token2) => {
      const {
        fontSize,
        lineHeight,
        controlHeight,
        colorWhite
      } = token2;
      const height = fontSize * lineHeight;
      const heightSM = controlHeight / 2;
      const padding = 2;
      const handleSize = height - padding * 2;
      const handleSizeSM = heightSM - padding * 2;
      return {
        trackHeight: height,
        trackHeightSM: heightSM,
        trackMinWidth: handleSize * 2 + padding * 4,
        trackMinWidthSM: handleSizeSM * 2 + padding * 2,
        trackPadding: padding,
        // Fixed value
        handleBg: colorWhite,
        handleSize,
        handleSizeSM,
        handleShadow: `0 2px 4px 0 ${new FastColor("#00230b").setA(0.2).toRgbString()}`,
        innerMinMargin: handleSize / 2,
        innerMaxMargin: handleSize + padding + padding * 2,
        innerMinMarginSM: handleSizeSM / 2,
        innerMaxMarginSM: handleSizeSM + padding + padding * 2
      };
    };
    const useStyle$3 = genStyleHooks("Switch", (token2) => {
      const switchToken = merge(token2, {
        switchDuration: token2.motionDurationMid,
        switchColor: token2.colorPrimary,
        switchDisabledOpacity: token2.opacityLoading,
        switchLoadingIconSize: token2.calc(token2.fontSizeIcon).mul(0.75).equal(),
        switchLoadingIconColor: `rgba(0, 0, 0, ${token2.opacityLoading})`,
        switchHandleActiveInset: "-30%"
      });
      return [
        genSwitchStyle(switchToken),
        // inner style
        genSwitchInnerStyle(switchToken),
        // handle style
        genSwitchHandleStyle(switchToken),
        // loading style
        genSwitchLoadingStyle(switchToken),
        // small style
        genSwitchSmallStyle(switchToken)
      ];
    }, prepareComponentToken$3);
    var __rest$9 = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const InternalSwitch = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        size: customizeSize,
        disabled: customDisabled,
        loading,
        className,
        rootClassName,
        style: style2,
        checked: checkedProp,
        value,
        defaultChecked: defaultCheckedProp,
        defaultValue,
        onChange
      } = props, restProps = __rest$9(props, ["prefixCls", "size", "disabled", "loading", "className", "rootClassName", "style", "checked", "value", "defaultChecked", "defaultValue", "onChange"]);
      const [checked, setChecked] = useMergedState(false, {
        value: checkedProp !== null && checkedProp !== void 0 ? checkedProp : value,
        defaultValue: defaultCheckedProp !== null && defaultCheckedProp !== void 0 ? defaultCheckedProp : defaultValue
      });
      const {
        getPrefixCls,
        direction,
        switch: SWITCH
      } = reactExports.useContext(ConfigContext);
      const disabled = reactExports.useContext(DisabledContext);
      const mergedDisabled = (customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled) || loading;
      const prefixCls = getPrefixCls("switch", customizePrefixCls);
      const loadingIcon = /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-handle`
      }, loading && /* @__PURE__ */ reactExports.createElement(RefIcon$x, {
        className: `${prefixCls}-loading-icon`
      }));
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$3(prefixCls);
      const mergedSize = useSize(customizeSize);
      const classes = classNames(SWITCH === null || SWITCH === void 0 ? void 0 : SWITCH.className, {
        [`${prefixCls}-small`]: mergedSize === "small",
        [`${prefixCls}-loading`]: loading,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId, cssVarCls);
      const mergedStyle = Object.assign(Object.assign({}, SWITCH === null || SWITCH === void 0 ? void 0 : SWITCH.style), style2);
      const changeHandler = function() {
        setChecked(arguments.length <= 0 ? void 0 : arguments[0]);
        onChange === null || onChange === void 0 ? void 0 : onChange.apply(void 0, arguments);
      };
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(Wave, {
        component: "Switch"
      }, /* @__PURE__ */ reactExports.createElement(Switch$2, Object.assign({}, restProps, {
        checked,
        onChange: changeHandler,
        prefixCls,
        className: classes,
        style: mergedStyle,
        disabled: mergedDisabled,
        ref,
        loadingIcon
      }))));
    });
    const Switch$1 = InternalSwitch;
    Switch$1.__ANT_SWITCH = true;
    const genBaseStyle = (token2) => {
      const {
        paddingXXS,
        lineWidth,
        tagPaddingHorizontal,
        componentCls,
        calc
      } = token2;
      const paddingInline = calc(tagPaddingHorizontal).sub(lineWidth).equal();
      const iconMarginInline = calc(paddingXXS).sub(lineWidth).equal();
      return {
        // Result
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          display: "inline-block",
          height: "auto",
          // https://github.com/ant-design/ant-design/pull/47504
          marginInlineEnd: token2.marginXS,
          paddingInline,
          fontSize: token2.tagFontSize,
          lineHeight: token2.tagLineHeight,
          whiteSpace: "nowrap",
          background: token2.defaultBg,
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusSM,
          opacity: 1,
          transition: `all ${token2.motionDurationMid}`,
          textAlign: "start",
          position: "relative",
          // RTL
          [`&${componentCls}-rtl`]: {
            direction: "rtl"
          },
          "&, a, a:hover": {
            color: token2.defaultColor
          },
          [`${componentCls}-close-icon`]: {
            marginInlineStart: iconMarginInline,
            fontSize: token2.tagIconSize,
            color: token2.colorTextDescription,
            cursor: "pointer",
            transition: `all ${token2.motionDurationMid}`,
            "&:hover": {
              color: token2.colorTextHeading
            }
          },
          [`&${componentCls}-has-color`]: {
            borderColor: "transparent",
            [`&, a, a:hover, ${token2.iconCls}-close, ${token2.iconCls}-close:hover`]: {
              color: token2.colorTextLightSolid
            }
          },
          "&-checkable": {
            backgroundColor: "transparent",
            borderColor: "transparent",
            cursor: "pointer",
            [`&:not(${componentCls}-checkable-checked):hover`]: {
              color: token2.colorPrimary,
              backgroundColor: token2.colorFillSecondary
            },
            "&:active, &-checked": {
              color: token2.colorTextLightSolid
            },
            "&-checked": {
              backgroundColor: token2.colorPrimary,
              "&:hover": {
                backgroundColor: token2.colorPrimaryHover
              }
            },
            "&:active": {
              backgroundColor: token2.colorPrimaryActive
            }
          },
          "&-hidden": {
            display: "none"
          },
          // To ensure that a space will be placed between character and `Icon`.
          [`> ${token2.iconCls} + span, > span + ${token2.iconCls}`]: {
            marginInlineStart: paddingInline
          }
        }),
        [`${componentCls}-borderless`]: {
          borderColor: "transparent",
          background: token2.tagBorderlessBg
        }
      };
    };
    const prepareToken = (token2) => {
      const {
        lineWidth,
        fontSizeIcon,
        calc
      } = token2;
      const tagFontSize = token2.fontSizeSM;
      const tagToken = merge(token2, {
        tagFontSize,
        tagLineHeight: unit$1(calc(token2.lineHeightSM).mul(tagFontSize).equal()),
        tagIconSize: calc(fontSizeIcon).sub(calc(lineWidth).mul(2)).equal(),
        // Tag icon is much smaller
        tagPaddingHorizontal: 8,
        // Fixed padding.
        tagBorderlessBg: token2.defaultBg
      });
      return tagToken;
    };
    const prepareComponentToken$2 = (token2) => ({
      defaultBg: new FastColor(token2.colorFillQuaternary).onBackground(token2.colorBgContainer).toHexString(),
      defaultColor: token2.colorText
    });
    const useStyle$2 = genStyleHooks("Tag", (token2) => {
      const tagToken = prepareToken(token2);
      return genBaseStyle(tagToken);
    }, prepareComponentToken$2);
    var __rest$8 = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const CheckableTag = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        style: style2,
        className,
        checked,
        onChange,
        onClick
      } = props, restProps = __rest$8(props, ["prefixCls", "style", "className", "checked", "onChange", "onClick"]);
      const {
        getPrefixCls,
        tag
      } = reactExports.useContext(ConfigContext);
      const handleClick = (e2) => {
        onChange === null || onChange === void 0 ? void 0 : onChange(!checked);
        onClick === null || onClick === void 0 ? void 0 : onClick(e2);
      };
      const prefixCls = getPrefixCls("tag", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$2(prefixCls);
      const cls = classNames(prefixCls, `${prefixCls}-checkable`, {
        [`${prefixCls}-checkable-checked`]: checked
      }, tag === null || tag === void 0 ? void 0 : tag.className, className, hashId, cssVarCls);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("span", Object.assign({}, restProps, {
        ref,
        style: Object.assign(Object.assign({}, style2), tag === null || tag === void 0 ? void 0 : tag.style),
        className: cls,
        onClick: handleClick
      })));
    });
    const genPresetStyle = (token2) => genPresetColor(token2, (colorKey, _ref) => {
      let {
        textColor,
        lightBorderColor,
        lightColor,
        darkColor
      } = _ref;
      return {
        [`${token2.componentCls}${token2.componentCls}-${colorKey}`]: {
          color: textColor,
          background: lightColor,
          borderColor: lightBorderColor,
          // Inverse color
          "&-inverse": {
            color: token2.colorTextLightSolid,
            background: darkColor,
            borderColor: darkColor
          },
          [`&${token2.componentCls}-borderless`]: {
            borderColor: "transparent"
          }
        }
      };
    });
    const PresetCmp = genSubStyleComponent(["Tag", "preset"], (token2) => {
      const tagToken = prepareToken(token2);
      return genPresetStyle(tagToken);
    }, prepareComponentToken$2);
    function capitalize(str) {
      if (typeof str !== "string") {
        return str;
      }
      const ret = str.charAt(0).toUpperCase() + str.slice(1);
      return ret;
    }
    const genTagStatusStyle = (token2, status, cssVariableType) => {
      const capitalizedCssVariableType = capitalize(cssVariableType);
      return {
        [`${token2.componentCls}${token2.componentCls}-${status}`]: {
          color: token2[`color${cssVariableType}`],
          background: token2[`color${capitalizedCssVariableType}Bg`],
          borderColor: token2[`color${capitalizedCssVariableType}Border`],
          [`&${token2.componentCls}-borderless`]: {
            borderColor: "transparent"
          }
        }
      };
    };
    const StatusCmp = genSubStyleComponent(["Tag", "status"], (token2) => {
      const tagToken = prepareToken(token2);
      return [genTagStatusStyle(tagToken, "success", "Success"), genTagStatusStyle(tagToken, "processing", "Info"), genTagStatusStyle(tagToken, "error", "Error"), genTagStatusStyle(tagToken, "warning", "Warning")];
    }, prepareComponentToken$2);
    var __rest$7 = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const InternalTag = /* @__PURE__ */ reactExports.forwardRef((tagProps, ref) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        style: style2,
        children,
        icon,
        color,
        onClose,
        bordered = true,
        visible: deprecatedVisible
      } = tagProps, props = __rest$7(tagProps, ["prefixCls", "className", "rootClassName", "style", "children", "icon", "color", "onClose", "bordered", "visible"]);
      const {
        getPrefixCls,
        direction,
        tag: tagContext
      } = reactExports.useContext(ConfigContext);
      const [visible, setVisible] = reactExports.useState(true);
      const domProps = omit(props, ["closeIcon", "closable"]);
      reactExports.useEffect(() => {
        if (deprecatedVisible !== void 0) {
          setVisible(deprecatedVisible);
        }
      }, [deprecatedVisible]);
      const isPreset = isPresetColor(color);
      const isStatus = isPresetStatusColor(color);
      const isInternalColor = isPreset || isStatus;
      const tagStyle = Object.assign(Object.assign({
        backgroundColor: color && !isInternalColor ? color : void 0
      }, tagContext === null || tagContext === void 0 ? void 0 : tagContext.style), style2);
      const prefixCls = getPrefixCls("tag", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$2(prefixCls);
      const tagClassName = classNames(prefixCls, tagContext === null || tagContext === void 0 ? void 0 : tagContext.className, {
        [`${prefixCls}-${color}`]: isInternalColor,
        [`${prefixCls}-has-color`]: color && !isInternalColor,
        [`${prefixCls}-hidden`]: !visible,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-borderless`]: !bordered
      }, className, rootClassName, hashId, cssVarCls);
      const handleCloseClick = (e2) => {
        e2.stopPropagation();
        onClose === null || onClose === void 0 ? void 0 : onClose(e2);
        if (e2.defaultPrevented) {
          return;
        }
        setVisible(false);
      };
      const [, mergedCloseIcon] = useClosable(pickClosable(tagProps), pickClosable(tagContext), {
        closable: false,
        closeIconRender: (iconNode2) => {
          const replacement = /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-close-icon`,
            onClick: handleCloseClick
          }, iconNode2);
          return replaceElement(iconNode2, replacement, (originProps) => ({
            onClick: (e2) => {
              var _a;
              (_a = originProps === null || originProps === void 0 ? void 0 : originProps.onClick) === null || _a === void 0 ? void 0 : _a.call(originProps, e2);
              handleCloseClick(e2);
            },
            className: classNames(originProps === null || originProps === void 0 ? void 0 : originProps.className, `${prefixCls}-close-icon`)
          }));
        }
      });
      const isNeedWave = typeof props.onClick === "function" || children && children.type === "a";
      const iconNode = icon || null;
      const kids = iconNode ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, iconNode, children && /* @__PURE__ */ reactExports.createElement("span", null, children)) : children;
      const tagNode = /* @__PURE__ */ reactExports.createElement("span", Object.assign({}, domProps, {
        ref,
        className: tagClassName,
        style: tagStyle
      }), kids, mergedCloseIcon, isPreset && /* @__PURE__ */ reactExports.createElement(PresetCmp, {
        key: "preset",
        prefixCls
      }), isStatus && /* @__PURE__ */ reactExports.createElement(StatusCmp, {
        key: "status",
        prefixCls
      }));
      return wrapCSSVar(isNeedWave ? /* @__PURE__ */ reactExports.createElement(Wave, {
        component: "Tag"
      }, tagNode) : tagNode);
    });
    const Tag = InternalTag;
    Tag.CheckableTag = CheckableTag;
    var __rest$6 = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const {
      TimePicker: InternalTimePicker,
      RangePicker: InternalRangePicker
    } = DatePicker;
    const RangePicker = /* @__PURE__ */ reactExports.forwardRef((props, ref) => /* @__PURE__ */ reactExports.createElement(InternalRangePicker, Object.assign({}, props, {
      picker: "time",
      mode: void 0,
      ref
    })));
    const TimePicker = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        addon,
        renderExtraFooter,
        variant,
        bordered
      } = _a, restProps = __rest$6(_a, ["addon", "renderExtraFooter", "variant", "bordered"]);
      const [mergedVariant] = useVariant("timePicker", variant, bordered);
      const internalRenderExtraFooter = reactExports.useMemo(() => {
        if (renderExtraFooter) {
          return renderExtraFooter;
        }
        if (addon) {
          return addon;
        }
        return void 0;
      }, [addon, renderExtraFooter]);
      return /* @__PURE__ */ reactExports.createElement(InternalTimePicker, Object.assign({}, restProps, {
        mode: void 0,
        ref,
        renderExtraFooter: internalRenderExtraFooter,
        variant: mergedVariant
      }));
    });
    const PurePanel = genPurePanel(TimePicker, "popupAlign", void 0, "picker");
    TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel;
    TimePicker.RangePicker = RangePicker;
    TimePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel;
    const getTitleStyle = (fontSize, lineHeight, color, token2) => {
      const {
        titleMarginBottom,
        fontWeightStrong
      } = token2;
      return {
        marginBottom: titleMarginBottom,
        color,
        fontWeight: fontWeightStrong,
        fontSize,
        lineHeight
      };
    };
    const getTitleStyles = (token2) => {
      const headings = [1, 2, 3, 4, 5];
      const styles = {};
      headings.forEach((headingLevel) => {
        styles[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(token2[`fontSizeHeading${headingLevel}`], token2[`lineHeightHeading${headingLevel}`], token2.colorTextHeading, token2);
      });
      return styles;
    };
    const getLinkStyles = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        "a&, a": Object.assign(Object.assign({}, operationUnit(token2)), {
          userSelect: "text",
          [`&[disabled], &${componentCls}-disabled`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            "&:active, &:hover": {
              color: token2.colorTextDisabled
            },
            "&:active": {
              pointerEvents: "none"
            }
          }
        })
      };
    };
    const getResetStyles = (token2) => ({
      code: {
        margin: "0 0.2em",
        paddingInline: "0.4em",
        paddingBlock: "0.2em 0.1em",
        fontSize: "85%",
        fontFamily: token2.fontFamilyCode,
        background: "rgba(150, 150, 150, 0.1)",
        border: "1px solid rgba(100, 100, 100, 0.2)",
        borderRadius: 3
      },
      kbd: {
        margin: "0 0.2em",
        paddingInline: "0.4em",
        paddingBlock: "0.15em 0.1em",
        fontSize: "90%",
        fontFamily: token2.fontFamilyCode,
        background: "rgba(150, 150, 150, 0.06)",
        border: "1px solid rgba(100, 100, 100, 0.2)",
        borderBottomWidth: 2,
        borderRadius: 3
      },
      mark: {
        padding: 0,
        // FIXME hardcode in v4
        backgroundColor: gold[2]
      },
      "u, ins": {
        textDecoration: "underline",
        textDecorationSkipInk: "auto"
      },
      "s, del": {
        textDecoration: "line-through"
      },
      strong: {
        fontWeight: 600
      },
      // list
      "ul, ol": {
        marginInline: 0,
        marginBlock: "0 1em",
        padding: 0,
        li: {
          marginInline: "20px 0",
          marginBlock: 0,
          paddingInline: "4px 0",
          paddingBlock: 0
        }
      },
      ul: {
        listStyleType: "circle",
        ul: {
          listStyleType: "disc"
        }
      },
      ol: {
        listStyleType: "decimal"
      },
      // pre & block
      "pre, blockquote": {
        margin: "1em 0"
      },
      pre: {
        padding: "0.4em 0.6em",
        whiteSpace: "pre-wrap",
        wordWrap: "break-word",
        background: "rgba(150, 150, 150, 0.1)",
        border: "1px solid rgba(100, 100, 100, 0.2)",
        borderRadius: 3,
        fontFamily: token2.fontFamilyCode,
        // Compatible for marked
        code: {
          display: "inline",
          margin: 0,
          padding: 0,
          fontSize: "inherit",
          fontFamily: "inherit",
          background: "transparent",
          border: 0
        }
      },
      blockquote: {
        paddingInline: "0.6em 0",
        paddingBlock: 0,
        borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
        opacity: 0.85
      }
    });
    const getEditableStyles = (token2) => {
      const {
        componentCls,
        paddingSM
      } = token2;
      const inputShift = paddingSM;
      return {
        "&-edit-content": {
          position: "relative",
          "div&": {
            insetInlineStart: token2.calc(token2.paddingSM).mul(-1).equal(),
            marginTop: token2.calc(inputShift).mul(-1).equal(),
            marginBottom: `calc(1em - ${unit$1(inputShift)})`
          },
          [`${componentCls}-edit-content-confirm`]: {
            position: "absolute",
            insetInlineEnd: token2.calc(token2.marginXS).add(2).equal(),
            insetBlockEnd: token2.marginXS,
            color: token2.colorTextDescription,
            // default style
            fontWeight: "normal",
            fontSize: token2.fontSize,
            fontStyle: "normal",
            pointerEvents: "none"
          },
          textarea: {
            margin: "0!important",
            // Fix Editable Textarea flash in Firefox
            MozTransition: "none",
            height: "1em"
          }
        }
      };
    };
    const getCopyableStyles = (token2) => ({
      [`${token2.componentCls}-copy-success`]: {
        [`
    &,
    &:hover,
    &:focus`]: {
          color: token2.colorSuccess
        }
      },
      [`${token2.componentCls}-copy-icon-only`]: {
        marginInlineStart: 0
      }
    });
    const getEllipsisStyles = () => ({
      [`
  a&-ellipsis,
  span&-ellipsis
  `]: {
        display: "inline-block",
        maxWidth: "100%"
      },
      "&-ellipsis-single-line": {
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
        // https://blog.csdn.net/iefreer/article/details/50421025
        "a&, span&": {
          verticalAlign: "bottom"
        },
        "> code": {
          paddingBlock: 0,
          maxWidth: "calc(100% - 1.2em)",
          display: "inline-block",
          overflow: "hidden",
          textOverflow: "ellipsis",
          verticalAlign: "bottom",
          // https://github.com/ant-design/ant-design/issues/45953
          boxSizing: "content-box"
        }
      },
      "&-ellipsis-multiple-line": {
        display: "-webkit-box",
        overflow: "hidden",
        WebkitLineClamp: 3,
        WebkitBoxOrient: "vertical"
      }
    });
    const genTypographyStyle = (token2) => {
      const {
        componentCls,
        titleMarginTop
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
          color: token2.colorText,
          wordBreak: "break-word",
          lineHeight: token2.lineHeight,
          [`&${componentCls}-secondary`]: {
            color: token2.colorTextDescription
          },
          [`&${componentCls}-success`]: {
            color: token2.colorSuccessText
          },
          [`&${componentCls}-warning`]: {
            color: token2.colorWarningText
          },
          [`&${componentCls}-danger`]: {
            color: token2.colorErrorText,
            "a&:active, a&:focus": {
              color: token2.colorErrorTextActive
            },
            "a&:hover": {
              color: token2.colorErrorTextHover
            }
          },
          [`&${componentCls}-disabled`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            userSelect: "none"
          },
          [`
        div&,
        p
      `]: {
            marginBottom: "1em"
          }
        }, getTitleStyles(token2)), {
          [`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: {
            marginTop: titleMarginTop
          },
          [`
      div,
      ul,
      li,
      p,
      h1,
      h2,
      h3,
      h4,
      h5`]: {
            [`
        + h1,
        + h2,
        + h3,
        + h4,
        + h5
        `]: {
              marginTop: titleMarginTop
            }
          }
        }), getResetStyles(token2)), getLinkStyles(token2)), {
          // Operation
          [`
        ${componentCls}-expand,
        ${componentCls}-collapse,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: Object.assign(Object.assign({}, operationUnit(token2)), {
            marginInlineStart: token2.marginXXS
          })
        }), getEditableStyles(token2)), getCopyableStyles(token2)), getEllipsisStyles()), {
          "&-rtl": {
            direction: "rtl"
          }
        })
      };
    };
    const prepareComponentToken$1 = () => ({
      titleMarginTop: "1.2em",
      titleMarginBottom: "0.5em"
    });
    const useStyle$1 = genStyleHooks("Typography", (token2) => [genTypographyStyle(token2)], prepareComponentToken$1);
    const Editable = (props) => {
      const {
        prefixCls,
        "aria-label": ariaLabel,
        className,
        style: style2,
        direction,
        maxLength,
        autoSize = true,
        value,
        onSave,
        onCancel,
        onEnd,
        component,
        enterIcon = /* @__PURE__ */ reactExports.createElement(RefIcon$7, null)
      } = props;
      const ref = reactExports.useRef(null);
      const inComposition = reactExports.useRef(false);
      const lastKeyCode = reactExports.useRef(null);
      const [current, setCurrent] = reactExports.useState(value);
      reactExports.useEffect(() => {
        setCurrent(value);
      }, [value]);
      reactExports.useEffect(() => {
        var _a;
        if ((_a = ref.current) === null || _a === void 0 ? void 0 : _a.resizableTextArea) {
          const {
            textArea
          } = ref.current.resizableTextArea;
          textArea.focus();
          const {
            length: length2
          } = textArea.value;
          textArea.setSelectionRange(length2, length2);
        }
      }, []);
      const onChange = (_ref) => {
        let {
          target
        } = _ref;
        setCurrent(target.value.replace(/[\n\r]/g, ""));
      };
      const onCompositionStart = () => {
        inComposition.current = true;
      };
      const onCompositionEnd = () => {
        inComposition.current = false;
      };
      const onKeyDown = (_ref2) => {
        let {
          keyCode
        } = _ref2;
        if (inComposition.current) return;
        lastKeyCode.current = keyCode;
      };
      const confirmChange = () => {
        onSave(current.trim());
      };
      const onKeyUp = (_ref3) => {
        let {
          keyCode,
          ctrlKey,
          altKey,
          metaKey,
          shiftKey
        } = _ref3;
        if (lastKeyCode.current !== keyCode || inComposition.current || ctrlKey || altKey || metaKey || shiftKey) {
          return;
        }
        if (keyCode === KeyCode.ENTER) {
          confirmChange();
          onEnd === null || onEnd === void 0 ? void 0 : onEnd();
        } else if (keyCode === KeyCode.ESC) {
          onCancel();
        }
      };
      const onBlur = () => {
        confirmChange();
      };
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$1(prefixCls);
      const textAreaClassName = classNames(prefixCls, `${prefixCls}-edit-content`, {
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-${component}`]: !!component
      }, className, hashId, cssVarCls);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
        className: textAreaClassName,
        style: style2
      }, /* @__PURE__ */ reactExports.createElement(TextArea, {
        ref,
        maxLength,
        value: current,
        onChange,
        onKeyDown,
        onKeyUp,
        onCompositionStart,
        onCompositionEnd,
        onBlur,
        "aria-label": ariaLabel,
        rows: 1,
        autoSize
      }), enterIcon !== null ? cloneElement(enterIcon, {
        className: `${prefixCls}-edit-content-confirm`
      }) : null));
    };
    var toggleSelection = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i2 = 0; i2 < selection.rangeCount; i2++) {
        ranges.push(selection.getRangeAt(i2));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range2) {
            selection.addRange(range2);
          });
        }
        active && active.focus();
      };
    };
    var deselectCurrent = toggleSelection;
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message2) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
      return message2.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options2) {
      var debug, message2, reselectPrevious, range2, selection, mark, success = false;
      if (!options2) {
        options2 = {};
      }
      debug = options2.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range2 = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options2.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options2.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options2.format, text);
            }
          }
          if (options2.onCopy) {
            e2.preventDefault();
            options2.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range2.selectNodeContents(mark);
        selection.addRange(range2);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options2.format || "text", text);
          options2.onCopy && options2.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message2 = format("message" in options2 ? options2.message : defaultMessage);
          window.prompt(message2, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range2);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    var copyToClipboard = copy;
    const copy$1 = /* @__PURE__ */ getDefaultExportFromCjs(copyToClipboard);
    var __awaiter = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    const useCopyClick = (_ref) => {
      let {
        copyConfig,
        children
      } = _ref;
      const [copied, setCopied] = reactExports.useState(false);
      const [copyLoading, setCopyLoading] = reactExports.useState(false);
      const copyIdRef = reactExports.useRef(null);
      const cleanCopyId = () => {
        if (copyIdRef.current) {
          clearTimeout(copyIdRef.current);
        }
      };
      const copyOptions = {};
      if (copyConfig.format) {
        copyOptions.format = copyConfig.format;
      }
      reactExports.useEffect(() => cleanCopyId, []);
      const onClick = useEvent((e2) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
        e2 === null || e2 === void 0 ? void 0 : e2.stopPropagation();
        setCopyLoading(true);
        try {
          const text = typeof copyConfig.text === "function" ? yield copyConfig.text() : copyConfig.text;
          copy$1(text || toList$1(children, true).join("") || "", copyOptions);
          setCopyLoading(false);
          setCopied(true);
          cleanCopyId();
          copyIdRef.current = setTimeout(() => {
            setCopied(false);
          }, 3e3);
          (_a = copyConfig.onCopy) === null || _a === void 0 ? void 0 : _a.call(copyConfig, e2);
        } catch (error) {
          setCopyLoading(false);
          throw error;
        }
      }));
      return {
        copied,
        copyLoading,
        onClick
      };
    };
    function useMergedConfig(propConfig, templateConfig) {
      return reactExports.useMemo(() => {
        const support = !!propConfig;
        return [support, Object.assign(Object.assign({}, templateConfig), support && typeof propConfig === "object" ? propConfig : null)];
      }, [propConfig]);
    }
    const usePrevious = (value) => {
      const ref = reactExports.useRef(void 0);
      reactExports.useEffect(() => {
        ref.current = value;
      });
      return ref.current;
    };
    const useTooltipProps = (tooltip, editConfigText, children) => reactExports.useMemo(() => {
      if (tooltip === true) {
        return {
          title: editConfigText !== null && editConfigText !== void 0 ? editConfigText : children
        };
      }
      if (/* @__PURE__ */ reactExports.isValidElement(tooltip)) {
        return {
          title: tooltip
        };
      }
      if (typeof tooltip === "object") {
        return Object.assign({
          title: editConfigText !== null && editConfigText !== void 0 ? editConfigText : children
        }, tooltip);
      }
      return {
        title: tooltip
      };
    }, [tooltip, editConfigText, children]);
    var __rest$5 = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const Typography$1 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        component: Component2 = "article",
        className,
        rootClassName,
        setContentRef,
        children,
        direction: typographyDirection,
        style: style2
      } = props, restProps = __rest$5(props, ["prefixCls", "component", "className", "rootClassName", "setContentRef", "children", "direction", "style"]);
      const {
        getPrefixCls,
        direction: contextDirection,
        className: contextClassName,
        style: contextStyle
      } = useComponentConfig("typography");
      const direction = typographyDirection !== null && typographyDirection !== void 0 ? typographyDirection : contextDirection;
      const mergedRef = setContentRef ? composeRef(ref, setContentRef) : ref;
      const prefixCls = getPrefixCls("typography", customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$1(prefixCls);
      const componentClassName = classNames(prefixCls, contextClassName, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId, cssVarCls);
      const mergedStyle = Object.assign(Object.assign({}, contextStyle), style2);
      return wrapCSSVar(
        // @ts-expect-error: Expression produces a union type that is too complex to represent.
        /* @__PURE__ */ reactExports.createElement(Component2, Object.assign({
          className: componentClassName,
          style: mergedStyle,
          ref: mergedRef
        }, restProps), children)
      );
    });
    function toList(val) {
      if (val === false) {
        return [false, false];
      }
      return Array.isArray(val) ? val : [val];
    }
    function getNode(dom, defaultNode, needDom) {
      if (dom === true || dom === void 0) {
        return defaultNode;
      }
      return dom || needDom && defaultNode;
    }
    function isEleEllipsis(ele) {
      const childDiv = document.createElement("em");
      ele.appendChild(childDiv);
      const rect = ele.getBoundingClientRect();
      const childRect = childDiv.getBoundingClientRect();
      ele.removeChild(childDiv);
      return (
        // Horizontal out of range
        rect.left > childRect.left || childRect.right > rect.right || // Vertical out of range
        rect.top > childRect.top || childRect.bottom > rect.bottom
      );
    }
    const isValidText = (val) => ["string", "number"].includes(typeof val);
    const CopyBtn = (_ref) => {
      let {
        prefixCls,
        copied,
        locale: locale2,
        iconOnly,
        tooltips,
        icon,
        tabIndex,
        onCopy,
        loading: btnLoading
      } = _ref;
      const tooltipNodes = toList(tooltips);
      const iconNodes = toList(icon);
      const {
        copied: copiedText,
        copy: copyText
      } = locale2 !== null && locale2 !== void 0 ? locale2 : {};
      const systemStr = copied ? copiedText : copyText;
      const copyTitle = getNode(tooltipNodes[copied ? 1 : 0], systemStr);
      const ariaLabel = typeof copyTitle === "string" ? copyTitle : systemStr;
      return /* @__PURE__ */ reactExports.createElement(Tooltip, {
        title: copyTitle
      }, /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        className: classNames(`${prefixCls}-copy`, {
          [`${prefixCls}-copy-success`]: copied,
          [`${prefixCls}-copy-icon-only`]: iconOnly
        }),
        onClick: onCopy,
        "aria-label": ariaLabel,
        tabIndex
      }, copied ? getNode(iconNodes[1], /* @__PURE__ */ reactExports.createElement(RefIcon$v, null), true) : getNode(iconNodes[0], btnLoading ? /* @__PURE__ */ reactExports.createElement(RefIcon$x, null) : /* @__PURE__ */ reactExports.createElement(RefIcon$a, null), true)));
    };
    const MeasureText = /* @__PURE__ */ reactExports.forwardRef((_ref, ref) => {
      let {
        style: style2,
        children
      } = _ref;
      const spanRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, () => ({
        isExceed: () => {
          const span = spanRef.current;
          return span.scrollHeight > span.clientHeight;
        },
        getHeight: () => spanRef.current.clientHeight
      }));
      return /* @__PURE__ */ reactExports.createElement("span", {
        "aria-hidden": true,
        ref: spanRef,
        style: Object.assign({
          position: "fixed",
          display: "block",
          left: 0,
          top: 0,
          pointerEvents: "none",
          backgroundColor: "rgba(255, 0, 0, 0.65)"
        }, style2)
      }, children);
    });
    const getNodesLen = (nodeList) => nodeList.reduce((totalLen, node2) => totalLen + (isValidText(node2) ? String(node2).length : 1), 0);
    function sliceNodes(nodeList, len) {
      let currLen = 0;
      const currentNodeList = [];
      for (let i2 = 0; i2 < nodeList.length; i2 += 1) {
        if (currLen === len) {
          return currentNodeList;
        }
        const node2 = nodeList[i2];
        const canCut = isValidText(node2);
        const nodeLen = canCut ? String(node2).length : 1;
        const nextLen = currLen + nodeLen;
        if (nextLen > len) {
          const restLen = len - currLen;
          currentNodeList.push(String(node2).slice(0, restLen));
          return currentNodeList;
        }
        currentNodeList.push(node2);
        currLen = nextLen;
      }
      return nodeList;
    }
    const STATUS_MEASURE_NONE = 0;
    const STATUS_MEASURE_PREPARE = 1;
    const STATUS_MEASURE_START = 2;
    const STATUS_MEASURE_NEED_ELLIPSIS = 3;
    const STATUS_MEASURE_NO_NEED_ELLIPSIS = 4;
    const lineClipStyle = {
      display: "-webkit-box",
      overflow: "hidden",
      WebkitBoxOrient: "vertical"
    };
    function EllipsisMeasure(props) {
      const {
        enableMeasure,
        width,
        text,
        children,
        rows,
        expanded,
        miscDeps,
        onEllipsis
      } = props;
      const nodeList = reactExports.useMemo(() => toArray$5(text), [text]);
      const nodeLen = reactExports.useMemo(() => getNodesLen(nodeList), [text]);
      const fullContent = reactExports.useMemo(() => children(nodeList, false), [text]);
      const [ellipsisCutIndex, setEllipsisCutIndex] = reactExports.useState(null);
      const cutMidRef = reactExports.useRef(null);
      const measureWhiteSpaceRef = reactExports.useRef(null);
      const needEllipsisRef = reactExports.useRef(null);
      const descRowsEllipsisRef = reactExports.useRef(null);
      const symbolRowEllipsisRef = reactExports.useRef(null);
      const [canEllipsis, setCanEllipsis] = reactExports.useState(false);
      const [needEllipsis, setNeedEllipsis] = reactExports.useState(STATUS_MEASURE_NONE);
      const [ellipsisHeight, setEllipsisHeight] = reactExports.useState(0);
      const [parentWhiteSpace, setParentWhiteSpace] = reactExports.useState(null);
      useLayoutEffect$1(() => {
        if (enableMeasure && width && nodeLen) {
          setNeedEllipsis(STATUS_MEASURE_PREPARE);
        } else {
          setNeedEllipsis(STATUS_MEASURE_NONE);
        }
      }, [width, text, rows, enableMeasure, nodeList]);
      useLayoutEffect$1(() => {
        var _a, _b, _c, _d;
        if (needEllipsis === STATUS_MEASURE_PREPARE) {
          setNeedEllipsis(STATUS_MEASURE_START);
          const nextWhiteSpace = measureWhiteSpaceRef.current && getComputedStyle(measureWhiteSpaceRef.current).whiteSpace;
          setParentWhiteSpace(nextWhiteSpace);
        } else if (needEllipsis === STATUS_MEASURE_START) {
          const isOverflow = !!((_a = needEllipsisRef.current) === null || _a === void 0 ? void 0 : _a.isExceed());
          setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);
          setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);
          setCanEllipsis(isOverflow);
          const baseRowsEllipsisHeight = ((_b = needEllipsisRef.current) === null || _b === void 0 ? void 0 : _b.getHeight()) || 0;
          const descRowsEllipsisHeight = rows === 1 ? 0 : ((_c = descRowsEllipsisRef.current) === null || _c === void 0 ? void 0 : _c.getHeight()) || 0;
          const symbolRowEllipsisHeight = ((_d = symbolRowEllipsisRef.current) === null || _d === void 0 ? void 0 : _d.getHeight()) || 0;
          const maxRowsHeight = Math.max(
            baseRowsEllipsisHeight,
            // height of rows with ellipsis
            descRowsEllipsisHeight + symbolRowEllipsisHeight
          );
          setEllipsisHeight(maxRowsHeight + 1);
          onEllipsis(isOverflow);
        }
      }, [needEllipsis]);
      const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;
      useLayoutEffect$1(() => {
        var _a;
        const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];
        if (minIndex !== maxIndex) {
          const midHeight = ((_a = cutMidRef.current) === null || _a === void 0 ? void 0 : _a.getHeight()) || 0;
          const isOverflow = midHeight > ellipsisHeight;
          let targetMidIndex = cutMidIndex;
          if (maxIndex - minIndex === 1) {
            targetMidIndex = isOverflow ? minIndex : maxIndex;
          }
          setEllipsisCutIndex(isOverflow ? [minIndex, targetMidIndex] : [targetMidIndex, maxIndex]);
        }
      }, [ellipsisCutIndex, cutMidIndex]);
      const finalContent = reactExports.useMemo(() => {
        if (!enableMeasure) {
          return children(nodeList, false);
        }
        if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {
          const content = children(nodeList, false);
          if ([STATUS_MEASURE_NO_NEED_ELLIPSIS, STATUS_MEASURE_NONE].includes(needEllipsis)) {
            return content;
          }
          return /* @__PURE__ */ reactExports.createElement("span", {
            style: Object.assign(Object.assign({}, lineClipStyle), {
              WebkitLineClamp: rows
            })
          }, content);
        }
        return children(expanded ? nodeList : sliceNodes(nodeList, ellipsisCutIndex[0]), canEllipsis);
      }, [expanded, needEllipsis, ellipsisCutIndex, nodeList].concat(_toConsumableArray(miscDeps)));
      const measureStyle = {
        width,
        margin: 0,
        padding: 0,
        whiteSpace: parentWhiteSpace === "nowrap" ? "normal" : "inherit"
      };
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(MeasureText, {
        style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {
          WebkitLineClamp: rows
        }),
        ref: needEllipsisRef
      }, fullContent), /* @__PURE__ */ reactExports.createElement(MeasureText, {
        style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {
          WebkitLineClamp: rows - 1
        }),
        ref: descRowsEllipsisRef
      }, fullContent), /* @__PURE__ */ reactExports.createElement(MeasureText, {
        style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {
          WebkitLineClamp: 1
        }),
        ref: symbolRowEllipsisRef
      }, children([], true))), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && /* @__PURE__ */ reactExports.createElement(MeasureText, {
        style: Object.assign(Object.assign({}, measureStyle), {
          top: 400
        }),
        ref: cutMidRef
      }, children(sliceNodes(nodeList, cutMidIndex), true)), needEllipsis === STATUS_MEASURE_PREPARE && /* @__PURE__ */ reactExports.createElement("span", {
        style: {
          whiteSpace: "inherit"
        },
        ref: measureWhiteSpaceRef
      }));
    }
    const EllipsisTooltip = (_ref) => {
      let {
        enableEllipsis,
        isEllipsis,
        children,
        tooltipProps
      } = _ref;
      if (!(tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.title) || !enableEllipsis) {
        return children;
      }
      return /* @__PURE__ */ reactExports.createElement(Tooltip, Object.assign({
        open: isEllipsis ? void 0 : false
      }, tooltipProps), children);
    };
    var __rest$4 = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function wrapperDecorations(_ref, content) {
      let {
        mark,
        code,
        underline,
        delete: del,
        strong,
        keyboard,
        italic
      } = _ref;
      let currentContent = content;
      function wrap(tag, needed) {
        if (!needed) {
          return;
        }
        currentContent = /* @__PURE__ */ reactExports.createElement(tag, {}, currentContent);
      }
      wrap("strong", strong);
      wrap("u", underline);
      wrap("del", del);
      wrap("code", code);
      wrap("mark", mark);
      wrap("kbd", keyboard);
      wrap("i", italic);
      return currentContent;
    }
    const ELLIPSIS_STR = "...";
    const Base = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a;
      const {
        prefixCls: customizePrefixCls,
        className,
        style: style2,
        type: type2,
        disabled,
        children,
        ellipsis,
        editable,
        copyable,
        component,
        title
      } = props, restProps = __rest$4(props, ["prefixCls", "className", "style", "type", "disabled", "children", "ellipsis", "editable", "copyable", "component", "title"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const [textLocale] = useLocale$1("Text");
      const typographyRef = reactExports.useRef(null);
      const editIconRef = reactExports.useRef(null);
      const prefixCls = getPrefixCls("typography", customizePrefixCls);
      const textProps = omit(restProps, ["mark", "code", "delete", "underline", "strong", "keyboard", "italic"]);
      const [enableEdit, editConfig] = useMergedConfig(editable);
      const [editing, setEditing] = useMergedState(false, {
        value: editConfig.editing
      });
      const {
        triggerType = ["icon"]
      } = editConfig;
      const triggerEdit = (edit) => {
        var _a2;
        if (edit) {
          (_a2 = editConfig.onStart) === null || _a2 === void 0 ? void 0 : _a2.call(editConfig);
        }
        setEditing(edit);
      };
      const prevEditing = usePrevious(editing);
      useLayoutEffect$1(() => {
        var _a2;
        if (!editing && prevEditing) {
          (_a2 = editIconRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
        }
      }, [editing]);
      const onEditClick = (e2) => {
        e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
        triggerEdit(true);
      };
      const onEditChange = (value) => {
        var _a2;
        (_a2 = editConfig.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(editConfig, value);
        triggerEdit(false);
      };
      const onEditCancel = () => {
        var _a2;
        (_a2 = editConfig.onCancel) === null || _a2 === void 0 ? void 0 : _a2.call(editConfig);
        triggerEdit(false);
      };
      const [enableCopy, copyConfig] = useMergedConfig(copyable);
      const {
        copied,
        copyLoading,
        onClick: onCopyClick
      } = useCopyClick({
        copyConfig,
        children
      });
      const [isLineClampSupport, setIsLineClampSupport] = reactExports.useState(false);
      const [isTextOverflowSupport, setIsTextOverflowSupport] = reactExports.useState(false);
      const [isJsEllipsis, setIsJsEllipsis] = reactExports.useState(false);
      const [isNativeEllipsis, setIsNativeEllipsis] = reactExports.useState(false);
      const [isNativeVisible, setIsNativeVisible] = reactExports.useState(true);
      const [enableEllipsis, ellipsisConfig] = useMergedConfig(ellipsis, {
        expandable: false,
        symbol: (isExpanded) => isExpanded ? textLocale === null || textLocale === void 0 ? void 0 : textLocale.collapse : textLocale === null || textLocale === void 0 ? void 0 : textLocale.expand
      });
      const [expanded, setExpanded] = useMergedState(ellipsisConfig.defaultExpanded || false, {
        value: ellipsisConfig.expanded
      });
      const mergedEnableEllipsis = enableEllipsis && (!expanded || ellipsisConfig.expandable === "collapsible");
      const {
        rows = 1
      } = ellipsisConfig;
      const needMeasureEllipsis = reactExports.useMemo(() => (
        // Disable ellipsis
        mergedEnableEllipsis && // Provide suffix
        (ellipsisConfig.suffix !== void 0 || ellipsisConfig.onEllipsis || // Can't use css ellipsis since we need to provide the place for button
        ellipsisConfig.expandable || enableEdit || enableCopy)
      ), [mergedEnableEllipsis, ellipsisConfig, enableEdit, enableCopy]);
      useLayoutEffect$1(() => {
        if (enableEllipsis && !needMeasureEllipsis) {
          setIsLineClampSupport(isStyleSupport("webkitLineClamp"));
          setIsTextOverflowSupport(isStyleSupport("textOverflow"));
        }
      }, [needMeasureEllipsis, enableEllipsis]);
      const [cssEllipsis, setCssEllipsis] = reactExports.useState(mergedEnableEllipsis);
      const canUseCssEllipsis = reactExports.useMemo(() => {
        if (needMeasureEllipsis) {
          return false;
        }
        if (rows === 1) {
          return isTextOverflowSupport;
        }
        return isLineClampSupport;
      }, [needMeasureEllipsis, isTextOverflowSupport, isLineClampSupport]);
      useLayoutEffect$1(() => {
        setCssEllipsis(canUseCssEllipsis && mergedEnableEllipsis);
      }, [canUseCssEllipsis, mergedEnableEllipsis]);
      const isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis);
      const cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis;
      const cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis;
      const onExpandClick = (e2, info) => {
        var _a2;
        setExpanded(info.expanded);
        (_a2 = ellipsisConfig.onExpand) === null || _a2 === void 0 ? void 0 : _a2.call(ellipsisConfig, e2, info);
      };
      const [ellipsisWidth, setEllipsisWidth] = reactExports.useState(0);
      const onResize2 = (_ref2) => {
        let {
          offsetWidth
        } = _ref2;
        setEllipsisWidth(offsetWidth);
      };
      const onJsEllipsis = (jsEllipsis) => {
        var _a2;
        setIsJsEllipsis(jsEllipsis);
        if (isJsEllipsis !== jsEllipsis) {
          (_a2 = ellipsisConfig.onEllipsis) === null || _a2 === void 0 ? void 0 : _a2.call(ellipsisConfig, jsEllipsis);
        }
      };
      reactExports.useEffect(() => {
        const textEle = typographyRef.current;
        if (enableEllipsis && cssEllipsis && textEle) {
          const currentEllipsis = isEleEllipsis(textEle);
          if (isNativeEllipsis !== currentEllipsis) {
            setIsNativeEllipsis(currentEllipsis);
          }
        }
      }, [enableEllipsis, cssEllipsis, children, cssLineClamp, isNativeVisible, ellipsisWidth]);
      reactExports.useEffect(() => {
        const textEle = typographyRef.current;
        if (typeof IntersectionObserver === "undefined" || !textEle || !cssEllipsis || !mergedEnableEllipsis) {
          return;
        }
        const observer = new IntersectionObserver(() => {
          setIsNativeVisible(!!textEle.offsetParent);
        });
        observer.observe(textEle);
        return () => {
          observer.disconnect();
        };
      }, [cssEllipsis, mergedEnableEllipsis]);
      const tooltipProps = useTooltipProps(ellipsisConfig.tooltip, editConfig.text, children);
      const topAriaLabel = reactExports.useMemo(() => {
        if (!enableEllipsis || cssEllipsis) {
          return void 0;
        }
        return [editConfig.text, children, title, tooltipProps.title].find(isValidText);
      }, [enableEllipsis, cssEllipsis, title, tooltipProps.title, isMergedEllipsis]);
      if (editing) {
        return /* @__PURE__ */ reactExports.createElement(Editable, {
          value: (_a = editConfig.text) !== null && _a !== void 0 ? _a : typeof children === "string" ? children : "",
          onSave: onEditChange,
          onCancel: onEditCancel,
          onEnd: editConfig.onEnd,
          prefixCls,
          className,
          style: style2,
          direction,
          component,
          maxLength: editConfig.maxLength,
          autoSize: editConfig.autoSize,
          enterIcon: editConfig.enterIcon
        });
      }
      const renderExpand = () => {
        const {
          expandable,
          symbol
        } = ellipsisConfig;
        return expandable ? /* @__PURE__ */ reactExports.createElement("button", {
          type: "button",
          key: "expand",
          className: `${prefixCls}-${expanded ? "collapse" : "expand"}`,
          onClick: (e2) => onExpandClick(e2, {
            expanded: !expanded
          }),
          "aria-label": expanded ? textLocale.collapse : textLocale === null || textLocale === void 0 ? void 0 : textLocale.expand
        }, typeof symbol === "function" ? symbol(expanded) : symbol) : null;
      };
      const renderEdit = () => {
        if (!enableEdit) {
          return;
        }
        const {
          icon,
          tooltip,
          tabIndex
        } = editConfig;
        const editTitle = toArray$5(tooltip)[0] || (textLocale === null || textLocale === void 0 ? void 0 : textLocale.edit);
        const ariaLabel = typeof editTitle === "string" ? editTitle : "";
        return triggerType.includes("icon") ? /* @__PURE__ */ reactExports.createElement(Tooltip, {
          key: "edit",
          title: tooltip === false ? "" : editTitle
        }, /* @__PURE__ */ reactExports.createElement("button", {
          type: "button",
          ref: editIconRef,
          className: `${prefixCls}-edit`,
          onClick: onEditClick,
          "aria-label": ariaLabel,
          tabIndex
        }, icon || /* @__PURE__ */ reactExports.createElement(RefIcon$8, {
          role: "button"
        }))) : null;
      };
      const renderCopy = () => {
        if (!enableCopy) {
          return null;
        }
        return /* @__PURE__ */ reactExports.createElement(CopyBtn, Object.assign({
          key: "copy"
        }, copyConfig, {
          prefixCls,
          copied,
          locale: textLocale,
          onCopy: onCopyClick,
          loading: copyLoading,
          iconOnly: children === null || children === void 0
        }));
      };
      const renderOperations = (canEllipsis) => [canEllipsis && renderExpand(), renderEdit(), renderCopy()];
      const renderEllipsis = (canEllipsis) => [canEllipsis && !expanded && /* @__PURE__ */ reactExports.createElement("span", {
        "aria-hidden": true,
        key: "ellipsis"
      }, ELLIPSIS_STR), ellipsisConfig.suffix, renderOperations(canEllipsis)];
      return /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onResize2,
        disabled: !mergedEnableEllipsis
      }, (resizeRef) => /* @__PURE__ */ reactExports.createElement(EllipsisTooltip, {
        tooltipProps,
        enableEllipsis: mergedEnableEllipsis,
        isEllipsis: isMergedEllipsis
      }, /* @__PURE__ */ reactExports.createElement(Typography$1, Object.assign({
        className: classNames({
          [`${prefixCls}-${type2}`]: type2,
          [`${prefixCls}-disabled`]: disabled,
          [`${prefixCls}-ellipsis`]: enableEllipsis,
          [`${prefixCls}-ellipsis-single-line`]: cssTextOverflow,
          [`${prefixCls}-ellipsis-multiple-line`]: cssLineClamp
        }, className),
        prefixCls: customizePrefixCls,
        style: Object.assign(Object.assign({}, style2), {
          WebkitLineClamp: cssLineClamp ? rows : void 0
        }),
        component,
        ref: composeRef(resizeRef, typographyRef, ref),
        direction,
        onClick: triggerType.includes("text") ? onEditClick : void 0,
        "aria-label": topAriaLabel === null || topAriaLabel === void 0 ? void 0 : topAriaLabel.toString(),
        title
      }, textProps), /* @__PURE__ */ reactExports.createElement(EllipsisMeasure, {
        enableMeasure: mergedEnableEllipsis && !cssEllipsis,
        text: children,
        rows,
        width: ellipsisWidth,
        onEllipsis: onJsEllipsis,
        expanded,
        miscDeps: [copied, expanded, copyLoading, enableEdit, enableCopy, textLocale]
      }, (node2, canEllipsis) => wrapperDecorations(props, /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, node2.length > 0 && canEllipsis && !expanded && topAriaLabel ? /* @__PURE__ */ reactExports.createElement("span", {
        key: "show-content",
        "aria-hidden": true
      }, node2) : node2, renderEllipsis(canEllipsis)))))));
    });
    var __rest$3 = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const Link = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        ellipsis,
        rel
      } = _a, restProps = __rest$3(_a, ["ellipsis", "rel"]);
      const mergedProps = Object.assign(Object.assign({}, restProps), {
        rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel
      });
      delete mergedProps.navigate;
      return /* @__PURE__ */ reactExports.createElement(Base, Object.assign({}, mergedProps, {
        ref,
        ellipsis: !!ellipsis,
        component: "a"
      }));
    });
    const Paragraph$1 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => /* @__PURE__ */ reactExports.createElement(Base, Object.assign({
      ref
    }, props, {
      component: "div"
    })));
    var __rest$2 = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const Text = (_a, ref) => {
      var {
        ellipsis
      } = _a, restProps = __rest$2(_a, ["ellipsis"]);
      const mergedEllipsis = reactExports.useMemo(() => {
        if (ellipsis && typeof ellipsis === "object") {
          return omit(ellipsis, ["expandable", "rows"]);
        }
        return ellipsis;
      }, [ellipsis]);
      return /* @__PURE__ */ reactExports.createElement(Base, Object.assign({
        ref
      }, restProps, {
        ellipsis: mergedEllipsis,
        component: "span"
      }));
    };
    const Text$1 = /* @__PURE__ */ reactExports.forwardRef(Text);
    var __rest$1 = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    const TITLE_ELE_LIST = [1, 2, 3, 4, 5];
    const Title = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        level = 1
      } = props, restProps = __rest$1(props, ["level"]);
      const component = TITLE_ELE_LIST.includes(level) ? `h${level}` : `h1`;
      return /* @__PURE__ */ reactExports.createElement(Base, Object.assign({
        ref
      }, restProps, {
        component
      }));
    });
    const Typography = Typography$1;
    Typography.Text = Text$1;
    Typography.Link = Link;
    Typography.Title = Title;
    Typography.Paragraph = Paragraph$1;
    const InternalPanel = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls,
        className,
        children,
        size,
        style: style2 = {}
      } = props;
      const panelClassName = classNames(`${prefixCls}-panel`, {
        [`${prefixCls}-panel-hidden`]: size === 0
      }, className);
      const hasSize = size !== void 0;
      return /* @__PURE__ */ i.createElement("div", {
        ref,
        className: panelClassName,
        style: Object.assign(Object.assign({}, style2), {
          // Use auto when start from ssr
          flexBasis: hasSize ? size : "auto",
          flexGrow: hasSize ? 0 : 1
        })
      }, children);
    });
    const Panel = () => null;
    var __rest = function(s, e2) {
      var t2 = {};
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0) t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
      }
      return t2;
    };
    function getCollapsible(collapsible) {
      if (collapsible && typeof collapsible === "object") {
        return collapsible;
      }
      const mergedCollapsible = !!collapsible;
      return {
        start: mergedCollapsible,
        end: mergedCollapsible
      };
    }
    function useItems(children) {
      const items = reactExports.useMemo(() => toArray$5(children).filter(reactExports.isValidElement).map((node2) => {
        const {
          props
        } = node2;
        const {
          collapsible
        } = props, restProps = __rest(props, ["collapsible"]);
        return Object.assign(Object.assign({}, restProps), {
          collapsible: getCollapsible(collapsible)
        });
      }), [children]);
      return items;
    }
    function useResizable(items, pxSizes, isRTL) {
      return reactExports.useMemo(() => {
        const resizeInfos = [];
        for (let i2 = 0; i2 < items.length - 1; i2 += 1) {
          const prevItem = items[i2];
          const nextItem = items[i2 + 1];
          const prevSize = pxSizes[i2];
          const nextSize = pxSizes[i2 + 1];
          const {
            resizable: prevResizable = true,
            min: prevMin,
            collapsible: prevCollapsible
          } = prevItem;
          const {
            resizable: nextResizable = true,
            min: nextMin,
            collapsible: nextCollapsible
          } = nextItem;
          const mergedResizable = (
            // Both need to be resizable
            prevResizable && nextResizable && // Prev is not collapsed and limit min size
            (prevSize !== 0 || !prevMin) && // Next is not collapsed and limit min size
            (nextSize !== 0 || !nextMin)
          );
          const startCollapsible = (
            // Self is collapsible
            prevCollapsible.end && prevSize > 0 || // Collapsed and can be collapsed
            nextCollapsible.start && nextSize === 0 && prevSize > 0
          );
          const endCollapsible = (
            // Self is collapsible
            nextCollapsible.start && nextSize > 0 || // Collapsed and can be collapsed
            prevCollapsible.end && prevSize === 0 && nextSize > 0
          );
          resizeInfos[i2] = {
            resizable: mergedResizable,
            startCollapsible: !!(isRTL ? endCollapsible : startCollapsible),
            endCollapsible: !!(isRTL ? startCollapsible : endCollapsible)
          };
        }
        return resizeInfos;
      }, [pxSizes, items]);
    }
    function getPtg(str) {
      return Number(str.slice(0, -1)) / 100;
    }
    function isPtg(itemSize) {
      return typeof itemSize === "string" && itemSize.endsWith("%");
    }
    function useSizes(items, containerSize) {
      const propSizes = items.map((item) => item.size);
      const itemsCount = items.length;
      const mergedContainerSize = containerSize || 0;
      const ptg2px = (ptg) => ptg * mergedContainerSize;
      const [innerSizes, setInnerSizes] = i.useState(() => items.map((item) => item.defaultSize));
      const sizes2 = i.useMemo(() => {
        var _a;
        const mergedSizes = [];
        for (let i2 = 0; i2 < itemsCount; i2 += 1) {
          mergedSizes[i2] = (_a = propSizes[i2]) !== null && _a !== void 0 ? _a : innerSizes[i2];
        }
        return mergedSizes;
      }, [itemsCount, innerSizes, propSizes]);
      const postPercentSizes = i.useMemo(() => {
        let ptgList = [];
        let emptyCount = 0;
        for (let i2 = 0; i2 < itemsCount; i2 += 1) {
          const itemSize = sizes2[i2];
          if (isPtg(itemSize)) {
            ptgList[i2] = getPtg(itemSize);
          } else if (itemSize || itemSize === 0) {
            const num = Number(itemSize);
            if (!Number.isNaN(num)) {
              ptgList[i2] = num / mergedContainerSize;
            }
          } else {
            emptyCount += 1;
            ptgList[i2] = void 0;
          }
        }
        const totalPtg = ptgList.reduce((acc, ptg) => acc + (ptg || 0), 0);
        if (totalPtg > 1 || !emptyCount) {
          const scale = 1 / totalPtg;
          ptgList = ptgList.map((ptg) => ptg === void 0 ? 0 : ptg * scale);
        } else {
          const avgRest = (1 - totalPtg) / emptyCount;
          ptgList = ptgList.map((ptg) => ptg === void 0 ? avgRest : ptg);
        }
        return ptgList;
      }, [sizes2, mergedContainerSize]);
      const postPxSizes = i.useMemo(() => postPercentSizes.map(ptg2px), [postPercentSizes, mergedContainerSize]);
      const postPercentMinSizes = i.useMemo(() => items.map((item) => {
        if (isPtg(item.min)) {
          return getPtg(item.min);
        }
        return (item.min || 0) / mergedContainerSize;
      }), [items, mergedContainerSize]);
      const postPercentMaxSizes = i.useMemo(() => items.map((item) => {
        if (isPtg(item.max)) {
          return getPtg(item.max);
        }
        return (item.max || mergedContainerSize) / mergedContainerSize;
      }), [items, mergedContainerSize]);
      const panelSizes = i.useMemo(() => containerSize ? postPxSizes : sizes2, [postPxSizes, containerSize]);
      return [panelSizes, postPxSizes, postPercentSizes, postPercentMinSizes, postPercentMaxSizes, setInnerSizes];
    }
    function useResize(items, resizableInfos, percentSizes, containerSize, updateSizes, isRTL) {
      const limitSizes = items.map((item) => [item.min, item.max]);
      const mergedContainerSize = containerSize || 0;
      const ptg2px = (ptg) => ptg * mergedContainerSize;
      function getLimitSize(str, defaultLimit) {
        if (typeof str === "string") {
          return ptg2px(getPtg(str));
        }
        return str !== null && str !== void 0 ? str : defaultLimit;
      }
      const [cacheSizes, setCacheSizes] = reactExports.useState([]);
      const cacheCollapsedSize = reactExports.useRef([]);
      const [movingIndex, setMovingIndex] = reactExports.useState(null);
      const getPxSizes = () => percentSizes.map(ptg2px);
      const onOffsetStart = (index2) => {
        setCacheSizes(getPxSizes());
        setMovingIndex({
          index: index2,
          confirmed: false
        });
      };
      const onOffsetUpdate = (index2, offset2) => {
        var _a;
        let confirmedIndex = null;
        if ((!movingIndex || !movingIndex.confirmed) && offset2 !== 0) {
          if (offset2 > 0) {
            confirmedIndex = index2;
            setMovingIndex({
              index: index2,
              confirmed: true
            });
          } else {
            for (let i2 = index2; i2 >= 0; i2 -= 1) {
              if (cacheSizes[i2] > 0 && resizableInfos[i2].resizable) {
                confirmedIndex = i2;
                setMovingIndex({
                  index: i2,
                  confirmed: true
                });
                break;
              }
            }
          }
        }
        const mergedIndex = (_a = confirmedIndex !== null && confirmedIndex !== void 0 ? confirmedIndex : movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index) !== null && _a !== void 0 ? _a : index2;
        const numSizes = _toConsumableArray(cacheSizes);
        const nextIndex = mergedIndex + 1;
        const startMinSize = getLimitSize(limitSizes[mergedIndex][0], 0);
        const endMinSize = getLimitSize(limitSizes[nextIndex][0], 0);
        const startMaxSize = getLimitSize(limitSizes[mergedIndex][1], mergedContainerSize);
        const endMaxSize = getLimitSize(limitSizes[nextIndex][1], mergedContainerSize);
        let mergedOffset = offset2;
        if (numSizes[mergedIndex] + mergedOffset < startMinSize) {
          mergedOffset = startMinSize - numSizes[mergedIndex];
        }
        if (numSizes[nextIndex] - mergedOffset < endMinSize) {
          mergedOffset = numSizes[nextIndex] - endMinSize;
        }
        if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {
          mergedOffset = startMaxSize - numSizes[mergedIndex];
        }
        if (numSizes[nextIndex] - mergedOffset > endMaxSize) {
          mergedOffset = numSizes[nextIndex] - endMaxSize;
        }
        numSizes[mergedIndex] += mergedOffset;
        numSizes[nextIndex] -= mergedOffset;
        updateSizes(numSizes);
        return numSizes;
      };
      const onOffsetEnd = () => {
        setMovingIndex(null);
      };
      const onCollapse = (index2, type2) => {
        const currentSizes = getPxSizes();
        const adjustedType = isRTL ? type2 === "start" ? "end" : "start" : type2;
        const currentIndex = adjustedType === "start" ? index2 : index2 + 1;
        const targetIndex = adjustedType === "start" ? index2 + 1 : index2;
        const currentSize = currentSizes[currentIndex];
        const targetSize = currentSizes[targetIndex];
        if (currentSize !== 0 && targetSize !== 0) {
          currentSizes[currentIndex] = 0;
          currentSizes[targetIndex] += currentSize;
          cacheCollapsedSize.current[index2] = currentSize;
        } else {
          const totalSize = currentSize + targetSize;
          const currentSizeMin = getLimitSize(limitSizes[currentIndex][0], 0);
          const currentSizeMax = getLimitSize(limitSizes[currentIndex][1], mergedContainerSize);
          const targetSizeMin = getLimitSize(limitSizes[targetIndex][0], 0);
          const targetSizeMax = getLimitSize(limitSizes[targetIndex][1], mergedContainerSize);
          const limitStart = Math.max(currentSizeMin, totalSize - targetSizeMax);
          const limitEnd = Math.min(currentSizeMax, totalSize - targetSizeMin);
          const halfOffset = (limitEnd - limitStart) / 2;
          const targetCacheCollapsedSize = cacheCollapsedSize.current[index2];
          const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;
          const shouldUseCache = targetCacheCollapsedSize && targetCacheCollapsedSize <= targetSizeMax && targetCacheCollapsedSize >= targetSizeMin && currentCacheCollapsedSize <= currentSizeMax && currentCacheCollapsedSize >= currentSizeMin;
          if (shouldUseCache) {
            currentSizes[targetIndex] = targetCacheCollapsedSize;
            currentSizes[currentIndex] = currentCacheCollapsedSize;
          } else {
            currentSizes[currentIndex] -= halfOffset;
            currentSizes[targetIndex] += halfOffset;
          }
        }
        updateSizes(currentSizes);
        return currentSizes;
      };
      return [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index];
    }
    function getValidNumber(num) {
      return typeof num === "number" && !Number.isNaN(num) ? Math.round(num) : 0;
    }
    const SplitBar = (props) => {
      const {
        prefixCls,
        vertical,
        index: index2,
        active,
        ariaNow,
        ariaMin,
        ariaMax,
        resizable,
        startCollapsible,
        endCollapsible,
        onOffsetStart,
        onOffsetUpdate,
        onOffsetEnd,
        onCollapse,
        lazy,
        containerSize
      } = props;
      const splitBarPrefixCls = `${prefixCls}-bar`;
      const [startPos, setStartPos] = reactExports.useState(null);
      const [constrainedOffset, setConstrainedOffset] = reactExports.useState(0);
      const constrainedOffsetX = vertical ? 0 : constrainedOffset;
      const constrainedOffsetY = vertical ? constrainedOffset : 0;
      const onMouseDown = (e2) => {
        if (resizable && e2.currentTarget) {
          setStartPos([e2.pageX, e2.pageY]);
          onOffsetStart(index2);
        }
      };
      const onTouchStart = (e2) => {
        if (resizable && e2.touches.length === 1) {
          const touch = e2.touches[0];
          setStartPos([touch.pageX, touch.pageY]);
          onOffsetStart(index2);
        }
      };
      const getConstrainedOffset = (rawOffset) => {
        const currentPos = containerSize * ariaNow / 100;
        const newPos = currentPos + rawOffset;
        const minAllowed = Math.max(0, containerSize * ariaMin / 100);
        const maxAllowed = Math.min(containerSize, containerSize * ariaMax / 100);
        const clampedPos = Math.max(minAllowed, Math.min(maxAllowed, newPos));
        return clampedPos - currentPos;
      };
      const handleLazyMove = useEvent((offsetX, offsetY) => {
        const constrainedOffsetValue = getConstrainedOffset(vertical ? offsetY : offsetX);
        setConstrainedOffset(constrainedOffsetValue);
      });
      const handleLazyEnd = useEvent(() => {
        onOffsetUpdate(index2, constrainedOffsetX, constrainedOffsetY);
        setConstrainedOffset(0);
      });
      i.useEffect(() => {
        if (startPos) {
          const onMouseMove = (e2) => {
            const {
              pageX,
              pageY
            } = e2;
            const offsetX = pageX - startPos[0];
            const offsetY = pageY - startPos[1];
            if (lazy) {
              handleLazyMove(offsetX, offsetY);
            } else {
              onOffsetUpdate(index2, offsetX, offsetY);
            }
          };
          const onMouseUp = () => {
            if (lazy) {
              handleLazyEnd();
            }
            setStartPos(null);
            onOffsetEnd();
          };
          const handleTouchMove = (e2) => {
            if (e2.touches.length === 1) {
              const touch = e2.touches[0];
              const offsetX = touch.pageX - startPos[0];
              const offsetY = touch.pageY - startPos[1];
              if (lazy) {
                handleLazyMove(offsetX, offsetY);
              } else {
                onOffsetUpdate(index2, offsetX, offsetY);
              }
            }
          };
          const handleTouchEnd = () => {
            if (lazy) {
              handleLazyEnd();
            }
            setStartPos(null);
            onOffsetEnd();
          };
          window.addEventListener("touchmove", handleTouchMove);
          window.addEventListener("touchend", handleTouchEnd);
          window.addEventListener("mousemove", onMouseMove);
          window.addEventListener("mouseup", onMouseUp);
          return () => {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);
            window.removeEventListener("touchmove", handleTouchMove);
            window.removeEventListener("touchend", handleTouchEnd);
          };
        }
      }, [startPos, lazy, vertical, index2, containerSize, ariaNow, ariaMin, ariaMax]);
      const transformStyle = {
        [`--${splitBarPrefixCls}-preview-offset`]: `${constrainedOffset}px`
      };
      const StartIcon = vertical ? RefIcon$o : RefIcon$s;
      const EndIcon = vertical ? RefIcon$u : RefIcon$w;
      return /* @__PURE__ */ i.createElement("div", {
        className: splitBarPrefixCls,
        role: "separator",
        "aria-valuenow": getValidNumber(ariaNow),
        "aria-valuemin": getValidNumber(ariaMin),
        "aria-valuemax": getValidNumber(ariaMax)
      }, lazy && /* @__PURE__ */ i.createElement("div", {
        className: classNames(`${splitBarPrefixCls}-preview`, {
          [`${splitBarPrefixCls}-preview-active`]: !!constrainedOffset
        }),
        style: transformStyle
      }), /* @__PURE__ */ i.createElement("div", {
        className: classNames(`${splitBarPrefixCls}-dragger`, {
          [`${splitBarPrefixCls}-dragger-disabled`]: !resizable,
          [`${splitBarPrefixCls}-dragger-active`]: active
        }),
        onMouseDown,
        onTouchStart
      }), startCollapsible && /* @__PURE__ */ i.createElement("div", {
        className: classNames(`${splitBarPrefixCls}-collapse-bar`, `${splitBarPrefixCls}-collapse-bar-start`),
        onClick: () => onCollapse(index2, "start")
      }, /* @__PURE__ */ i.createElement(StartIcon, {
        className: classNames(`${splitBarPrefixCls}-collapse-icon`, `${splitBarPrefixCls}-collapse-start`)
      })), endCollapsible && /* @__PURE__ */ i.createElement("div", {
        className: classNames(`${splitBarPrefixCls}-collapse-bar`, `${splitBarPrefixCls}-collapse-bar-end`),
        onClick: () => onCollapse(index2, "end")
      }, /* @__PURE__ */ i.createElement(EndIcon, {
        className: classNames(`${splitBarPrefixCls}-collapse-icon`, `${splitBarPrefixCls}-collapse-end`)
      })));
    };
    const genRtlStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`&-rtl${componentCls}-horizontal`]: {
          [`> ${componentCls}-bar`]: {
            [`${componentCls}-bar-collapse-previous`]: {
              insetInlineEnd: 0,
              insetInlineStart: "unset"
            },
            [`${componentCls}-bar-collapse-next`]: {
              insetInlineEnd: "unset",
              insetInlineStart: 0
            }
          }
        },
        [`&-rtl${componentCls}-vertical`]: {
          [`> ${componentCls}-bar`]: {
            [`${componentCls}-bar-collapse-previous`]: {
              insetInlineEnd: "50%",
              insetInlineStart: "unset"
            },
            [`${componentCls}-bar-collapse-next`]: {
              insetInlineEnd: "50%",
              insetInlineStart: "unset"
            }
          }
        }
      };
    };
    const centerStyle = {
      position: "absolute",
      top: "50%",
      left: {
        _skip_check_: true,
        value: "50%"
      },
      transform: "translate(-50%, -50%)"
    };
    const genSplitterStyle = (token2) => {
      const {
        componentCls,
        colorFill,
        splitBarDraggableSize,
        splitBarSize,
        splitTriggerSize,
        controlItemBgHover,
        controlItemBgActive,
        controlItemBgActiveHover,
        prefixCls
      } = token2;
      const splitBarCls = `${componentCls}-bar`;
      const splitMaskCls = `${componentCls}-mask`;
      const splitPanelCls = `${componentCls}-panel`;
      const halfTriggerSize = token2.calc(splitTriggerSize).div(2).equal();
      const splitterBarPreviewOffsetVar = `${prefixCls}-bar-preview-offset`;
      const splitterBarPreviewStyle = {
        position: "absolute",
        background: token2.colorPrimary,
        opacity: 0.2,
        pointerEvents: "none",
        transition: "none",
        zIndex: 1,
        display: "none"
      };
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
          display: "flex",
          width: "100%",
          height: "100%",
          alignItems: "stretch",
          // ======================== SplitBar ========================
          // Use `>` to avoid conflict with mix layout
          [`> ${splitBarCls}`]: {
            flex: "none",
            position: "relative",
            userSelect: "none",
            // ======================= Dragger =======================
            [`${splitBarCls}-dragger`]: Object.assign(Object.assign({}, centerStyle), {
              zIndex: 1,
              // Hover background
              "&::before": Object.assign({
                content: '""',
                background: controlItemBgHover
              }, centerStyle),
              // Spinner
              "&::after": Object.assign({
                content: '""',
                background: colorFill
              }, centerStyle),
              // Hover
              [`&:hover:not(${splitBarCls}-dragger-active)`]: {
                "&::before": {
                  background: controlItemBgActive
                }
              },
              // Active
              "&-active": {
                zIndex: 2,
                "&::before": {
                  background: controlItemBgActiveHover
                }
              },
              // Disabled, not use `pointer-events: none` since still need trigger collapse
              [`&-disabled${splitBarCls}-dragger`]: {
                zIndex: 0,
                "&, &:hover, &-active": {
                  cursor: "default",
                  "&::before": {
                    background: controlItemBgHover
                  }
                },
                "&::after": {
                  display: "none"
                }
              }
            }),
            // ======================= Collapse =======================
            [`${splitBarCls}-collapse-bar`]: Object.assign(Object.assign({}, centerStyle), {
              zIndex: token2.zIndexPopupBase,
              background: controlItemBgHover,
              fontSize: token2.fontSizeSM,
              borderRadius: token2.borderRadiusXS,
              color: token2.colorText,
              cursor: "pointer",
              opacity: 0,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              // Hover
              "&:hover": {
                background: controlItemBgActive
              },
              // Active
              "&:active": {
                background: controlItemBgActiveHover
              }
            }),
            // ======================== Status ========================
            // Hover
            "&:hover, &:active": {
              [`${splitBarCls}-collapse-bar`]: {
                opacity: 1
              }
            }
          },
          // =========================== Mask =========================
          // Util dom for handle cursor
          [splitMaskCls]: {
            position: "fixed",
            zIndex: token2.zIndexPopupBase,
            inset: 0,
            "&-horizontal": {
              cursor: "col-resize"
            },
            "&-vertical": {
              cursor: "row-resize"
            }
          },
          // ==========================================================
          // ==                        Layout                        ==
          // ==========================================================
          "&-horizontal": {
            flexDirection: "row",
            [`> ${splitBarCls}`]: {
              width: 0,
              // ======================= Preview =======================
              [`${splitBarCls}-preview`]: Object.assign(Object.assign({
                height: "100%",
                width: splitBarSize
              }, splitterBarPreviewStyle), {
                [`&${splitBarCls}-preview-active`]: {
                  display: "block",
                  transform: `translateX(var(--${splitterBarPreviewOffsetVar}))`
                }
              }),
              // ======================= Dragger =======================
              [`${splitBarCls}-dragger`]: {
                cursor: "col-resize",
                height: "100%",
                width: splitTriggerSize,
                "&::before": {
                  height: "100%",
                  width: splitBarSize
                },
                "&::after": {
                  height: splitBarDraggableSize,
                  width: splitBarSize
                }
              },
              // ======================= Collapse =======================
              [`${splitBarCls}-collapse-bar`]: {
                width: token2.fontSizeSM,
                height: token2.controlHeightSM,
                "&-start": {
                  left: {
                    _skip_check_: true,
                    value: "auto"
                  },
                  right: {
                    _skip_check_: true,
                    value: halfTriggerSize
                  },
                  transform: "translateY(-50%)"
                },
                "&-end": {
                  left: {
                    _skip_check_: true,
                    value: halfTriggerSize
                  },
                  right: {
                    _skip_check_: true,
                    value: "auto"
                  },
                  transform: "translateY(-50%)"
                }
              }
            }
          },
          "&-vertical": {
            flexDirection: "column",
            [`> ${splitBarCls}`]: {
              height: 0,
              // ======================= Preview =======================
              [`${splitBarCls}-preview`]: Object.assign(Object.assign({
                height: splitBarSize,
                width: "100%"
              }, splitterBarPreviewStyle), {
                [`&${splitBarCls}-preview-active`]: {
                  display: "block",
                  transform: `translateY(var(--${splitterBarPreviewOffsetVar}))`
                }
              }),
              // ======================= Dragger =======================
              [`${splitBarCls}-dragger`]: {
                cursor: "row-resize",
                width: "100%",
                height: splitTriggerSize,
                "&::before": {
                  width: "100%",
                  height: splitBarSize
                },
                "&::after": {
                  width: splitBarDraggableSize,
                  height: splitBarSize
                }
              },
              // ======================= Collapse =======================
              [`${splitBarCls}-collapse-bar`]: {
                height: token2.fontSizeSM,
                width: token2.controlHeightSM,
                "&-start": {
                  top: "auto",
                  bottom: halfTriggerSize,
                  transform: "translateX(-50%)"
                },
                "&-end": {
                  top: halfTriggerSize,
                  bottom: "auto",
                  transform: "translateX(-50%)"
                }
              }
            }
          },
          // ========================= Panels =========================
          [splitPanelCls]: {
            overflow: "auto",
            padding: "0 1px",
            scrollbarWidth: "thin",
            boxSizing: "border-box",
            "&-hidden": {
              padding: 0,
              overflow: "hidden"
            },
            [`&:has(${componentCls}:only-child)`]: {
              overflow: "hidden"
            }
          }
        }), genRtlStyle(token2))
      };
    };
    const prepareComponentToken = (token2) => {
      var _a;
      const splitBarSize = token2.splitBarSize || 2;
      const splitTriggerSize = token2.splitTriggerSize || 6;
      const resizeSpinnerSize = token2.resizeSpinnerSize || 20;
      const splitBarDraggableSize = (_a = token2.splitBarDraggableSize) !== null && _a !== void 0 ? _a : resizeSpinnerSize;
      return {
        splitBarSize,
        splitTriggerSize,
        splitBarDraggableSize,
        resizeSpinnerSize
      };
    };
    const useStyle = genStyleHooks("Splitter", (token2) => [genSplitterStyle(token2)], prepareComponentToken);
    const Splitter$1 = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        style: style2,
        layout = "horizontal",
        children,
        rootClassName,
        onResizeStart,
        onResize: onResize2,
        onResizeEnd,
        lazy
      } = props;
      const {
        getPrefixCls,
        direction,
        className: contextClassName,
        style: contextStyle
      } = useComponentConfig("splitter");
      const prefixCls = getPrefixCls("splitter", customizePrefixCls);
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle(prefixCls, rootCls);
      const isVertical = layout === "vertical";
      const isRTL = direction === "rtl";
      const reverse = !isVertical && isRTL;
      const items = useItems(children);
      const [containerSize, setContainerSize] = reactExports.useState();
      const onContainerResize = (size) => {
        const {
          offsetWidth,
          offsetHeight
        } = size;
        const containerSize2 = isVertical ? offsetHeight : offsetWidth;
        if (containerSize2 === 0) {
          return;
        }
        setContainerSize(containerSize2);
      };
      const [panelSizes, itemPxSizes, itemPtgSizes, itemPtgMinSizes, itemPtgMaxSizes, updateSizes] = useSizes(items, containerSize);
      const resizableInfos = useResizable(items, itemPxSizes, isRTL);
      const [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex] = useResize(items, resizableInfos, itemPtgSizes, containerSize, updateSizes, isRTL);
      const onInternalResizeStart = useEvent((index2) => {
        onOffsetStart(index2);
        onResizeStart === null || onResizeStart === void 0 ? void 0 : onResizeStart(itemPxSizes);
      });
      const onInternalResizeUpdate = useEvent((index2, offset2) => {
        const nextSizes = onOffsetUpdate(index2, offset2);
        onResize2 === null || onResize2 === void 0 ? void 0 : onResize2(nextSizes);
      });
      const onInternalResizeEnd = useEvent(() => {
        onOffsetEnd();
        onResizeEnd === null || onResizeEnd === void 0 ? void 0 : onResizeEnd(itemPxSizes);
      });
      const onInternalCollapse = useEvent((index2, type2) => {
        const nextSizes = onCollapse(index2, type2);
        onResize2 === null || onResize2 === void 0 ? void 0 : onResize2(nextSizes);
        onResizeEnd === null || onResizeEnd === void 0 ? void 0 : onResizeEnd(nextSizes);
      });
      const containerClassName = classNames(prefixCls, className, `${prefixCls}-${layout}`, {
        [`${prefixCls}-rtl`]: isRTL
      }, rootClassName, contextClassName, cssVarCls, rootCls, hashId);
      const maskCls = `${prefixCls}-mask`;
      const stackSizes = i.useMemo(() => {
        const mergedSizes = [];
        let stack = 0;
        for (let i2 = 0; i2 < items.length; i2 += 1) {
          stack += itemPtgSizes[i2];
          mergedSizes.push(stack);
        }
        return mergedSizes;
      }, [itemPtgSizes]);
      const mergedStyle = Object.assign(Object.assign({}, contextStyle), style2);
      return wrapCSSVar(/* @__PURE__ */ i.createElement(RefResizeObserver, {
        onResize: onContainerResize
      }, /* @__PURE__ */ i.createElement("div", {
        style: mergedStyle,
        className: containerClassName
      }, items.map((item, idx) => {
        const panel = /* @__PURE__ */ i.createElement(InternalPanel, Object.assign({}, item, {
          prefixCls,
          size: panelSizes[idx]
        }));
        let splitBar = null;
        const resizableInfo = resizableInfos[idx];
        if (resizableInfo) {
          const ariaMinStart = (stackSizes[idx - 1] || 0) + itemPtgMinSizes[idx];
          const ariaMinEnd = (stackSizes[idx + 1] || 100) - itemPtgMaxSizes[idx + 1];
          const ariaMaxStart = (stackSizes[idx - 1] || 0) + itemPtgMaxSizes[idx];
          const ariaMaxEnd = (stackSizes[idx + 1] || 100) - itemPtgMinSizes[idx + 1];
          splitBar = /* @__PURE__ */ i.createElement(SplitBar, {
            lazy,
            index: idx,
            active: movingIndex === idx,
            prefixCls,
            vertical: isVertical,
            resizable: resizableInfo.resizable,
            ariaNow: stackSizes[idx] * 100,
            ariaMin: Math.max(ariaMinStart, ariaMinEnd) * 100,
            ariaMax: Math.min(ariaMaxStart, ariaMaxEnd) * 100,
            startCollapsible: resizableInfo.startCollapsible,
            endCollapsible: resizableInfo.endCollapsible,
            onOffsetStart: onInternalResizeStart,
            onOffsetUpdate: (index2, offsetX, offsetY) => {
              let offset2 = isVertical ? offsetY : offsetX;
              if (reverse) {
                offset2 = -offset2;
              }
              onInternalResizeUpdate(index2, offset2);
            },
            onOffsetEnd: onInternalResizeEnd,
            onCollapse: onInternalCollapse,
            containerSize: containerSize || 0
          });
        }
        return /* @__PURE__ */ i.createElement(i.Fragment, {
          key: `split-panel-${idx}`
        }, panel, splitBar);
      }), typeof movingIndex === "number" && /* @__PURE__ */ i.createElement("div", {
        "aria-hidden": true,
        className: classNames(maskCls, `${maskCls}-${layout}`)
      }))));
    };
    const Splitter = Splitter$1;
    Splitter.Panel = Panel;
    const Style = {
      margin: {
        none: "0px",
        xs: "0.25rem",
        sm: "0.5rem",
        md: "1rem",
        lg: "1.5rem",
        xl: "2rem",
        "2xl": "3rem",
        "3xl": "4rem",
        "4xl": "5rem"
      }
    };
    const Heading = createElement({
      id: "Heading",
      value: "readonly",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$6, {}),
      props: create$3({
        level: create$5().oneOf([1, 2, 3, 4, 5, 6]).required().default(1).label("Size").meta({ description: "Heading level (1-6)" }),
        text: create$6().required().default("Heading").label("Text").meta({ description: "Heading text" }),
        marginTop: create$6().oneOf(Object.keys(Style.margin)).label("Margin Top").default("none").required(),
        marginBottom: create$6().oneOf(Object.keys(Style.margin)).label("Margin Bottom").default("none").required()
      }),
      Component: ({ level, text, marginBottom, marginTop }) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography.Title,
          {
            level,
            style: { marginBottom: Style.margin[marginBottom], marginTop: Style.margin[marginTop] },
            children: text
          }
        );
      }
    });
    const Paragraph = createElement({
      id: "Paragraph",
      value: "readonly",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$3, {}),
      props: create$3({
        text: create$6().required().default("Paragraph").label("Text").meta({ description: "Paragraph text", control: "textarea" }),
        type: create$6().oneOf(["default", "secondary", "success", "warning", "danger"]).default("default").nullable().label("Type"),
        marginTop: create$6().oneOf(Object.keys(Style.margin)).label("Margin Top").default("none").required(),
        marginBottom: create$6().oneOf(Object.keys(Style.margin)).label("Margin Bottom").default("none").required()
      }),
      Component: ({ text, marginTop, marginBottom, type: type2 }) => {
        const paragraphType = type2 === "default" ? void 0 : type2;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography.Paragraph,
          {
            type: paragraphType ?? void 0,
            style: {
              whiteSpace: "pre-line",
              marginTop: Style.margin[marginTop],
              marginBottom: Style.margin[marginBottom]
            },
            children: text
          }
        );
      }
    });
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options2) {
      return options2.clone !== false && options2.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options2) : value;
    }
    function defaultArrayMerge(target, source, options2) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options2);
      });
    }
    function mergeObject(target, source, options2) {
      var destination = {};
      if (options2.isMergeableObject(target)) {
        Object.keys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options2);
        });
      }
      Object.keys(source).forEach(function(key) {
        if (!options2.isMergeableObject(source[key]) || !target[key]) {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options2);
        } else {
          destination[key] = deepmerge(target[key], source[key], options2);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options2) {
      options2 = options2 || {};
      options2.arrayMerge = options2.arrayMerge || defaultArrayMerge;
      options2.isMergeableObject = options2.isMergeableObject || isMergeableObject;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options2);
      } else if (sourceIsArray) {
        return options2.arrayMerge(target, source, options2);
      } else {
        return mergeObject(target, source, options2);
      }
    }
    deepmerge.all = function deepmergeAll(array2, options2) {
      if (!Array.isArray(array2)) {
        throw new Error("first argument should be an array");
      }
      return array2.reduce(function(prev2, next2) {
        return deepmerge(prev2, next2, options2);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto$d = Object.prototype;
    var hasOwnProperty$a = objectProto$d.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$d.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$c = Object.prototype;
    var nativeObjectToString = objectProto$c.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var objectTag$3 = "[object Object]";
    var funcProto$2 = Function.prototype, objectProto$b = Object.prototype;
    var funcToString$2 = funcProto$2.toString;
    var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
    var objectCtorString = funcToString$2.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$9.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function assocIndexOf(array2, key) {
      var length2 = array2.length;
      while (length2--) {
        if (eq(array2[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function isObject$1(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction$1(value) {
      if (!isObject$1(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$1 = Function.prototype;
    var funcToString$1 = funcProto$1.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype, objectProto$a = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject$1(value) || isMasked(value)) {
        return false;
      }
      var pattern2 = isFunction$1(value) ? reIsNative : reIsHostCtor;
      return pattern2.test(toSource(value));
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var Map$1 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$1 ? void 0 : result;
      }
      return hasOwnProperty$7.call(data, key) ? data[key] : void 0;
    }
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$6.call(data, key);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    function Hash(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayEach(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    var defineProperty$1 = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty$1) {
        defineProperty$1(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
    function assignValue(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty$5.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index2 = -1, length2 = props.length;
      while (++index2 < length2) {
        var key = props[index2];
        var newValue = void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object2, key, newValue);
        } else {
          assignValue(object2, key, newValue);
        }
      }
      return object2;
    }
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    var argsTag$2 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$2;
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    var isArray$1 = Array.isArray;
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length2) {
      var type2 = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
      return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$4 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$4;
      return value === proto;
    }
    var nativeKeys = overArg(Object.keys, Object);
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction$1(value);
    }
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function baseAssign(object2, source) {
      return object2 && copyObject(source, keys(source), object2);
    }
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject$1(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$1.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    function baseAssignIn(object2, source) {
      return object2 && copyObject(source, keysIn(source), object2);
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
      buffer.copy(result);
      return result;
    }
    function copyArray(source, array2) {
      var index2 = -1, length2 = source.length;
      array2 || (array2 = Array(length2));
      while (++index2 < length2) {
        array2[index2] = source[index2];
      }
      return array2;
    }
    function arrayFilter(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$1 = Object.prototype;
    var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    function copySymbols(source, object2) {
      return copyObject(source, getSymbols(source), object2);
    }
    function arrayPush(array2, values) {
      var index2 = -1, length2 = values.length, offset2 = array2.length;
      while (++index2 < length2) {
        array2[offset2 + index2] = values[index2];
      }
      return array2;
    }
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
      var result = [];
      while (object2) {
        arrayPush(result, getSymbols(object2));
        object2 = getPrototype(object2);
      }
      return result;
    };
    function copySymbolsIn(source, object2) {
      return copyObject(source, getSymbolsIn(source), object2);
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray$1(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols);
    }
    function getAllKeysIn(object2) {
      return baseGetAllKeys(object2, keysIn, getSymbolsIn);
    }
    var DataView = getNative(root, "DataView");
    var Promise$1 = getNative(root, "Promise");
    var Set$1 = getNative(root, "Set");
    var WeakMap$1 = getNative(root, "WeakMap");
    var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
    var dataViewTag$2 = "[object DataView]";
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$3 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$3 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$2;
            case mapCtorString:
              return mapTag$3;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$3;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array2) {
      var length2 = array2.length, result = new array2.constructor(length2);
      if (length2 && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    var Uint8Array2 = root.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    var reFlags = /\w*$/;
    function cloneRegExp(regexp2) {
      var result = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
      result.lastIndex = regexp2.lastIndex;
      return result;
    }
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag$1:
          return cloneArrayBuffer(object2);
        case boolTag$1:
        case dateTag$1:
          return new Ctor(+object2);
        case dataViewTag$1:
          return cloneDataView(object2, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object2, isDeep);
        case mapTag$2:
          return new Ctor();
        case numberTag$1:
        case stringTag$1:
          return new Ctor(object2);
        case regexpTag$1:
          return cloneRegExp(object2);
        case setTag$2:
          return new Ctor();
        case symbolTag$2:
          return cloneSymbol(object2);
      }
    }
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject$1(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object2.prototype = proto;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
    }
    var mapTag$1 = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag$1;
    }
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    var setTag$1 = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag$1;
    }
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$2 = 4;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object2, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
      if (result !== void 0) {
        return result;
      }
      if (!isObject$1(value)) {
        return value;
      }
      var isArr = isArray$1(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object2) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object2 ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG$1 = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG$1);
    }
    var isArray = Array.isArray;
    var keyList = Object.keys;
    var hasProp = Object.prototype.hasOwnProperty;
    var hasElementType = typeof Element !== "undefined";
    function equal(a, b2) {
      if (a === b2) return true;
      if (a && b2 && typeof a == "object" && typeof b2 == "object") {
        var arrA = isArray(a), arrB = isArray(b2), i2, length2, key;
        if (arrA && arrB) {
          length2 = a.length;
          if (length2 != b2.length) return false;
          for (i2 = length2; i2-- !== 0; )
            if (!equal(a[i2], b2[i2])) return false;
          return true;
        }
        if (arrA != arrB) return false;
        var dateA = a instanceof Date, dateB = b2 instanceof Date;
        if (dateA != dateB) return false;
        if (dateA && dateB) return a.getTime() == b2.getTime();
        var regexpA = a instanceof RegExp, regexpB = b2 instanceof RegExp;
        if (regexpA != regexpB) return false;
        if (regexpA && regexpB) return a.toString() == b2.toString();
        var keys2 = keyList(a);
        length2 = keys2.length;
        if (length2 !== keyList(b2).length)
          return false;
        for (i2 = length2; i2-- !== 0; )
          if (!hasProp.call(b2, keys2[i2])) return false;
        if (hasElementType && a instanceof Element && b2 instanceof Element)
          return a === b2;
        for (i2 = length2; i2-- !== 0; ) {
          key = keys2[i2];
          if (key === "_owner" && a.$$typeof) {
            continue;
          } else {
            if (!equal(a[key], b2[key])) return false;
          }
        }
        return true;
      }
      return a !== a && b2 !== b2;
    }
    var reactFastCompare = function exportedEqual(a, b2) {
      try {
        return equal(a, b2);
      } catch (error) {
        if (error.message && error.message.match(/stack|recursion/i) || error.number === -2146828260) {
          console.warn("Warning: react-fast-compare does not handle circular references.", error.name, error.message);
          return false;
        }
        throw error;
      }
    };
    const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    function arrayMap(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
      while (++index2 < length2) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName, function(match2, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray$1(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function toPath(value) {
      if (isArray$1(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }
    var reactIs$1 = { exports: {} };
    var reactIs_production_min = {};
    /** @license React v16.13.1
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b$1 = "function" === typeof Symbol && Symbol.for, c = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l = b$1 ? Symbol.for("react.async_mode") : 60111, m = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n = b$1 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r = b$1 ? Symbol.for("react.memo") : 60115, t = b$1 ? Symbol.for("react.lazy") : 60116, v = b$1 ? Symbol.for("react.block") : 60121, w$1 = b$1 ? Symbol.for("react.fundamental") : 60117, x$2 = b$1 ? Symbol.for("react.responder") : 60118, y = b$1 ? Symbol.for("react.scope") : 60119;
    function z$1(a) {
      if ("object" === typeof a && null !== a) {
        var u2 = a.$$typeof;
        switch (u2) {
          case c:
            switch (a = a.type, a) {
              case l:
              case m:
              case e:
              case g$1:
              case f$1:
              case p$1:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k$1:
                  case n:
                  case t:
                  case r:
                  case h:
                    return a;
                  default:
                    return u2;
                }
            }
          case d$1:
            return u2;
        }
      }
    }
    function A$1(a) {
      return z$1(a) === m;
    }
    reactIs_production_min.AsyncMode = l;
    reactIs_production_min.ConcurrentMode = m;
    reactIs_production_min.ContextConsumer = k$1;
    reactIs_production_min.ContextProvider = h;
    reactIs_production_min.Element = c;
    reactIs_production_min.ForwardRef = n;
    reactIs_production_min.Fragment = e;
    reactIs_production_min.Lazy = t;
    reactIs_production_min.Memo = r;
    reactIs_production_min.Portal = d$1;
    reactIs_production_min.Profiler = g$1;
    reactIs_production_min.StrictMode = f$1;
    reactIs_production_min.Suspense = p$1;
    reactIs_production_min.isAsyncMode = function(a) {
      return A$1(a) || z$1(a) === l;
    };
    reactIs_production_min.isConcurrentMode = A$1;
    reactIs_production_min.isContextConsumer = function(a) {
      return z$1(a) === k$1;
    };
    reactIs_production_min.isContextProvider = function(a) {
      return z$1(a) === h;
    };
    reactIs_production_min.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === c;
    };
    reactIs_production_min.isForwardRef = function(a) {
      return z$1(a) === n;
    };
    reactIs_production_min.isFragment = function(a) {
      return z$1(a) === e;
    };
    reactIs_production_min.isLazy = function(a) {
      return z$1(a) === t;
    };
    reactIs_production_min.isMemo = function(a) {
      return z$1(a) === r;
    };
    reactIs_production_min.isPortal = function(a) {
      return z$1(a) === d$1;
    };
    reactIs_production_min.isProfiler = function(a) {
      return z$1(a) === g$1;
    };
    reactIs_production_min.isStrictMode = function(a) {
      return z$1(a) === f$1;
    };
    reactIs_production_min.isSuspense = function(a) {
      return z$1(a) === p$1;
    };
    reactIs_production_min.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g$1 || a === f$1 || a === p$1 || a === q$1 || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k$1 || a.$$typeof === n || a.$$typeof === w$1 || a.$$typeof === x$2 || a.$$typeof === y || a.$$typeof === v);
    };
    reactIs_production_min.typeOf = z$1;
    {
      reactIs$1.exports = reactIs_production_min;
    }
    var reactIsExports = reactIs$1.exports;
    var reactIs = reactIsExports;
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function _extends$1() {
      _extends$1 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$1.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    var FormikContext = /* @__PURE__ */ reactExports.createContext(void 0);
    FormikContext.displayName = "FormikContext";
    var FormikProvider = FormikContext.Provider;
    FormikContext.Consumer;
    function useFormikContext() {
      var formik = reactExports.useContext(FormikContext);
      return formik;
    }
    var isFunction = function isFunction2(obj) {
      return typeof obj === "function";
    };
    var isObject = function isObject2(obj) {
      return obj !== null && typeof obj === "object";
    };
    var isInteger = function isInteger2(obj) {
      return String(Math.floor(Number(obj))) === obj;
    };
    var isString = function isString2(obj) {
      return Object.prototype.toString.call(obj) === "[object String]";
    };
    var isEmptyChildren = function isEmptyChildren2(children) {
      return reactExports.Children.count(children) === 0;
    };
    var isPromise = function isPromise2(value) {
      return isObject(value) && isFunction(value.then);
    };
    function getIn(obj, key, def, p2) {
      if (p2 === void 0) {
        p2 = 0;
      }
      var path2 = toPath(key);
      while (obj && p2 < path2.length) {
        obj = obj[path2[p2++]];
      }
      if (p2 !== path2.length && !obj) {
        return def;
      }
      return obj === void 0 ? def : obj;
    }
    function setIn(obj, path2, value) {
      var res = clone(obj);
      var resVal = res;
      var i2 = 0;
      var pathArray = toPath(path2);
      for (; i2 < pathArray.length - 1; i2++) {
        var currentPath = pathArray[i2];
        var currentObj = getIn(obj, pathArray.slice(0, i2 + 1));
        if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {
          resVal = resVal[currentPath] = clone(currentObj);
        } else {
          var nextPath = pathArray[i2 + 1];
          resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
        }
      }
      if ((i2 === 0 ? obj : resVal)[pathArray[i2]] === value) {
        return obj;
      }
      if (value === void 0) {
        delete resVal[pathArray[i2]];
      } else {
        resVal[pathArray[i2]] = value;
      }
      if (i2 === 0 && value === void 0) {
        delete res[pathArray[i2]];
      }
      return res;
    }
    function setNestedObjectValues(object2, value, visited, response) {
      if (visited === void 0) {
        visited = /* @__PURE__ */ new WeakMap();
      }
      if (response === void 0) {
        response = {};
      }
      for (var _i = 0, _Object$keys = Object.keys(object2); _i < _Object$keys.length; _i++) {
        var k2 = _Object$keys[_i];
        var val = object2[k2];
        if (isObject(val)) {
          if (!visited.get(val)) {
            visited.set(val, true);
            response[k2] = Array.isArray(val) ? [] : {};
            setNestedObjectValues(val, value, visited, response[k2]);
          }
        } else {
          response[k2] = value;
        }
      }
      return response;
    }
    function formikReducer(state, msg) {
      switch (msg.type) {
        case "SET_VALUES":
          return _extends$1({}, state, {
            values: msg.payload
          });
        case "SET_TOUCHED":
          return _extends$1({}, state, {
            touched: msg.payload
          });
        case "SET_ERRORS":
          if (isEqual(state.errors, msg.payload)) {
            return state;
          }
          return _extends$1({}, state, {
            errors: msg.payload
          });
        case "SET_STATUS":
          return _extends$1({}, state, {
            status: msg.payload
          });
        case "SET_ISSUBMITTING":
          return _extends$1({}, state, {
            isSubmitting: msg.payload
          });
        case "SET_ISVALIDATING":
          return _extends$1({}, state, {
            isValidating: msg.payload
          });
        case "SET_FIELD_VALUE":
          return _extends$1({}, state, {
            values: setIn(state.values, msg.payload.field, msg.payload.value)
          });
        case "SET_FIELD_TOUCHED":
          return _extends$1({}, state, {
            touched: setIn(state.touched, msg.payload.field, msg.payload.value)
          });
        case "SET_FIELD_ERROR":
          return _extends$1({}, state, {
            errors: setIn(state.errors, msg.payload.field, msg.payload.value)
          });
        case "RESET_FORM":
          return _extends$1({}, state, msg.payload);
        case "SET_FORMIK_STATE":
          return msg.payload(state);
        case "SUBMIT_ATTEMPT":
          return _extends$1({}, state, {
            touched: setNestedObjectValues(state.values, true),
            isSubmitting: true,
            submitCount: state.submitCount + 1
          });
        case "SUBMIT_FAILURE":
          return _extends$1({}, state, {
            isSubmitting: false
          });
        case "SUBMIT_SUCCESS":
          return _extends$1({}, state, {
            isSubmitting: false
          });
        default:
          return state;
      }
    }
    var emptyErrors = {};
    var emptyTouched = {};
    function useFormik(_ref) {
      var _ref$validateOnChange = _ref.validateOnChange, validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange, _ref$validateOnBlur = _ref.validateOnBlur, validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur, _ref$validateOnMount = _ref.validateOnMount, validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount, isInitialValid = _ref.isInitialValid, _ref$enableReinitiali = _ref.enableReinitialize, enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali, onSubmit = _ref.onSubmit, rest = _objectWithoutPropertiesLoose(_ref, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"]);
      var props = _extends$1({
        validateOnChange,
        validateOnBlur,
        validateOnMount,
        onSubmit
      }, rest);
      var initialValues = reactExports.useRef(props.initialValues);
      var initialErrors = reactExports.useRef(props.initialErrors || emptyErrors);
      var initialTouched = reactExports.useRef(props.initialTouched || emptyTouched);
      var initialStatus = reactExports.useRef(props.initialStatus);
      var isMounted = reactExports.useRef(false);
      var fieldRegistry = reactExports.useRef({});
      reactExports.useEffect(function() {
        isMounted.current = true;
        return function() {
          isMounted.current = false;
        };
      }, []);
      var _React$useState = reactExports.useState(0), setIteration = _React$useState[1];
      var stateRef = reactExports.useRef({
        values: cloneDeep(props.initialValues),
        errors: cloneDeep(props.initialErrors) || emptyErrors,
        touched: cloneDeep(props.initialTouched) || emptyTouched,
        status: cloneDeep(props.initialStatus),
        isSubmitting: false,
        isValidating: false,
        submitCount: 0
      });
      var state = stateRef.current;
      var dispatch = reactExports.useCallback(function(action) {
        var prev2 = stateRef.current;
        stateRef.current = formikReducer(prev2, action);
        if (prev2 !== stateRef.current) setIteration(function(x2) {
          return x2 + 1;
        });
      }, []);
      var runValidateHandler = reactExports.useCallback(function(values, field) {
        return new Promise(function(resolve, reject) {
          var maybePromisedErrors = props.validate(values, field);
          if (maybePromisedErrors == null) {
            resolve(emptyErrors);
          } else if (isPromise(maybePromisedErrors)) {
            maybePromisedErrors.then(function(errors) {
              resolve(errors || emptyErrors);
            }, function(actualException) {
              reject(actualException);
            });
          } else {
            resolve(maybePromisedErrors);
          }
        });
      }, [props.validate]);
      var runValidationSchema = reactExports.useCallback(function(values, field) {
        var validationSchema = props.validationSchema;
        var schema = isFunction(validationSchema) ? validationSchema(field) : validationSchema;
        var promise = field && schema.validateAt ? schema.validateAt(field, values) : validateYupSchema(values, schema);
        return new Promise(function(resolve, reject) {
          promise.then(function() {
            resolve(emptyErrors);
          }, function(err) {
            if (err.name === "ValidationError") {
              resolve(yupToFormErrors(err));
            } else {
              reject(err);
            }
          });
        });
      }, [props.validationSchema]);
      var runSingleFieldLevelValidation = reactExports.useCallback(function(field, value) {
        return new Promise(function(resolve) {
          return resolve(fieldRegistry.current[field].validate(value));
        });
      }, []);
      var runFieldLevelValidations = reactExports.useCallback(function(values) {
        var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function(f2) {
          return isFunction(fieldRegistry.current[f2].validate);
        });
        var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function(f2) {
          return runSingleFieldLevelValidation(f2, getIn(values, f2));
        }) : [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")];
        return Promise.all(fieldValidations).then(function(fieldErrorsList) {
          return fieldErrorsList.reduce(function(prev2, curr, index2) {
            if (curr === "DO_NOT_DELETE_YOU_WILL_BE_FIRED") {
              return prev2;
            }
            if (curr) {
              prev2 = setIn(prev2, fieldKeysWithValidation[index2], curr);
            }
            return prev2;
          }, {});
        });
      }, [runSingleFieldLevelValidation]);
      var runAllValidations = reactExports.useCallback(function(values) {
        return Promise.all([runFieldLevelValidations(values), props.validationSchema ? runValidationSchema(values) : {}, props.validate ? runValidateHandler(values) : {}]).then(function(_ref2) {
          var fieldErrors = _ref2[0], schemaErrors = _ref2[1], validateErrors = _ref2[2];
          var combinedErrors = deepmerge_1.all([fieldErrors, schemaErrors, validateErrors], {
            arrayMerge
          });
          return combinedErrors;
        });
      }, [props.validate, props.validationSchema, runFieldLevelValidations, runValidateHandler, runValidationSchema]);
      var validateFormWithHighPriority = useEventCallback(function(values) {
        if (values === void 0) {
          values = state.values;
        }
        dispatch({
          type: "SET_ISVALIDATING",
          payload: true
        });
        return runAllValidations(values).then(function(combinedErrors) {
          if (!!isMounted.current) {
            dispatch({
              type: "SET_ISVALIDATING",
              payload: false
            });
            dispatch({
              type: "SET_ERRORS",
              payload: combinedErrors
            });
          }
          return combinedErrors;
        });
      });
      reactExports.useEffect(function() {
        if (validateOnMount && isMounted.current === true && isEqual(initialValues.current, props.initialValues)) {
          validateFormWithHighPriority(initialValues.current);
        }
      }, [validateOnMount, validateFormWithHighPriority]);
      var resetForm2 = reactExports.useCallback(function(nextState) {
        var values = nextState && nextState.values ? nextState.values : initialValues.current;
        var errors = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};
        var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};
        var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;
        initialValues.current = values;
        initialErrors.current = errors;
        initialTouched.current = touched;
        initialStatus.current = status;
        var dispatchFn = function dispatchFn2() {
          dispatch({
            type: "RESET_FORM",
            payload: {
              isSubmitting: !!nextState && !!nextState.isSubmitting,
              errors,
              touched,
              status,
              values,
              isValidating: !!nextState && !!nextState.isValidating,
              submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === "number" ? nextState.submitCount : 0
            }
          });
        };
        if (props.onReset) {
          var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);
          if (isPromise(maybePromisedOnReset)) {
            maybePromisedOnReset.then(dispatchFn);
          } else {
            dispatchFn();
          }
        } else {
          dispatchFn();
        }
      }, [props.initialErrors, props.initialStatus, props.initialTouched, props.onReset]);
      reactExports.useEffect(function() {
        if (isMounted.current === true && !isEqual(initialValues.current, props.initialValues)) {
          if (enableReinitialize) {
            initialValues.current = props.initialValues;
            resetForm2();
            if (validateOnMount) {
              validateFormWithHighPriority(initialValues.current);
            }
          }
        }
      }, [enableReinitialize, props.initialValues, resetForm2, validateOnMount, validateFormWithHighPriority]);
      reactExports.useEffect(function() {
        if (enableReinitialize && isMounted.current === true && !isEqual(initialErrors.current, props.initialErrors)) {
          initialErrors.current = props.initialErrors || emptyErrors;
          dispatch({
            type: "SET_ERRORS",
            payload: props.initialErrors || emptyErrors
          });
        }
      }, [enableReinitialize, props.initialErrors]);
      reactExports.useEffect(function() {
        if (enableReinitialize && isMounted.current === true && !isEqual(initialTouched.current, props.initialTouched)) {
          initialTouched.current = props.initialTouched || emptyTouched;
          dispatch({
            type: "SET_TOUCHED",
            payload: props.initialTouched || emptyTouched
          });
        }
      }, [enableReinitialize, props.initialTouched]);
      reactExports.useEffect(function() {
        if (enableReinitialize && isMounted.current === true && !isEqual(initialStatus.current, props.initialStatus)) {
          initialStatus.current = props.initialStatus;
          dispatch({
            type: "SET_STATUS",
            payload: props.initialStatus
          });
        }
      }, [enableReinitialize, props.initialStatus, props.initialTouched]);
      var validateField = useEventCallback(function(name) {
        if (fieldRegistry.current[name] && isFunction(fieldRegistry.current[name].validate)) {
          var value = getIn(state.values, name);
          var maybePromise = fieldRegistry.current[name].validate(value);
          if (isPromise(maybePromise)) {
            dispatch({
              type: "SET_ISVALIDATING",
              payload: true
            });
            return maybePromise.then(function(x2) {
              return x2;
            }).then(function(error) {
              dispatch({
                type: "SET_FIELD_ERROR",
                payload: {
                  field: name,
                  value: error
                }
              });
              dispatch({
                type: "SET_ISVALIDATING",
                payload: false
              });
            });
          } else {
            dispatch({
              type: "SET_FIELD_ERROR",
              payload: {
                field: name,
                value: maybePromise
              }
            });
            return Promise.resolve(maybePromise);
          }
        } else if (props.validationSchema) {
          dispatch({
            type: "SET_ISVALIDATING",
            payload: true
          });
          return runValidationSchema(state.values, name).then(function(x2) {
            return x2;
          }).then(function(error) {
            dispatch({
              type: "SET_FIELD_ERROR",
              payload: {
                field: name,
                value: getIn(error, name)
              }
            });
            dispatch({
              type: "SET_ISVALIDATING",
              payload: false
            });
          });
        }
        return Promise.resolve();
      });
      var registerField = reactExports.useCallback(function(name, _ref3) {
        var validate = _ref3.validate;
        fieldRegistry.current[name] = {
          validate
        };
      }, []);
      var unregisterField = reactExports.useCallback(function(name) {
        delete fieldRegistry.current[name];
      }, []);
      var setTouched = useEventCallback(function(touched, shouldValidate) {
        dispatch({
          type: "SET_TOUCHED",
          payload: touched
        });
        var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
        return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
      });
      var setErrors = reactExports.useCallback(function(errors) {
        dispatch({
          type: "SET_ERRORS",
          payload: errors
        });
      }, []);
      var setValues = useEventCallback(function(values, shouldValidate) {
        var resolvedValues = isFunction(values) ? values(state.values) : values;
        dispatch({
          type: "SET_VALUES",
          payload: resolvedValues
        });
        var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
        return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();
      });
      var setFieldError = reactExports.useCallback(function(field, value) {
        dispatch({
          type: "SET_FIELD_ERROR",
          payload: {
            field,
            value
          }
        });
      }, []);
      var setFieldValue = useEventCallback(function(field, value, shouldValidate) {
        dispatch({
          type: "SET_FIELD_VALUE",
          payload: {
            field,
            value
          }
        });
        var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
        return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();
      });
      var executeChange = reactExports.useCallback(function(eventOrTextValue, maybePath) {
        var field = maybePath;
        var val = eventOrTextValue;
        var parsed;
        if (!isString(eventOrTextValue)) {
          if (eventOrTextValue.persist) {
            eventOrTextValue.persist();
          }
          var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;
          var type2 = target.type, name = target.name, id = target.id, value = target.value, checked = target.checked;
          target.outerHTML;
          var options2 = target.options, multiple = target.multiple;
          field = maybePath ? maybePath : name ? name : id;
          val = /number|range/.test(type2) ? (parsed = parseFloat(value), isNaN(parsed) ? "" : parsed) : /checkbox/.test(type2) ? getValueForCheckbox(getIn(state.values, field), checked, value) : options2 && multiple ? getSelectedValues(options2) : value;
        }
        if (field) {
          setFieldValue(field, val);
        }
      }, [setFieldValue, state.values]);
      var handleChange = useEventCallback(function(eventOrPath) {
        if (isString(eventOrPath)) {
          return function(event) {
            return executeChange(event, eventOrPath);
          };
        } else {
          executeChange(eventOrPath);
        }
      });
      var setFieldTouched = useEventCallback(function(field, touched, shouldValidate) {
        if (touched === void 0) {
          touched = true;
        }
        dispatch({
          type: "SET_FIELD_TOUCHED",
          payload: {
            field,
            value: touched
          }
        });
        var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
        return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
      });
      var executeBlur = reactExports.useCallback(function(e2, path2) {
        if (e2.persist) {
          e2.persist();
        }
        var _e$target = e2.target, name = _e$target.name, id = _e$target.id;
        _e$target.outerHTML;
        var field = path2 ? path2 : name ? name : id;
        setFieldTouched(field, true);
      }, [setFieldTouched]);
      var handleBlur = useEventCallback(function(eventOrString) {
        if (isString(eventOrString)) {
          return function(event) {
            return executeBlur(event, eventOrString);
          };
        } else {
          executeBlur(eventOrString);
        }
      });
      var setFormikState = reactExports.useCallback(function(stateOrCb) {
        if (isFunction(stateOrCb)) {
          dispatch({
            type: "SET_FORMIK_STATE",
            payload: stateOrCb
          });
        } else {
          dispatch({
            type: "SET_FORMIK_STATE",
            payload: function payload() {
              return stateOrCb;
            }
          });
        }
      }, []);
      var setStatus = reactExports.useCallback(function(status) {
        dispatch({
          type: "SET_STATUS",
          payload: status
        });
      }, []);
      var setSubmitting = reactExports.useCallback(function(isSubmitting) {
        dispatch({
          type: "SET_ISSUBMITTING",
          payload: isSubmitting
        });
      }, []);
      var submitForm = useEventCallback(function() {
        dispatch({
          type: "SUBMIT_ATTEMPT"
        });
        return validateFormWithHighPriority().then(function(combinedErrors) {
          var isInstanceOfError = combinedErrors instanceof Error;
          var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;
          if (isActuallyValid) {
            var promiseOrUndefined;
            try {
              promiseOrUndefined = executeSubmit();
              if (promiseOrUndefined === void 0) {
                return;
              }
            } catch (error) {
              throw error;
            }
            return Promise.resolve(promiseOrUndefined).then(function(result) {
              if (!!isMounted.current) {
                dispatch({
                  type: "SUBMIT_SUCCESS"
                });
              }
              return result;
            })["catch"](function(_errors) {
              if (!!isMounted.current) {
                dispatch({
                  type: "SUBMIT_FAILURE"
                });
                throw _errors;
              }
            });
          } else if (!!isMounted.current) {
            dispatch({
              type: "SUBMIT_FAILURE"
            });
            if (isInstanceOfError) {
              throw combinedErrors;
            }
          }
          return;
        });
      });
      var handleSubmit = useEventCallback(function(e2) {
        if (e2 && e2.preventDefault && isFunction(e2.preventDefault)) {
          e2.preventDefault();
        }
        if (e2 && e2.stopPropagation && isFunction(e2.stopPropagation)) {
          e2.stopPropagation();
        }
        submitForm()["catch"](function(reason) {
          console.warn("Warning: An unhandled error was caught from submitForm()", reason);
        });
      });
      var imperativeMethods = {
        resetForm: resetForm2,
        validateForm: validateFormWithHighPriority,
        validateField,
        setErrors,
        setFieldError,
        setFieldTouched,
        setFieldValue,
        setStatus,
        setSubmitting,
        setTouched,
        setValues,
        setFormikState,
        submitForm
      };
      var executeSubmit = useEventCallback(function() {
        return onSubmit(state.values, imperativeMethods);
      });
      var handleReset = useEventCallback(function(e2) {
        if (e2 && e2.preventDefault && isFunction(e2.preventDefault)) {
          e2.preventDefault();
        }
        if (e2 && e2.stopPropagation && isFunction(e2.stopPropagation)) {
          e2.stopPropagation();
        }
        resetForm2();
      });
      var getFieldMeta = reactExports.useCallback(function(name) {
        return {
          value: getIn(state.values, name),
          error: getIn(state.errors, name),
          touched: !!getIn(state.touched, name),
          initialValue: getIn(initialValues.current, name),
          initialTouched: !!getIn(initialTouched.current, name),
          initialError: getIn(initialErrors.current, name)
        };
      }, [state.errors, state.touched, state.values]);
      var getFieldHelpers = reactExports.useCallback(function(name) {
        return {
          setValue: function setValue(value, shouldValidate) {
            return setFieldValue(name, value, shouldValidate);
          },
          setTouched: function setTouched2(value, shouldValidate) {
            return setFieldTouched(name, value, shouldValidate);
          },
          setError: function setError(value) {
            return setFieldError(name, value);
          }
        };
      }, [setFieldValue, setFieldTouched, setFieldError]);
      var getFieldProps = reactExports.useCallback(function(nameOrOptions) {
        var isAnObject = isObject(nameOrOptions);
        var name = isAnObject ? nameOrOptions.name : nameOrOptions;
        var valueState = getIn(state.values, name);
        var field = {
          name,
          value: valueState,
          onChange: handleChange,
          onBlur: handleBlur
        };
        if (isAnObject) {
          var type2 = nameOrOptions.type, valueProp = nameOrOptions.value, is2 = nameOrOptions.as, multiple = nameOrOptions.multiple;
          if (type2 === "checkbox") {
            if (valueProp === void 0) {
              field.checked = !!valueState;
            } else {
              field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));
              field.value = valueProp;
            }
          } else if (type2 === "radio") {
            field.checked = valueState === valueProp;
            field.value = valueProp;
          } else if (is2 === "select" && multiple) {
            field.value = field.value || [];
            field.multiple = true;
          }
        }
        return field;
      }, [handleBlur, handleChange, state.values]);
      var dirty = reactExports.useMemo(function() {
        return !isEqual(initialValues.current, state.values);
      }, [initialValues.current, state.values]);
      var isValid = reactExports.useMemo(function() {
        return typeof isInitialValid !== "undefined" ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;
      }, [isInitialValid, dirty, state.errors, props]);
      var ctx = _extends$1({}, state, {
        initialValues: initialValues.current,
        initialErrors: initialErrors.current,
        initialTouched: initialTouched.current,
        initialStatus: initialStatus.current,
        handleBlur,
        handleChange,
        handleReset,
        handleSubmit,
        resetForm: resetForm2,
        setErrors,
        setFormikState,
        setFieldTouched,
        setFieldValue,
        setFieldError,
        setStatus,
        setSubmitting,
        setTouched,
        setValues,
        submitForm,
        validateForm: validateFormWithHighPriority,
        validateField,
        isValid,
        dirty,
        unregisterField,
        registerField,
        getFieldProps,
        getFieldMeta,
        getFieldHelpers,
        validateOnBlur,
        validateOnChange,
        validateOnMount
      });
      return ctx;
    }
    function Formik(props) {
      var formikbag = useFormik(props);
      var component = props.component, children = props.children, render2 = props.render, innerRef = props.innerRef;
      reactExports.useImperativeHandle(innerRef, function() {
        return formikbag;
      });
      return reactExports.createElement(FormikProvider, {
        value: formikbag
      }, component ? reactExports.createElement(component, formikbag) : render2 ? render2(formikbag) : children ? isFunction(children) ? children(formikbag) : !isEmptyChildren(children) ? reactExports.Children.only(children) : null : null);
    }
    function yupToFormErrors(yupError) {
      var errors = {};
      if (yupError.inner) {
        if (yupError.inner.length === 0) {
          return setIn(errors, yupError.path, yupError.message);
        }
        for (var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
          var _ref5;
          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref5 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref5 = _i.value;
          }
          var err = _ref5;
          if (!getIn(errors, err.path)) {
            errors = setIn(errors, err.path, err.message);
          }
        }
      }
      return errors;
    }
    function validateYupSchema(values, schema, sync, context) {
      if (sync === void 0) {
        sync = false;
      }
      var normalizedValues = prepareDataForValidation(values);
      return schema[sync ? "validateSync" : "validate"](normalizedValues, {
        abortEarly: false,
        context: normalizedValues
      });
    }
    function prepareDataForValidation(values) {
      var data = Array.isArray(values) ? [] : {};
      for (var k2 in values) {
        if (Object.prototype.hasOwnProperty.call(values, k2)) {
          var key = String(k2);
          if (Array.isArray(values[key]) === true) {
            data[key] = values[key].map(function(value) {
              if (Array.isArray(value) === true || isPlainObject(value)) {
                return prepareDataForValidation(value);
              } else {
                return value !== "" ? value : void 0;
              }
            });
          } else if (isPlainObject(values[key])) {
            data[key] = prepareDataForValidation(values[key]);
          } else {
            data[key] = values[key] !== "" ? values[key] : void 0;
          }
        }
      }
      return data;
    }
    function arrayMerge(target, source, options2) {
      var destination = target.slice();
      source.forEach(function merge2(e2, i2) {
        if (typeof destination[i2] === "undefined") {
          var cloneRequested = options2.clone !== false;
          var shouldClone = cloneRequested && options2.isMergeableObject(e2);
          destination[i2] = shouldClone ? deepmerge_1(Array.isArray(e2) ? [] : {}, e2, options2) : e2;
        } else if (options2.isMergeableObject(e2)) {
          destination[i2] = deepmerge_1(target[i2], e2, options2);
        } else if (target.indexOf(e2) === -1) {
          destination.push(e2);
        }
      });
      return destination;
    }
    function getSelectedValues(options2) {
      return Array.from(options2).filter(function(el) {
        return el.selected;
      }).map(function(el) {
        return el.value;
      });
    }
    function getValueForCheckbox(currentValue, checked, valueProp) {
      if (typeof currentValue === "boolean") {
        return Boolean(checked);
      }
      var currentArrayOfValues = [];
      var isValueInArray = false;
      var index2 = -1;
      if (!Array.isArray(currentValue)) {
        if (!valueProp || valueProp == "true" || valueProp == "false") {
          return Boolean(checked);
        }
      } else {
        currentArrayOfValues = currentValue;
        index2 = currentValue.indexOf(valueProp);
        isValueInArray = index2 >= 0;
      }
      if (checked && valueProp && !isValueInArray) {
        return currentArrayOfValues.concat(valueProp);
      }
      if (!isValueInArray) {
        return currentArrayOfValues;
      }
      return currentArrayOfValues.slice(0, index2).concat(currentArrayOfValues.slice(index2 + 1));
    }
    var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
    function useEventCallback(fn) {
      var ref = reactExports.useRef(fn);
      useIsomorphicLayoutEffect(function() {
        ref.current = fn;
      });
      return reactExports.useCallback(function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return ref.current.apply(void 0, args);
      }, []);
    }
    function useField(propsOrFieldName) {
      var formik = useFormikContext();
      var getFieldProps = formik.getFieldProps, getFieldMeta = formik.getFieldMeta, getFieldHelpers = formik.getFieldHelpers, registerField = formik.registerField, unregisterField = formik.unregisterField;
      var isAnObject = isObject(propsOrFieldName);
      var props = isAnObject ? propsOrFieldName : {
        name: propsOrFieldName
      };
      var fieldName = props.name, validateFn = props.validate;
      reactExports.useEffect(function() {
        if (fieldName) {
          registerField(fieldName, {
            validate: validateFn
          });
        }
        return function() {
          if (fieldName) {
            unregisterField(fieldName);
          }
        };
      }, [registerField, unregisterField, fieldName, validateFn]);
      var fieldHelpers = reactExports.useMemo(function() {
        return getFieldHelpers(fieldName);
      }, [getFieldHelpers, fieldName]);
      return [getFieldProps(props), getFieldMeta(fieldName), fieldHelpers];
    }
    var Form = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var action = props.action, rest = _objectWithoutPropertiesLoose(props, ["action"]);
      var _action = action != null ? action : "#";
      var _useFormikContext = useFormikContext(), handleReset = _useFormikContext.handleReset, handleSubmit = _useFormikContext.handleSubmit;
      return reactExports.createElement("form", _extends$1({
        onSubmit: handleSubmit,
        ref,
        onReset: handleReset,
        action: _action
      }, rest));
    });
    Form.displayName = "Form";
    function k(e2, n2) {
      var t2 = {};
      for (var r2 in e2) Object.prototype.hasOwnProperty.call(e2, r2) && n2.indexOf(r2) < 0 && (t2[r2] = e2[r2]);
      if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
        var a = 0;
        for (r2 = Object.getOwnPropertySymbols(e2); a < r2.length; a++) n2.indexOf(r2[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, r2[a]) && (t2[r2[a]] = e2[r2[a]]);
      }
      return t2;
    }
    function C$1(e2, n2, t2, r2) {
      return new (t2 || (t2 = Promise))(function(a, o2) {
        function i2(e3) {
          try {
            u2(r2.next(e3));
          } catch (e4) {
            o2(e4);
          }
        }
        function s(e3) {
          try {
            u2(r2.throw(e3));
          } catch (e4) {
            o2(e4);
          }
        }
        function u2(e3) {
          var n3;
          e3.done ? a(e3.value) : (n3 = e3.value, n3 instanceof t2 ? n3 : new t2(function(e4) {
            e4(n3);
          })).then(i2, s);
        }
        u2((r2 = r2.apply(e2, [])).next());
      });
    }
    const P = i.createContext(void 0);
    function x$1() {
      return reactExports.useContext(P);
    }
    const w = (e2) => e2, T = { useTranslation: () => w };
    function _$1(e2) {
      return (function() {
        const e3 = x$1();
        return e3 ? e3 + "." : "";
      }() + e2).replace(/\[\d+\]/g, "");
    }
    function B(e2, n2) {
      const t2 = "string" == typeof e2 ? e2 : e2.name;
      n2 = "string" == typeof e2 ? n2 : e2.label;
      const r2 = T.useTranslation(), a = _$1(t2);
      if (false !== n2) return n2 && true !== n2 ? n2 : r2(a);
    }
    function R(e2) {
      let n2 = 0;
      return Object.entries(e2).forEach(([e3, t2]) => {
        Array.isArray(t2) ? n2 += I(t2) : "object" == typeof t2 && null !== t2 ? n2 += R(t2) : n2++;
      }), n2;
    }
    function I(e2) {
      let n2 = 0;
      return e2.forEach((e3) => {
        Array.isArray(e3) ? n2 += I(e3) : "object" == typeof e3 && null !== e3 ? n2 += R(e3) : n2++;
      }), n2;
    }
    function A(e2) {
      const n2 = function(e3) {
        const { name: n3, mode: t3 = "touched" } = e3, [, { error: r2, touched: a }] = useField(n3), i2 = !!r2;
        return reactExports.useMemo(() => i2 && ("always" === t3 || a), [i2, t3, a]);
      }(e2), t2 = function(e3) {
        const { name: n3, label: t3 } = e3, [, { error: r2 }] = useField(n3), a = T.useTranslation();
        return reactExports.useMemo(() => {
          if ("string" == typeof r2) return r2;
          if ("object" == typeof (e4 = r2) && e4.hasOwnProperty("key") && null != e4.key) {
            const e5 = r2;
            return a(`errors.${e5.key}`, Object.assign(Object.assign({}, e5), { label: t3 }));
          }
          var e4;
          if (Array.isArray(r2)) return a("errors.inner", { count: I(r2), label: t3, error: r2 });
          if ("object" == typeof r2 && null !== r2) {
            const e5 = R(r2);
            if (e5 > 0) return a("errors.inner", { count: e5, label: t3, error: r2 });
          }
          return String(r2).toString();
        }, [r2, a, t3]);
      }(e2);
      return reactExports.useMemo(() => ({ show: n2, error: t2 }), [n2, t2]);
    }
    const E = reactExports.memo((n2) => {
      const { error: t2, show: r2 } = n2;
      return r2 ? jsxRuntimeExports.jsx("span", { children: t2 }) : null;
    });
    E.displayName = "Form.ErrorMessage";
    const M = (n2) => {
      const t2 = A(n2);
      return jsxRuntimeExports.jsx(E, Object.assign({}, t2));
    };
    M.displayName = "Form.ErrorMessage";
    const D = i.createContext(void 0);
    function V() {
      return reactExports.useContext(D);
    }
    function L(e2, n2 = true) {
      var t2;
      const { name: r2 } = null !== (t2 = V()) && void 0 !== t2 ? t2 : {};
      if (e2 && n2) return e2;
      if (null == r2 && null == e2) throw new Error("`<Form.Item /> might wrap component or `name` should be provided");
      return r2 ? e2 ? r2 + "." + e2 : r2 : e2;
    }
    const z = reactExports.memo((n2) => {
      const { error: t2, show: r2, help: a, validateStatus: o2, noErrorMessage: i2 = false } = n2, s = k(n2, ["error", "show", "help", "validateStatus", "noErrorMessage"]), u2 = i2 ? void 0 : null != a ? a : r2 ? t2 : void 0, l2 = null != o2 ? o2 : r2 ? "error" : "";
      return jsxRuntimeExports.jsx(Form$1.Item, Object.assign({}, s, { validateStatus: l2, help: u2 }));
    }), W = i.createContext(false);
    function Y() {
      return reactExports.useContext(W);
    }
    function $(e2) {
      var n2;
      const t2 = "object" == typeof e2 ? e2.disabled : e2;
      return null !== (n2 = Y()) && void 0 !== n2 && n2 || t2 || false;
    }
    function q(e2) {
      const n2 = reactExports.useRef(e2);
      return n2.current = e2, n2;
    }
    function H(e2) {
      const n2 = "string" == typeof e2 ? e2 : e2.name, [, , { setTouched: t2 }] = useField(n2), r2 = q(t2);
      return reactExports.useCallback(() => r2.current(true, true), [r2]);
    }
    function J(e2, n2) {
      const t2 = "string" == typeof e2 ? e2 : e2.name, [, , { setValue: r2, setTouched: a }] = useField(t2), o2 = q(a), i2 = q(r2);
      return reactExports.useCallback((...e3) => {
        o2.current(true), i2.current(n2 ? n2.call(null, ...e3) : e3[0], true);
      }, [n2, o2, i2]);
    }
    const K = reactExports.memo((n2) => {
      const { name: t2 } = n2, r2 = k(n2, ["name"]);
      return jsxRuntimeExports.jsx(Input$1, Object.assign({ name: t2 }, r2));
    });
    K.displayName = "Form.Input";
    const Q = (n2) => {
      const t2 = Object.assign(Object.assign({}, U), n2), { name: r2, mapGet: a, mapSet: o2 } = t2, i2 = k(t2, ["name", "mapGet", "mapSet"]), s = L(r2), u2 = useField(s), l2 = $(n2), c2 = H(s), m2 = J(s, o2);
      return jsxRuntimeExports.jsx(K, Object.assign({}, i2, { name: s, value: a(u2), onChange: m2, onBlur: c2, disabled: l2 }));
    }, U = { mapGet: ([{ value: e2 = "" }]) => e2, mapSet: (e2) => {
      var n2, t2;
      return 0 === (null === (n2 = e2.target.value) || void 0 === n2 ? void 0 : n2.length) ? null : null !== (t2 = e2.target.value) && void 0 !== t2 ? t2 : null;
    } };
    Q.defaultProps = Object.assign({}, U), Q.displayName = "Form.Input";
    const X = {}, Z = {};
    const ee = { set: function(e2, n2) {
      !function(e3, n3) {
        var r2;
        X[e3] = null !== (r2 = X[e3]) && void 0 !== r2 ? r2 : i.createRef(), X[e3].current = n3;
      }(e2, n2), function(e3, n3) {
        var t2;
        const { values: r2 } = n3, a = null !== (t2 = Z[e3]) && void 0 !== t2 ? t2 : [];
        for (const e4 of a) e4(r2);
      }(e2, n2);
    }, getRef: function(e2) {
      var n2;
      return X[e2] = null !== (n2 = X[e2]) && void 0 !== n2 ? n2 : i.createRef(), X[e2];
    }, subscribe: function(e2, n2, t2) {
      var r2;
      Z[e2] = null !== (r2 = Z[e2]) && void 0 !== r2 ? r2 : [];
      const a = (e3) => t2(getIn(e3, n2));
      return Z[e2].push(a), () => {
        Z[e2] = Z[e2].slice().splice(Z[e2].indexOf(a), 1);
      };
    }, destroy: function(e2) {
      X[e2] && (X[e2].current = void 0), Z[e2] = void 0;
    } };
    function ne(t2) {
      const { children: r2, uid: a } = t2, o2 = useFormikContext();
      return function(e2) {
        const n2 = useFormikContext();
        reactExports.useEffect(() => {
          ee.set(e2, n2);
        }, [n2, e2]), reactExports.useEffect(() => () => {
          ee.destroy(e2);
        }, [e2]);
      }(a), "function" == typeof r2 ? r2(o2) : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: r2 });
    }
    function te(n2) {
      const { uid: t2, children: r2, ns: a } = n2, o2 = k(n2, ["uid", "children", "ns"]);
      return jsxRuntimeExports.jsx(P.Provider, { value: a, children: jsxRuntimeExports.jsx(D.Provider, { value: void 0, children: jsxRuntimeExports.jsx(Formik, Object.assign({}, o2, { children: jsxRuntimeExports.jsx(ne, { uid: t2, children: r2 }) })) }) });
    }
    function re(e2) {
      return ee.getRef(e2);
    }
    const ae = ({ onSubmitted: e2, onClick: n2 }, t2) => reactExports.useCallback((r2) => C$1(void 0, void 0, void 0, function* () {
      const a = yield t2.current.validateForm(), o2 = 0 === Object.keys(a).length;
      yield t2.current.submitForm(), o2 && e2 && e2(), n2 && n2(r2);
    }), [t2, e2, n2]);
    function oe(n2) {
      const t2 = useFormikContext(), r2 = ae(n2, { current: t2 });
      return jsxRuntimeExports.jsx(Button$1, Object.assign({}, n2, { onClick: r2 }));
    }
    function ie(n2) {
      const { uid: t2, onSubmitted: r2 } = n2, a = k(n2, ["uid", "onSubmitted"]), o2 = re(t2), i2 = ae(n2, o2);
      return jsxRuntimeExports.jsx(Button$1, Object.assign({}, a, { onClick: i2 }));
    }
    const ue = ["uid", "ns", "component", "render", "initialValues", "initialStatus", "initialErrors", "initialTouched", "onReset", "onSubmit", "validationSchema", "validate", "innerRef", "validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize"];
    const le = (n2) => {
      if (!function(e2) {
        return "formik" === e2.type;
      }(n2)) return jsxRuntimeExports.jsx(Form$1, Object.assign({}, n2));
      const [t2, r2, a] = function(e2) {
        const n3 = {}, t3 = {};
        for (const [r3, a2] of Object.entries(e2)) ue.includes(r3) ? n3[r3] = a2 : "children" !== r3 && (t3[r3] = a2);
        return [n3, t3, e2.children];
      }(n2), { onSubmit: o2, validationSchema: i2 } = t2, u2 = reactExports.useCallback((e2, n3) => C$1(void 0, void 0, void 0, function* () {
        try {
          const r3 = (t3 = i2) && "object" == typeof t3 && true === t3.__isYupSchema__ ? yield i2.validate(e2) : e2;
          yield Promise.resolve(null == o2 ? void 0 : o2(r3, n3));
        } finally {
          n3.setSubmitting(false);
        }
        var t3;
      }), [i2, o2]);
      return jsxRuntimeExports.jsx(te, "function" == typeof a ? Object.assign({}, t2, { onSubmit: u2, children: (n3) => jsxRuntimeExports.jsx(Form$1, Object.assign({}, r2, { children: a(n3) })) }) : Object.assign({}, t2, { onSubmit: u2, children: jsxRuntimeExports.jsx(Form$1, Object.assign({}, r2, { children: a })) }));
    };
    le.displayName = "Form", le.defaultProps = {};
    let ce = function(n2) {
      const t2 = k(n2, ["name"]);
      return jsxRuntimeExports.jsx(Select$1, Object.assign({}, t2));
    };
    ce.displayName = "Form.Select", ce = reactExports.memo(ce);
    const me = function(n2) {
      const { name: t2, valueType: r2 } = n2, a = k(n2, ["name", "valueType"]), i2 = L(t2), u2 = function(e2, n3, t3 = "value") {
        var r3;
        const { value: a2 = "value" } = null !== (r3 = e2.fieldNames) && void 0 !== r3 ? r3 : {}, [{ value: i3 }] = useField(n3);
        return reactExports.useMemo(() => "value" === t3 ? i3 : i3 ? i3[a2] : i3, [i3, a2, t3]);
      }(n2, i2, r2), l2 = $(n2), c2 = function(e2 = "value") {
        return reactExports.useCallback((n3, t3) => "value" === e2 ? null != n3 ? n3 : null : null != t3 ? t3 : null, [e2]);
      }(r2), m2 = J(i2, c2), d2 = H(i2);
      return jsxRuntimeExports.jsx(ce, Object.assign({}, a, { name: i2, value: u2, onChange: m2, onBlur: d2, disabled: l2 }));
    };
    me.displayName = "Form.Select";
    const de = reactExports.memo((n2) => jsxRuntimeExports.jsx(Checkbox, Object.assign({}, n2)));
    de.displayName = "Form.Checkbox";
    const pe = (n2) => {
      const { name: t2, mapGet: r2, mapSet: a } = n2, o2 = k(n2, ["name", "mapGet", "mapSet"]), i2 = L(t2), s = useField({ name: i2, type: "checkbox" }), u2 = J(i2, a), l2 = $(n2);
      return jsxRuntimeExports.jsx(de, Object.assign({}, o2, { name: i2, onChange: u2, checked: r2(s), disabled: l2 }));
    };
    pe.displayName = "Form.Checkbox", pe.defaultProps = Object.assign({}, { mapSet: (e2) => e2.target.checked, mapGet: ([{ value: e2 }]) => !!e2 });
    const fe = reactExports.memo((n2) => jsxRuntimeExports.jsx(Input$1.TextArea, Object.assign({}, n2)));
    fe.displayName = "Form.TextArea";
    const ve = (n2) => {
      const { name: t2, mapGet: r2 = be.mapGet, mapSet: a = be.mapSet } = n2, o2 = k(n2, ["name", "mapGet", "mapSet"]), i2 = L(t2), s = useField(i2), u2 = $(n2), l2 = J(i2, a), c2 = H(i2);
      return jsxRuntimeExports.jsx(fe, Object.assign({}, o2, { name: i2, disabled: u2, onChange: l2, onBlur: c2, value: r2(s) }));
    }, be = { mapGet: ([{ value: e2 }]) => null != e2 ? e2 : "", mapSet: (e2) => {
      var n2, t2;
      return 0 === (null === (n2 = e2.target.value) || void 0 === n2 ? void 0 : n2.length) ? null : null !== (t2 = e2.target.value) && void 0 !== t2 ? t2 : null;
    } };
    ve.displayName = "Form.TextArea";
    const he = reactExports.memo((n2) => jsxRuntimeExports.jsx(DatePicker, Object.assign({}, n2)));
    he.displayName = "Form.DatePicker";
    const ge = (n2) => {
      const { name: t2, mapGet: r2, mapSet: a } = Object.assign(Object.assign({}, ye), n2), i2 = L(t2), s = useField(i2), u2 = $(n2), l2 = J(i2, a), c2 = H(i2), m2 = r2(s), d2 = reactExports.useMemo(() => m2, [null == m2 ? void 0 : m2.toISOString()]);
      return jsxRuntimeExports.jsx(he, Object.assign({}, n2, { picker: n2.picker, name: i2, disabled: u2, onChange: l2, onBlur: c2, value: d2 }));
    }, ye = { mapGet: ([{ value: e2 = null }]) => null != e2 ? N(e2) : e2, mapSet: (e2) => e2 };
    ge.defaultProps = Object.assign({}, ye), ge.displayName = "Form.DatePicker";
    let Oe = reactExports.memo((n2) => jsxRuntimeExports.jsx(TypedInputNumber, Object.assign({}, n2)));
    Oe.displayName = "Form.InputNumber", Oe = reactExports.memo(Oe);
    const je = (n2) => {
      const { name: t2, mapGet: r2 = Se.mapGet, mapSet: a = Se.mapSet } = n2, o2 = k(n2, ["name", "mapGet", "mapSet"]), i2 = L(t2), s = useField(i2), u2 = $(n2), l2 = J(i2, a), c2 = H(i2);
      return jsxRuntimeExports.jsx(Oe, Object.assign({}, o2, { name: i2, value: r2(s), onChange: l2, onBlur: c2, disabled: u2 }));
    }, Se = { mapSet: (e2) => null != e2 ? e2 : null, mapGet: ([{ value: e2 }]) => null != e2 ? e2 : null };
    je.defaultProps = Object.assign({}, Se), je.displayName = "Form.InputNumber";
    const Ge = reactExports.memo((n2) => jsxRuntimeExports.jsx(Radio.Group, Object.assign({}, n2)));
    Ge.displayName = "Form.RadioGroup";
    const Fe = (n2) => {
      const { name: t2, mapGet: r2 = Ne.mapGet, mapSet: a = Ne.mapSet } = n2, o2 = k(n2, ["name", "mapGet", "mapSet"]), i2 = L(t2), s = useField(i2), u2 = J(i2, a), l2 = $(n2);
      return jsxRuntimeExports.jsx(Ge, Object.assign({}, o2, { name: i2, value: r2(s), onChange: u2, disabled: l2 }));
    }, Ne = { mapGet: ([{ value: e2 }]) => null != e2 ? e2 : null, mapSet: (e2) => {
      var n2;
      return null !== (n2 = e2.target.value) && void 0 !== n2 ? n2 : null;
    } };
    Fe.defaultProps = Object.assign({}, Ne), Fe.displayName = "Form.RadioGroup";
    const ke = reactExports.memo((n2) => jsxRuntimeExports.jsx(Switch$1, Object.assign({}, n2)));
    ke.displayName = "Form.Switch";
    const Ce = (n2) => {
      const { name: t2, mapGet: r2 = Pe.mapGet, mapSet: a = Pe.mapSet } = n2, o2 = k(n2, ["name", "mapGet", "mapSet"]), i2 = L(t2), s = useField(i2), u2 = $(n2), l2 = J(i2, a);
      return jsxRuntimeExports.jsx(ke, Object.assign({}, o2, { name: i2, checked: r2(s), disabled: u2, onChange: l2 }));
    }, Pe = { mapGet: ([{ value: e2 }]) => !!e2, mapSet: (e2) => e2 };
    Ce.defaultProps = Object.assign({}, Pe), Ce.displayName = "Form.Switch";
    const xe = [], we = reactExports.memo((n2) => jsxRuntimeExports.jsx(Checkbox.Group, Object.assign({}, n2)));
    we.displayName = "Form.CheckboxGroup";
    const Te = (n2) => {
      const { name: t2, mapGet: r2 = _e.mapGet, mapSet: a = _e.mapSet } = n2, o2 = k(n2, ["name", "mapGet", "mapSet"]), i2 = L(t2), s = useField(i2), u2 = $(n2), l2 = J(i2, a);
      return jsxRuntimeExports.jsx(we, Object.assign({}, o2, { value: r2(s), onChange: l2, name: i2, disabled: u2 }));
    }, _e = { mapSet: (e2) => e2, mapGet: ([{ value: e2 }]) => null != e2 ? e2 : xe };
    Te.displayName = "Form.CheckboxGroup";
    const Be = reactExports.memo((n2) => {
      const { value: t2 } = n2, r2 = k(n2, ["value"]);
      return jsxRuntimeExports.jsx(Typography.Text, Object.assign({}, r2, { children: t2 }));
    });
    Be.displayName = "Form.Text";
    const Re = (n2) => {
      const { name: t2, mapGet: r2 = Ie.mapGet } = n2, a = k(n2, ["name", "mapGet"]), o2 = L(t2), i2 = useField(o2);
      return jsxRuntimeExports.jsx(Be, Object.assign({}, a, { value: r2(i2) }));
    }, Ie = { mapGet: ([{ value: e2 }]) => e2 };
    Re.defaultProps = Object.assign({}, Ie), Re.displayName = "Form.Text";
    const Ae = reactExports.memo((n2) => jsxRuntimeExports.jsx(TimePicker, Object.assign({}, n2)));
    Ae.displayName = "Form.TimePicker";
    const Ee = (n2) => {
      const t2 = Object.assign(Object.assign({}, Me), n2), { name: r2, mapGet: a, mapSet: i2, value: s, onChange: u2, onBlur: l2 } = t2, c2 = k(t2, ["name", "mapGet", "mapSet", "value", "onChange", "onBlur"]), m2 = L(r2), d2 = useField(m2), p2 = $(n2), f2 = J(m2, i2), v2 = H(m2), b2 = reactExports.useMemo(() => a(d2), [d2, a]);
      return jsxRuntimeExports.jsx(Ae, Object.assign({}, c2, { name: m2, disabled: p2, onChange: f2, onBlur: v2, value: b2 }));
    }, Me = { mapGet: ([{ value: e2 = null }]) => "string" == typeof e2 ? N(e2) : e2, mapSet: (e2) => e2 };
    Ee.defaultProps = Object.assign({}, Me), Ee.displayName = "Form.TimePicker";
    const De = { Item: (n2) => {
      const { name: t2, nameAbsolute: r2 = false } = n2, a = L(t2, r2), i2 = B(a, n2.label), s = A({ name: a, label: i2 }), u2 = reactExports.useMemo(() => ({ name: a }), [a]);
      return jsxRuntimeExports.jsx(D.Provider, { value: u2, children: jsxRuntimeExports.jsx(z, Object.assign({}, n2, s, { label: i2 })) });
    }, Input: Q, TextArea: ve, Text: Re, Formik: te, Submit: (n2) => {
      var t2;
      const r2 = Y(), a = null !== (t2 = n2.disabled) && void 0 !== t2 ? t2 : r2;
      return n2.uid ? jsxRuntimeExports.jsx(ie, Object.assign({}, n2, { disabled: a })) : jsxRuntimeExports.jsx(oe, Object.assign({}, n2, { disabled: a }));
    }, FieldSet: function(n2) {
      const { disabled: t2, children: r2 } = n2;
      return jsxRuntimeExports.jsx(W.Provider, { value: !!t2, children: jsxRuntimeExports.jsx("fieldset", { disabled: !!t2, children: r2 }) });
    }, Select: me, Checkbox: pe, DatePicker: ge, TimePicker: Ee, InputNumber: je, RadioGroup: Fe, ErrorMessage: M, Switch: Ce, CheckboxGroup: Te, useWatch: function(e2, n2) {
      const t2 = re(e2), [r2, a] = reactExports.useState(() => (null == t2 ? void 0 : t2.current) ? getIn(null == t2 ? void 0 : t2.current, n2) : void 0), o2 = reactExports.useRef(r2);
      return reactExports.useEffect(() => {
        var t3, i2;
        const s = (null === (t3 = ee.getRef(e2)) || void 0 === t3 ? void 0 : t3.current) ? getIn(ee.getRef(null === (i2 = ee.getRef(e2).current) || void 0 === i2 ? void 0 : i2.values), n2) : void 0;
        r2 !== s && (o2.current = s, a(s));
        const u2 = ee.subscribe(e2, n2, (e3) => {
          o2.current !== e3 && (o2.current = e3, a(e3));
        });
        return () => {
          a(void 0), o2.current = void 0, u2();
        };
      }, [e2, n2]), r2;
    }, useRef: re, useSubmit: function(e2) {
      const n2 = re(e2);
      return reactExports.useCallback(() => {
        if (n2.current) return n2.current.submitForm();
      }, [n2]);
    }, useLabel: B, useDisabled: $, useName: L, useValidate: function(e2) {
      const n2 = re(e2);
      return reactExports.useCallback(() => n2.current.validateForm().then((e3) => {
        var t2;
        const r2 = 0 === Object.keys(e3).length;
        return r2 || null === (t2 = n2.current) || void 0 === t2 || t2.submitForm(), r2;
      }), [n2]);
    } }, Ve = Object.assign(le, De, {}, { settings: T });
    const RadioGroup = createElement({
      id: "RadioGroup",
      title: "Radio Group",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$c, {}),
      props: create$3({
        title: create$6().required().default("Select").label("Title"),
        options: create$2().of(create$6().required()).required().default(["A", "B", "C"]).label("Options").min(1, "At least one option is required").meta({ description: "Options for the radio group, each option is a string." }),
        optionType: create$6().oneOf(["default", "button"]).default("default").nullable().label("Option Type").meta({ description: "Type of radio options, either default or button." })
      }),
      Component: ({ name, title, options: options2, optionType, required: required2 }) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Item, { name, label: title, required: required2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.RadioGroup, { options: options2, optionType: optionType ?? void 0 }) });
      }
    });
    const CheckboxGroup = createElement({
      id: "CheckboxGroup",
      title: "Checkbox Group",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$b, {}),
      props: create$3({
        title: create$6().default("Checkbox").label("Title").nullable(),
        description: create$6().nullable().default(null).label("Description"),
        options: create$2().of(create$6().required()).required().default(["A", "B", "C"]).label("Options"),
        disabled: create$7().nullable().default(null).label("Disabled When").meta({ control: "expression" })
      }),
      Component: ({ title, description, options: options2, name, disabled }) => {
        const label = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: title }),
          description && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography.Text, { type: "secondary", style: { fontSize: "0.875rem" }, children: description }) })
        ] });
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Item, { name, label, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.CheckboxGroup, { options: options2, disabled: disabled ?? void 0 }) });
      }
    });
    const Divider = createElement({
      id: "Divider",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$4, {}),
      props: create$3({
        marginTop: create$6().oneOf(Object.keys(Style.margin)).label("Margin Top").default("none").required(),
        marginBottom: create$6().oneOf(Object.keys(Style.margin)).label("Margin Bottom").default("none").required()
      }),
      Component: ({ marginBottom, marginTop }) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Divider$1, { style: { marginBottom: Style.margin[marginBottom], marginTop: Style.margin[marginTop] } });
      }
    });
    const Input = createElement({
      id: "Input",
      props: create$3({
        title: create$6().required().default("Input").label("Title").meta({ description: "Input field title" }),
        type: create$6().oneOf(["input", "textarea"]).default("input").label("Type").required(),
        htmlType: create$6().oneOf(["text", "email", "password"]).default("text").label("HTML Type").meta({
          description: "HTML input type.\n\nWhen `email` selected, browser will auto suggest users email.\n\nWhen `password` selected, input will be masked."
        }),
        placeholder: create$6().label("Placeholder").nullable(),
        disabled: create$7().nullable().default(null).label("Disabled When").meta({ control: "expression" })
      }),
      Component: ({ title, name, placeholder, type: type2, required: required2, htmlType }) => {
        const [{ value }] = useField(name);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Ve.Item, { label: title, name, required: required2, children: [
          type2 === "textarea" && /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.TextArea, { value: value ?? "", placeholder: placeholder ?? void 0 }),
          type2 === "input" && /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Input, { type: htmlType, placeholder: placeholder ?? void 0 })
        ] });
      }
    });
    const Select = createElement({
      id: "Select",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$r, {}),
      props: create$3({
        title: create$6().required().default("Select").label("Title"),
        options: create$2().of(create$6().required()).required().default(["A", "B", "C"]).label("Options"),
        disabled: create$7().nullable().default(null).label("Disabled When").meta({ control: "expression" })
      }),
      Component: ({ title, options: options2, name, disabled, required: required2 }) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Item, { label: title, name, required: required2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Ve.Select,
          {
            disabled: disabled ?? void 0,
            options: options2.map((x2) => ({ label: x2, value: x2 })),
            allowClear: !required2
          }
        ) });
      }
    });
    const Rate = createElement({
      id: "Rate",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$1, {}),
      props: create$3({
        title: create$6().required().default("Rate").label("Title").meta({ description: "Rate component" }),
        count: create$5().required().default(5).label("Count"),
        disabled: create$7().nullable().meta({ control: "expression", description: "Disable when expression is true" })
      }),
      Component: ({ title, name, disabled, count }) => {
        const [{ value }, , { setValue, setTouched }] = useField(name);
        const onChange = (val) => {
          setValue(val);
          setTouched(true);
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Item, { label: title, name, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Rate$1, { disabled: disabled ?? void 0, value, onChange, count, allowClear: true }) });
      }
    });
    const SubmitButton = createElement({
      id: "SubmitButton",
      title: "Submit Button",
      value: "readonly",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$d, {}),
      props: create$3({
        type: create$6().oneOf(["primary", "default", "dashed", "text", "link"]).required().default("primary").label("Type").meta({ description: "Button type" }),
        text: create$6().required().default("Submit").label("Text").meta({ description: "Text of the button" }),
        disabled: create$7().nullable().label("Disabled When").meta({ control: "expression" }),
        align: create$6().oneOf(["left", "center", "right"]).required().default("left").label("Align").meta({ description: "Alignment of the button" })
      }),
      Component: ({ text, type: type2, disabled, align }) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { textAlign: align }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Submit, { disabled: disabled ?? void 0, type: type2 ?? void 0, children: text }) });
      }
    });
    const ELEMENTS = Object.assign(
      [
        ["Form", Input, Select, RadioGroup, CheckboxGroup, Rate, SubmitButton],
        ["Layout", Heading, Paragraph, Divider]
      ],
      {
        elements() {
          return ELEMENTS.flatMap((x2) => x2.slice(1));
        }
      }
    );
    const ErrorBoundaryContext = reactExports.createContext(null);
    const initialState = {
      didCatch: false,
      error: null
    };
    class ErrorBoundary extends reactExports.Component {
      constructor(props) {
        super(props);
        this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
        this.state = initialState;
      }
      static getDerivedStateFromError(error) {
        return {
          didCatch: true,
          error
        };
      }
      resetErrorBoundary() {
        const {
          error
        } = this.state;
        if (error !== null) {
          var _this$props$onReset, _this$props;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
            args,
            reason: "imperative-api"
          });
          this.setState(initialState);
        }
      }
      componentDidCatch(error, info) {
        var _this$props$onError, _this$props2;
        (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);
      }
      componentDidUpdate(prevProps, prevState) {
        const {
          didCatch
        } = this.state;
        const {
          resetKeys
        } = this.props;
        if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
          var _this$props$onReset2, _this$props3;
          (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
            next: resetKeys,
            prev: prevProps.resetKeys,
            reason: "keys"
          });
          this.setState(initialState);
        }
      }
      render() {
        const {
          children,
          fallbackRender,
          FallbackComponent,
          fallback
        } = this.props;
        const {
          didCatch,
          error
        } = this.state;
        let childToRender = children;
        if (didCatch) {
          const props = {
            error,
            resetErrorBoundary: this.resetErrorBoundary
          };
          if (typeof fallbackRender === "function") {
            childToRender = fallbackRender(props);
          } else if (FallbackComponent) {
            childToRender = reactExports.createElement(FallbackComponent, props);
          } else if (fallback !== void 0) {
            childToRender = fallback;
          } else {
            throw error;
          }
        }
        return reactExports.createElement(ErrorBoundaryContext.Provider, {
          value: {
            didCatch,
            error,
            resetErrorBoundary: this.resetErrorBoundary
          }
        }, childToRender);
      }
    }
    function hasArrayChanged() {
      let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      let b2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return a.length !== b2.length || a.some((item, index2) => !Object.is(item, b2[index2]));
    }
    function isRequiredValidationRule(x2) {
      return "type" in x2 && x2.type === "required";
    }
    function validateModelElementId(id) {
      if (!id) return "ID is required";
      if (!/^[a-zA-Z0-9_]+$/.test(id)) return "ID can only contain alphanumeric characters and underscores";
      return void 0;
    }
    const BINARY_OPERATORS = [
      "=",
      "!=",
      ">",
      "<",
      ">=",
      "<=",
      "contains",
      "not contains",
      "allof",
      "anyof"
    ];
    const CALL_EXPRESSION_FUNCTIONS = ["len"];
    const BOOL_OPERATORS = ["and", "or"];
    function isExpression(x2) {
      return x2 && typeof x2 === "object" && "type" in x2 && (x2.type === "ConstantExpression" || x2.type === "ReferenceExpression" || x2.type === "BinaryExpression" || x2.type === "BoolExpression");
    }
    function exec(expression, values) {
      switch (expression.type) {
        case "ConstantExpression":
          return expression.value;
        case "ReferenceExpression":
          return values[expression.ref];
        case "BinaryExpression": {
          const leftValue = exec(expression.left, values);
          const rightValue = exec(expression.right, values);
          switch (expression.operator) {
            case "=":
              return leftValue === rightValue;
            case "!=":
              return leftValue !== rightValue;
            case ">":
              return leftValue > rightValue;
            case "<":
              return leftValue < rightValue;
            case ">=":
              return leftValue >= rightValue;
            case "<=":
              return leftValue <= rightValue;
            case "contains": {
              if (typeof leftValue === "string" || typeof rightValue === "string") {
                return String(leftValue).includes(String(rightValue));
              }
              return Array.isArray(leftValue) && leftValue.includes(rightValue);
            }
            case "not contains": {
              if (typeof leftValue === "string" || typeof rightValue === "string") {
                return !String(leftValue).includes(String(rightValue));
              }
              return Array.isArray(leftValue) && !leftValue.includes(rightValue);
            }
            default:
              throw new Error(`Unknown binary operator: ${expression.operator}`);
          }
        }
        case "BoolExpression": {
          const results = expression.expressions.map((expr) => exec(expr, values));
          switch (expression.operator) {
            case "and":
              return results.every(Boolean);
            case "or":
              return results.some(Boolean);
            default:
              throw new Error(`Unknown boolean operator: ${expression["operator"]}`);
          }
        }
        case "CallExpression": {
          if (expression.function !== "len") {
            throw new Error(`Unknown function: ${expression.function}`);
          }
          if (expression.args.length !== 1) {
            throw new Error(`Function 'len' expects exactly one argument, got ${expression.args.length}`);
          }
          const argValue = exec(expression.args[0], values);
          if (argValue == null) {
            return 0;
          }
          return Array.isArray(argValue) ? argValue.length : String(argValue).length;
        }
        default:
          throw new Error(`Unknown expression type: ${expression["type"]}`);
      }
    }
    function visit(expression, visitor) {
      switch (expression.type) {
        case "ConstantExpression":
          return visitor(expression);
        case "ReferenceExpression":
          return visitor(expression);
        case "BinaryExpression": {
          const left = visit(expression.left, visitor);
          const right = visit(expression.right, visitor);
          expression = left !== expression.left || right !== expression.right ? { ...expression, left, right } : expression;
          return visitor(expression);
        }
        case "CallExpression": {
          const args = expression.args.map((arg) => visit(arg, visitor));
          const callExpression = expression;
          expression = args.length !== expression.args.length || args.some((arg, index2) => arg !== callExpression.args[index2]) ? { ...expression, args } : expression;
          return visitor(expression);
        }
        case "BoolExpression": {
          const exp = expression;
          const expressions = expression.expressions.map((expr) => visit(expr, visitor));
          expression = expressions.length != exp.expressions.length || expressions.some((expr, index2) => expr !== exp.expressions[index2]) ? { ...exp, expressions } : exp;
          return visitor(expression);
        }
        default:
          throw new Error(`Unknown expression type: ${expression["type"]}`);
      }
    }
    const ExpressionUtil = {
      exec,
      isExpression,
      visit
    };
    function initialValue(model) {
      return model.elements.reduce(
        (acc, x2) => {
          acc[x2.id] = elementInitialValue(x2);
          return acc;
        },
        {}
      );
    }
    function elementInitialValue(el) {
      return el.defaultValue ?? null;
    }
    function propsOf(el, values) {
      const props = { ...el.props };
      for (const key in props) {
        if (Object.prototype.hasOwnProperty.call(props, key)) {
          if (ExpressionUtil.isExpression(props[key])) props[key] = ExpressionUtil.exec(props[key], values);
        }
      }
      return props;
    }
    function schemaOfType(type2) {
      if (Array.isArray(type2) && type2[0] === "arrayOf") {
        return create$2(schemaOfType(type2[1])).nullable();
      }
      switch (type2) {
        case "string":
          return create$6().nullable();
        case "number":
          return create$5().nullable();
        case "boolean":
          return create$7().nullable();
        case "date":
          return create$4().nullable();
        case "object":
          return create$3().nullable();
        default:
          return create$6().nullable();
      }
    }
    function schemaOf(model, Element2) {
      let base = schemaOfType(Element2.value ?? "string");
      let testIndex = -1;
      for (const validation of model.validation ?? []) {
        if (isRequiredValidationRule(validation)) {
          base = validation.message ? base.required(validation.message) : base.required();
        }
        if (validation.type === "test") {
          base = base.test({
            name: `test-${++testIndex}`,
            message: validation.message,
            test: (_2, context) => {
              return !ExpressionUtil.exec(validation.test, context.parent);
            }
          });
        }
      }
      return base;
    }
    const ModelUtil = {
      initialValue,
      elementInitialValue,
      propsOf,
      schemaOf
    };
    const DesignerUtil = {
      initialValue: (el) => {
        const describe = el.props.describe();
        const props = describe.default ?? {};
        return { props };
      },
      flattenElements: (elements) => {
        return elements.flatMap((x2) => Array.isArray(x2) ? x2.slice(1) : x2);
      }
    };
    function swap(array2, index1, index2) {
      if (index1 < 0 || index2 < 0 || index1 >= array2.length || index2 >= array2.length) {
        throw new Error("Index out of bounds");
      }
      const newArray = [...array2];
      [newArray[index1], newArray[index2]] = [newArray[index2], newArray[index1]];
      return newArray;
    }
    function parsePath(path2) {
      const parts = [];
      path2.split(".").forEach((part) => {
        const regex = /([^[\]]+)|\[(\d+)\]/g;
        let match2;
        while ((match2 = regex.exec(part)) !== null) {
          if (match2[1] !== void 0) {
            parts.push(match2[1]);
          } else if (match2[2] !== void 0) {
            parts.push(Number(match2[2]));
          }
        }
      });
      return parts;
    }
    function pathToName(path2) {
      if (path2.length === 0) {
        return null;
      }
      let result = "";
      for (const x2 of path2) {
        if (typeof x2 === "number") {
          result += `[${x2}]`;
        } else {
          if (result.length > 0) {
            result += ".";
          }
          result += x2;
        }
      }
      return result;
    }
    function parseIndex(name) {
      const match2 = name.match(/\[(\d+)\]$/);
      if (match2) {
        return parseInt(match2[1], 10);
      }
      return null;
    }
    function useLocalStorageState(key, initialValue2) {
      const [state, setState] = reactExports.useState(() => {
        const storedValue = localStorage.getItem(key);
        return storedValue !== null ? storedValue : initialValue2;
      });
      reactExports.useEffect(() => {
        localStorage.setItem(key, state);
      }, [key, state]);
      return [state, setState];
    }
    function useLocalStorageBool(key, initialValue2) {
      const [state, setState] = useLocalStorageState(key, "false");
      const boolState = state === "true";
      const setBoolState = (value) => {
        setState(value ? "true" : "false");
      };
      return [boolState, setBoolState];
    }
    function debounce(func, delay) {
      let timeoutId = null;
      return (...args) => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
          func(...args);
        }, delay);
      };
    }
    const DesignerContext = i.createContext(null);
    function usePushElement(props) {
      const { model, set: set2 } = props;
      return reactExports.useCallback(
        (x2) => {
          const last = model.elements.filter((el) => el.id.startsWith("el")).slice().sort(
            (a, b2) => b2.id.length != a.id.length ? b2.id.length - a.id.length : b2.id.substring(2).localeCompare(a.id.substring(2))
          )[0];
          const nextNumber = last ? +last.id.substring(2) + 1 : 1;
          const id = `el${nextNumber}`;
          set2({
            ...model,
            elements: [
              ...model.elements,
              {
                id,
                element: x2.id,
                defaultValue: null,
                ...DesignerUtil.initialValue(x2),
                validation: null
              }
            ]
          });
          return id;
        },
        [model, set2]
      );
    }
    function useRemoveElement(props) {
      const { model, set: set2 } = props;
      return reactExports.useCallback(
        (el) => {
          set2({ ...model, elements: model.elements.filter((x2) => x2.id !== el.id) });
        },
        [model, set2]
      );
    }
    function useMoveElement(props, value) {
      const { model, set: set2 } = props;
      return reactExports.useCallback(
        (el) => {
          const index2 = model.elements.findIndex((x2) => x2.id === el.id);
          if (index2 + value < 0 || index2 + value >= model.elements.length) {
            return;
          }
          set2({ ...model, elements: swap(model.elements, index2, index2 + value) });
        },
        [model, set2, value]
      );
    }
    function useRenameElement(props) {
      const { set: set2, select, selectedId, model } = props;
      return reactExports.useCallback(
        (id, newId) => {
          const error = validateModelElementId(newId);
          if (error) {
            throw new Error(error);
          }
          set2({
            ...model,
            elements: model.elements.map((x2) => {
              if (x2.id === id) {
                x2 = { ...x2, id: newId };
              }
              for (const key in x2.props) {
                if (Object.prototype.hasOwnProperty.call(x2.props, key)) {
                  if (ExpressionUtil.isExpression(x2.props[key])) {
                    x2 = {
                      ...x2,
                      props: {
                        ...x2.props,
                        [key]: ExpressionUtil.visit(
                          x2.props[key],
                          (node2) => node2.type === "ReferenceExpression" && node2.ref === id ? { ...node2, ref: newId } : node2
                        )
                      }
                    };
                  }
                }
              }
              if (x2.condition) {
                x2 = {
                  ...x2,
                  condition: ExpressionUtil.visit(
                    x2.condition,
                    (node2) => node2.type === "ReferenceExpression" && node2.ref === id ? { ...node2, ref: newId } : node2
                  )
                };
              }
              if (x2.validation) {
                x2 = {
                  ...x2,
                  validation: x2.validation.map(
                    (x22) => x22.type === "test" ? {
                      ...x22,
                      test: ExpressionUtil.visit(
                        x22.test,
                        (node2) => node2.type === "ReferenceExpression" && node2.ref === id ? { ...node2, ref: newId } : node2
                      )
                    } : x22
                  )
                };
              }
              return x2;
            })
          });
          if (selectedId === id) {
            select(newId);
          }
        },
        [model, set2, select, selectedId]
      );
    }
    function DesignerContextProvider(props) {
      const { children, Elements, model, set: set2, selectedId, select } = props;
      const pushElement = usePushElement(props);
      const removeElement = useRemoveElement(props);
      const moveElementUp = useMoveElement(props, -1);
      const moveElementDown = useMoveElement(props, 1);
      const renameElement = useRenameElement(props);
      const ElementValues = reactExports.useMemo(
        () => Elements.flatMap((x2) => Array.isArray(x2) ? x2.slice(1) : x2),
        [Elements]
      );
      const value = reactExports.useMemo(
        () => ({
          ElementsInput: Elements,
          Elements: Elements.flatMap((x2) => Array.isArray(x2) ? x2.slice(1) : x2),
          model,
          set: set2,
          pushElement,
          removeElement,
          moveElementUp,
          moveElementDown,
          selectedId,
          select,
          selected: model.elements.find((x2) => x2.id === selectedId) ?? null,
          selectedElement: ElementValues.find((x2) => {
            var _a;
            return x2.id === ((_a = model.elements.find((el) => el.id === selectedId)) == null ? void 0 : _a.element);
          }) ?? null,
          renameElement
        }),
        [
          Elements,
          ElementValues,
          model,
          set2,
          pushElement,
          removeElement,
          moveElementUp,
          moveElementDown,
          select,
          selectedId,
          renameElement
        ]
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DesignerContext.Provider, { value, children });
    }
    function useDesignerContext() {
      return reactExports.useContext(DesignerContext);
    }
    var f = Object.defineProperty;
    var d = (n2, e2, t2) => e2 in n2 ? f(n2, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : n2[e2] = t2;
    var u = (n2, e2, t2) => d(n2, typeof e2 != "symbol" ? e2 + "" : e2, t2);
    class _ {
      /**
       * Creates a new FlexyTheme with a unique string key.
       *
       * @param key - A non-empty string used to identify the theme.
       * @throws If `key` is null, undefined, or empty.
       */
      constructor(e2) {
        u(this, "_key");
        u(this, "_context");
        u(this, "Provider", reactExports.memo((e3) => {
          const { children: t2, components: o2 } = e3, s = reactExports.useMemo(
            () => ({
              key: this._key,
              components: o2
            }),
            // eslint-disable-next-line react-hooks/exhaustive-deps
            [o2.length, Object.keys(o2), Object.values(o2)]
          );
          return /* @__PURE__ */ jsxRuntimeExports.jsx(this._context.Provider, { value: s, children: t2 });
        }));
        if (e2 == null || e2.length === 0)
          throw new Error("Theme key must be a non-empty string.");
        this._key = e2, this._context = i.createContext({
          key: this._key,
          components: {}
        });
      }
      /**
       * Returns the theme's unique key.
       */
      get key() {
        return this._key;
      }
      /**
       * Accesses the current theme context value.
       *
       * @returns The current theme context including its override map.
       */
      useContext() {
        return reactExports.useContext(this._context);
      }
      /**
       * Creates a Flexy-wrapped component that resolves overrides from this specific theme.
       *
       * @template TKey - Component override key (usually matches the prop used in `components`).
       * @template TComponent - Original component type.
       *
       * @param key - Unique key for identifying this component in the theme.
       * @param Component - The base component to render if no override is found.
       * @returns A themed component that uses the override if present, otherwise falls back.
       *
       * @example
       * ```tsx
       * const Button = theme.flexy('Button', (props) => <button {...props} />);
       * ```
       */
      flexy(e2, t2) {
        const o2 = i.forwardRef((s, r2) => {
          const m2 = this.useContext().components[e2];
          return m2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(m2, { ...s, ref: r2 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(t2, { ...s, ref: r2 });
        });
        return o2.displayName = `Flexy:${this.key}:${e2}`, Object.assign(o2, {
          Component: t2
        });
      }
    }
    function C(n2) {
      return new _(n2);
    }
    const x = i.createContext({}), b = Object.freeze({});
    reactExports.memo((n2) => {
      const { children: e2, value: t2, mode: o2 } = n2, s = reactExports.useContext(x), r2 = reactExports.useMemo(
        () => o2 === "replace" ? t2 ?? b : { ...s, ...t2 },
        [s, t2, o2]
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx(x.Provider, { value: r2, children: e2 });
    });
    function g() {
      return reactExports.useContext(x);
    }
    function j(n2, e2) {
      const t2 = i.forwardRef(
        (o2, s) => {
          const l2 = g()[n2];
          return l2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(l2, { ...o2, ref: s }) : /* @__PURE__ */ jsxRuntimeExports.jsx(e2, { ...o2, ref: s });
        }
      );
      return t2.displayName = `Flexy:${n2}`, Object.assign(t2, {
        Component: e2
      });
    }
    const p = Object.assign(j, {
      createTheme: C
    });
    const DynamicFormTheme = p.createTheme("wxd-dynamic-form");
    const DynamicFormSettings = {
      clx: "wxd-"
    };
    function clx(name) {
      return `${DynamicFormSettings.clx}${name}`;
    }
    const ElementListItemControlBlock = DynamicFormTheme.flexy(
      "ElementListItemControlBlock",
      (props) => {
        const { element } = props;
        const { removeElement, moveElementUp, moveElementDown } = useDesignerContext();
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clx("element-list-item-control-block"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { children: element.id }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { type: "link", onClick: () => moveElementUp(element), icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$e, {}) }, "up"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              type: "link",
              onClick: () => moveElementDown(element),
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$f, {})
            },
            "down"
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { type: "link", onClick: () => removeElement(element), icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$9, {}) }, "remove")
        ] });
      }
    );
    const ElementListItem = DynamicFormTheme.flexy("ElementListItem", (props) => {
      var _a;
      const { element, animate } = props;
      const { Elements, selectedId: selected, select } = useDesignerContext();
      const [isAppearanceAnimationShown, setAppearanceAnimationShown] = reactExports.useState(animate ?? false);
      const ref = reactExports.useRef(null);
      const def = Elements.find((x2) => x2.id === element.element);
      const Element2 = def.Component;
      reactExports.useLayoutEffect(() => {
        var _a2;
        if (animate) (_a2 = ref.current) == null ? void 0 : _a2.scrollIntoView({ behavior: "smooth", block: "center" });
      }, []);
      reactExports.useEffect(() => {
        if (animate) setTimeout(() => setAppearanceAnimationShown(false), 500);
      }, []);
      const onClick = reactExports.useCallback(() => {
        if (selected === element.id) {
          select(null);
        } else {
          select(element.id);
        }
      }, [select, selected, element.id]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          ref,
          className: classNames(clx("element-list-item"), {
            "--selected": selected === element.id,
            "--appearance-animation-shown": animate && isAppearanceAnimationShown
          }),
          onClick,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ElementListItemControlBlock, { element }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography.Text, { type: "danger", children: "Error" }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Element2,
              {
                ...element.props,
                name: element.id,
                disabled: false,
                required: ((_a = element.validation) == null ? void 0 : _a.some(isRequiredValidationRule)) === true
              }
            ) })
          ]
        }
      );
    });
    const ElementList = DynamicFormTheme.flexy("ElementList", (props) => {
      const { model } = useDesignerContext();
      const { animate } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1, { layout: "vertical", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        List,
        {
          dataSource: model.elements,
          renderItem: (el) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(List.Item, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ElementListItem, { element: el, animate }) }, el.id);
          }
        }
      ) });
    });
    function useMenuItems() {
      const { ElementsInput } = useDesignerContext();
      return reactExports.useMemo(() => {
        const mapElement = (el) => {
          return { key: el.id, label: el.title ?? el.id, icon: el.icon ?? /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$5, {}) };
        };
        const mapGroup = (el) => {
          return {
            type: "group",
            label: el[0],
            key: el[0],
            children: el.slice(1).map(mapElement)
          };
        };
        return ElementsInput.map((x2) => Array.isArray(x2) ? mapGroup(x2) : mapElement(x2));
      }, [ElementsInput]);
    }
    const ElementMenu = DynamicFormTheme.flexy("ElementMenu", (props) => {
      const { offsetTop, collapsed = false, onCollapsedChange } = props;
      const { Elements, pushElement } = useDesignerContext();
      const items = useMenuItems();
      const onPush = reactExports.useCallback(
        (elementBaseId) => {
          const el = Elements.find((x2) => x2.id === elementBaseId);
          pushElement(el);
        },
        [Elements, pushElement]
      );
      const content = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Menu,
          {
            inlineCollapsed: collapsed,
            className: clx("h-full"),
            selectable: false,
            onClick: (e2) => onPush(e2.key),
            items,
            mode: "vertical"
          },
          String(collapsed)
        ),
        onCollapsedChange && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Divider$1, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clx("element-menu-toggle-container"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button$1,
            {
              color: "default",
              variant: "text",
              onClick: () => onCollapsedChange == null ? void 0 : onCollapsedChange(!collapsed),
              className: clx("element-menu-toggle"),
              children: [
                collapsed && /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$g, {}),
                !collapsed && /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$h, {})
              ]
            }
          ) })
        ] })
      ] });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: classNames(clx("element-menu"), clx("h-full"), { "--affix": offsetTop != null }), children: [
        offsetTop != null && /* @__PURE__ */ jsxRuntimeExports.jsx(Affix, { offsetTop, children: content }, String(collapsed)),
        offsetTop == null && content
      ] });
    });
    function isRequired(description) {
      const d2 = description;
      return d2.optional === false && d2.nullable === false;
    }
    function isOneOfDescription(description) {
      return "oneOf" in description;
    }
    function isArrayOfDescription(description) {
      return "innerType" in description;
    }
    const SchemaUtil = {
      isRequired,
      isOneOfDescription,
      isArrayOfDescription
    };
    var QuestionCircleOutlined$5 = { exports: {} };
    var QuestionCircleOutlined$4 = {};
    var interopRequireWildcard = { exports: {} };
    var _typeof = { exports: {} };
    (function(module2) {
      function _typeof3(o2) {
        "@babel/helpers - typeof";
        return module2.exports = _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
          return typeof o3;
        } : function(o3) {
          return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof3(o2);
      }
      module2.exports = _typeof3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(_typeof);
    var _typeofExports = _typeof.exports;
    (function(module2) {
      var _typeof3 = _typeofExports["default"];
      function _getRequireWildcardCache(e2) {
        if ("function" != typeof WeakMap) return null;
        var r2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(e3) {
          return e3 ? t2 : r2;
        })(e2);
      }
      function _interopRequireWildcard2(e2, r2) {
        if (!r2 && e2 && e2.__esModule) return e2;
        if (null === e2 || "object" != _typeof3(e2) && "function" != typeof e2) return {
          "default": e2
        };
        var t2 = _getRequireWildcardCache(r2);
        if (t2 && t2.has(e2)) return t2.get(e2);
        var n2 = {
          __proto__: null
        }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var u2 in e2) if ("default" !== u2 && {}.hasOwnProperty.call(e2, u2)) {
          var i2 = a ? Object.getOwnPropertyDescriptor(e2, u2) : null;
          i2 && (i2.get || i2.set) ? Object.defineProperty(n2, u2, i2) : n2[u2] = e2[u2];
        }
        return n2["default"] = e2, t2 && t2.set(e2, n2), n2;
      }
      module2.exports = _interopRequireWildcard2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(interopRequireWildcard);
    var interopRequireWildcardExports = interopRequireWildcard.exports;
    var interopRequireDefault = { exports: {} };
    (function(module2) {
      function _interopRequireDefault2(e2) {
        return e2 && e2.__esModule ? e2 : {
          "default": e2
        };
      }
      module2.exports = _interopRequireDefault2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(interopRequireDefault);
    var interopRequireDefaultExports = interopRequireDefault.exports;
    var _extends = { exports: {} };
    (function(module2) {
      function _extends3() {
        return module2.exports = _extends3 = Object.assign ? Object.assign.bind() : function(n2) {
          for (var e2 = 1; e2 < arguments.length; e2++) {
            var t2 = arguments[e2];
            for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
          }
          return n2;
        }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _extends3.apply(null, arguments);
      }
      module2.exports = _extends3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(_extends);
    var _extendsExports = _extends.exports;
    var QuestionCircleOutlined$3 = {};
    Object.defineProperty(QuestionCircleOutlined$3, "__esModule", { value: true });
    var QuestionCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
    QuestionCircleOutlined$3.default = QuestionCircleOutlined$2;
    var AntdIcon = {};
    var slicedToArray = { exports: {} };
    var arrayWithHoles = { exports: {} };
    (function(module2) {
      function _arrayWithHoles2(r2) {
        if (Array.isArray(r2)) return r2;
      }
      module2.exports = _arrayWithHoles2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(arrayWithHoles);
    var arrayWithHolesExports = arrayWithHoles.exports;
    var iterableToArrayLimit = { exports: {} };
    (function(module2) {
      function _iterableToArrayLimit2(r2, l2) {
        var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
        if (null != t2) {
          var e2, n2, i2, u2, a = [], f2 = true, o2 = false;
          try {
            if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
              if (Object(t2) !== t2) return;
              f2 = false;
            } else for (; !(f2 = (e2 = i2.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true) ;
          } catch (r3) {
            o2 = true, n2 = r3;
          } finally {
            try {
              if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
            } finally {
              if (o2) throw n2;
            }
          }
          return a;
        }
      }
      module2.exports = _iterableToArrayLimit2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(iterableToArrayLimit);
    var iterableToArrayLimitExports = iterableToArrayLimit.exports;
    var unsupportedIterableToArray = { exports: {} };
    var arrayLikeToArray = { exports: {} };
    (function(module2) {
      function _arrayLikeToArray2(r2, a) {
        (null == a || a > r2.length) && (a = r2.length);
        for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r2[e2];
        return n2;
      }
      module2.exports = _arrayLikeToArray2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(arrayLikeToArray);
    var arrayLikeToArrayExports = arrayLikeToArray.exports;
    (function(module2) {
      var arrayLikeToArray2 = arrayLikeToArrayExports;
      function _unsupportedIterableToArray2(r2, a) {
        if (r2) {
          if ("string" == typeof r2) return arrayLikeToArray2(r2, a);
          var t2 = {}.toString.call(r2).slice(8, -1);
          return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? arrayLikeToArray2(r2, a) : void 0;
        }
      }
      module2.exports = _unsupportedIterableToArray2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(unsupportedIterableToArray);
    var unsupportedIterableToArrayExports = unsupportedIterableToArray.exports;
    var nonIterableRest = { exports: {} };
    (function(module2) {
      function _nonIterableRest2() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module2.exports = _nonIterableRest2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(nonIterableRest);
    var nonIterableRestExports = nonIterableRest.exports;
    (function(module2) {
      var arrayWithHoles2 = arrayWithHolesExports;
      var iterableToArrayLimit2 = iterableToArrayLimitExports;
      var unsupportedIterableToArray2 = unsupportedIterableToArrayExports;
      var nonIterableRest2 = nonIterableRestExports;
      function _slicedToArray3(r2, e2) {
        return arrayWithHoles2(r2) || iterableToArrayLimit2(r2, e2) || unsupportedIterableToArray2(r2, e2) || nonIterableRest2();
      }
      module2.exports = _slicedToArray3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(slicedToArray);
    var slicedToArrayExports = slicedToArray.exports;
    var defineProperty = { exports: {} };
    var toPropertyKey = { exports: {} };
    var toPrimitive = { exports: {} };
    (function(module2) {
      var _typeof3 = _typeofExports["default"];
      function toPrimitive2(t2, r2) {
        if ("object" != _typeof3(t2) || !t2) return t2;
        var e2 = t2[Symbol.toPrimitive];
        if (void 0 !== e2) {
          var i2 = e2.call(t2, r2 || "default");
          if ("object" != _typeof3(i2)) return i2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r2 ? String : Number)(t2);
      }
      module2.exports = toPrimitive2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(toPrimitive);
    var toPrimitiveExports = toPrimitive.exports;
    (function(module2) {
      var _typeof3 = _typeofExports["default"];
      var toPrimitive2 = toPrimitiveExports;
      function toPropertyKey2(t2) {
        var i2 = toPrimitive2(t2, "string");
        return "symbol" == _typeof3(i2) ? i2 : i2 + "";
      }
      module2.exports = toPropertyKey2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(toPropertyKey);
    var toPropertyKeyExports = toPropertyKey.exports;
    (function(module2) {
      var toPropertyKey2 = toPropertyKeyExports;
      function _defineProperty3(e2, r2, t2) {
        return (r2 = toPropertyKey2(r2)) in e2 ? Object.defineProperty(e2, r2, {
          value: t2,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e2[r2] = t2, e2;
      }
      module2.exports = _defineProperty3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(defineProperty);
    var definePropertyExports = defineProperty.exports;
    var objectWithoutProperties = { exports: {} };
    var objectWithoutPropertiesLoose = { exports: {} };
    (function(module2) {
      function _objectWithoutPropertiesLoose2(r2, e2) {
        if (null == r2) return {};
        var t2 = {};
        for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
          if (-1 !== e2.indexOf(n2)) continue;
          t2[n2] = r2[n2];
        }
        return t2;
      }
      module2.exports = _objectWithoutPropertiesLoose2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(objectWithoutPropertiesLoose);
    var objectWithoutPropertiesLooseExports = objectWithoutPropertiesLoose.exports;
    (function(module2) {
      var objectWithoutPropertiesLoose2 = objectWithoutPropertiesLooseExports;
      function _objectWithoutProperties3(e2, t2) {
        if (null == e2) return {};
        var o2, r2, i2 = objectWithoutPropertiesLoose2(e2, t2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e2, o2) && (i2[o2] = e2[o2]);
        }
        return i2;
      }
      module2.exports = _objectWithoutProperties3, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(objectWithoutProperties);
    var objectWithoutPropertiesExports = objectWithoutProperties.exports;
    const require$$8 = /* @__PURE__ */ getAugmentedNamespace(es);
    var Context = {};
    Object.defineProperty(Context, "__esModule", {
      value: true
    });
    Context.default = void 0;
    var _react$1 = reactExports;
    var IconContext = /* @__PURE__ */ (0, _react$1.createContext)({});
    Context.default = IconContext;
    var IconBase$1 = {};
    var objectSpread2 = { exports: {} };
    (function(module2) {
      var defineProperty2 = definePropertyExports;
      function ownKeys2(e2, r2) {
        var t2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          r2 && (o2 = o2.filter(function(r3) {
            return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
          })), t2.push.apply(t2, o2);
        }
        return t2;
      }
      function _objectSpread22(e2) {
        for (var r2 = 1; r2 < arguments.length; r2++) {
          var t2 = null != arguments[r2] ? arguments[r2] : {};
          r2 % 2 ? ownKeys2(Object(t2), true).forEach(function(r3) {
            defineProperty2(e2, r3, t2[r3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys2(Object(t2)).forEach(function(r3) {
            Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
          });
        }
        return e2;
      }
      module2.exports = _objectSpread22, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(objectSpread2);
    var objectSpread2Exports = objectSpread2.exports;
    var utils = {};
    var dynamicCSS = {};
    var canUseDom$1 = {};
    Object.defineProperty(canUseDom$1, "__esModule", {
      value: true
    });
    canUseDom$1.default = canUseDom;
    function canUseDom() {
      return !!(typeof window !== "undefined" && window.document && window.document.createElement);
    }
    var contains$1 = {};
    Object.defineProperty(contains$1, "__esModule", {
      value: true
    });
    contains$1.default = contains;
    function contains(root2, n2) {
      if (!root2) {
        return false;
      }
      if (root2.contains) {
        return root2.contains(n2);
      }
      var node2 = n2;
      while (node2) {
        if (node2 === root2) {
          return true;
        }
        node2 = node2.parentNode;
      }
      return false;
    }
    var _interopRequireDefault$5 = interopRequireDefaultExports.default;
    Object.defineProperty(dynamicCSS, "__esModule", {
      value: true
    });
    dynamicCSS.clearContainerCache = clearContainerCache;
    dynamicCSS.injectCSS = injectCSS;
    dynamicCSS.removeCSS = removeCSS;
    dynamicCSS.updateCSS = updateCSS;
    var _objectSpread2$2 = _interopRequireDefault$5(objectSpread2Exports);
    var _canUseDom = _interopRequireDefault$5(canUseDom$1);
    var _contains = _interopRequireDefault$5(contains$1);
    var APPEND_ORDER = "data-rc-order";
    var APPEND_PRIORITY = "data-rc-priority";
    var MARK_KEY = "rc-util-key";
    var containerCache = /* @__PURE__ */ new Map();
    function getMark() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
      if (mark) {
        return mark.startsWith("data-") ? mark : "data-".concat(mark);
      }
      return MARK_KEY;
    }
    function getContainer(option) {
      if (option.attachTo) {
        return option.attachTo;
      }
      var head = document.querySelector("head");
      return head || document.body;
    }
    function getOrder(prepend) {
      if (prepend === "queue") {
        return "prependQueue";
      }
      return prepend ? "prepend" : "append";
    }
    function findStyles(container) {
      return Array.from((containerCache.get(container) || container).children).filter(function(node2) {
        return node2.tagName === "STYLE";
      });
    }
    function injectCSS(css) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!(0, _canUseDom.default)()) {
        return null;
      }
      var csp = option.csp, prepend = option.prepend, _option$priority = option.priority, priority = _option$priority === void 0 ? 0 : _option$priority;
      var mergedOrder = getOrder(prepend);
      var isPrependQueue = mergedOrder === "prependQueue";
      var styleNode = document.createElement("style");
      styleNode.setAttribute(APPEND_ORDER, mergedOrder);
      if (isPrependQueue && priority) {
        styleNode.setAttribute(APPEND_PRIORITY, "".concat(priority));
      }
      if (csp !== null && csp !== void 0 && csp.nonce) {
        styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
      }
      styleNode.innerHTML = css;
      var container = getContainer(option);
      var firstChild = container.firstChild;
      if (prepend) {
        if (isPrependQueue) {
          var existStyle = (option.styles || findStyles(container)).filter(function(node2) {
            if (!["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER))) {
              return false;
            }
            var nodePriority = Number(node2.getAttribute(APPEND_PRIORITY) || 0);
            return priority >= nodePriority;
          });
          if (existStyle.length) {
            container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
            return styleNode;
          }
        }
        container.insertBefore(styleNode, firstChild);
      } else {
        container.appendChild(styleNode);
      }
      return styleNode;
    }
    function findExistNode(key) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var container = getContainer(option);
      return (option.styles || findStyles(container)).find(function(node2) {
        return node2.getAttribute(getMark(option)) === key;
      });
    }
    function removeCSS(key) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var existNode = findExistNode(key, option);
      if (existNode) {
        var container = getContainer(option);
        container.removeChild(existNode);
      }
    }
    function syncRealContainer(container, option) {
      var cachedRealContainer = containerCache.get(container);
      if (!cachedRealContainer || !(0, _contains.default)(document, cachedRealContainer)) {
        var placeholderStyle = injectCSS("", option);
        var parentNode = placeholderStyle.parentNode;
        containerCache.set(container, parentNode);
        container.removeChild(placeholderStyle);
      }
    }
    function clearContainerCache() {
      containerCache.clear();
    }
    function updateCSS(css, key) {
      var originOption = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var container = getContainer(originOption);
      var styles = findStyles(container);
      var option = (0, _objectSpread2$2.default)((0, _objectSpread2$2.default)({}, originOption), {}, {
        styles
      });
      syncRealContainer(container, option);
      var existNode = findExistNode(key, option);
      if (existNode) {
        var _option$csp, _option$csp2;
        if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
          var _option$csp3;
          existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
        }
        if (existNode.innerHTML !== css) {
          existNode.innerHTML = css;
        }
        return existNode;
      }
      var newNode = injectCSS(css, option);
      newNode.setAttribute(getMark(option), key);
      return newNode;
    }
    var shadow = {};
    Object.defineProperty(shadow, "__esModule", {
      value: true
    });
    shadow.getShadowRoot = getShadowRoot;
    shadow.inShadow = inShadow;
    function getRoot(ele) {
      var _ele$getRootNode;
      return ele === null || ele === void 0 || (_ele$getRootNode = ele.getRootNode) === null || _ele$getRootNode === void 0 ? void 0 : _ele$getRootNode.call(ele);
    }
    function inShadow(ele) {
      return getRoot(ele) instanceof ShadowRoot;
    }
    function getShadowRoot(ele) {
      return inShadow(ele) ? getRoot(ele) : null;
    }
    var warning$2 = {};
    Object.defineProperty(warning$2, "__esModule", {
      value: true
    });
    warning$2.call = call;
    warning$2.default = void 0;
    warning$2.note = note;
    warning$2.noteOnce = noteOnce;
    warning$2.preMessage = void 0;
    warning$2.resetWarned = resetWarned;
    warning$2.warning = warning$1;
    warning$2.warningOnce = warningOnce;
    var warned = {};
    var preMessage = warning$2.preMessage = function preMessage2(fn) {
    };
    function warning$1(valid, message2) {
    }
    function note(valid, message2) {
    }
    function resetWarned() {
      warned = {};
    }
    function call(method2, valid, message2) {
      if (!valid && !warned[message2]) {
        method2(false, message2);
        warned[message2] = true;
      }
    }
    function warningOnce(valid, message2) {
      call(warning$1, valid, message2);
    }
    function noteOnce(valid, message2) {
      call(note, valid, message2);
    }
    warningOnce.preMessage = preMessage;
    warningOnce.resetWarned = resetWarned;
    warningOnce.noteOnce = noteOnce;
    warning$2.default = warningOnce;
    var _interopRequireWildcard$3 = interopRequireWildcardExports.default;
    var _interopRequireDefault$4 = interopRequireDefaultExports.default;
    Object.defineProperty(utils, "__esModule", {
      value: true
    });
    utils.generate = generate;
    utils.getSecondaryColor = getSecondaryColor;
    utils.iconStyles = void 0;
    utils.isIconDefinition = isIconDefinition;
    utils.normalizeAttrs = normalizeAttrs;
    utils.normalizeTwoToneColors = normalizeTwoToneColors;
    utils.useInsertStyles = utils.svgBaseProps = void 0;
    utils.warning = warning;
    var _objectSpread2$1 = _interopRequireDefault$4(objectSpread2Exports);
    var _typeof2 = _interopRequireDefault$4(_typeofExports);
    var _colors$1 = require$$8;
    var _dynamicCSS = dynamicCSS;
    var _shadow = shadow;
    var _warning = _interopRequireDefault$4(warning$2);
    var _react = _interopRequireWildcard$3(reactExports);
    var _Context$1 = _interopRequireDefault$4(Context);
    function camelCase(input) {
      return input.replace(/-(.)/g, function(match2, g2) {
        return g2.toUpperCase();
      });
    }
    function warning(valid, message2) {
      (0, _warning.default)(valid, "[@ant-design/icons] ".concat(message2));
    }
    function isIconDefinition(target) {
      return (0, _typeof2.default)(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && ((0, _typeof2.default)(target.icon) === "object" || typeof target.icon === "function");
    }
    function normalizeAttrs() {
      var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return Object.keys(attrs).reduce(function(acc, key) {
        var val = attrs[key];
        switch (key) {
          case "class":
            acc.className = val;
            delete acc.class;
            break;
          default:
            delete acc[key];
            acc[camelCase(key)] = val;
        }
        return acc;
      }, {});
    }
    function generate(node2, key, rootProps) {
      if (!rootProps) {
        return /* @__PURE__ */ _react.default.createElement(node2.tag, (0, _objectSpread2$1.default)({
          key
        }, normalizeAttrs(node2.attrs)), (node2.children || []).map(function(child, index2) {
          return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
        }));
      }
      return /* @__PURE__ */ _react.default.createElement(node2.tag, (0, _objectSpread2$1.default)((0, _objectSpread2$1.default)({
        key
      }, normalizeAttrs(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
        return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
      }));
    }
    function getSecondaryColor(primaryColor) {
      return (0, _colors$1.generate)(primaryColor)[0];
    }
    function normalizeTwoToneColors(twoToneColor) {
      if (!twoToneColor) {
        return [];
      }
      return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
    }
    utils.svgBaseProps = {
      width: "1em",
      height: "1em",
      fill: "currentColor",
      "aria-hidden": "true",
      focusable: "false"
    };
    var iconStyles = utils.iconStyles = "\n.anticon {\n  display: inline-flex;\n  align-items: center;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
    utils.useInsertStyles = function useInsertStyles2(eleRef) {
      var _useContext = (0, _react.useContext)(_Context$1.default), csp = _useContext.csp, prefixCls = _useContext.prefixCls, layer = _useContext.layer;
      var mergedStyleStr = iconStyles;
      if (prefixCls) {
        mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
      }
      if (layer) {
        mergedStyleStr = "@layer ".concat(layer, " {\n").concat(mergedStyleStr, "\n}");
      }
      (0, _react.useEffect)(function() {
        var ele = eleRef.current;
        var shadowRoot = (0, _shadow.getShadowRoot)(ele);
        (0, _dynamicCSS.updateCSS)(mergedStyleStr, "@ant-design-icons", {
          prepend: !layer,
          csp,
          attachTo: shadowRoot
        });
      }, []);
    };
    var _interopRequireDefault$3 = interopRequireDefaultExports.default;
    var _interopRequireWildcard$2 = interopRequireWildcardExports.default;
    Object.defineProperty(IconBase$1, "__esModule", {
      value: true
    });
    IconBase$1.default = void 0;
    var _objectWithoutProperties2$1 = _interopRequireDefault$3(objectWithoutPropertiesExports);
    var _objectSpread2 = _interopRequireDefault$3(objectSpread2Exports);
    var React$2 = _interopRequireWildcard$2(reactExports);
    var _utils$2 = utils;
    var _excluded$1 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
    var twoToneColorPalette = {
      primaryColor: "#333",
      secondaryColor: "#E6E6E6",
      calculated: false
    };
    function setTwoToneColors(_ref) {
      var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
      twoToneColorPalette.primaryColor = primaryColor;
      twoToneColorPalette.secondaryColor = secondaryColor || (0, _utils$2.getSecondaryColor)(primaryColor);
      twoToneColorPalette.calculated = !!secondaryColor;
    }
    function getTwoToneColors() {
      return (0, _objectSpread2.default)({}, twoToneColorPalette);
    }
    var IconBase = function IconBase2(props) {
      var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = (0, _objectWithoutProperties2$1.default)(props, _excluded$1);
      var svgRef = React$2.useRef();
      var colors = twoToneColorPalette;
      if (primaryColor) {
        colors = {
          primaryColor,
          secondaryColor: secondaryColor || (0, _utils$2.getSecondaryColor)(primaryColor)
        };
      }
      (0, _utils$2.useInsertStyles)(svgRef);
      (0, _utils$2.warning)((0, _utils$2.isIconDefinition)(icon), "icon should be icon definiton, but got ".concat(icon));
      if (!(0, _utils$2.isIconDefinition)(icon)) {
        return null;
      }
      var target = icon;
      if (target && typeof target.icon === "function") {
        target = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, target), {}, {
          icon: target.icon(colors.primaryColor, colors.secondaryColor)
        });
      }
      return (0, _utils$2.generate)(target.icon, "svg-".concat(target.name), (0, _objectSpread2.default)((0, _objectSpread2.default)({
        className,
        onClick,
        style: style2,
        "data-icon": target.name,
        width: "1em",
        height: "1em",
        fill: "currentColor",
        "aria-hidden": "true"
      }, restProps), {}, {
        ref: svgRef
      }));
    };
    IconBase.displayName = "IconReact";
    IconBase.getTwoToneColors = getTwoToneColors;
    IconBase.setTwoToneColors = setTwoToneColors;
    IconBase$1.default = IconBase;
    var twoTonePrimaryColor = {};
    var _interopRequireDefault$2 = interopRequireDefaultExports.default;
    Object.defineProperty(twoTonePrimaryColor, "__esModule", {
      value: true
    });
    twoTonePrimaryColor.getTwoToneColor = getTwoToneColor;
    twoTonePrimaryColor.setTwoToneColor = setTwoToneColor;
    var _slicedToArray2$1 = _interopRequireDefault$2(slicedToArrayExports);
    var _IconBase$1 = _interopRequireDefault$2(IconBase$1);
    var _utils$1 = utils;
    function setTwoToneColor(twoToneColor) {
      var _normalizeTwoToneColo = (0, _utils$1.normalizeTwoToneColors)(twoToneColor), _normalizeTwoToneColo2 = (0, _slicedToArray2$1.default)(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
      return _IconBase$1.default.setTwoToneColors({
        primaryColor,
        secondaryColor
      });
    }
    function getTwoToneColor() {
      var colors = _IconBase$1.default.getTwoToneColors();
      if (!colors.calculated) {
        return colors.primaryColor;
      }
      return [colors.primaryColor, colors.secondaryColor];
    }
    var _interopRequireDefault$1 = interopRequireDefaultExports.default;
    var _interopRequireWildcard$1 = interopRequireWildcardExports.default;
    Object.defineProperty(AntdIcon, "__esModule", {
      value: true
    });
    AntdIcon.default = void 0;
    var _extends2$1 = _interopRequireDefault$1(_extendsExports);
    var _slicedToArray2 = _interopRequireDefault$1(slicedToArrayExports);
    var _defineProperty2 = _interopRequireDefault$1(definePropertyExports);
    var _objectWithoutProperties2 = _interopRequireDefault$1(objectWithoutPropertiesExports);
    var React$1 = _interopRequireWildcard$1(reactExports);
    var _classnames = _interopRequireDefault$1(classnamesExports);
    var _colors = require$$8;
    var _Context = _interopRequireDefault$1(Context);
    var _IconBase = _interopRequireDefault$1(IconBase$1);
    var _twoTonePrimaryColor = twoTonePrimaryColor;
    var _utils = utils;
    var _excluded = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
    (0, _twoTonePrimaryColor.setTwoToneColor)(_colors.blue.primary);
    var Icon = /* @__PURE__ */ React$1.forwardRef(function(props, ref) {
      var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = (0, _objectWithoutProperties2.default)(props, _excluded);
      var _React$useContext = React$1.useContext(_Context.default), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
      var classString = (0, _classnames.default)(rootClassName, prefixCls, (0, _defineProperty2.default)((0, _defineProperty2.default)({}, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), className);
      var iconTabIndex = tabIndex;
      if (iconTabIndex === void 0 && onClick) {
        iconTabIndex = -1;
      }
      var svgStyle = rotate ? {
        msTransform: "rotate(".concat(rotate, "deg)"),
        transform: "rotate(".concat(rotate, "deg)")
      } : void 0;
      var _normalizeTwoToneColo = (0, _utils.normalizeTwoToneColors)(twoToneColor), _normalizeTwoToneColo2 = (0, _slicedToArray2.default)(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
      return /* @__PURE__ */ React$1.createElement("span", (0, _extends2$1.default)({
        role: "img",
        "aria-label": icon.name
      }, restProps, {
        ref,
        tabIndex: iconTabIndex,
        onClick,
        className: classString
      }), /* @__PURE__ */ React$1.createElement(_IconBase.default, {
        icon,
        primaryColor,
        secondaryColor,
        style: svgStyle
      }));
    });
    Icon.displayName = "AntdIcon";
    Icon.getTwoToneColor = _twoTonePrimaryColor.getTwoToneColor;
    Icon.setTwoToneColor = _twoTonePrimaryColor.setTwoToneColor;
    AntdIcon.default = Icon;
    var _interopRequireWildcard = interopRequireWildcardExports.default;
    var _interopRequireDefault = interopRequireDefaultExports.default;
    Object.defineProperty(QuestionCircleOutlined$4, "__esModule", {
      value: true
    });
    QuestionCircleOutlined$4.default = void 0;
    var _extends2 = _interopRequireDefault(_extendsExports);
    var React = _interopRequireWildcard(reactExports);
    var _QuestionCircleOutlined = _interopRequireDefault(QuestionCircleOutlined$3);
    var _AntdIcon = _interopRequireDefault(AntdIcon);
    var QuestionCircleOutlined$1 = function QuestionCircleOutlined2(props, ref) {
      return /* @__PURE__ */ React.createElement(_AntdIcon.default, (0, _extends2.default)({}, props, {
        ref,
        icon: _QuestionCircleOutlined.default
      }));
    };
    var RefIcon = /* @__PURE__ */ React.forwardRef(QuestionCircleOutlined$1);
    QuestionCircleOutlined$4.default = RefIcon;
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      const _QuestionCircleOutlined2 = _interopRequireDefault2(QuestionCircleOutlined$4);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      const _default = _QuestionCircleOutlined2;
      exports2.default = _default;
      module2.exports = _default;
    })(QuestionCircleOutlined$5, QuestionCircleOutlined$5.exports);
    var QuestionCircleOutlinedExports = QuestionCircleOutlined$5.exports;
    const QuestionCircleOutlined = /* @__PURE__ */ getDefaultExportFromCjs(QuestionCircleOutlinedExports);
    const FormPropLabel = DynamicFormTheme.flexy(
      "FormPropLabel",
      reactExports.memo((props) => {
        var _a, _b;
        const { name, description } = props;
        const label = "label" in description ? ((_a = description.label) == null ? void 0 : _a.toString()) ?? name : name;
        if (!("meta" in description) || ((_b = description.meta) == null ? void 0 : _b.description) == null) {
          return label;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: 0, children: [
          label,
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clx("text-pre-wrap"), children: description.meta.description }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { type: "link", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(QuestionCircleOutlined, {}) }) })
        ] });
      })
    );
    const OPTIONS = BINARY_OPERATORS.map((op) => ({ label: op, value: op }));
    const FormBinaryExpressionOperator = DynamicFormTheme.flexy(
      "FormBinaryExpressionOperator",
      (props) => {
        const { name } = props;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Select, { name, options: OPTIONS, style: { minWidth: 150 } });
      }
    );
    const FormConstantExpression = DynamicFormTheme.flexy(
      "FormConstantExpression",
      (props) => {
        const { name } = props;
        const [{ value, onBlur }, , { setValue, setTouched }] = useField(name);
        function onChange(e2) {
          const value2 = e2.target.value;
          setValue({ type: "ConstantExpression", value: value2 });
          setTouched(true, true);
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { onChange, onBlur, value: (value == null ? void 0 : value.value) ?? "" });
      }
    );
    const FORM_CONSTANT_EXPRESSION_SCHEMA = create$3({
      type: create$6().oneOf(["ConstantExpression"]).required(),
      value: create$8().required()
    });
    const FormReferenceExpression = DynamicFormTheme.flexy(
      "FormReferenceExpression",
      (props) => {
        const { name } = props;
        const { model } = useDesignerContext();
        const options2 = reactExports.useMemo(
          () => model.elements.map((el) => ({ value: el.id, label: el.id })),
          [model.elements]
        );
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Select, { name: `${name}.ref`, options: options2, style: { minWidth: 120 } });
      }
    );
    const FORM_REFERENCE_EXPRESSION_SCHEMA = create$3({
      type: create$6().oneOf(["ReferenceExpression"]).required(),
      ref: create$6().required()
    });
    function FormControl(props) {
      const { name } = props;
      const [{ value }] = useField(name);
      if (value.type === "ReferenceExpression") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(FormReferenceExpression, { name });
      }
      if (value.type === "CallExpression") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(FormReferenceExpression, { name: `${name}.args[0]` });
      }
    }
    function useValueChange(props) {
      const { name } = props;
      const [{ value }, , { setValue }] = useField(name);
      return reactExports.useCallback(
        (newValue) => {
          if (newValue === "value" && value.type === "CallExpression") {
            setValue(value.args[0]);
          }
          if (newValue === "len" && value.type === "ReferenceExpression") {
            setValue({
              type: "CallExpression",
              function: "len",
              args: [value]
            });
          }
        },
        [value, setValue]
      );
    }
    const FormBinaryExpressionLeft = DynamicFormTheme.flexy(
      "FormBinaryExpressionLeft",
      (props) => {
        const { name } = props;
        const [{ value }] = useField(name);
        const onValueChange = useValueChange(props);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Select$1,
            {
              value: value.type === "ReferenceExpression" ? "value" : "len",
              onChange: onValueChange,
              options: [
                { value: "value", label: "Value" },
                { value: "len", label: "Length()" }
              ]
            }
          )
        ] });
      }
    );
    function findParentPath(name) {
      const path2 = parsePath(name);
      return path2 != null ? pathToName(path2.slice(0, -2)) : null;
    }
    const INITIAL_VALUE$2 = {
      type: "BinaryExpression",
      operator: "=",
      left: { type: "ReferenceExpression", ref: null },
      right: { type: "ConstantExpression", value: null }
    };
    function useAdd$1(props) {
      const { name } = props;
      const [{ value }, , { setValue }] = useField(name);
      return reactExports.useCallback(() => {
        setValue({
          type: "BoolExpression",
          operator: "and",
          expressions: [value, INITIAL_VALUE$2]
        });
      }, [value, setValue]);
    }
    function useParent(props) {
      const { name: fieldName } = props;
      const { values } = useFormikContext();
      const name = reactExports.useMemo(() => findParentPath(fieldName), [fieldName]);
      const value = reactExports.useMemo(() => name && getIn(values, name), [values, name]);
      return name ? { value, name } : null;
    }
    function useDelete$1(props, parent) {
      const { name } = props;
      const { setFieldValue } = useFormikContext();
      return reactExports.useCallback(() => {
        if (!parent) {
          setFieldValue(name, null);
          return;
        }
        if (parent.value.type === "BoolExpression" && parent.value.expressions.length === 2) {
          setFieldValue(parent.name, parent.value.expressions[0]);
          return;
        }
        if (parent.value.type === "BoolExpression" && parent.value.expressions.length > 2) {
          const index2 = parseIndex(name);
          const newExpressions = [...parent.value.expressions];
          newExpressions.splice(index2, 1);
          setFieldValue(parent.name, { ...parent.value, expressions: newExpressions });
        }
        throw new Error(
          `Cannot delete expression at ${name} from parent ${parent.name}. Parent value: ${JSON.stringify(parent.value)}`
        );
      }, [parent, setFieldValue, name]);
    }
    const FormBinaryExpressionComponent = DynamicFormTheme.flexy(
      "FormBinaryExpression",
      (props) => {
        const { name } = props;
        const parent = useParent(props);
        const onAdd = useAdd$1(props);
        const onDelete = useDelete$1(props, parent);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { wrap: false, gutter: 8, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { flex: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormBinaryExpressionLeft, { name: `${name}.left` }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { flex: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormBinaryExpressionOperator, { name: `${name}.operator` }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { flex: "auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormConstantExpression, { name: `${name}.right` }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { flex: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "default", variant: "filled", onClick: onAdd, children: "AND" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { flex: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "default", variant: "filled", onClick: onDelete, children: "DEL" }) })
        ] });
      }
    );
    const FormBinaryExpression = Object.assign(FormBinaryExpressionComponent, {
      initialValue: INITIAL_VALUE$2
    });
    const options = BOOL_OPERATORS.map((op) => ({ label: op, value: op }));
    const FormBoolExpressionOperator = DynamicFormTheme.flexy(
      "FormBoolExpressionOperator",
      (props) => {
        const { name, ...selectProps } = props;
        const [{ value, onBlur }, , { setTouched, setValue }] = useField(name);
        function onChange(value2) {
          setValue(value2);
          setTouched(true, true);
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, { ...selectProps, value, options, onChange, onBlur });
      }
    );
    function useAdd(props) {
      const { name } = props;
      const [, , { setValue }] = useField(name);
      return reactExports.useCallback(() => setValue(FormBinaryExpression.initialValue), [setValue]);
    }
    function Blurb(props) {
      const onAdd = useAdd(props);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "No expression set" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Flex, { justify: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: onAdd, type: "primary", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$p, {}), children: "Add Expression" }) })
      ] });
    }
    const FormExpressionEmpty = DynamicFormTheme.flexy(
      "FormExpressionEmpty",
      (props) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Empty,
          {
            description: /* @__PURE__ */ jsxRuntimeExports.jsx(Blurb, { ...props }),
            image: Empty.PRESENTED_IMAGE_SIMPLE,
            style: { marginTop: 20 }
          }
        );
      }
    );
    const FormExpression = DynamicFormTheme.flexy("FormExpression", (props) => {
      const { name } = props;
      const [{ value }] = useField(name);
      if (value == null) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(FormExpressionEmpty, { name });
      }
      switch (value == null ? void 0 : value.type) {
        case "BoolExpression":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(FormBoolExpression, { name });
        case "BinaryExpression":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(FormBinaryExpression, { name });
        default:
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Unknown Expression Type" });
      }
    });
    const FormBoolExpressionAddButton = DynamicFormTheme.flexy(
      "FormBoolExpressionAddButton",
      (props) => {
        const { name } = props;
        const [{ value }, , { setValue }] = useField(name);
        const onClick = reactExports.useCallback(
          () => setValue({
            ...value,
            expressions: [
              ...value.expressions,
              { type: "BinaryExpression", operator: "=", left: null, right: null }
            ]
          }),
          [value, setValue]
        );
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "default", variant: "filled", onClick, children: "Add Expression" });
      }
    );
    const FormBoolExpression = DynamicFormTheme.flexy(
      "FormBoolExpression",
      (props) => {
        const { name } = props;
        const [{ value }] = useField(name);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { vertical: true, gap: "small", align: "start", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { gap: "small", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormBoolExpressionOperator, { name: `${name}.operator` }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { color: "default", variant: "filled", onClick: () => {
            }, children: "DEL" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clx("form-bool-expression-list"), children: [
            value.expressions.map((_2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(FormExpression, { name: `${name}.expressions[${index2}]` }, index2)),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormBoolExpressionAddButton, { name }) })
          ] })
        ] });
      }
    );
    const FORM_BOOL_EXPRESSION_SCHEMA = create$3({
      type: create$6().oneOf(["BoolExpression"]).required(),
      operator: create$6().oneOf(BOOL_OPERATORS).required(),
      expressions: create(() => create$2(FORM_EXPRESSION_SCHEMA).required())
    });
    const CALL_EXPRESSION_SCHEMA = create$3({
      type: create$6().oneOf(["CallExpression"]).required(),
      function: create$6().oneOf(CALL_EXPRESSION_FUNCTIONS).required(),
      args: create(() => create$2(FORM_EXPRESSION_SCHEMA).required())
    });
    const FORM_EXPRESSION_SCHEMA = create((value) => {
      if (!value) {
        return create$3().nullable();
      }
      switch (value.type) {
        case "ConstantExpression":
          return FORM_CONSTANT_EXPRESSION_SCHEMA.required();
        case "ReferenceExpression":
          return FORM_REFERENCE_EXPRESSION_SCHEMA.required();
        case "BoolExpression":
          return FORM_BOOL_EXPRESSION_SCHEMA.required();
        case "BinaryExpression":
          return FORM_BINARY_EXPRESSION_SCHEMA.required();
        case "CallExpression":
          return CALL_EXPRESSION_SCHEMA.required();
        default:
          throw new Error(`Unknown expression type: ${value.type}`);
      }
    });
    const FORM_BINARY_EXPRESSION_SCHEMA = create$3({
      type: create$6().oneOf(["BinaryExpression"]).required(),
      left: create(() => FORM_EXPRESSION_SCHEMA),
      operator: create$6().required(),
      right: create(() => FORM_CONSTANT_EXPRESSION_SCHEMA)
    });
    const ConstantExpressionValue = DynamicFormTheme.flexy(
      "ConstantExpressionValue",
      (props) => {
        const { value } = props;
        if (Array.isArray(value.value)) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: value.value.join(", ") });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: value.value });
      }
    );
    const BinaryExpressionValue = DynamicFormTheme.flexy(
      "BinaryExpressionValue",
      (props) => {
        const { value } = props;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          value.left ? /* @__PURE__ */ jsxRuntimeExports.jsx(ExpressionValue, { value: value.left }) : "NULL",
          ` ${value.operator} `,
          value.right ? /* @__PURE__ */ jsxRuntimeExports.jsx(ExpressionValue, { value: value.right }) : "NULL"
        ] });
      }
    );
    const BoolExpressionValue = DynamicFormTheme.flexy(
      "BoolExpressionValue",
      (props) => {
        const { value } = props;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          "(",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Space, { split: value.operator, children: value.expressions.map((expression, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(ExpressionValue, { value: expression }, index2)) }),
          ")"
        ] });
      }
    );
    const ReferenceExpressionValue = DynamicFormTheme.flexy(
      "ReferenceExpressionValue",
      (props) => {
        const { value } = props;
        return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: value.ref });
      }
    );
    const CallExpressionValue = DynamicFormTheme.flexy(
      "CallExpressionValue",
      (props) => {
        const { value } = props;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          value.function,
          "(",
          value.args.map((arg, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ExpressionValue, { value: arg }),
            index2 < value.args.length - 1 ? ", " : ""
          ] }, index2)),
          ")"
        ] });
      }
    );
    const ExpressionValue = DynamicFormTheme.flexy("ExpressionValue", (props) => {
      const { value } = props;
      switch (value.type) {
        case "ReferenceExpression":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ReferenceExpressionValue, { value });
        case "ConstantExpression":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ConstantExpressionValue, { value });
        case "BinaryExpression":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(BinaryExpressionValue, { value });
        case "BoolExpression":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(BoolExpressionValue, { value });
        case "CallExpression":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(CallExpressionValue, { value });
        default:
          return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "red" }, children: "Unknown Expression Type" });
      }
    });
    const SCHEMA$1 = create$3({
      value: FORM_EXPRESSION_SCHEMA
    });
    const INITIAL_VALUE$1 = {
      value: FormBinaryExpression.initialValue
    };
    const ExpressionFormComponent = DynamicFormTheme.flexy("ExpressionForm", (props) => {
      const { initialValue: initialValue2, onSubmit } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Ve,
        {
          type: "formik",
          uid: ExpressionForm.uid,
          initialValues: initialValue2,
          validationSchema: SCHEMA$1,
          onSubmit,
          layout: "vertical",
          children: ({ values }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormExpression, { name: "value" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { style: { marginTop: 20 }, children: values.value && /* @__PURE__ */ jsxRuntimeExports.jsx(ExpressionValue, { value: values.value }) })
          ] })
        }
      );
    });
    const ExpressionForm = Object.assign(ExpressionFormComponent, {
      uid: "edit-expression-form",
      schema: SCHEMA$1,
      initialValue: INITIAL_VALUE$1
    });
    function useFormValue(props) {
      const { initialValue: initialValue2 } = props;
      return reactExports.useMemo(
        () => initialValue2 ? { value: initialValue2 } : ExpressionForm.initialValue,
        [initialValue2]
      );
    }
    function useSubmit$3(props) {
      const { onSubmit } = props;
      return reactExports.useCallback((value) => onSubmit(value.value), [onSubmit]);
    }
    const EditExpressionModal = DynamicFormTheme.flexy(
      "EditExpressionModal",
      (props) => {
        const { onClose, title = "Edit Expression" } = props;
        const submitForm = Ve.useSubmit(ExpressionForm.uid);
        const formValue = useFormValue(props);
        const onSubmit = useSubmit$3(props);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            open: true,
            title,
            onCancel: onClose,
            onOk: submitForm,
            width: "80%",
            style: { maxWidth: 1e3 },
            className: clx("edit-expression-modal"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpressionForm, { initialValue: formValue, onSubmit })
          }
        );
      }
    );
    const FormExpressionEditable = DynamicFormTheme.flexy(
      "FormExpressionEditable",
      (props) => {
        const name = Ve.useName(props.name);
        const [{ value }, , { setTouched, setValue }] = useField(name);
        const [isOpen, setOpen] = reactExports.useState(false);
        function onChange(value2) {
          setOpen(false);
          setValue(value2);
          setTouched(true, true);
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          value && /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpressionValue, { value }) }),
          !value && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography.Text, { type: "secondary", italic: true, children: "No expression set" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { type: "link", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$8, {}), onClick: () => setOpen(true) }),
          isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(EditExpressionModal, { initialValue: value, onClose: () => setOpen(false), onSubmit: onChange })
        ] });
      }
    );
    const FormPropList = DynamicFormTheme.flexy(
      "FormPropList",
      (props) => {
        const { name, description } = props;
        const [{ value }, , { setValue }] = useField(name);
        if (!value) {
          return null;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          List,
          {
            dataSource: value.map((_2, index2) => ({ key: index2 })),
            renderItem: ({ key }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              List.Item,
              {
                className: clx("form-prop-list-item"),
                actions: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button$1,
                    {
                      type: "link",
                      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$9, {}),
                      onClick: () => setValue(value.filter((_2, i2) => i2 !== key))
                    },
                    "delete"
                  )
                ],
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormProp, { name: `${name}[${key}]`, description: description.innerType, noLabel: true, noErrorMessage: true })
              }
            ),
            footer: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                color: "default",
                variant: "filled",
                onClick: () => setValue([...value, null]),
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$p, {}),
                children: "Add item"
              }
            ),
            locale: { emptyText: "No items" },
            rootClassName: clx("form-prop-list")
          }
        );
      }
    );
    const FormProp = DynamicFormTheme.flexy(
      "FormProp",
      reactExports.memo((props) => {
        var _a, _b;
        const { name, description, noLabel, noErrorMessage } = props;
        const createFormItemElement = reactExports.useCallback(
          (children, props2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Ve.Item,
            {
              label: noLabel ? false : /* @__PURE__ */ jsxRuntimeExports.jsx(FormPropLabel, { name, description }),
              required: SchemaUtil.isRequired(description),
              name,
              nameAbsolute: true,
              noErrorMessage,
              className: classNames({ [clx("no-error-message")]: noErrorMessage }),
              ...props2,
              children
            }
          ),
          [name, description, noLabel, noErrorMessage]
        );
        if ((description.type === "string" || description.type === "number") && SchemaUtil.isOneOfDescription(description) && description.oneOf.length > 0) {
          return createFormItemElement(
            /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Select, { options: description.oneOf.map((x2) => ({ label: x2, value: x2 })), allowClear: true })
          );
        }
        if (description.type === "string" && ((_a = description.meta) == null ? void 0 : _a.control) === "textarea") {
          return createFormItemElement(/* @__PURE__ */ jsxRuntimeExports.jsx(Ve.TextArea, { autoSize: { minRows: 4, maxRows: 10 } }));
        }
        if (description.type === "boolean" && ((_b = description.meta) == null ? void 0 : _b.control) === "expression") {
          return createFormItemElement(/* @__PURE__ */ jsxRuntimeExports.jsx(FormExpressionEditable, { name }));
        }
        if (description.type === "string") {
          return createFormItemElement(/* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Input, {}));
        }
        if (description.type === "array" && SchemaUtil.isArrayOfDescription(description)) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Ve.Item,
            {
              label: /* @__PURE__ */ jsxRuntimeExports.jsx(FormPropLabel, { name, description }),
              required: SchemaUtil.isRequired(description),
              name,
              nameAbsolute: true,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormPropList, { name, description })
            }
          );
        }
        if (description.type === "number") {
          return createFormItemElement(/* @__PURE__ */ jsxRuntimeExports.jsx(Ve.InputNumber, {}));
        }
        if (description.type === "boolean") {
          return createFormItemElement(
            /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Checkbox, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormPropLabel, { name, description }) }),
            { label: false }
          );
        }
        if (description.type === "object" && "fields" in description) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            List,
            {
              dataSource: Object.keys(description.fields),
              renderItem: (key) => /* @__PURE__ */ jsxRuntimeExports.jsx(List.Item, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormProp, { name: `${name}.${key}`, description: description.fields[key] }) })
            }
          );
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Typography.Text, { type: "danger", children: "Unknown type" });
      })
    );
    function FormAutoSubmit({ schema }) {
      const { values, submitForm } = useFormikContext();
      const submitFormDebounced = reactExports.useMemo(() => debounce(submitForm, 500), [submitForm]);
      reactExports.useEffect(() => {
        if (schema.isValidSync(values)) {
          submitFormDebounced();
        }
      }, [values]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
    }
    const SCHEMA = create$3({
      test: create$8().required(),
      message: create$6().nullable().required()
    });
    const INITIAL_VALUE = {
      message: null,
      test: FormBinaryExpression.initialValue
    };
    function FormContent() {
      const { values } = useFormikContext();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Ve.Item,
          {
            name: "test",
            label: "Test",
            required: true,
            extra: values.test && /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpressionValue, { value: values.test }) }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormExpression, { name: "test" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Item, { name: "message", label: "Message", required: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Input, {}) })
      ] });
    }
    const ValidationRuleFormComponent = DynamicFormTheme.flexy(
      "ValidationRuleForm",
      (props) => {
        const {
          initialValue: initialValue2,
          onSubmit,
          innerRef,
          uid = EditValidationForm.uid,
          schema = EditValidationForm.schema
        } = props;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Ve,
          {
            type: "formik",
            uid,
            initialValues: initialValue2,
            onSubmit,
            validationSchema: schema,
            innerRef,
            layout: "vertical",
            enableReinitialize: true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormContent, {})
          }
        );
      }
    );
    const EditValidationForm = Object.assign(ValidationRuleFormComponent, {
      schema: SCHEMA,
      initialValue: INITIAL_VALUE,
      uid: "validation-rule-form"
    });
    function useSubmit$2(props) {
      const { onSubmit } = props;
      return (value) => onSubmit({ ...value, type: "test" });
    }
    const ValidationRuleModalComponent = DynamicFormTheme.flexy(
      "ValidationRuleModal",
      (props) => {
        const {
          initialValue: initialValue2 = EditValidationForm.initialValue,
          onClose,
          title = ValidationRuleModal.title
        } = props;
        const form = reactExports.useRef(null);
        const onSubmit = useSubmit$2(props);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            open: true,
            title,
            onCancel: onClose,
            onOk: () => {
              var _a;
              return (_a = form.current) == null ? void 0 : _a.submitForm();
            },
            width: "80%",
            style: { maxWidth: 1e3 },
            className: clx("validation-rule-modal"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditValidationForm, { initialValue: initialValue2, onSubmit, innerRef: form })
          }
        );
      }
    );
    const ValidationRuleModal = Object.assign(ValidationRuleModalComponent, {
      title: "Validation Rule"
    });
    function useSubmit$1(props, onSubmitted) {
      const { name } = props;
      const [{ value }, , { setValue }] = useField(name);
      return reactExports.useCallback(
        (formValue) => {
          const newValue = (value == null ? void 0 : value.slice()) ?? [];
          newValue.push({ type: "test", ...formValue });
          setValue(newValue);
          onSubmitted();
        },
        [value, setValue, onSubmitted]
      );
    }
    const FormAddValidationRuleButton = DynamicFormTheme.flexy(
      "FormAddValidationRuleButton",
      (props) => {
        const { text = "Add Validation Rule" } = props;
        const [modalShown, setModalShown] = reactExports.useState(false);
        const toggleModal = reactExports.useCallback(() => setModalShown((prev2) => !prev2), []);
        const onSubmit = useSubmit$1(props, toggleModal);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          modalShown && /* @__PURE__ */ jsxRuntimeExports.jsx(ValidationRuleModal, { onClose: toggleModal, onSubmit }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$p, {}), color: "default", variant: "filled", onClick: toggleModal, children: text })
        ] });
      }
    );
    function useCheckbox(props) {
      const { name } = props;
      const [{ value }, , { setValue, setTouched }] = useField(name);
      const checked = reactExports.useMemo(() => !!value && value.some(isRequiredValidationRule), [value]);
      const onChange = reactExports.useCallback(
        (e2) => {
          let newValue = (value == null ? void 0 : value.filter((x2) => !isRequiredValidationRule(x2))) ?? [];
          if (e2.target.checked) newValue = [...newValue, { type: "required", message: null }];
          setValue(newValue.length > 0 ? newValue : null);
          setTouched(true, true);
        },
        [value, setValue, setTouched]
      );
      return { checked, onChange };
    }
    const FormValidationRequired = DynamicFormTheme.flexy(
      "FormValidationRequired",
      (props) => {
        const { text = "Required?" } = props;
        const { checked, onChange } = useCheckbox(props);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { checked, onChange, children: text });
      }
    );
    function useSubmit(props, onSubmitted) {
      const { name } = props;
      const [{ value }, , { setValue }] = useField(name);
      return reactExports.useCallback(
        (values) => Promise.resolve(setValue({ ...value, ...values })).then(onSubmitted),
        [value, setValue, onSubmitted]
      );
    }
    const FormValidationTest = DynamicFormTheme.flexy(
      "FormValidationTest",
      (props) => {
        const { name, onDelete: onDeleteProp } = props;
        const [{ value }] = useField(name);
        const [modalShown, setModalShown] = reactExports.useState(false);
        const toggleModal = reactExports.useCallback(() => setModalShown((prev2) => !prev2), []);
        const onSubmit = useSubmit(props, toggleModal);
        const onDelete = reactExports.useMemo(
          () => onDeleteProp ? () => onDeleteProp(value) : void 0,
          [onDeleteProp, value]
        );
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpressionValue, { value: value.test }) }),
          value.message,
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { type: "link", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$8, {}), onClick: toggleModal }),
          onDelete && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: onDelete, type: "link", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$9, {}) }),
          modalShown && /* @__PURE__ */ jsxRuntimeExports.jsx(ValidationRuleModal, { initialValue: value, onSubmit, onClose: toggleModal })
        ] });
      }
    );
    function useDelete(props) {
      const name = Ve.useName(props.name);
      const [{ value: rules2 }, , { setValue }] = useField(name);
      return reactExports.useCallback(
        (value) => setValue(rules2.filter((x2) => x2 !== value)),
        [setValue, rules2]
      );
    }
    const FormValidationBlock = DynamicFormTheme.flexy(
      "FormValidationBlock",
      (props) => {
        const name = Ve.useName(props.name);
        const [{ value: rules2 }] = useField(name);
        const onDelete = useDelete(props);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { vertical: true, gap: "small", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormValidationRequired, { name }) }),
          rules2 == null ? void 0 : rules2.map((rule, index2) => {
            if (rule.type === "required") {
              return null;
            }
            if (rule.type === "test") {
              return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormValidationTest, { name: `${name}[${index2}]`, onDelete }) }, index2);
            }
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography.Text, { type: "danger", children: "Unknown validation rule" }) }, index2);
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "1rem" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormAddValidationRuleButton, { name }) })
        ] });
      }
    );
    function useElementModelSchema() {
      const { selectedElement } = useDesignerContext();
      const { props } = selectedElement;
      return reactExports.useMemo(() => {
        let propsSchema = props;
        const fields = props.describe().fields;
        for (const key in fields) {
          if (Object.prototype.hasOwnProperty.call(fields, key)) {
            const element = fields[key];
            if (element.type === "boolean" && element.meta && element.meta.control === "expression") {
              const isRequired2 = SchemaUtil.isRequired(element);
              let newPropSchema = create$7().nullable();
              if (isRequired2) newPropSchema = newPropSchema.required();
              propsSchema = propsSchema.concat(create$3({ [key]: newPropSchema }));
            }
          }
        }
        return create$3({ props: props.required(), validation: create$2(create$3().required()).nullable() });
      }, [props]);
    }
    function useEditValue(messageApi) {
      const { selectedId } = useDesignerContext();
      const [isEdit, setEdit] = reactExports.useState(false);
      const [idEditValue, setIdEditValue] = reactExports.useState(selectedId);
      const { renameElement } = useDesignerContext();
      const toggleEdit = reactExports.useCallback(() => setEdit((prev2) => !prev2), []);
      reactExports.useEffect(() => {
        setIdEditValue(selectedId);
        setEdit(false);
      }, [selectedId]);
      const onSubmit = reactExports.useCallback(() => {
        const value = idEditValue == null ? void 0 : idEditValue.trim();
        const error = validateModelElementId(value);
        if (error) {
          messageApi.error(error);
          return;
        }
        if (value !== selectedId) {
          renameElement(selectedId, value);
        }
        setEdit(false);
      }, [idEditValue, selectedId, renameElement, messageApi]);
      return { selectedId, isEdit, toggleEdit, idEditValue, onIdEditValueChange: setIdEditValue, onSubmit };
    }
    const ElementModelIdControl = DynamicFormTheme.flexy(
      "ElementModelIdControl",
      (props) => {
        const { style: style2 } = props;
        const [messageApi, messageContext] = staticMethods.useMessage();
        const { selectedId, idEditValue, isEdit, onIdEditValueChange, toggleEdit, onSubmit } = useEditValue(messageApi);
        if (!isEdit) {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { align: "center", style: style2, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { children: selectedId }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: toggleEdit, icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$8, {}), type: "link" })
          ] });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Flex, { gap: "small", align: "center", style: style2, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input$1,
            {
              value: idEditValue ?? "",
              onChange: (e2) => onIdEditValueChange(e2.target.value),
              onPressEnter: onSubmit,
              autoFocus: true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: onSubmit, type: "link", children: "Save" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: toggleEdit, type: "link", children: "Discard" }),
          messageContext
        ] });
      }
    );
    const ElementModelDesigner = DynamicFormTheme.flexy("ElementModelDesigner", () => {
      const { model, set: set2, selected, selectedElement: Element2 } = useDesignerContext();
      const schema = useElementModelSchema();
      const description = reactExports.useMemo(() => Element2.props.describe(), [Element2.props]);
      const onSubmit = reactExports.useCallback(
        (values) => set2({
          ...model,
          elements: model.elements.map((el) => el.id === selected.id ? { ...el, ...values } : el)
        }),
        [model, selected, set2]
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clx("element-model-designer"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Ve,
        {
          type: "formik",
          uid: "element-model-designer-form",
          onSubmit,
          initialValues: selected,
          validationSchema: schema,
          enableReinitialize: true,
          layout: "vertical",
          rootClassName: clx("element-model-designer-form"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: (Element2 == null ? void 0 : Element2.title) ?? (Element2 == null ? void 0 : Element2.id) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ElementModelIdControl, { style: { marginBottom: "1rem" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormAutoSubmit, { schema }),
            Object.entries(description.fields).map(([name, description2]) => /* @__PURE__ */ jsxRuntimeExports.jsx(FormProp, { name: `props.${name}`, description: description2 }, name)),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Ve.Item,
              {
                name: "condition",
                label: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: 0, children: [
                  "Condition",
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Tooltip,
                    {
                      title: `This condition is used to determine when this element should be displayed. It can be an
                  expression that evaluates to true or false.`,
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { type: "link", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$k, {}) })
                    }
                  )
                ] }),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormExpressionEditable, { name: "condition" })
              }
            ),
            (Element2 == null ? void 0 : Element2.value) !== "readonly" && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Ve.Item,
              {
                name: "validation",
                label: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { size: 0, children: [
                  "Validation",
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Tooltip,
                    {
                      title: `Validation rules for this element. You can define multiple rules, each with a test expression and a message.`,
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { type: "link", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefIcon$k, {}) })
                    }
                  )
                ] }),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormValidationBlock, { name: "validation" })
              }
            )
          ]
        }
      ) });
    });
    const JsonValue = DynamicFormTheme.flexy(
      "JsonValue",
      reactExports.memo((props) => {
        const { value } = props;
        const [expanded, setExpanded] = reactExports.useState(false);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { style: { overflowY: "auto", maxHeight: expanded ? void 0 : 500 }, children: JSON.stringify(value, void 0, 2) }),
          !expanded && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              style: { position: "absolute", bottom: 25, right: 25 },
              color: "default",
              variant: "solid",
              onClick: () => setExpanded(true),
              children: "EXPAND"
            }
          )
        ] });
      })
    );
    const Schema = reactExports.memo(() => {
      const { model, Elements } = useDesignerContext();
      const value = reactExports.useMemo(
        () => model.elements.map((x2) => {
          var _a;
          return (_a = Elements.find((el) => el.id === x2.element)) == null ? void 0 : _a.props.describe();
        }),
        [model.elements, Elements]
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clx("designer-state-schema"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(JsonValue, { value }) });
    });
    const Model = reactExports.memo(() => {
      const { model } = useDesignerContext();
      return /* @__PURE__ */ jsxRuntimeExports.jsx(JsonValue, { value: model });
    });
    const DesignerState = DynamicFormTheme.flexy("DesignerState", () => {
      const [active, setActive] = reactExports.useState(null);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clx("designer-state"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clx("designer-state-tabs"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Radio.Group,
          {
            value: active,
            optionType: "button",
            onChange: (e2) => setActive(e2.target.value),
            options: [
              { label: "Model", value: "model" },
              { label: "Schema", value: "schema" }
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: clx("designer-state-content"), children: [
          active === "model" && /* @__PURE__ */ jsxRuntimeExports.jsx(Model, {}),
          active === "schema" && /* @__PURE__ */ jsxRuntimeExports.jsx(Schema, {})
        ] })
      ] });
    });
    function renderDynamicFormElement(args) {
      var _a;
      const { Elements, modelElement, values } = args;
      const Element2 = Elements.find((x2) => x2.id === modelElement.element).Component;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Element2,
        {
          ...ModelUtil.propsOf(modelElement, values),
          name: modelElement.id,
          required: ((_a = modelElement.validation) == null ? void 0 : _a.some(isRequiredValidationRule)) === true
        },
        modelElement.id
      );
    }
    function useSchema(model, Elements) {
      const findElement = reactExports.useCallback((id) => Elements.find((el) => el.id === id), [Elements]);
      return reactExports.useMemo(() => {
        return create$3(
          Object.fromEntries(
            model.elements.map((x2) => [x2.id, ModelUtil.schemaOf(x2, findElement(x2.element))])
          )
        );
      }, [model, findElement]);
    }
    function Element$1(props) {
      const { renderElement = renderDynamicFormElement, ...args } = props;
      const [, , { setValue }] = useField(args.modelElement.id);
      reactExports.useEffect(() => {
        return () => {
          setValue(ModelUtil.elementInitialValue(args.modelElement));
        };
      }, []);
      return renderElement({ ...args });
    }
    function Content(props) {
      const { model, renderElement, Elements } = props;
      const { values } = useFormikContext();
      const isShown = reactExports.useCallback(
        (el) => !el.condition || ExpressionUtil.exec(el.condition, values),
        [values]
      );
      return model.elements.filter(isShown).map((element) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        Element$1,
        {
          renderElement,
          Elements,
          model,
          modelElement: element,
          values
        },
        element.id
      ));
    }
    function DynamicForm(props) {
      const { uid = "dynamic-form", Elements, model, initialValue: initialValue2, onSubmit, className, renderElement } = props;
      const schema = useSchema(model, Elements);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames(clx("dynamic-form"), className), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Ve,
        {
          uid,
          type: "formik",
          initialValues: initialValue2,
          onSubmit,
          validationSchema: schema,
          enableReinitialize: true,
          layout: "vertical",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { model, Elements, renderElement })
        }
      ) });
    }
    function useDynamicForm(model) {
      const initialState2 = reactExports.useMemo(
        () => model.elements.reduce(
          (acc, c2) => {
            acc[c2.id] = c2.defaultValue ?? null;
            return acc;
          },
          {}
        ),
        [model]
      );
      const result = reactExports.useState(initialState2);
      return result;
    }
    function DynamicFormTabContent(props) {
      const { model, Elements } = props;
      const [state, setState] = useDynamicForm(model);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Flex, { justify: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        DynamicForm,
        {
          Elements: DesignerUtil.flattenElements(Elements),
          model,
          initialValue: state,
          onSubmit: setState
        }
      ) });
    }
    const DesignerGroup = DynamicFormTheme.flexy("DesignerGroup", (props) => {
      const { locationHash: _2, rootClassName, defaultTab = "designer", ...designerProps } = props;
      const { locationHash, Elements, model } = props;
      const [tab, setTab] = reactExports.useState(
        window.location.hash.length > 0 ? window.location.hash.substring(1) : defaultTab
      );
      reactExports.useEffect(() => {
        if (locationHash) window.location.hash = tab;
      }, [tab]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames(clx("designer-group"), rootClassName), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tabs,
        {
          activeKey: tab,
          onChange: setTab,
          items: [
            {
              key: "form",
              label: "Preview",
              children: tab === "form" && /* @__PURE__ */ jsxRuntimeExports.jsx(DynamicFormTabContent, { Elements, model })
            },
            { key: "designer", label: "Designer", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Designer, { ...designerProps }) }
          ]
        }
      ) });
    });
    const EMPTY_SUBMIT = () => {
    };
    function useDesignerState(props) {
      const { onChange: onChangeProp } = props;
      const [selected, setSelected] = reactExports.useState(null);
      const [animate, setAnimate] = reactExports.useState(false);
      const onChange = reactExports.useCallback(
        (model) => {
          if (selected && !model.elements.some((el) => el.id === selected)) {
            setSelected(null);
          }
          onChangeProp(model);
        },
        [onChangeProp, selected]
      );
      reactExports.useEffect(() => {
        setAnimate(true);
      }, []);
      return {
        ...props,
        onChange,
        selected,
        onSelect: setSelected,
        animate
      };
    }
    function ElementModelSection(props) {
      const { offsetTop } = props;
      const { model, selectedId } = useDesignerContext();
      const content = model.elements.find((el) => el.id === selectedId) && /* @__PURE__ */ jsxRuntimeExports.jsx(ElementModelDesigner, {});
      return offsetTop == null ? content : /* @__PURE__ */ jsxRuntimeExports.jsx(Affix, { offsetTop, children: content });
    }
    const DesignerComponent = DynamicFormTheme.flexy("Designer", (props) => {
      const { Elements, model, offsetTop, className, style: style2 } = props;
      const { onChange, selected, onSelect, animate } = useDesignerState(props);
      const initialValues = reactExports.useMemo(() => ModelUtil.initialValue(model), [model]);
      const [elementMenuCollapsed, setElementMenuCollapsed] = useLocalStorageBool(
        "@webinex/dynamic-form://element-menu-expanded"
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        DesignerContextProvider,
        {
          Elements,
          model,
          set: onChange,
          selectedId: selected,
          select: onSelect,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames(clx("designer"), className), style: style2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Row, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { flex: "none", className: clx("designer-menu-section"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ElementMenu,
              {
                offsetTop,
                collapsed: elementMenuCollapsed,
                onCollapsedChange: setElementMenuCollapsed
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { flex: "auto", className: clx("designer-main-section"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Splitter, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Splitter.Panel, { min: 500, defaultSize: "70%", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Formik,
                {
                  uid: "designer-element-list",
                  type: "formik",
                  layout: "vertical",
                  initialValues,
                  onSubmit: EMPTY_SUBMIT,
                  enableReinitialize: true,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clx("designer-element-list-section"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ElementList, { animate }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: clx("designer-state-section"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(DesignerState, {}) })
                  ] })
                }
              ) }),
              selected && /* @__PURE__ */ jsxRuntimeExports.jsx(Splitter.Panel, { defaultSize: "30%", min: 300, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Col, { flex: "none", className: clx("designer-element-model-section"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ElementModelSection, { offsetTop }) }) })
            ] }) })
          ] }) })
        }
      );
    });
    const Designer = Object.assign(DesignerComponent, {
      Group: DesignerGroup
    });
    const DEFAULT_MODEL = {
      elements: [
        {
          id: "title",
          element: "Heading",
          defaultValue: null,
          props: {
            marginBottom: "md",
            marginTop: "none",
            text: "Demographics",
            level: 3
          },
          validation: null
        },
        {
          id: "helpText",
          element: "Paragraph",
          defaultValue: null,
          props: {
            marginBottom: "lg",
            marginTop: "none",
            type: "secondary",
            text: 'We would need some demographics and contact information.\nPlease fill in information below, information with "*" mark is required.'
          },
          validation: null
        },
        {
          id: "gender",
          element: "RadioGroup",
          defaultValue: null,
          props: {
            condition: null,
            disabled: null,
            options: ["Male", "Female", "Other"],
            title: "Gender"
          },
          validation: [
            {
              type: "required"
            }
          ]
        },
        {
          id: "firstName",
          element: "Input",
          defaultValue: null,
          props: {
            disabled: null,
            placeholder: "James",
            htmlType: "text",
            type: "input",
            title: "First Name",
            multiline: false
          },
          validation: [
            {
              type: "required",
              message: null
            },
            {
              type: "test",
              message: "Might be at least 3 characters",
              test: {
                type: "BinaryExpression",
                operator: "<",
                left: {
                  type: "CallExpression",
                  function: "len",
                  args: [
                    {
                      type: "ReferenceExpression",
                      ref: "firstName"
                    }
                  ]
                },
                right: {
                  type: "ConstantExpression",
                  value: "3"
                }
              }
            },
            {
              type: "test",
              message: "Might be less than 10 characters",
              test: {
                type: "BinaryExpression",
                operator: ">",
                left: {
                  type: "CallExpression",
                  function: "len",
                  args: [
                    {
                      type: "ReferenceExpression",
                      ref: "firstName"
                    }
                  ]
                },
                right: {
                  type: "ConstantExpression",
                  value: "10"
                }
              }
            }
          ]
        },
        {
          id: "lastName",
          element: "Input",
          defaultValue: null,
          props: {
            disabled: null,
            placeholder: "Doe",
            htmlType: "text",
            type: "input",
            title: "Last Name",
            multiline: false
          },
          validation: [
            {
              type: "required",
              message: null
            },
            {
              type: "test",
              message: "Might be at least 3 characters",
              test: {
                type: "BinaryExpression",
                operator: "<",
                left: {
                  type: "CallExpression",
                  function: "len",
                  args: [
                    {
                      type: "ReferenceExpression",
                      ref: "lastName"
                    }
                  ]
                },
                right: {
                  type: "ConstantExpression",
                  value: "3"
                }
              }
            },
            {
              type: "test",
              message: "Might be less than 10 characters",
              test: {
                type: "BinaryExpression",
                operator: ">",
                left: {
                  type: "CallExpression",
                  function: "len",
                  args: [
                    {
                      type: "ReferenceExpression",
                      ref: "lastName"
                    }
                  ]
                },
                right: {
                  type: "ConstantExpression",
                  value: "10"
                }
              }
            }
          ]
        },
        {
          id: "maidenName",
          element: "Input",
          defaultValue: null,
          props: {
            disabled: null,
            htmlType: "text",
            type: "input",
            title: "Maiden Name"
          },
          validation: null,
          condition: {
            type: "BinaryExpression",
            operator: "=",
            left: {
              type: "ReferenceExpression",
              ref: "gender"
            },
            right: {
              type: "ConstantExpression",
              value: "Female"
            }
          }
        },
        {
          id: "divider1",
          element: "Divider",
          defaultValue: null,
          props: {
            marginBottom: "lg",
            marginTop: "lg"
          },
          validation: null
        },
        {
          id: "contactInformationTitle",
          element: "Heading",
          defaultValue: null,
          props: {
            marginBottom: "md",
            marginTop: "none",
            text: "Contact information",
            level: 4
          },
          validation: null
        },
        {
          id: "phoneNumber",
          element: "Input",
          defaultValue: null,
          props: {
            disabled: null,
            placeholder: "+1 25325 326 3262",
            htmlType: "text",
            type: "input",
            title: "Phone Number",
            multiline: false
          },
          validation: null
        },
        {
          id: "email",
          element: "Input",
          defaultValue: null,
          props: {
            disabled: null,
            placeholder: "james.doe@gmail.com",
            htmlType: "text",
            type: "input",
            title: "Email",
            multiline: false
          },
          validation: [
            {
              type: "required"
            }
          ]
        },
        {
          id: "divider2",
          element: "Divider",
          defaultValue: null,
          props: {
            marginBottom: "lg",
            marginTop: "lg"
          },
          validation: null
        },
        {
          id: "aboutYourselfTitle",
          element: "Heading",
          defaultValue: null,
          props: {
            marginBottom: "md",
            marginTop: "none",
            text: "About yourself",
            level: 4
          },
          validation: null
        },
        {
          id: "bio",
          element: "Input",
          defaultValue: null,
          props: {
            disabled: null,
            htmlType: "text",
            type: "textarea",
            title: "Bio"
          },
          validation: null
        },
        {
          id: "specialty",
          element: "Select",
          defaultValue: null,
          props: {
            disabled: null,
            options: ["Therapist", "Surgery", "Pediatrics", "Dentist", "Other"],
            title: "Specialty"
          },
          validation: [
            {
              type: "required",
              message: null
            }
          ]
        },
        {
          id: "submitBtn",
          element: "SubmitButton",
          defaultValue: null,
          props: {
            align: "right",
            text: "Submit",
            type: "primary"
          },
          validation: null
        }
      ]
    };
    const Switch = createElement({
      id: "Switch",
      props: create$3({
        textOn: create$6().required().default("ON").label("Text displayed when switch is ON"),
        textOff: create$6().required().default("OFF").label("Text displayed when switch is OFF")
      }),
      Component: ({ name, textOn, textOff }) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Ve.Switch, { name, checkedChildren: textOn, unCheckedChildren: textOff });
      }
    });
    function App() {
      const [model, setModel] = reactExports.useState(DEFAULT_MODEL);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Designer.Group,
        {
          model,
          onChange: setModel,
          Elements: [...ELEMENTS, Switch],
          locationHash: true,
          offsetTop: 0
        }
      );
    }
    clientExports.createRoot(document.getElementById("root")).render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
    );
  }
});
export default require_index_001();
//# sourceMappingURL=index-BAyBVE51.js.map
